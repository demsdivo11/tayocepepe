#include <io.h>
#pragma warning(push)
#pragma warning(disable: 26812)
#pragma warning(disable: 6054)
#pragma warning(disable: 6385)
#pragma warning(disable: 4267)
#pragma warning(disable: 4244)
#pragma warning(disable: 4267)

#pragma once
#include <chrono>
#include <sstream>
#include <filesystem>
#include <regex>
#include <deque>
#include "proton/Variant.hpp"
#include "proton/Vector.hpp"

#define HOME_TIME (15 * 1000)
#define WARP_TIME (15 * 1000)
#define WORLDBAN_TIME (36 * 1000)
#define CONNECT_TIME (100 * 1000)
#define REQUEST_TIME (180 * 1000)
namespace fs = std::filesystem;
using namespace chrono;
bool saving_ = false, f_saving_ = false;
bool only_role = false;
int gems_c = 0, day_ = 0, soulItem1 = 0, soulItem2 = 0, soulItem1c = 0, soulItem2c = 0, soulNeeded = 0, thedaytoday = 0, theitemtoday = 0, today_day = 0, today_month = 0;
string news_text = "", news_texture = "";
int Current_Clothes_Need = 7112;
int NPCX_1 = 0, NPCX_2 = 0, NPCX_3 = 0, NPCX_4 = 0, NPCX_5 = 0, NPCX_6 = 0, NPCX_7 = 0, NPCX_8 = 0, NPCX_9 = 0, NPCX_10 = 0;
int NPCY_1 = 0, NPCY_2 = 0, NPCY_3 = 0, NPCY_4 = 0, NPCY_5 = 0, NPCY_6 = 0, NPCY_7 = 0, NPCY_8 = 0, NPCY_9 = 0, NPCY_10 = 0;

long long int purchased_dl = 0, purchased_wl = 0;

namespace database {
	int create_random_int(int const& min, int const& max) {
		std::mt19937 generator{ std::random_device{}() };
		return std::uniform_int_distribution<int>{ min, max }(generator);
	}
}
namespace date_time {
	std::int64_t get_epoch_seconds() {
		return std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	}
	template<typename T = std::chrono::seconds>
	std::int64_t get_epoch_time() {
		return std::chrono::duration_cast<T>(std::chrono::system_clock::now().time_since_epoch()).count();
	}
	int64_t get_epoch_ms() {
		return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	}
	std::string get_time() {
		std::time_t time = std::time(nullptr);
		tm localTime = *std::localtime(&time);

		std::ostringstream os;
		os << std::put_time(&localTime, "%Y-%m-%d (%H:%M:%S)");

		return os.str();
	}
}

namespace global::algorithm {
	struct HideAndSeek {
		bool GameStarted = false;

		bool SeekersWon = false;
		bool HidersWon = false;

		std::uint16_t Players = 0;

		std::uint16_t Seekers = 0;
		std::uint16_t Hiders = 0;

		std::int64_t Timers = 0;
		std::int64_t LobbyTimers = 0;
		std::int64_t RestTimers = 0;
	} hideseek;

	std::string RemoveWordFromLine(std::string& line, const std::string& word)
	{
		std::string lines = line;

		auto n = lines.find(word);
		if (n != std::string::npos)
		{
			lines.erase(n, word.length());
		}

		return lines;
	}
}

namespace global::events {
	bool valentine = false;

	std::vector<pair<std::string, int>> leaderboards;
	
	std::vector<int> stores;
	
	std::int64_t valentineTimers = 0;

	std::int64_t valentineUpdate = 0;

	std::uint64_t valentineRarity = 0;
}

namespace world::database {
}
namespace updates {
	bool is_cooldown(std::string const& leaderboards) {
		if (leaderboards == "valentine") {
			if (global::events::valentineUpdate < +date_time::get_epoch_time()) return false;

			return true;
		}
		return false;
	}
}

namespace global {
	std::vector<ENetPeer*> autoFarming;
}

long long int login_time = 0;
int login_count = 0;
int serverTimeOn = 0;
vector<int> growganoth_platform, growganoth_disabled;
long long int server_event_spawn = 0, last_world_save = 0, server_log_sent = 0;
string cooldown_logs1 = "", cooldown_logs2 = "", cooldown_logs3 = "", cooldown_logs4 = "", cooldown_logs5 = "", cooldown_logs6 = "", cooldown_logs7 = "", cooldown_logs8 = "", cooldown_logs9 = "", cooldown_logs10 = "";
bool restart_server_status = false;
bool restart_server_status_seconds = false;
int restart_server_time = 10;
//
int volcanic_cape = 0, volcanic_wings = 0;
string server_name = "TayoPs";
string nama_music = "";
string file_music = "";

vector<pair<int, string>> top_worlds, top_honors;
vector<pair<int, string>> top_points, top_yesterday, top_overall;
long long last_honors_reset = 0;
string top_list = "", top_yesterday_list = "", top_overall_list = "";
string top_list_world_menu = "";

struct Position2D {
	int x, y;
};
struct { int16_t param1 = 0, param2 = 0, param3 = 0, param4 = 0, param5 = 0, param6 = 0; } DaylightDragon;
struct { uint64_t totalUserIDGenerated = 1, totalGuildIDGenerated = 1, totalWorldGenerated = 1, totalModeratorBought = 1; } GlobalStats;
string a = "", lastServerSave = Algorithm::get_time();
vector<pair<string, long long int>> home_timed, banned_ip_temporary;
vector<string> ridbans, ipbans, t_worlds;
string lastsbworld = "";
int server_port = 17091;
struct Playmod {
	string consumableid_time = "";
	string name = "";
	string onUsed = "";
	string onRemoved = "";
	int displayId = 0;
	int state = 0;
	string sound = "";
	string skin = "";
	string howWork = "";
	string eff = "";
	string usetext = "";
	string gravity = "";

	Playmod() {}

	explicit Playmod(string c_t, string name_, string used, string removed, int displayid, int st_, 
		string audio, string color, string how, string effect, string txt, string grav) :
		consumableid_time(c_t), name(name_), onUsed(used), onRemoved(removed), displayId(displayid), state(st_),
		sound(audio), skin(color), howWork(how), eff(effect), usetext(txt), gravity(grav) {}
};
map<int, Playmod> info_about_playmods {
	{ 1, Playmod{ "388_300", "Stinky", "You really really smell.", "The air clears.", 372, 14, "spray.wav", "", "", "" ,"", "" }},
	{ 2, Playmod{ "1368_2", "Frozen", "Your body has turned to ice. You can't move!", "You've thawed out.", 1368, 11, "freeze.wav", "4284769380", "", "", "", ""} },
	{ 3, Playmod{ "274_10", "Frozen", "Freeze!", "You've thawed out.", 274, 11, "freeze.wav", "4284769380", "", "", "", ""} },
	{ 4, Playmod{ "874_180", "Egged!", "You have egg on your face.", "You washed your face!", 874, 0, "", "16777215", "throw", "42", "", ""} },
	{ 5, Playmod{ "3404_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 6, Playmod{ "3406_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 7, Playmod{ "4422_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 8, Playmod{ "386_0", "", "", "", 0, 0, "", "", "cutewords", "", "", ""} },
	{ 9, Playmod{ "10660_1800", "Lucky in Love: Increased chance of Golden Heart Crystal", "Increased chance of Golden Heart Crystal!", "The honeymoon phase is over!", 10660, 0, "", "", "", "", ":D`#YUMMY!``", ""} },
	{ 10, Playmod{ "2206_120", "Irradiated", "You are aglow with radiation!", "You have recovered.", 2206, 0, "", "", "", "", "", ""} },
	{ 11, Playmod{ "408_600", "Duct Tape", "Duct tape has covered your mouth!", "Duct tape removed. OUCH!", 408, 0, "already_used.wav", "", "", "", "", ""} },
	{ 12, Playmod{ "384_3600", "Valentine", "You are somebody's valentine!", "Yuck!", 384, 0, "choir.wav", "2526478335", "", "", "", ""} },
	{ 13, Playmod{ "2480_600", "Megaphone!", "Broadcasting to ALL!", "You can broadcast once again.", 2480, 0, "", "", "", "", "", ""} },
	{ 14, Playmod{ "528_1800", "Lucky", "You're luckier than before!", "Your luck has worn off.", 528, 15, "", "", "", "", "", ""} },
	{ 15, Playmod{ "1510_10", "1512", "", "", 0, 0, "", "", "pet", "", "Legend says that you need 10 Blarney Pebbles!", ""} },
	{ 16, Playmod{ "540_900", "Envious", "It ain't easy being you.", "Healthy color restored.", 540, 0, "eat.wav", "1627349247", "", "", "", ""} },
	{ 17, Playmod{ "196_3600", "Feelin' Blue", "A `!blueberry`` slides down your throat!", "The effects of the `!blueberry`` have worn off.", 196, 0, "spray.wav", "4278190335", "drop", "", "", ""} },
	{ 18, Playmod{ "338_2", "Floating!", "Whoooooooaaaaaaaa...", "Gravity - it's the law.", 338, 0, "balloon.wav", "", "drop", "", "", "-30"} },
	{ 19, Playmod{ "962_180", "Saucy!", "You are a saucy person.", "You got cleaned up.", 962, 0, "", "2554747", "throw", "45", "", ""} },
	{ 20, Playmod{ "950_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	//{ 21, Playmod{ "968_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 22, Playmod{ "1058_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 23, Playmod{ "1096_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 24, Playmod{ "868_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 25, Playmod{ "782_3600", "Antidote!", "You are now immune to zombie bites! Temporarily...", "Your immunity is gone.", 782, 0, "", "", "drop", "25", "", ""} },
	{ 26, Playmod{ "4668_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", "" } },
	{ 27, Playmod{ "128_1800", "Golden Halo!", "You have been good.", "You're falling out of favor.", 128, 7, "", "-2104114177", "drop", "25", "", ""} },
	{ 28, Playmod{ "764_60", "Infected!", "You've been infected by the g-Virus. Punch others to infect them, too! Braiiiins...", "You've been cured.", 764, 16, "", "", "drop", "", "", ""} },
	{ 30, Playmod{ "1058_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 31, Playmod{ "1094_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 32, Playmod{ "1096_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 33, Playmod{ "1098_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 34, Playmod{ "2002_86400", "Doctor Replusion", "Doctors won't come near you!", "You no longer repel doctors.", 2002, 0, "spray.wav", "", "", "", "", ""} },
	{ 35, Playmod{ "7058_300", "Food: Purified Scythe", "Hand Scythe breaks 5% less!", "You no longer feel pure!", 7058, 15, "", "", "", "", "", ""} },
	{ 36, Playmod{ "1056_1800", "Lucky", "You're luckier than before!", "Your luck has worn off.", 1056, 15, "", "", "", "", "", ""} },
	{ 37, Playmod{ "4378_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 38, Playmod{ "614_300", "Stinky", "You really really smell.", "The air clears.", 614, 14, "spray.wav", "", "", "", "", ""} },
	{ 39, Playmod{ "1374_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 40, Playmod{ "406_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 41, Playmod{ "966_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 42, Playmod{ "4766_1800", "Blushing Red", "`4Cherry`` red lips!", "The effects of the `!Cherry`` have worn off.", 4766, 0, "spray.wav", "842203135", "drop", "", "", ""} },
	{ 43, Playmod{ "958_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 44, Playmod{ "950_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 45, Playmod{ "1580_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 46, Playmod{ "7052_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 47, Playmod{ "1634_5", "Caffeinated", "You are full of caffeine!", "Ugh. Caffeine crash.", 1634, 14, "spray.wav", "", "", "", "", ""} },
	{ 48, Playmod{ "4672_900", "Envious", "It ain't easy being you.", "Healthy color restored.", 4672, 0, "spray.wav", "1234743295", "", "", "", ""} },
	{ 49, Playmod{ "6314_2", "Frozen", "Your body has turned to ice. You can't move!", "You've thawed out.", 6314, 11, "freeze.wav", "4284769380", "", "", "", ""} },
	{ 50, Playmod{ "3064_0", "", "", "", 3064, 0, "", "", "throw", "34", "", ""} },
	{ 51, Playmod{ "8520_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 52, Playmod{ "10628_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 53, Playmod{ "1474_1800", "Food: Extra XP", "25% chance of double XP for all actions.", "Your stomach's rumbling.", 1474, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 54, Playmod{ "3546_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 55, Playmod{ "3600_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 56, Playmod{ "3836_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 57, Playmod{ "3240_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 58, Playmod{ "4410_0", ":P`#Bleh.``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 59, Playmod{ "4984_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 60, Playmod{ "2734_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 61, Playmod{ "3622_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 62, Playmod{ "10988_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 63, Playmod{ "4764_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 64, Playmod{ "964_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 65, Playmod{ "3428_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 66, Playmod{ "4752_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 67, Playmod{ "3816_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 68, Playmod{ "3816_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 69, Playmod{ "126_1800", "Devil Horns", "You little devil...", "Off the naughty list!", 126, 6, "spray.wav", "", "drop", "", "", ""} },
	{ 70, Playmod{ "1964_1800", "Devil Horns", "You little devil...", "Off the naughty list!", 1964, 6, "spray.wav", "", "drop", "", "", ""} },
	{ 71, Playmod{ "960_5", "ON FIRE!!!", "You are burning up!", "The fire's out.", 960, 17, "spray.wav", "842203135", "", "", "", ""} },
	{ 72, Playmod{ "712_5", "ON FIRE!!!", "You are burning up!", "The fire's out.", 712, 17, "spray.wav", "842203135", "", "", "", ""} },
	{ 73, Playmod{ "1988_1800", "Haunted!", "You are haunted!", "Not anymore.", 372, 18, "spray.wav", "", "", "", "", ""} },
	{ 74, Playmod{ "1772_2", "Floating!", "Whoooooooaaaaaaaa...", "Gravity - it's the law.", 1772, 0, "balloon.wav", "", "drop", "", "", "-30"} },
	{ 75, Playmod{ "5262_5", "Neon Gum!", "Dazzle your friends as super funky neon lines course across your skin.", "Party's over.", 5262, 28, "spray.wav", "", "drop", "", "", ""} },
	{ 76, Playmod{ "676_86400", "Doctor Replusion", "Doctors won't come near you!", "You no longer repel doctors.", 676, 0, "spray.wav", "", "", "", "", ""} },
	{ 77, Playmod{ "276_0", "", "", "", 0, 0, "", "", "cutewords", "", "", ""} },
	{ 78, Playmod{ "278_600", "Go to HELL!!", "You're on the HIGHWAY TO HELL!!", "You no longer cursed.", 278, 0, "already_used.wav", "", "", "", "", ""} },
	{ 79, Playmod{ "618_0", "", "", "", 0, 0, "", "", "cutewords", "", "", ""} },
	{ 80, Playmod{ "616_0", "", "", "", 0, 0, "", "", "cutewords", "", "", ""} },
	{ 81, Playmod{ "614_0", ":P", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 82, Playmod{ "750_1800", "Lucky", "You're luckier than before!", "Your luck has worn off.", 750, 15, "", "", "", "", "", ""} },
	{ 83, Playmod{ "752_0", "", "", "", 0, 0, "", "", "cutewords", "25", "", ""} },
	{ 84, Playmod{ "1208_0", ":D`#YUM!``", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 85, Playmod{ "5114_120", "Calm Nerves", "Steady hands of a surgeon.", "Butterfingers again.", 5114, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 86, Playmod{ "6912_1800", "Spicey Skills", "Reduce your skill fails by half in both Surgery and Startopia missions.", "Your stomach's too spicey.", 6912, 0, "spray.wav", "", "", "", "", ""} },
	{ 87, Playmod{ "3536_0", "Mmm, sugar!", "", "", 0, 0, "", "", "consume", "", "", ""} },
	{ 88, Playmod{ "1260_3600", "Malpractice", "You are not allowed to perform surgery for a while!", "You can surg again.", 1260, 0, "", "", "", "", "", ""} },
	{ 89, Playmod{ "1270_3600", "Recovering", "You are recovering from surgery.", "You healed.", 1270, 0, "", "", "", "", "", ""} },
	{ 90, Playmod{ "8500_0", "", "", "", 0, 0, "", "", "cutewords", "", "", ""} },
	{ 91, Playmod{ "4602_300", "Stinky", "You really really smell.", "The air clears.", 4602, 14, "spray.wav", "", "", "", "", ""} },
	{ 92, Playmod{ "8544_43200", "Lupus malady", "You've been infected with lupus!", "You no longer have lupus!", 8544, 0, "spray.wav", "", "", "", "", ""} },
	{ 93, Playmod{ "8540_43200", "Moldy Guts malady", "You've been infected with moldy guts!", "You no longer have moldy guts!", 8540, 0, "spray.wav", "", "", "", "", ""} },
	{ 94, Playmod{ "8546_43200", "Ecto-Bones malady", "You've been infected with Ecto-Bones!", "Your bones are no longer ectoplasmic!", 8546, 0, "spray.wav", "", "", "", "", ""} },
	{ 95, Playmod{ "8538_43200", "Chaos Infection malady", "You've been infected with CHAOS!", "You no longer have CHAOS!", 8538, 0, "spray.wav", "", "", "", "", ""} },
	{ 96, Playmod{ "8548_43200", "Fatty Liver malady", "You've been infected with fatty liver!", "You no longer have fatty liver!", 8548, 0, "spray.wav", "", "", "", "", ""} },
	{ 97, Playmod{ "8542_43200", "Brainworms malady", "You've been infected with brainworms!", "You no longer have brainworms!", 8542, 0, "spray.wav", "", "", "", "", ""} },
	{ 98, Playmod{ "6908_1800", "Food: Buff Duration", "Increase the duration of food buffs by 30%", "Your stomach can't take anymore buffs!", 6908, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 99, Playmod{ "5452_1800", "Food: Extra XP", "10% chance of triple XP for all actions.", "Your body craves sugar!", 5452, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 100, Playmod{ "2480_600", "Locke's Megaphone!", "Broadcasting to ALL!", "You can broadcast once again.", 11230, 0, "", "", "", "", "", ""} },
	{ 101, Playmod{ "11304_2678000", "Royal GrowPass", "We received your royalty, thanks for supporting `1LiteTopia``.!", "Monthly royalty has been reseted.", 11304, 0, "", "", "", "", "", ""} },
	{ 102, Playmod{ "5406_300", "Red Winterfest Crown!", "You're in the Winterfest spirit.", "Your paper crown dissolved in your forehead sweat!", 5406, 0, "spray.wav", "", "", "", "", ""} },
	{ 103, Playmod{ "5408_300", "Green Winterfest Crown!", "You're in the Winterfest spirit.", "Your paper crown dissolved in your forehead sweat!", 5408, 0, "spray.wav", "", "", "", "", ""} },
	{ 104, Playmod{ "5410_300", "Silver Winterfest Crown!", "You're in the Winterfest spirit.", "Your paper crown dissolved in your forehead sweat!", 5410, 0, "spray.wav", "", "", "", "", ""} },
	{ 105, Playmod{ "5412_300", "Gold Winterfest Crown!", "You're in the Winterfest spirit.", "Your paper crown dissolved in your forehead sweat!", 5412, 0, "spray.wav", "", "", "", "", ""} },
	{ 106, Playmod{ "4232_0", "`#:D YUM!``", "", "", 4232, 0, "", "", "consume", "204", "", ""} },
	{ 107, Playmod{ "4324_1800", "Extra XP", "Your brain has been enhanced!", "You're getting dumber by the second.", 4324, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 108, Playmod{ "4596_1800", "Food: Surgery XP", "Gain 30% more XP from Surgery!", "Your stomach's rumbling.", 4596, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 109, Playmod{ "11068_0", "`#:D Ahhh! That is REFRESHING!``", "", "", 11068, 0, "", "", "consume", "204", "", ""} },
	{ 110, Playmod{ "6050_1800", "Food: Pet Gems 200", "Get 200 Gems for beating a Pet Trainer.", "Your stomach's rumbling.", 6050, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 111, Playmod{ "6048_1800", "Food: Pet Gems 150", "Get 150 Gems for beating a Pet Trainer.", "Your stomach's rumbling.", 6048, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 112, Playmod{ "6046_1800", "Food: Pet Gems 100", "Get 100 Gems for beating a Pet Trainer.", "Your stomach's rumbling.", 6046, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 113, Playmod{ "6910_1800", "Food: Delectable", "25% chance of double Growtokens from Daily Quests.", "Your stomach's devasted!", 6910, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 114, Playmod{ "4604_1800", "Food: Breaking Gems", "10% chance of a gem when you break a block.", "Your stomach's rumbling.", 4604, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 115, Playmod{ "3728_6", "Slimed!", "You're covered in ectoplasm!", "You got cleaned up.", 3728, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 116, Playmod{ "1602_900", "Minty", "Ya'll are feelin' minty, sugah.", "Healthy color restored.", 1602, 0, "eat.wav", "1627349247", "", "", "", ""} },
	{ 117, Playmod{ "12152_600", "Janeway's Coffee: Speedy", "On my mark... Go Fast!", "Speed normalized!", 12152, 14, "spray.wav", "", "", "", "", ""} },
	{ 118, Playmod{ "4982_180", "`#:D YUM!``", "You are an orange person.", "You got cleaned up.", 4982, 0, "", "726390783", "consume", "", "", ""} },
	{ 119, Playmod{ "4984_0", "`#:D YUM!``", "", "", 4984, 0, "", "", "consume", "204", "", ""} },
	{ 120, Playmod{ "4594_1800", "Food: Tree Growth food buff", "Trees you plant grow 5% faster!", "Your stomach's rumbling.", 4594, 0, "spray.wav", "", "drop", "", "", ""} },
	{ 121, Playmod{ "1662_5", "Spikeproof", "You are briefly immune to spikes and lava.", "You feel vulnerable again.", 1662, 10, "", "", "", "", "", ""} },
	{ 122, Playmod{ "732_120", "BAN Cooldown!", "BAN cooldown!", "Your ban cooldown is gone.", 732, 0, "", "", "", "", "", ""} },
	{ 123, Playmod{ "368_6", "Muddy", "You've been splattered with mud!", "Clean again!", 368, 0, "", "1348237567", "consume", "", "", ""} },
	{ 124, Playmod{ "1280_2592000", "Recently Name-Changed", "You changed your name.", "You can now change your name again!", 1280, 0, "", "", "", "", "", ""} },
	{ 125, Playmod{ "9500_1800", "Lucky More Gems", "You're luckier than before!", "Your luck has worn off.", 9500, 15, "", "", "", "", "", "" } },
	{ 126, Playmod{ "3000_300", "Tournament Mode", "Your tournament has been started!", "Your tournament has been ended.", 3000, 0, "", "", "", "", "", ""} },
	{ 127, Playmod{ "0_604800", "Boosted: Extra Gems + Unlimited SB", "Feel free to do Broadcasts and earn massive gems!", "Back to normal, profitter.", 9148, 0, "", "", "", "", "", ""} }
};
vector<pair<uint32_t, int>> growch_prize{
	{5172, 200000},
	{6016, 500000},
	{12992, 1000000},
	{2392, 2000000},
	{7832, 5000000},
	{1460, 10000000},
	{5172, 50000000}, 
};
void print_info_pmod(Playmod playmod) {
	tayo_info(format(
		"Playmod id: {}\n"
		"consumableid_time: {}\n"
		"name: {}\n"
		"onUsed: {}\n"
		"onRemoved: {}\n"
		"gravity: {}\n"
		"howWork: {}\n"
		"state: {}\n"
		"skin: {}\n"
		"audio: {}\n"
		"displayId: {}\n"
		"effect: {}\n"
		"text: {}\n",
		explode("_", playmod.consumableid_time)[0],
		playmod.consumableid_time,
		playmod.name,
		playmod.onUsed,
		playmod.onRemoved,
		playmod.gravity,
		playmod.howWork,
		playmod.state,
		playmod.skin,
		playmod.sound,
		playmod.displayId,
		playmod.eff,
		playmod.usetext)
	);
}
void print_info_pmod(int playmod_id) {
	auto playmod = info_about_playmods[playmod_id];
	tayo_info(format(
		"Playmod id: {}\n"
	    "consumableid_time: {}\n"
	    "name: {}\n"
	    "onUsed: {}\n"
	    "onRemoved: {}\n"
	    "gravity: {}\n"
		"howWork: {}\n"
		"state: {}\n"
		"skin: {}\n"
		"audio: {}\n"
		"displayId: {}\n"
		"effect: {}\n"
		"text: {}\n",
		playmod_id,
		playmod.consumableid_time,
		playmod.name,
		playmod.onUsed,
		playmod.onRemoved,
		playmod.gravity,
		playmod.howWork,
		playmod.state,
		playmod.skin,
		playmod.sound,
		playmod.displayId,
		playmod.eff,
		playmod.usetext)
	);
}

int get_playmod_id(int mod_id) {
	if (mod_id >= items.size() || mod_id <= 0) return 0; 
	int the_result = 0;
	for (auto& mods : info_about_playmods) {
		int mod_item = atoi(explode("_", mods.second.consumableid_time)[0].c_str());
		if (mod_item == mod_id)
		{
			the_result = mods.first;
			break;
		}
	}
	return the_result;
}
struct Portrait
{
	uint32_t c_expression = 1;
	/*
	* 1: Unconcerned
	* 2: Happy
	* 3: Sad
	* 4: Tongue Out
	* 5: Surprised
	* 6: Angry
	* 7: Talking
	* 9: Ecstatic
	* 24: Wry
	* 12: Sleeping
	* 14: Winking
	* 16: Trolling
	* 18: Vampire
	* 22: Underwater
	* 26: Blushed
	*
	*/
	uint32_t c_hair_colour = 0;
	uint32_t c_skin = 0;
	uint16_t c_face = 0;
	uint16_t c_head = 0;
	uint16_t c_hair = 0;
};
void save_purchase() {
	json j;
	ofstream writer("database/purchase_event.json");
	j["coin_1"] = g_obtained_coin1;
	j["coin_5"] = g_obtained_coin5;
	j["coin_10"] = g_obtained_coin10;
	writer << j;
	writer.close();
}
void to_json(json& j, const Portrait& p) {
	j = json{
		{"c_expression", p.c_expression},
		{"c_hair_colour", p.c_hair_colour},
		{"c_skin", p.c_skin},
		{"c_face", p.c_face},
		{"c_head", p.c_head},
		{"c_hair", p.c_hair}
	};
}
void from_json(const json& j, Portrait& p) {
	j["c_expression"].get_to(p.c_expression);
	j["c_hair_colour"].get_to(p.c_hair_colour);
	j["c_skin"].get_to(p.c_skin);
	j["c_face"].get_to(p.c_face);
	j["c_head"].get_to(p.c_head);
	j["c_hair"].get_to(p.c_hair);
}
string fixint(int jumlah) {
	string result = to_string(jumlah);
	for (int i = result.size() - 3; i > 0; i -= 3)
		result.insert(i, ",");
	return result;
}
inline string get_string_low(string tt)
{
	string result;
	for (char c : tt) {
		result += tolower(c);
	}
	return result;
}
struct Mannequin
{
	uint16_t c_head = 0;
	uint16_t c_shirt = 0;
	uint16_t c_pants = 0;
	uint16_t c_feet = 0;
	uint16_t c_mask = 0;
	uint16_t c_hand = 0;
	uint16_t c_back = 0;
	uint16_t c_hair = 0;
	uint16_t c_neck = 0;
};
void to_json(json& j, const Mannequin& p) {
	j = json{
		{"c_head", p.c_head},
		{"c_shirt", p.c_shirt},
		{"c_pants", p.c_pants},
		{"c_feet", p.c_feet},
		{"c_mask", p.c_mask},
		{"c_hand", p.c_hand},
		{"c_back", p.c_back},
		{"c_hair", p.c_hair},
		{"c_neck", p.c_neck}
	};
}
void set_bux(ENetPeer* peer, int const& gems) {
	time_t currentTime;
	time(&currentTime);
	const auto localTime = localtime(&currentTime);
	const auto Hour = localTime->tm_hour; const auto Min = localTime->tm_min; const auto Sec = localTime->tm_sec; const auto Year = localTime->tm_year + 1900; const auto Day = localTime->tm_mday; const auto Month = localTime->tm_mon + 1;
	int voucher = 0;
	int servertime = (Hour * 3600) + (Min * 60) + Sec;
	gamepacket_t p8;
	p8.Insert("OnSetBux");
	p8.Insert(gems);
	p8.Insert(0);
	p8.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
	p8.Insert((float)servertime, (float)1, (float)0);
	p8.CreatePacket(peer);
}
void from_json(const json& j, Mannequin& p) {
	j["c_head"].get_to(p.c_head);
	j["c_shirt"].get_to(p.c_shirt);
	j["c_pants"].get_to(p.c_pants);
	j["c_feet"].get_to(p.c_feet);
	j["c_mask"].get_to(p.c_mask);
	j["c_hand"].get_to(p.c_hand);
	j["c_back"].get_to(p.c_back);
	j["c_hair"].get_to(p.c_hair);
	j["c_neck"].get_to(p.c_neck);
}
struct Donate
{
	int item = 0, count = 0;
	string name = "", text = "";
};
void to_json(json& j, const Donate& p) {
	j = json{
		{"item", p.item},
		{"count", p.count},
		{"name", p.name},
		{"text", p.text}
	};
}
void from_json(const json& j, Donate& p) {
	j["item"].get_to(p.item);
	j["count"].get_to(p.count);
	j["name"].get_to(p.name);
	j["text"].get_to(p.text);
}

struct BlockTeam {
	vector<string> players;
	int8_t team_id = -1;
};

struct WorldBlock
{
	uint16_t fg = 0, bg = 0;
	int fruit = 0;
	uint32_t id = 0, wl = 0;
	int audio_volume = 0;
	string audio_notes = "";
	size_t c_ = 0;
	string game_label = "Classic Deathmatch";
	int game_time = 3600;
	int pr = 0;
	long long lp = 0, planted = 0;
	vector<BlockTeam> teams;
	int hp = -1, sp = 0;
	uint8_t roll = 0;
	string txt = "";
	string door_destination = "", door_id = "";
	bool open = true;
	int flags = 0x00000000;
	long long last_punch_weather = 0;
	bool scanned = false;
	int rate_of_fire = 10, projectile_speed = 100;
	// magplants
	bool enabled = false;
	int gravity = 50;
	bool spin = false, invert = false;
	bool magnetron = false;
	bool locked = false;
	int lock_origin = -1;
	bool open_to_public = false;
	bool empty_air = false;
	bool visited = false;
	int path_parent = -1;
	float local = 0.0f;
	float global = 0.0f;
	vector<int> admins{};
	string owner_name = "";
	string owner_named = "";
	bool build_only = false;
	bool limit_admins = false;
	vector<vector<int>> crystals{};
	Mannequin mannequin{};
	vector<Donate> donates{};
	int r = 255, g = 128, b = 64;
	Portrait portrait{};
	uint32_t bunny_egg_progress = 0;
	string heart_monitor = "";
	string spotlight = "";
	bool fossil = false;
	uint32_t shelf_1 = 0, shelf_2 = 0, shelf_3 = 0, shelf_4 = 0;
	vector<int> offering_items;
	int owner_id = 0;
	uint8_t kranken_pattern = 0;
	uint8_t epoch_minute = 10;
	// weather infinity & epoch ?
	vector<int> weatherListID;
	pair<vector<bool>, int> epoch_state{ {true, false, false}, 10 };
	long long epoch_cycle = 0;
	bool ep_def() {
		if (this->epoch_state.first[0] == true &&
			this->epoch_state.first[1] == false &&
			this->epoch_state.first[2] == false &&
			this->epoch_state.second == 10) return true;
		return false;
	}
	int bbm_d = 0;
};
class kranken_pattern {
public:
	enum : uint8_t {
		NONE,
		PT1,
		PT2,
		PT3,
		PT4,
		PT5,
		PT6,
		PT7,
		PT8,
		PT9,
		PT10,
		PT11,
		PT12,
	};
	static std::pair<uint32_t, uint32_t> get_pattern(const uint8_t& pattern) {
		switch (pattern) {
		case NONE:
			return { (uint32_t)0, (uint32_t)10962 };
		case PT1:
			return { (uint32_t)1, (uint32_t)10964 };
		case PT2:
			return { (uint32_t)2, (uint32_t)10966 };
		case PT3:
			return { (uint32_t)3, (uint32_t)10968 };
		case PT4:
			return { (uint32_t)4, (uint32_t)10970 };
		case PT5:
			return { (uint32_t)5, (uint32_t)10972 };
		case PT6:
			return { (uint32_t)6, (uint32_t)10974 };
		case PT7:
			return { (uint32_t)7, (uint32_t)10976 };
		case PT8:
			return { (uint32_t)8, (uint32_t)10978 };
		case PT9:
			return { (uint32_t)9, (uint32_t)10980 };
		case PT10:
			return { (uint32_t)10, (uint32_t)10982 };
		case PT11:
			return { (uint32_t)11, (uint32_t)10984 };
		case PT12:
			return { (uint32_t)12, (uint32_t)10986 };
		default:
			return { (uint32_t)0, (uint32_t)10962 };
		}
	}
};
struct WorldMachines
{
	uint16_t id = 0, x = 0, y = 0, target_item = 0;
	bool enabled = false;
	long long last_ = 0;
};

struct WorldNPC
{
	uint16_t id = 0, x = 0, y = 0, rate_of_fire = 10, projectile_speed = 100;
	float kryptis = 0;
	int uid = 0;
	bool enabled = false;
	long long last_ = 0, started_moving = 0;
};
struct WorldDrop
{
	int id = 0, count = 0, uid = 0, x = 0, y = 0;
	bool special = false;
};
struct WorldSBOX1
{
	int id = 0, count = 0, x = 0, y = 0;
};
struct WorldGrowscan
{
	int x = 0, y = 0;
	bool world_public = false, floating_public = false;
};
struct WorldBulletinSettings
{
	int x = 0, y = 0;
	bool public_can_add = false, hide_names = false;
};

struct WorldCCTVSettings
{
	int x = 0, y = 0;
	bool show_item_taking = false, show_item_dropping = false, show_people_entering = true, show_people_exiting = false, dont_show_owner = false, dont_show_admins = false, dont_show_noaccess = false;
};

struct WorldCCTV
{
	int x = 0, y = 0;
	string logs;
};

struct WorldBulletin
{
	int x = 0, y = 0;
	string name = "", text = "";
};
struct GlobalMonitors
{
	string world_name = "";
	int x = -1, y = -1;
	uint32_t active = 0;
};
vector<GlobalMonitors> monitors;
struct World
{
	string verifiedTime = "";
	bool verified = false;

	int width = 100, height = 60;
	pair<int, int> s4tb{ 0, 0 };
	bool no_antibounce = false;
	double Honor = 0.0, Overall = 0.0, Yesterday = 0.0, World_Rating = 0.0;
	string honors = "";
	int yesterday = 0;
	int overall = 0;
	bool allow_noclip = true;
	int World_Time = 0;
	string Category = "None";
	string name = "", owner_name = "", owner_named = "";
	int world_id = 0;
	bool nuked = false;
	bool xenonite = false;
	bool X_1 = false, X_2 = false, X_3 = false, X_4 = false, X_5 = false, X_6 = false, X_7 = false, X_8 = false, X_9 = false, X_10 = false, X_11 = false, X_12 = false, X_13 = false, X_14 = false, X_15 = false, X_16 = false, X_17 = false, X_18 = false, X_19 = false;
	string n_t = "";
	string n_b = "";
	vector<int> admins{};
	vector<WorldBlock> blocks{};
	vector<WorldDrop> drop{};
	vector<WorldGrowscan> gscan{};
	std::int64_t lastAutoSave = date_time::get_epoch_time() + 600, lastRedundant = 0;
	std::uint64_t lastSave = 0;
	vector<WorldCCTVSettings> cctv_settings{};
	vector<WorldCCTV> cctv{};
	vector<WorldSBOX1> sbox1{};
	vector<WorldBulletin> bulletin{};
	vector<WorldBulletinSettings> bulletins{};
	uint16_t weather = 0;
	uint16_t d_weather = 0;
	bool v_p = false;
	bool open_to_public = false, disable_music_blocks = false, make_music_blocks_invisible = false;
	//vector<pair<int, long long int>> banned_player_uid{};
	vector<pair<int, long long int>> bannedPlayers{};
	long long last_address_change = 0;
	bool zombie_jammer = false;
	uint32_t music_bpm = 100;
	int entry_level = 1;
	vector<int> active_jammers{};
	vector<WorldNPC> npc{};
	vector<WorldMachines> machines{};
	int guild_id = 0, owner_id = 0;
	long long int save_time = 0;
	int lockid = 0;
	bool rainbows = false, silence = false;

	long long last_special_event = 0, last_comet_spawn = 0;
	int special_event_item = 0;
	int special_event_item_taken = 0;
	bool special_event = false;
	int r = 255, g = 255, b = 255;
};

vector<World> worlds;
map<string, vector<WorldNPC>> active_npc;
map<string, vector<WorldMachines>> active_machines;
int get_free_slots(Player* p_) {
	int free = 0; // -1
	for (int i_ = 0; i_ < p_->inv.size(); i_++) {
		if (p_->inv[i_].id == 0 and p_->inv[i_].count == 0)
			free++;
	}
	return free;
}
int get_item_count(Player* p_, int id) {
	for (int i = 0; i < p_->inv.size(); i++) {
		if (p_->inv[i].id == id)
			return p_->inv[i].count;
	}
	return 0;
}
int get_mag_size(int lock) {
	switch (lock) {
	case 8470: return 100000;
	case 7188: return 50000;
	case 1796: return 10000;
	default: return 5000;
	}
	return 5000;
}
void packet_(ENetPeer* p_, string t_, string l_ = "") {
	if (l_ != "")
		t_ = "action|log\nmsg|" + t_;
	int y_ = 3;
	BYTE z_ = 0;
	BYTE* const d_ = new BYTE[5 + t_.length()];
	memcpy(d_, &y_, 4);
	memcpy(d_ + 4, t_.c_str(), t_.length());
	memcpy(d_ + 4 + t_.length(), &z_, 1);
	ENetPacket* const p = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(p_, 0, p);
	delete[]d_;
	if (l_ != "") {
		const string w_ = "https://discord.gg/Hz3Kq5xCs8";
		l_ = "action|set_url\nurl|" + w_ + "\nlabel|" + l_ + "\n";
		BYTE* const u_ = new BYTE[5 + l_.length()];
		memcpy(u_, &y_, 4);
		memcpy(u_ + 4, l_.c_str(), l_.length());
		memcpy(u_ + 4 + l_.length(), &z_, 1);
		ENetPacket* const p3 = enet_packet_create(u_, 5 + l_.length(), ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(p_, 0, p3);
		delete[]u_;
	}
}

void packets_(ENetPeer* p_, string t_, string l_ = "") {
	if (l_ != "")
		t_ = "action|log\nmsg|" + t_;
	int y_ = 3;
	BYTE z_ = 0;
	BYTE* const d_ = new BYTE[5 + t_.length()];
	memcpy(d_, &y_, 4);
	memcpy(d_ + 4, t_.c_str(), t_.length());
	memcpy(d_ + 4 + t_.length(), &z_, 1);
	ENetPacket* const p = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(p_, 0, p);
	delete[]d_;
	if (l_ != "") {
		const string w_ = "https://discord.gg/m56PsDExQ9";
		l_ = "action|set_url\nurl|" + w_ + "\nlabel|" + l_ + "\n";
		BYTE* const u_ = new BYTE[5 + l_.length()];
		memcpy(u_, &y_, 4);
		memcpy(u_ + 4, l_.c_str(), l_.length());
		memcpy(u_ + 4 + l_.length(), &z_, 1);
		ENetPacket* const p3 = enet_packet_create(u_, 5 + l_.length(), ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(p_, 0, p3);
		delete[]u_;
	}
}

namespace game_packet {
	void play_audio(ENetPeer* peer, std::string const& file, int const& delay = 0) {
		packets_(peer, "action|play_sfx\nfile|audio/" + file + "\ndelayMS|" + std::to_string(delay));
	}
}

void news(ENetPeer* peer, bool show_banner = true) {
	{
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		if (thedaytoday == 1) p.Insert("`3Today is Trees Day!`` 50% higher chance to get `2extra block`` from harvesting tree.");
		else if (thedaytoday == 2) p.Insert("`3Today is Breaking Day!`` 15% higher chance to get `2extra seed``.");
		else if (thedaytoday == 3) p.Insert("`3Today is Geiger Day!`` Higher chance of getting a `2better Geiger prize`` & Irradiated mod will last only `210 minutes``.");
		else if (thedaytoday == 4) p.Insert("`3Today is Level Day!`` Get extra `2500 gems`` bonus for leveling up.");
		else if (thedaytoday == 5) p.Insert("`3Today is Gems Day!`` 50% higher chance to get `2extra`` gem drop.");
		else if (thedaytoday == 6) p.Insert("`3Today is Surgery Day!`` Malpractice takes `215 minutes`` and Recovering takes `230 minutes`` & receive `2different prizes``.");
		else if (thedaytoday == 0) p.Insert("`3Today is Fishing Day!`` Catch a fish and receive `2extra lb``.");
		p.CreatePacket(peer);
	}
	if (gem_event > 1) {
		packet_(peer, format("action|log\nmsg|`9{}x gems event`` is going on! Make sure to grab your farmables.", gem_event));
	}
	if (provider_event > 1) {
		packet_(peer, format("action|log\nmsg|`9{}x provider event`` is going on! In this event, all providers will grow x{} faster. Make sure to grab your farmables.", provider_event, provider_event));
	}
	if (xp_event > 1) {
		packet_(peer, format("action|log\nmsg|`9{}x xp event`` is going on! Make sure to grab your farmables.", xp_event));
	}
	if (carnival_open) {
		packet_(peer, "action|log\nmsg|`2Carnival has visited the town! Don't forget to pay a visit in `9CARNIVAL`2 because it's limited.``");
	}
	if (salesman_open) {
		packet_(peer, "action|log\nmsg|`2Salesman has visited the town! Don't forget to pay a visit in `9LOCKE`2 because it's limited.``");
	}
	if (Harvest_Festival) {
		packet_(peer, "action|log\nmsg|`2Harvest Festival is here!`` Go collect some mooncakes from harvesting trees.``");
	}
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
	string month = months[newtime.tm_mon], translated = "", str = to_string(today_day), locke = "";
	if (str == "01" || str == "21") translated = "st";
	else if (str == "02" || str == "22") translated = "nd";
	else if (str == "03" || str == "23") translated = "rd";
	else translated = "th";
	if (salesman_open) 
		locke = "\nadd_spacer|small|\nadd_textbox|`oToday, `5Locke`` the traveling salesman is visiting TayoPs! He comes one day a week to hawk his fabulous wares, though this time he'll stick around a day and a half to introduce himself. Checkout the world `5LOCKE``!``|left|";
	//locke = "\nadd_spacer|small|\nadd_textbox|`oToday HeroPS is being paid a visit by `5Locke`` the traveling salesman! He comes one day a week to hawk his fabulous wares, though this time he'll stick around a day and a half to introduce himself. Checkout the world `5LOCKE``!``|left|" UPDATE NEWS;
	news_texture = "set_default_color|`o\n"
		"add_label_with_icon|big|`wThe TayoPs Gazette``|left|5016|\n"
		"add_spacer|small|";
	if (show_banner) news_texture += "\nadd_image_button||interface/large/news_banner.rttex|bannerlayout|||";
	news_texture += "\nadd_spacer|small|"
		//"\nadd_image_button|join_dc|interface/large/discord.rttex|3imageslayout|https://discord.gg/growlandps|Do you want to join our discord server?|"
		//"\nadd_image_button|rules_bro|interface/large/rules.rttex|3imageslayout|||"
		//"\nadd_image_button|feature_bang|interface/large/features.rttex|3imageslayout|||"
		//"\nadd_spacer|small|\nadd_textbox|`w" + month + " " + to_string(today_day) + "" + translated + "``: `5Harvest Fest."
		"|left|\nadd_label|small|" + locke +
		"|\nadd_label|small|Welcome to TayoPs.|"
		;
	int total_event = 0; 
	//if (xp_event > 1) news_texture += "\nadd_image_button||interface/large/gazette/gtps_1.rttex|3imageslayout|||";
	//if (salesman_open) news_texture += "\nadd_image_button||interface/large/salesman_open.rttex|3imageslayout|||";
	if (gem_event > 1) total_event++, news_texture += "\nadd_image_button||interface/large/gazette/gtps_2.rttex|3imageslayout|||";
	if (provider_event > 1) total_event++, news_texture += "\nadd_image_button||interface/large/gazette/gtps_3.rttex|3imageslayout|||";
	//if (xp_event > 1) total_event++, news_texture += "\nadd_image_button||interface/large/gazette/gtps_4.rttex|3imageslayout|||";
	
	news_texture += format("\nadd_spacer|{}|\nadd_spacer|{}|\nadd_spacer|{}|", (total_event == 3 ? "small" : "big"), (total_event == 3 ? "small" : "big"), (total_event == 3 ? "small" : "big"));

	news_texture += "\nadd_label_with_icon|small|New Wrench UI: Some changes.|left|32|";
	news_texture += "\nadd_label_with_icon|small|New shop items: New items are in shop.|left|242|";
	news_texture += "\nadd_label_with_icon|small|Adjustments on Broadcasts: Adjusted the text color and display name for `#MOD-SB`` and `1VIP-SB``.|left|2480|";
	news_texture += "\nadd_label_with_icon|small|TayoPoint Shop: Returned to the V1 UI which was easier to use.|left|9784|";
	news_texture += "\nadd_label_with_icon|small|Birth Certificate: Now fully working without losing your essential data.|left|1280|";
	news_texture += "\nadd_label_with_icon|small|Power Adjustments: Adjusted powers for `#@MODERATOR`` & `b@SUPER-MODERATOR``.|left|278|";
	news_texture += "\nadd_label_with_icon|small|Bugs Fixes & Optimized: Applied some fixes on bugs.|left|98|";
	news_texture += "\nadd_label_with_icon|small|Growpedia Update: Contains `2combiner recipes``, `2splicing``, `2rules``, `2combusting``, and `2crystal recipes``.|left|6336|";
	news_texture += "\nadd_label_with_icon|small|Harvest Fest Update: `2Mooncake Offering Table``, `2Random Mooncake drops from harvesting tree``.|left|1828|";
	news_texture += "\nadd_label_with_icon|small|Another Updates:`` All updates are written in #update-server channel in `2TayoPs Discord Server``.|left|18|";
	news_texture += "\nadd_spacer|small|\nadd_spacer|small|\nend_dialog|news_gacor||OK|\nadd_quick_exit|";
	gamepacket_t p(250);
	p.Insert("OnDialogRequest"), p.Insert(news_texture), p.CreatePacket(peer);
}
void replaceAll(string& str, const string& from, const string& to) {
	if (from.empty())return;
	size_t start_pos = 0;
	while ((start_pos = str.find(from, start_pos)) != string::npos) {
		str.replace(start_pos, from.length(), to);
		start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
	}
}

void replace(string& str, string from, string to) {
	size_t start_pos = str.find(from);
	if (start_pos == std::string::npos)
		return;
	str.replace(start_pos, from.length(), to);
}

void punch_tile(ENetPeer* peer, int x, int y, int t_, int n_, int net_, int state_, bool tree_ = false, int count_ = 1, bool every_ = true) {
	PlayerMoving data{ items[pInfo(peer)->hand].punch_far > 1 ? 0 : net_, 0, t_, state_, n_, x, y, 0, (float)x, (float)y, 0, 0 };
	BYTE* p_ = packPlayerMoving(&data);
	p_[2] = 0, p_[3] = tree_ ? count_ : 0;
	int32_t item = pInfo(peer)->hand;
	memcpy(p_ + 8, &item, 4);
	if (every_) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
			send_raw(currentPeer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	else {
		send_raw(peer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
	}
	delete[]p_;
}

void update_tile(ENetPeer* peer, int16_t x, int16_t y, int16_t n_, bool add, bool everyone) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (add) growganoth_platform.push_back(x + (y * world_->width));
		PlayerMoving data{ 0, 0, 3, 0, n_, x, y, 0, (float)x, (float)y, 0, 0 };
		BYTE* p_ = packPlayerMoving(&data);
		if (everyone) {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				send_raw(currentPeer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
			}
		}
		else send_raw(peer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
		send_raw(peer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
		delete[]p_;
	}
}

World create_mars2(const string& name_, int width, int height) {
	World world;
	world.name = name_;
	world.weather = 7;
	world.d_weather = 7;
	world.width = width;
	world.height = height;

	world.blocks.reserve(width * height);
	for (auto i = 0; i < width * height; i++) {
		WorldBlock block_{ 0, 0, uint16_t(-1) };
		world.blocks.push_back(block_);
	}

	const int dirtType = 1132, bedrockType = 8, caveBackgroundType = 14, rockType = 1134, lavaType = 440;

	const auto offset = new int[width];
	const auto offset2 = new int[width];
	offset[0] = (height - 60 < 0) ? -10 : height - 60;
	offset2[0] = offset[0] < 0 ? -10 : offset[0];
	auto settile = [](World wr, const int x, const int y, const int id)
	{
		auto w = &wr;
		if (x < w->width && x >= 0 && y < w->height && y >= 0)
			w->blocks.at(x + y * w->width).fg = id;
	};
	auto settilebg = [](World wr, const int x, const int y, const int id)
	{
		auto w = &wr;
		if (x < w->width && x >= 0 && y < w->height && y >= 0)
			w->blocks.at(x + y * w->width).bg = id;
	};
	auto gettile = [](World wr, const int x, const int y) -> uint16_t
	{
		auto w = &wr;
		if (x < w->width && x >= 0 && y < w->height && y >= 0)
			return w->blocks.at(x + y * w->width).fg;
		return uint16_t(0);
	};
	for (auto i = 1; i < width; i++)
	{
		offset[i] = (height - 60 < 0) ? -10 : height - 60;
		const auto rnd = rand() % 30 - 10;
		if (rnd < -2)
			offset[i] = offset[i - 1] - 1; // rise
		else if (rnd > 11)
			offset[i] = offset[i - 1] + 1; // fall
		else
			offset[i] = offset[i - 1]; // no change
		offset2[i] = offset[i] < 0 ? -10 : offset[i];
	}
	for (auto j = 0; j < width; j++)
	{
		for (auto k = 26 + offset[j]; k < height - 5; k++)
		{
			settile(world, j, k, dirtType);
			settilebg(world, j, k, caveBackgroundType);
			const auto renrnd = rand() % 12;
			if (renrnd > 10)
				settile(world, j, k, rockType);
		}
		settile(world, j, 26 + offset[j], dirtType);
		settilebg(world, j, 26 + offset[j], caveBackgroundType);
		settile(world, j, height - 6, bedrockType);
		settile(world, j, height - 5, bedrockType);
		settile(world, j, height - 4, bedrockType);
		settile(world, j, height - 3, bedrockType);
		settile(world, j, height - 2, bedrockType);
		settile(world, j, height - 1, bedrockType);
		settilebg(world, j, height - 6, caveBackgroundType);
		settilebg(world, j, height - 5, caveBackgroundType);
		settilebg(world, j, height - 4, caveBackgroundType);
		settilebg(world, j, height - 3, caveBackgroundType);
		settilebg(world, j, height - 2, caveBackgroundType);
		settilebg(world, j, height - 1, caveBackgroundType);
	}
	for (auto srg = height - 10; srg < height - 6; srg++)
	{
		for (auto dhk = 0; dhk < width; dhk++)
		{
			const auto djkf = rand() % 2;
			if (djkf == 1)
			{
				settile(world, dhk, srg, lavaType);
			}
		}
	}
	int deco1Id = 0, deco2Id = 0;
	int id = 0;
	if (id & 4)
	{
		for (auto i = 0; i < width; i++)
		{
			for (auto j = deco2Id; j < height; j++)
			{
				if (gettile(world, i, j) == 0)
				{
					if (i < world.width && i >= 0 && j < world.height && j >= 0)
						world.blocks.at(i + j * world.width).flags |= 0x04000000;
				}
			}
		}
	}
	else if (id & 1)
	{
		const auto deco1Count = rand() % 25 + 3;
		for (auto i = 0; i < deco1Count; i++)
		{
			const auto a = rand() % width;
			settile(world, a, 25 + offset[a], deco1Id);
		}
	}
	else if (id & 2)
	{
		const auto deco2Count = rand() % 25 + 3;
		for (auto i = 0; i < deco2Count; i++)
		{
			const auto a = rand() % width;
			settile(world, a, 25 + offset[a], deco2Id);
		}
	}
/*
regenerate:
	const auto mainDoorX = (rand() % (width - 4)) + 2;
	auto f = 25 + offset[mainDoorX];
	while (gettile(world, mainDoorX, f) != 0)
	{
		f--;
		if (f < 0) goto regenerate;
	}
	settile(world, mainDoorX, f, 6);
	settile(world, mainDoorX, f + 1, bedrockType);
	delete[] offset;
	delete[] offset2;
// end
*/
	
	worlds.push_back(world);
	return world;
}

World create_mars(const string& name_, int width, int height) {
	World world_;
	world_.name = name_;
	world_.weather = 7;
	world_.d_weather = 7;
	world_.width = width;
	world_.height = height;

	int s_ = width * height;
	int d_ = rand() % (s_ / (s_ / width) - 4) + 2;
	for (int i = 0; i < s_; i++) {
		WorldBlock block_{ 0, 0, uint16_t(-1) };
		if (i == 2300 + d_)
			block_.fg = 6;
		else if (i == 2200 && !(rand() % 3))
		{
			if (block_.fg != 6) {
				block_.fg = 1138;
			}
		}
		else if (i == 2300)
		{
			if (block_.fg != 6 and !(rand() % 3)) {
				block_.fg = 1132;
			}
		}
		else if (i == 2400 + d_)
		{
			block_.fg = 8;
		}
		else if (i >= 2500 && i < 5400 && !(rand() % 40))
		{
			block_.fg = 1134;
		}
		else if (i >= 2400 && i < 5400)
		{
			if (i > 5000 && !(rand() % 9))
			{
				block_.fg = 440;
			}
			else
			{
				block_.fg = 1132;
			}
		}
		else if (i >= 5400)
		{
			block_.fg = 8;
		}

		if (i >= 2400)
		{
			block_.bg = 14;
		}
		world_.blocks.push_back(block_);
	}
	worlds.push_back(world_);
	return world_;
}

World create_beach(const string& name_, int width, int height) {
	World world_;
	world_.name = name_;
	world_.weather = 1;
	world_.d_weather = 1;
	world_.width = width;
	world_.height = height;
	//int d_ = rand() % (s_ / (s_ / 100) - 4) + 2;
	// reserve tiles by size
	world_.blocks.reserve(width * height);
	for (int i_ = 0; i_ < width * height; ++i_) {
		WorldBlock block_{ 0, 0, uint16_t(-1) };
		world_.blocks.push_back(block_);
	}
	auto offset = new int32_t[width]; // create a static array
	offset[0] = 6;

	auto random = [](int min, int max) {
		mt19937 generator{ random_device{}() };
		return uniform_int_distribution<int>{ min, max }(generator);
	};

	pair<int, int> height_t = { 19, 23 };
	auto initial_height = height_t.second;
	auto start_offset_x = 20;

	for (int i = 1; i < width; i++) {
		offset[i] = 0x6;
		if ((random(0, 30) - 10) > 13 && i >= start_offset_x)
			offset[i] = offset[i - 1] + 1;
		else 
			offset[i] = offset[i - 1];
	}

	int door_x = (random(0, start_offset_x - 2)) + 1;
	int tree_x = (random(0, start_offset_x - 2)) + 1;
	int umbrella_x = (random(0, start_offset_x - 2)) + 3;
	bool d_done = false, u_done = false, t_generated = false;

	if (door_x == umbrella_x) // checker to prevent duplicate on tile data
		umbrella_x = (random(0, start_offset_x - 2)) + 1; // swap umbrella pos
	if (tree_x == umbrella_x || door_x == umbrella_x) // another checker to prevent duplicate on tile data
		tree_x = (random(0, start_offset_x - 2)) + 1; // swap tree pos

	for (int x = 0; x < width; x++) {
		for (int y = initial_height; y < height; y++) {
			int pos_x = x;
			int pos_y = y + 6;
			int index = pos_x + pos_y * width;

			if (index > width * height || index < 0)
				continue;
			if (pos_x >= width || pos_y >= height)
				continue;

			world_.blocks[index].flags |= 0x04000000;
			world_.blocks[index].bg = 850;
		}
	}
	for (int x = 0; x < width; x++) {
		for (int y = initial_height; y < height; y++) {
			int pos_x = x;
			int pos_y = y + offset[x];
			int index = pos_x + pos_y * width;

			if (index > width * height || index < 0)
				continue;
			if (pos_x >= width || pos_y >= height)
				continue;

			if (door_x == pos_x && !d_done) {
				d_done = true;
				world_.blocks[index - width].fg = 6;
				world_.blocks[index].fg = 8;
				world_.blocks[index].flags ^= 0x04000000;
				continue;
			}
			if (world_.blocks[index].fg == 8 || world_.blocks[index].fg == 6)
				continue;

			if (pos_y == initial_height + offset[x]) {
				if (pos_x > start_offset_x + 7) 
					if (!(rand() % 10))
						world_.blocks[index - width].fg = 846;
			}

			if (umbrella_x == pos_x && !u_done) {
				u_done = true;
				world_.blocks[index - width].fg = 848;
			}
			if (tree_x == pos_x && !t_generated) {
				t_generated = true;
				world_.blocks[index - width].fg = 854;
			}

			world_.blocks[index].fg = 442;
			world_.blocks[index].flags ^= 0x04000000;

			if (y > initial_height) {
				if (!(rand() % 280))
					world_.blocks[index].fg = 10;

				if (!(rand() % 590))
					world_.blocks[index].fg = 596;
			}
		}
	}
	for (int i = 0; i < width * height; i++) {
		if (i >= 5400)
			world_.blocks[i].fg = 8;
	}

	delete[] offset;

	worlds.push_back(world_);
	return world_;
}

World create_undersea(const string& name_, int width, int height) {
	World world_;
	world_.name = name_;
	world_.weather = 14;
	world_.d_weather = 14;
	world_.width = width;
	world_.height = height;
	int s_ = height * width;
	int d_ = rand() % (s_ / (s_ / width) - 4) + 2;
	for (int i_ = 0; i_ < s_; i_++) {
		WorldBlock block_{ 0, 0, uint16_t(-1) };
		block_.flags |= 0x04000000;
		if (i_ >= 3800 && i_ < 5400 && !(rand() % 50))
			block_.fg = 1538;
		else if (i_ >= 3700 && i_ < 5400) {
			if (i_ > 5000) {
				if (rand() % 30 < 3)
					block_.fg = 832;
				else
					block_.fg = 1536;
			}
			else
				block_.fg = 1536;
		}
		else if (i_ >= 5400)
			block_.fg = 8, block_.flags ^= 0x04000000;
		if (i_ == 3600 + d_)
			block_.fg = 6, block_.flags ^= 0x04000000;
		if (i_ == 3700 + d_)
			block_.fg = 8, block_.flags ^= 0x04000000;
		if (i_ >= 3700)
			block_.bg = 850;
		world_.blocks.push_back(block_);
	}
	worlds.push_back(world_);
	return world_;
}

World create_world(const string& name_, int width, int height) {
	World world_;
	world_.name = name_;
	world_.width = width;
	world_.height = height;
	int s_ = width * height;
	int d_ = rand() % (s_ / (s_ / width) - 4) + 2;
	for (int i_ = 0; i_ < s_; i_++) {
		WorldBlock block_{ 0, 0, uint16_t(-1) };
		if (i_ >= 3800 && i_ < 5400 && !(rand() % 50))
			block_.fg = 10;
		else if (i_ >= 3700 && i_ < 5400) {
			if (i_ > 5000) {
				if (rand() % 8 < 3)
					block_.fg = 4;
				else
					block_.fg = 2;
			}
			else
				block_.fg = 2;
		}
		else if (i_ >= 5400)
			block_.fg = 8;
		if (i_ == 3600 + d_)
			block_.fg = 6;
		if (i_ == 3700 + d_)
			block_.fg = 8;
		if (i_ >= 3700)
			block_.bg = 14;
		world_.blocks.push_back(block_);
	}
	worlds.push_back(world_);
	return world_;
}

World create_farm(ENetPeer* peer, const string& name_,int plat_id = 102, bool wide = false) {
	World world_;
	world_.name = name_;
	world_.width = wide ? 200 : 100;
	world_.height = wide ? 200 : 60;
	int bedrock_layer_y = 6 * world_.width; 
	vector<int> random_door_x = { (world_.width * world_.height) - bedrock_layer_y - 1, (world_.width * world_.height) - bedrock_layer_y - world_.width};
	int door_x = random_door_x[rand() % random_door_x.size()];
	int random_sign = (rand() % door_x - 2) + 1;
	int random_monitor = (rand() % door_x - 2) + 1;
	if (door_x == random_door_x[1])
		random_sign = door_x + rand() % 3 + 1;
	if (door_x == random_door_x[0]) 
		random_sign = door_x - rand() % 3 + 1;
	if (random_sign >= random_door_x[1])
		random_monitor = random_sign + rand() % 5 + 1;
	if (random_sign >= (random_door_x[0] + (world_.width - 10 * (world_.width / 100)))) // checker?
		random_monitor = random_sign - rand() % 5 + 1;
	if (random_sign == random_monitor)
	{
		if (door_x == random_door_x[0]) 
			random_sign = random_sign = door_x - rand() % 3 + 1;
		if (door_x == random_door_x[1])
			random_sign = door_x - rand() % 3 + 1;
	}
	for (int i_ = 0; i_ < world_.width * world_.height; i_++) {
		WorldBlock block_{ 0, 0, uint16_t(-1) };
		if (i_ >= world_.width && i_ < ((world_.width * world_.height) - bedrock_layer_y)) {
			int x_ = i_ % world_.width; 
			int y_ = i_ / world_.width; 
			if (y_ % 2 == 0 and x_ < (world_.width - 1) and x_ > 0)
				block_.fg = plat_id;
			else if (y_ % 2 != 0 and x_ < (world_.width - 1) and x_ > 0 and rand() % 250 < 3)
				block_.fg = farmable_seeds.at(rand() % farmable_seeds.size()), block_.planted = 0, block_.fruit = items[block_.fg].rarity == 999 ? 1 : (rand() % 4) + 1;
			else
				block_.fg = 0;
		}
		if (i_ == random_sign) {
			block_.fg = 20;
			block_.txt = format("Welcome to {}'s farm!", pInfo(peer)->tankIDName);
		}
		if (i_ == random_monitor) {
			block_.fg = 1240;
			block_.heart_monitor = pInfo(peer)->modName + "``";
		}
		if (i_ == door_x) block_.fg = 6;
		if (i_ >= ((world_.width * world_.height) - bedrock_layer_y)) block_.fg = 8;
		world_.blocks.push_back(block_);
	}
	worlds.push_back(world_);
	return world_;
}

World create_island(const string& name_, int width = 200, int height = 200, int weather = 44) {
	World world_;
	world_.name = name_;
	world_.width = width;
	world_.height = height;
	world_.weather = weather;
	world_.d_weather = weather;
	int s_ = width * height;
	int d_ = rand() % (s_ / (s_ / width) - 8) + 4;
	for (int i_ = 0; i_ < s_; i_++) {
		WorldBlock block_{ 0, 0, uint16_t(-1) };
		if (i_ >= 20000 && i_ < 37600 && !(rand() % 50))
			block_.fg = 10;
		else if (i_ >= 14600 && i_ < 37600) {
			if (i_ > 30000) {
				if (rand() % 8 < 3)
					block_.fg = 4;
				else
					block_.fg = 2;
			}
			else
				block_.fg = 2;
		}
		else if (i_ >= 37600)
			block_.fg = 8;
		if (i_ == 14400 + d_)
			block_.fg = 6;
		if (i_ == 14600 + d_)
			block_.fg = 8;
		if (i_ >= 14600)
			block_.bg = 14;
		world_.blocks.push_back(block_);
	}
	worlds.push_back(world_);
	return world_;
}

void AddLogs(ENetPeer* p_, string logs) {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	pInfo(p_)->logs.push_back("" + to_string(newtime.tm_mon + 1) + "/" + to_string(today_day) + "/2023 " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec) + " Console - " + logs + "");
}

World* GetCurrentWorld(string name) {
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
	if (p != worlds.end()) {
		return &worlds[p - worlds.begin()]; // return worldo struktura
	}
	return nullptr;
}

World get_world(const string& name_) {
	/*galima buvo daryti pagal worldid o ne name bet jeigu worldus trinti is memory tai nk gero nebus*/
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		return worlds[p - worlds.begin()]; // return worldo struktura
	}
	// Worldo Nera bet jis gali buti issaugotas
	string path_ = "database/worlds/" + name_ + "_.json";
	if (_access_s(path_.c_str(), 0) == 0) {
		World world_;
		try {
			// Pakrauti worlda is json

			/*
			jeigu nera naudoti sita
						if (world_read.find("rainbows") != world_read.end()) world_.rainbows = world_read["rainbows"].get<bool>();
						*/
			json world_read;
			ifstream world_file(path_, ifstream::binary);
			world_file >> world_read;
			world_file.close();
			world_.name = name_;
			world_.verifiedTime = world_read["verifiedt"].get<string>();
			world_.verified = world_read["verified"].get<bool>();
			world_.entry_level = world_read["entry_level"].get<int>();
			world_.open_to_public = world_read["public"].get<bool>();
			world_.nuked = world_read["nuked"].get<bool>();
			world_.n_t = world_read["n_t"].get<string>();
			world_.n_b = world_read["n_b"].get<string>();
			world_.music_bpm = world_read["music_bpm"].get<uint32_t>();
			world_.weather = world_read["weather"].get<uint16_t>();
			world_.make_music_blocks_invisible = world_read["invisible_music_blocks"].get<bool>();
			world_.disable_music_blocks = world_read["disable_music_blocks"].get<bool>();
			world_.owner_name = world_read["owner"].get<string>();
			world_.rainbows = world_read["rainbows"].get<bool>();
			world_.silence = world_read["silence"].get<bool>();
			world_.Honor = (!(world_read.find("Honor") != world_read.end()) ? world_.Honor : world_read["Honor"].get<float>());
			world_.Yesterday = (!(world_read.find("Yesterday") != world_read.end()) ? world_.Yesterday : world_read["Yesterday"].get<float>());
			world_.Overall = (!(world_read.find("Overall") != world_read.end()) ? world_.Overall : world_read["Overall"].get<float>());
			world_.World_Rating = (!(world_read.find("World_Rating") != world_read.end()) ? world_.World_Rating : world_read["World_Rating"].get<float>());
			world_.World_Time = (!(world_read.find("World_Time") != world_read.end()) ? world_.World_Time : world_read["World_Time"].get<int>());
			world_.Category = (!(world_read.find("Category") != world_read.end()) ? world_.Category : world_read["Category"].get<string>());
			world_.X_1 = (!(world_read.find("X_1") != world_read.end()) ? world_.X_1 : world_read["X_1"].get<bool>());
			world_.X_2 = (!(world_read.find("X_2") != world_read.end()) ? world_.X_2 : world_read["X_2"].get<bool>());
			world_.X_3 = (!(world_read.find("X_3") != world_read.end()) ? world_.X_3 : world_read["X_3"].get<bool>());
			world_.X_4 = (!(world_read.find("X_4") != world_read.end()) ? world_.X_4 : world_read["X_4"].get<bool>());
			world_.X_5 = (!(world_read.find("X_5") != world_read.end()) ? world_.X_5 : world_read["X_5"].get<bool>());
			world_.X_6 = (!(world_read.find("X_6") != world_read.end()) ? world_.X_6 : world_read["X_6"].get<bool>());
			world_.X_7 = (!(world_read.find("X_7") != world_read.end()) ? world_.X_7 : world_read["X_7"].get<bool>());
			world_.X_8 = (!(world_read.find("X_8") != world_read.end()) ? world_.X_8 : world_read["X_8"].get<bool>());
			world_.X_9 = (!(world_read.find("X_9") != world_read.end()) ? world_.X_9 : world_read["X_9"].get<bool>());
			world_.X_10 = (!(world_read.find("X_10") != world_read.end()) ? world_.X_10 : world_read["X_10"].get<bool>());
			world_.X_11 = (!(world_read.find("X_11") != world_read.end()) ? world_.X_11 : world_read["X_11"].get<bool>());
			world_.X_12 = (!(world_read.find("X_12") != world_read.end()) ? world_.X_12 : world_read["X_12"].get<bool>());
			world_.X_13 = (!(world_read.find("X_13") != world_read.end()) ? world_.X_13 : world_read["X_13"].get<bool>());
			world_.X_14 = (!(world_read.find("X_14") != world_read.end()) ? world_.X_14 : world_read["X_14"].get<bool>());
			world_.X_15 = (!(world_read.find("X_15") != world_read.end()) ? world_.X_15 : world_read["X_15"].get<bool>());
			world_.X_16 = (!(world_read.find("X_16") != world_read.end()) ? world_.X_16 : world_read["X_16"].get<bool>());
			world_.X_17 = (!(world_read.find("X_17") != world_read.end()) ? world_.X_17 : world_read["X_17"].get<bool>());
			world_.X_18 = (!(world_read.find("X_18") != world_read.end()) ? world_.X_18 : world_read["X_18"].get<bool>());
			world_.X_19 = (!(world_read.find("X_19") != world_read.end()) ? world_.X_19 : world_read["X_19"].get<bool>());
			world_.world_id = world_read.find("world_id") != world_read.end() ? world_.world_id : world_read["world_id"].get<int>();
			world_.owner_id = world_read["owner_id"].get<int>();
			world_.guild_id = world_read["guild_id"].get<int>();
			world_.d_weather = world_read["d_weather"].get<int>();
			world_.owner_named = world_read["o2"].get<string>();
			world_.width = (!(world_read.find("width") != world_read.end()) ? world_.width : world_read["width"].get<int>());
			world_.height = (!(world_read.find("height") != world_read.end()) ? world_.height : world_read["height"].get<int>());
			world_.v_p = world_read["v_p"].get<bool>();
			world_.allow_noclip = world_read.find("allow_noclip") == world_read.end() ? world_.allow_noclip : world_read["allow_noclip"].get<bool>();
			world_.no_antibounce = world_read.find("no_ab") == world_read.end() ? world_.no_antibounce : world_read["no_ab"].get<bool>();
			
			/*if cant find
						json gscan_ = json::array();
			if (world_read.find("gscan") != world_read.end()) gscan_ = world_read["gscan"].get<json>();
			*/
			json sbx1_ = world_read["sbox1"].get<json>();
			json gscan_ = world_read["gscan"].get<json>();
			json bulletins_ = world_read["sbull"].get<json>();
			json cctv_get_settings_ = world_read["sstv"].get<json>();
			json cctv_ = world_read["cctv"].get<json>();
			json bullet_ = world_read["bulletin"].get<json>();
			json p_ = world_read["blocks"].get<json>(), a_ = world_read["drop"].get<json>(), adm_ = world_read["admins"].get<json>(), npc_vector_ = world_read["npc"].get<json>(), machine_vector_ = world_read["machine"].get<json>();
			for (int i_ = 0; i_ < adm_.size(); i_++) {
				int name_ = adm_[i_]["uid"].get<int>();
				world_.admins.push_back(name_);
			}
			for (int i_ = 0; i_ < p_.size(); i_++) {
				WorldBlock b_{};
				if (p_[i_].find("f") != p_[i_].end()) b_.fg = p_[i_]["f"].get<int>();
				if (p_[i_].find("b") != p_[i_].end()) b_.bg = p_[i_]["b"].get<int>();
				if (p_[i_].find("p") != p_[i_].end()) b_.planted = p_[i_]["p"].get<long long>();
				if (p_[i_].find("fc") != p_[i_].end()) b_.fruit = p_[i_]["fc"].get<int>();
				if (p_[i_].find("sp") != p_[i_].end()) b_.sp = p_[i_]["sp"].get<int>();
				if (p_[i_].find("t") != p_[i_].end()) b_.txt = p_[i_]["t"].get<string>();
				if (p_[i_].find("n") != p_[i_].end()) b_.roll = p_[i_]["n"].get<uint8_t>();
				if (p_[i_].find("id") != p_[i_].end()) b_.id = p_[i_]["id"].get<uint32_t>();
				if (p_[i_].find("c") != p_[i_].end()) b_.c_ = p_[i_]["c"].get<uint32_t>();
				if (p_[i_].find("wl") != p_[i_].end()) b_.wl = p_[i_]["wl"].get<uint32_t>();
				if (p_[i_].find("pr") != p_[i_].end()) b_.pr = p_[i_]["pr"].get<int>();
				if (p_[i_].find("o") != p_[i_].end()) b_.open = p_[i_]["o"].get<bool>();
				if (p_[i_].find("dd") != p_[i_].end()) b_.door_destination = p_[i_]["dd"].get<string>();
				if (p_[i_].find("di") != p_[i_].end()) b_.door_id = p_[i_]["di"].get<string>();
				if (p_[i_].find("fl") != p_[i_].end()) b_.flags = p_[i_]["fl"].get<int>();
				if (p_[i_].find("ps") != p_[i_].end()) b_.projectile_speed = p_[i_]["ps"].get<int>();
				if (p_[i_].find("rf") != p_[i_].end()) b_.rate_of_fire = p_[i_]["rf"].get<int>();
				if (p_[i_].find("en") != p_[i_].end()) b_.enabled = p_[i_]["en"].get<bool>();
				if (p_[i_].find("in") != p_[i_].end()) b_.invert = p_[i_]["in"].get<bool>();
				if (p_[i_].find("sn") != p_[i_].end()) b_.spin = p_[i_]["sn"].get<bool>();
				if (p_[i_].find("g") != p_[i_].end()) b_.gravity = p_[i_]["g"].get<int>();
				if (p_[i_].find("bbm_d") != p_[i_].end()) b_.bbm_d = p_[i_]["bbm_d"].get<int>();
				if (p_[i_].find("a_v") != p_[i_].end()) b_.audio_volume = p_[i_]["a_v"].get<int>();
				if (p_[i_].find("a_n") != p_[i_].end()) b_.audio_notes = p_[i_]["a_n"].get<string>();
				if (p_[i_].find("m") != p_[i_].end()) b_.magnetron = p_[i_]["m"].get<bool>();
				if (p_[i_].find("l") != p_[i_].end()) b_.locked = p_[i_]["l"].get<bool>();
				if (p_[i_].find("loi") != p_[i_].end()) b_.owner_id = p_[i_]["loi"].get<int>(); 
				if (p_[i_].find("lq") != p_[i_].end()) b_.lock_origin = p_[i_]["lq"].get<int>();  
				if (p_[i_].find("lo") != p_[i_].end()) b_.owner_name = p_[i_]["lo"].get<string>();
				if (p_[i_].find("ea") != p_[i_].end()) b_.empty_air = p_[i_]["ea"].get<bool>();
				if (p_[i_].find("otp") != p_[i_].end()) b_.open_to_public = p_[i_]["otp"].get<bool>();
				if (p_[i_].find("ad") != p_[i_].end()) {
					json read_block_admins_ = p_[i_]["ad"].get<json>();
					for (int i_2 = 0; i_2 < read_block_admins_.size(); i_2++) {
						int name_ = read_block_admins_[i_2]["uid"].get<int>();
						b_.admins.push_back(name_);
					}
				}
				if (p_[i_].find("bo") != p_[i_].end()) b_.build_only = p_[i_]["bo"].get<bool>();
				if (p_[i_].find("la") != p_[i_].end()) b_.limit_admins = p_[i_]["la"].get<bool>();
				if (p_[i_].find("cr") != p_[i_].end()) b_.crystals = p_[i_]["cr"].get<vector<vector<int>>>();
				if (p_[i_].find("mq") != p_[i_].end()) b_.mannequin = p_[i_]["mq"].get<Mannequin>();
				if (p_[i_].find("dnt") != p_[i_].end()) {
					json read_block_donation_ = p_[i_]["dnt"].get<json>();
					for (int i_2 = 0; i_2 < read_block_donation_.size(); i_2++) {
						Donate new_donate;
						new_donate.item = read_block_donation_[i_2]["item"].get<int>();
						new_donate.count = read_block_donation_[i_2]["count"].get<int>();
						new_donate.text = read_block_donation_[i_2]["text"].get<string>();
						new_donate.name = read_block_donation_[i_2]["name"].get<string>();
						b_.donates.push_back(new_donate);
					}
				}
				if (p_[i_].find("r1") != p_[i_].end()) b_.r = p_[i_]["r1"].get<int>();
				if (p_[i_].find("g1") != p_[i_].end()) b_.g = p_[i_]["g1"].get<int>();
				if (p_[i_].find("b1") != p_[i_].end()) b_.b = p_[i_]["b1"].get<int>();
				if (p_[i_].find("prs") != p_[i_].end()) b_.portrait = p_[i_]["prs"].get<Portrait>();
				if (p_[i_].find("bep") != p_[i_].end()) b_.bunny_egg_progress = p_[i_]["bep"].get<uint32_t>();
				if (p_[i_].find("hm") != p_[i_].end()) b_.heart_monitor = p_[i_]["hm"].get<string>();
				if (p_[i_].find("sh1") != p_[i_].end()) b_.shelf_1 = p_[i_]["sh1"].get<uint32_t>();
				if (p_[i_].find("sh2") != p_[i_].end()) b_.shelf_2 = p_[i_]["sh2"].get<uint32_t>();
				if (p_[i_].find("sh3") != p_[i_].end()) b_.shelf_3 = p_[i_]["sh3"].get<uint32_t>();
				if (p_[i_].find("sh4") != p_[i_].end()) b_.shelf_4 = p_[i_]["sh4"].get<uint32_t>();
				if (p_[i_].find("iwm") != p_[i_].end()) b_.weatherListID = p_[i_]["iwm"].get<vector<int>>();
				if (p_[i_].find("cyc") != p_[i_].end()) b_.epoch_cycle = p_[i_]["cyc"].get<int>();
				//if (p_[i_].find("uranium") != p_[i_].end()) b_.uranium = p_[i_]["uranium"].get<bool>();
				//if (p_[i_].find("ice_water") != p_[i_].end()) b_.ice_water = p_[i_]["ice_water"].get<bool>();
				/*
				if (world_->blocks[i_].uranium) block_["uranium"] = world_->blocks[i_].uranium;
			if (world_->blocks[i_].ice_water) block_["ice_water"] = world_->blocks[i_].ice_water;
				*/
				world_.blocks.push_back(b_);
			}
			int fix_uid = 0;
			for (int i_ = 0; i_ < a_.size(); i_++) {
				WorldDrop b_{};
				b_.id = a_[i_]["i"].get<int>();
				if (b_.id == 0) {
					fix_uid++;
					continue;
				}
				b_.count = a_[i_]["c"].get<int>();
				b_.uid = a_[i_]["u"].get<int>() - fix_uid;
				b_.x = a_[i_]["x"].get<int>();
				b_.y = a_[i_]["y"].get<int>();
				world_.drop.push_back(b_);
			}
			for (int i_ = 0; i_ < sbx1_.size(); i_++) {
				WorldSBOX1 db_{};
				db_.id = sbx1_[i_]["i"].get<int>();
				db_.count = sbx1_[i_]["c"].get<int>();
				db_.x = sbx1_[i_]["x"].get<int>();
				db_.y = sbx1_[i_]["y"].get<int>();
				world_.sbox1.push_back(db_);
			}
			for (int i_ = 0; i_ < gscan_.size(); i_++) {
				WorldGrowscan db_{};
				db_.x = gscan_[i_]["x"].get<int>();
				db_.y = gscan_[i_]["y"].get<int>();
				db_.world_public = gscan_[i_]["world_public"].get<bool>();
				db_.floating_public = gscan_[i_]["floating_public"].get<bool>();
				world_.gscan.push_back(db_);
			}
			for (int i_ = 0; i_ < cctv_get_settings_.size(); i_++) {
				WorldCCTVSettings db_{};
				db_.x = cctv_get_settings_[i_]["x"].get<int>();
				db_.y = cctv_get_settings_[i_]["y"].get<int>();
				db_.show_item_taking = cctv_get_settings_[i_]["s1"].get<bool>();
				db_.show_item_dropping = cctv_get_settings_[i_]["s2"].get<bool>();
				db_.show_people_entering = cctv_get_settings_[i_]["s3"].get<bool>();
				db_.show_people_exiting = cctv_get_settings_[i_]["s4"].get<bool>();
				db_.dont_show_owner = cctv_get_settings_[i_]["s5"].get<bool>();
				db_.dont_show_admins = cctv_get_settings_[i_]["s6"].get<bool>();
				db_.dont_show_noaccess = cctv_get_settings_[i_]["s7"].get<bool>();
				world_.cctv_settings.push_back(db_);
			}
			for (int i_ = 0; i_ < cctv_.size(); i_++) {
				WorldCCTV db_{};
				db_.x = cctv_[i_]["x"].get<int>();
				db_.y = cctv_[i_]["y"].get<int>();
				db_.logs = cctv_[i_]["l"].get<string>();
				world_.cctv.push_back(db_);
			}
			for (int i_ = 0; i_ < bullet_.size(); i_++) {
				WorldBulletin db_{};
				db_.x = bullet_[i_]["x"].get<int>();
				db_.y = bullet_[i_]["y"].get<int>();
				db_.name = bullet_[i_]["n"].get<string>();
				db_.text = bullet_[i_]["t"].get<string>();
				world_.bulletin.push_back(db_);
			}
			for (int i_ = 0; i_ < bulletins_.size(); i_++) {
				WorldBulletinSettings db_{};
				db_.x = bulletins_[i_]["x"].get<int>();
				db_.y = bulletins_[i_]["y"].get<int>();
				db_.public_can_add = bulletins_[i_]["s1"].get<bool>();
				db_.hide_names = bulletins_[i_]["s2"].get<bool>();
				world_.bulletins.push_back(db_);
			}
			for (int i_ = 0; i_ < npc_vector_.size(); i_++) {
				WorldNPC npc_{};
				npc_.id = npc_vector_[i_]["i"].get<uint16_t>();
				npc_.x = npc_vector_[i_]["x"].get<uint16_t>();
				npc_.y = npc_vector_[i_]["y"].get<uint16_t>();
				npc_.projectile_speed = npc_vector_[i_]["ps"].get<uint16_t>();
				npc_.rate_of_fire = npc_vector_[i_]["rf"].get<uint16_t>();
				npc_.kryptis = npc_vector_[i_]["kr"].get<float>();
				npc_.enabled = npc_vector_[i_]["en"].get<bool>();
				npc_.last_ = npc_vector_[i_]["l"].get<long long>();
				npc_.started_moving = npc_vector_[i_]["sm"].get<long long>();
				world_.npc.push_back(npc_);
			}
			for (int i_ = 0; i_ < machine_vector_.size(); i_++) {
				WorldMachines machine_{};
				machine_.id = machine_vector_[i_]["i"].get<uint16_t>();
				machine_.x = machine_vector_[i_]["x"].get<uint16_t>();
				machine_.y = machine_vector_[i_]["y"].get<uint16_t>();
				machine_.target_item = machine_vector_[i_]["ti"].get<uint16_t>();
				machine_.enabled = machine_vector_[i_]["en"].get<bool>();
				machine_.last_ = machine_vector_[i_]["l"].get<long long>();
				world_.machines.push_back(machine_);
			}
		}
		catch (exception err) {
			remove(path_.c_str());
			world_ = create_world(name_, 100, 60);
		}
		worlds.push_back(world_);
		if (world_.npc.size() != 0 or world_.machines.size() != 0) {
			if (find(t_worlds.begin(), t_worlds.end(), world_.name) == t_worlds.end()) {
				t_worlds.push_back(world_.name);
			}
		}
		return world_;
	}
	return create_world(name_, 100, 60);
}

void getPlyersWorld(ENetPeer* peer)
{
	try {
		get_world(pInfo(peer)->world);
	}
	catch (exception e) {
		return;
	}
}

void updateSpecificJSONData(const std::string& file_, const std::string& field_, const json& var) {
	std::ifstream infile(file_);
	if (!infile.is_open()) {
		std::cout << "Error opening " << file_ << " file for reading." << std::endl;
		return;
	}

	try {
		json j;
		infile >> j;
		infile.close();

		if (j.contains(field_)) {
			j[field_] = var;

			std::ofstream outfile(file_);
			if (!outfile.is_open()) {
				std::cout << "Error opening " << file_ << " file for writing." << std::endl;
				return;
			}

			outfile << j.dump(4);
			outfile.close();

			std::cout << "Value for \"" << field_ << "\" updated successfully in JSON file." << std::endl;
		}
		else {
			std::cout << "The \"" << field_ << "\" field does not exist in the JSON data." << std::endl;
		}
	}
	catch (json::exception& e) {
		std::cerr << "Error updating JSON data (" << file_ << ", " << field_ << "): " << e.what() << std::endl;
	}
}
void readSpecificJSONData(const string file_, const string field_, auto& var) {
	ifstream file(file_);
	if (!file.is_open()) {
		cout << "Error opening " << file_ << " file or file was not found." << endl;
		return;
	}
	json j;
	try {
		file >> j;
	}
	catch (json::parse_error& e) {
		cout << "Error parsing JSON: " << e.what() << endl;
		return;
	}
	if (j.contains(field_)) {
		auto& resValue = j[field_];

		if (resValue.is_boolean()) {
			var = static_cast<bool>(resValue);
		}
		else if (resValue.is_number()) {
			var = static_cast<int>(resValue);
		}
		else if (resValue.is_string()) {
			var = resValue;
		}
		else {
			cout << "The value of \"" << field_ << "\" has an unsupported type." << endl;
			return;
		}
	}
	else {
		cout << "The \"" << field_ << "\" field was not found in the \"" << file_ << "\" data." << endl;
		return;
	}
}

#include <algorithm>
#include <ranges>

void save_valentine() {
	std::ofstream ofs("database/VALENTINE.json");
	if (ofs.is_open()) {
		nlohmann::json j;

		j["events"] = global::events::valentine;
		j["rarity"] = global::events::valentineRarity;
		j["timers"] = global::events::valentineTimers;

		ofs << j;
		ofs.close();
	}
}

namespace world::algorithm {
	World* get_world(ENetPeer* peer) {
		if (auto it = std::ranges::find_if(worlds, [name = pInfo(peer)->world](World const& world) { return world.name == name; }); it != worlds.end())
			return &(*it);

		return nullptr;
	}
	World* get_world(std::string const& name) {
		if (auto it = std::ranges::find_if(worlds, [name](World const& world) { return world.name == name; }); it != worlds.end())
			return &(*it);

		return nullptr;
	}
}

World create_world_blast(ENetPeer* peer, const string& name_, int blast, int width = 100, int height = 60) {
	vector<int> id;
	World world_;
	if (blast == 9164 || blast == 1402 || blast == 1060) {
		if (blast == 1060) world_.d_weather = 6;
		int s_ = width * height;
		int d_ = rand() % (s_ / (s_ / width) - 4) + 2;
		for (int i_ = 0; i_ < 6000; i_++) {
			WorldBlock block_{ 0, 0, 0 }; // buvo WorldBlock block_{0, 0, -1};
			if (blast == 9164) {
				if (i_ >= 1700 && i_ < 5400) {
					if (i_ > 5000) {
						if (rand() % 8 < 3) block_.fg = 9162;
					}
				}
				else if (i_ >= 5400) block_.fg = 8;
				if (i_ == 1600 + d_) block_.fg = 6;
				if (i_ == 1700 + d_) block_.fg = 8;
				if (i_ >= 1700) block_.bg = 14;
			}
			else if (blast == 1402) {
				if (i_ >= 5400) block_.fg = 8;
				if (i_ == 5200) block_.fg = 6;
				if (i_ == 5300)block_.fg = 8;
			}
			else if (blast == 1060) {
				if (i_ >= 3800 && i_ < 5400 && !(rand() % 50)) block_.fg = 10;
				else if (i_ >= 3600 && i_ < 3700) {
					id = { 231,487,483,2019,427,1757,2009,281,781,329,459,1041,421,2787,2789,1043,2797,181,613,65,4983,283,553,425,4635,987,627,2017,989,61,4639,973,3523,331,265,859,433,253,339,1105,439,4567,333,677,5673,1427,5603,183,10533,5731,7223,10833,6035,6813,1113,1047,653,2811,4703,1429,847,665,485,1613,833,2025,1775,3931,429,3831,423,437,1773,4767,1299,361,667,2815,3473,301,4637,5683,2709,415,955,461,861,9389,5467,2791,2815,1803,419,2027,685,555,741,10531,5729,7221,10831,6033,6811,621,6401,1107,359,3471,855,309,1685,1449,1309,441,1111,221,1431,3065,9307,1257,1501,1109,4641,3587,1103,417,743,431,3823,2949,1131,3825,727,5379,729,187,787,5459,4785,3261,3521,2293,2309,2321,2333,5461,3721,327,247,63,3479,445,4783,299,863,8935,1451,261,1871,1499,455,9391,683,1159,551,1745,411,3005,557,687,4799,559,4643,3899,1605,9309,567,565,1155,3827,1327,1767,993,1157,563,4721,115,1423,10515,1329,6545,287,669,777,5463,1655,1599,561,4585,3413,4745,1771,2011,1161,1729,3757,3753,321,3265,3263,623,775,6397,129,4667,759,3767,1529,6543,4707,3835,1435,651,8929,569,527,3287,1595,6063,2795,1003,1731,4943,4963,597,4669,1531,1523,625,4297,599,657,571,873,3755,2969,1725,4603,1447,3267,5375,1683 };
					block_.fg = id[rand() % id.size()], block_.fruit = items[block_.fg].rarity == 999 ? 1 : (rand() % 4) + 1, block_.planted = time(nullptr) - (items[block_.fg].growTime);
				}
				else if (i_ >= 3700 && i_ < 5400) {
					if (i_ > 5000) {
						if (rand() % 8 < 3) block_.fg = 4;
						else block_.fg = 2;
					}
					else block_.fg = 2;
				}
				else if (i_ >= 5400) block_.fg = 8;
				if (i_ == 3600 + d_) block_.fg = 6;
				if (i_ == 3700 + d_) block_.fg = 8;
				if (i_ >= 3700) block_.bg = 14;
			}
			world_.blocks.push_back(block_);
		}
	}
	/*
	else if (blast == 1532) {
		world_ = get_world("GENERATED_UNDERSEA_BLAST_1532");
		world_.d_weather = 14;
	}
	*/
	/*
	else if (blast == 830) {
		world_ = get_world("GENERATED_SUMMER_BLAST_830");
		world_.d_weather = 1;
	}
	*/
	/*
	else if (blast == 1136) {
		world_ = get_world("GENERATED_MARS_BLAST_1136");
		world_.d_weather = 7;
	}
	*/
	else if (blast == 3562) {
		world_ = get_world("GENERATED_CAVE_BLAST_3562");
		world_.blocks[5000 - rand() % 700].fg = 3604;
		world_.blocks[5300 - rand() % 700].fg = 3604;
	}
	else if (blast == 7588) {
		world_ = get_world("GENERATED_TREASURE_BLAST_7588");
		world_.d_weather = 44;
	}
	else if (blast == 9488) {
		world_ = get_world("GENERATED_FARM_BLAST_9488");
	}
	else if (blast == 942) {
		world_ = get_world("GENERATED_DESERT_BLAST_942");
		world_.d_weather = 3;
		if (rand() % 100 < 10) {
			id = { 12292 , 12294 };
			WorldDrop drop_block_{};
			drop_block_.id = id[rand() % id.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_.drop.size()) + 1, drop_block_.x = 1536, drop_block_.y = 544;
			world_.drop.push_back(drop_block_);
		}
	}
	else if (blast == 4774) {
		id = { 4778, 4714,4778, 4714, 10066, 11188 };
		world_ = get_world("GENERATE_JUNGLE_BLAST_4774");
		WorldDrop drop_block_{};
		drop_block_.id = id[rand() % id.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_.drop.size()) + 1, drop_block_.x = 835, drop_block_.y = 1485;
		world_.d_weather = 32;
		world_.drop.push_back(drop_block_);
	}
	else if (blast == 7380) {
		world_ = get_world("GENERATE_MONOCHROME_BLAST_7380");
		world_.d_weather = 43;
	}
	else if (blast == 8556) {
		world_ = get_world("GENERATE_SURG_BLAST_8556");
		world_.d_weather = 45;
	}
	else {
		world_ = get_world("GENERATED_UNKNOWN_BLAST");
		world_.d_weather = 3;
	}
	world_.name = name_;
	worlds.push_back(world_);
	return world_;
}

void writelog(string text) {
	fstream fs;
	fs.open("database/server_logs/logs.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}
void writelogd(string text) {
	fstream fs;
	fs.open("database/server_logs/crash.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}
void tradelog(string text) {
	fstream fs;
	fs.open("database/server_logs/trade.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}
void writepacket(string text) {
	fstream fs;
	fs.open("database/server_logs/packet.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}
namespace valentine {
	std::vector<string> chanceItems = { "7.5", "5.8", "4.2", "2.5", "0.5" };
	std::vector<int> rewardsItems = { 1796, 8530, 1784, 9152, 8532 };

	std::vector<double> converts() {
		std::vector<double> doubleItems;

		for (const auto& item : chanceItems) {
			double value = std::stod(item);
			doubleItems.push_back(value);
		}
		return doubleItems;
	}
	std::string getName(int const& number) {
		if (number > rewardsItems.size() || number < 1) return "Unknown";

		return items[rewardsItems[number + 1]].name;
	}
	double create_chance(const std::vector<double>& chances) {
		std::random_device rd;

		std::mt19937 gen(rd());

		std::uniform_real_distribution<> dis(0.0, 100.0);

		double numeric = dis(gen);

		for (int i = 0; i < chances.size(); ++i) {
			if (numeric <= chances[i]) return i + 1;
		}
		return -1;
	}
}
namespace snacks {
	std::vector<string> chanceItems = { "30.0", "22.0", "18.0", "15.0", "12.0", "10.0", "5.0", "3.0", "2.5", "0.5"};
	std::vector<int> rewardsItems = { 1796, 13870, 13868, 13912, 13904, 13902, 7188, 13900, 13906, 13554 };

	std::string rewards(int const& level) {
		for (int i = 0; i < rewardsItems.size(); i++) {
			if (i + 1 == level) return "1 " + items[rewardsItems[i]].name;
		}
		return "1 Dirt";
	}

	std::vector<double> converts() {
		std::vector<double> doubleItems;

		for (const auto& item : chanceItems) {
			double value = std::stod(item);
			doubleItems.push_back(value);
		}
		return doubleItems;
	}

	bool chance(double probability) {
		std::random_device rd;

		std::mt19937 gen(rd());

		std::uniform_real_distribution<> dis(0.0, 100.0);

		double numeric = dis(gen);

		if (numeric <= probability) return true;

		return false;
	}
}
namespace ghosts {
	std::vector<string> chanceItems = { "35.5", "18.5", "12.0", "8.2", "5.5", "4.5", "3.5", "3.0", "2.5", "1.5" };
	std::vector<int> rewardsItems = { 5172, 8530, 8532, 5160, 13828, 7188, 9510, 9512, 13864, 9508 };

	std::string rewards(int const& level) {
		for (int i = 0; i < rewardsItems.size(); i++) {
			if (i + 1 == level) return "1 " + items[rewardsItems[i]].name;
		}
		return "1 Dirt";
	}

	std::vector<double> converts() {
		std::vector<double> doubleItems;

		for (const auto& item : chanceItems) {
			double value = std::stod(item);
			doubleItems.push_back(value);
		}
		return doubleItems;
	}

	bool chance(double probability) {
		std::random_device rd;

		std::mt19937 gen(rd());

		std::uniform_real_distribution<> dis(0.0, 100.0);

		double numeric = dis(gen);

		if (numeric <= probability) return true;

		return false;
	}
}
namespace algorithm {
	std::string decode_special_char(std::string const& str) {
		std::string result;
		for (char const& c : str) {
			switch (c) {
			case '\n': result += "\\n";
				break;
			case '\t': result += "\\t";
				break;
			case '\\': result += "\\\\";
				break;
			default: result += c;
			}
		}
		return result;
	}

	bool contains_regex(std::string const& str, std::string const& regex) {
		std::regex r{ regex };
		return std::regex_search(str, r);
	}
	void log_text(std::string const& file, std::string const& content) {
		std::ofstream ostream("server_logs/" + file, std::ios::app);
		ostream << decode_special_char(content) << '\n';
	}
	void send_logtext(std::string const& file, ENetPeer* peer, std::string const& message) {
		std::string contents = std::format("[{}] ({}) >> from {} ({}) in [{}] : {}", Algorithm::get_time(), pInfo(peer)->ip, pInfo(peer)->tankIDName.empty() ? pInfo(peer)->requestedName : pInfo(peer)->tankIDName, pInfo(peer)->tankIDName, pInfo(peer)->world, message);

		log_text(file, contents);
	}
}
void send_devlogs(string const& who, string const& content) {
	string message = format("DEV-LOG: {} {}.", who, content);
	gamepacket_t packet;
	packet.Insert("OnConsoleMessage");
	packet.Insert("`6>> " + message + "``");
	/*
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->hide_logs) continue;
		if (pInfo(currentPeer)->dev) {
			packet.CreatePacket(currentPeer);
		}
	}
	*/
	ofstream devlog("database/server_logs/devlogs.txt", ios::app);
	devlog << message << endl;
	devlog.close();
}

namespace player::algorithm {
	std::string get_chat_color(ENetPeer* peer, bool const& nickname = true) {
		std::string color = "$";

		if (pInfo(peer)->dev) color = "1";

		else if (pInfo(peer)->tmod) color = "^";

		if (!pInfo(peer)->d_name.empty() && nickname) color = "$";

		if (!pInfo(peer)->chatColor.empty()) color = pInfo(peer)->chatColor;


		return color;
	}

}

void save_world(const string& name_, bool erase = true) {
	try {
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			__int64 id_ = p - worlds.begin();
			World* world_ = &worlds[id_];
			json save_, blocks_ = json::array(), drops_ = json::array(), sboxs1_ = json::array(), gscans_ = json::array(), bulletin_s = json::array(), cctv_save_settings_ = json::array(), cctv_save_ = json::array(), bulletins_ = json::array(), donates_ = json::array(), infinity_lists_ = json::array(), admins_ = json::array(), npcs = json::array(), machines = json::array();
			save_["verifiedt"] = world_->verifiedTime;
			save_["verified"] = world_->verified;
			save_["entry_level"] = world_->entry_level;
			save_["nuked"] = world_->nuked;
			save_["n_t"] = world_->n_t;
			save_["n_b"] = world_->n_b;
			save_["music_bpm"] = world_->music_bpm;
			save_["public"] = world_->open_to_public;
			save_["weather"] = world_->weather;
			save_["invisible_music_blocks"] = world_->make_music_blocks_invisible;
			save_["disable_music_blocks"] = world_->disable_music_blocks;
			save_["owner"] = world_->owner_name;
			save_["guild_id"] = world_->guild_id;
			save_["d_weather"] = world_->d_weather;
			save_["o2"] = world_->owner_named;
			save_["width"] = world_->width;
			save_["height"] = world_->height;
			save_["v_p"] = world_->v_p;
			save_["allow_noclip"] = world_->allow_noclip;
			save_["no_ab"] = world_->no_antibounce;
			save_["rainbows"] = world_->rainbows;
			save_["silence"] = world_->silence;
			save_["Honor"] = world_->Honor;
			save_["Yesterday"] = world_->Yesterday;
			save_["Overall"] = world_->Overall;
			save_["World_Rating"] = world_->World_Rating;
			save_["World_Time"] = world_->World_Time;
			save_["Category"] = world_->Category;
			save_["world_id"] = world_->world_id;
			save_["owner_id"] = world_->owner_id;
			save_["X_1"] = world_->X_1;
			save_["X_2"] = world_->X_2;
			save_["X_3"] = world_->X_3;
			save_["X_4"] = world_->X_4;
			save_["X_5"] = world_->X_5;
			save_["X_6"] = world_->X_6;
			save_["X_7"] = world_->X_7;
			save_["X_8"] = world_->X_8;
			save_["X_9"] = world_->X_9;
			save_["X_10"] = world_->X_10;
			save_["X_11"] = world_->X_11;
			save_["X_12"] = world_->X_12;
			save_["X_13"] = world_->X_13;
			save_["X_14"] = world_->X_14;
			save_["X_15"] = world_->X_15;
			save_["X_16"] = world_->X_16;
			save_["X_17"] = world_->X_17;
			save_["X_18"] = world_->X_18;
			save_["X_19"] = world_->X_19;
			for (int i_ = 0; i_ < world_->admins.size(); i_++) {
				json admin_;
				admin_["uid"] = world_->admins[i_];
				admins_.push_back(admin_);
			}
			bool add_fossil = false;
			if (rand() % 2 < 1) add_fossil = true;
			for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
				json block_;
				if (world_->blocks[i_].fg != 0) {
					if (add_fossil && f_saving_ && world_->blocks[i_].fg == 10 && rand() % 6900 < 1) {
						cout << "gave a fossil to " << name_ << endl;
						block_["f"] = 3918;
					}
					else block_["f"] = world_->blocks[i_].fg;
				}
				if (world_->blocks[i_].bg != 0) block_["b"] = world_->blocks[i_].bg;
				if (world_->blocks[i_].planted != 0) block_["p"] = world_->blocks[i_].planted;
				if (world_->blocks[i_].fruit != 0 and world_->blocks[i_].fruit != 65535) block_["fc"] = world_->blocks[i_].fruit;
				if (world_->blocks[i_].sp != 0) block_["sp"] = world_->blocks[i_].sp;
				if (world_->blocks[i_].txt != "") block_["t"] = world_->blocks[i_].txt;
				if (world_->blocks[i_].roll != 0) block_["n"] = world_->blocks[i_].roll;
				if (world_->blocks[i_].id != 0) block_["id"] = world_->blocks[i_].id;
				if (world_->blocks[i_].c_ != 0) block_["c"] = world_->blocks[i_].c_;
				if (world_->blocks[i_].wl != 0) block_["wl"] = world_->blocks[i_].wl;
				if (world_->blocks[i_].pr != 0) block_["pr"] = world_->blocks[i_].pr;
				if (world_->blocks[i_].open != true) block_["o"] = world_->blocks[i_].open;
				if (world_->blocks[i_].door_destination != "") block_["dd"] = world_->blocks[i_].door_destination;
				if (world_->blocks[i_].door_id != "") block_["di"] = world_->blocks[i_].door_id;
				if (world_->blocks[i_].flags != 0x00000000) block_["fl"] = world_->blocks[i_].flags;
				if (world_->blocks[i_].rate_of_fire != 10) block_["rf"] = world_->blocks[i_].rate_of_fire;
				if (world_->blocks[i_].projectile_speed != 100) block_["ps"] = world_->blocks[i_].projectile_speed;
				if (world_->blocks[i_].enabled != false) block_["en"] = world_->blocks[i_].enabled;
				if (world_->blocks[i_].invert != false) block_["in"] = world_->blocks[i_].invert;
				if (world_->blocks[i_].spin != false) block_["sn"] = world_->blocks[i_].spin;
				if (world_->blocks[i_].gravity != 50) block_["g"] = world_->blocks[i_].gravity;
				if (world_->blocks[i_].bbm_d != 0) block_["bbm_d"] = world_->blocks[i_].bbm_d;
				if (world_->blocks[i_].audio_volume > 0) block_["a_v"] = world_->blocks[i_].audio_volume;
				if (not world_->blocks[i_].audio_notes.empty()) block_["a_n"] = world_->blocks[i_].audio_notes;
				if (world_->blocks[i_].magnetron != false) block_["m"] = world_->blocks[i_].magnetron;
				if (world_->blocks[i_].locked != false) block_["l"] = world_->blocks[i_].locked;
				if (world_->blocks[i_].lock_origin != -1) block_["lq"] = world_->blocks[i_].lock_origin;
				if (world_->blocks[i_].owner_name != "") block_["lo"] = world_->blocks[i_].owner_name;
				if (world_->blocks[i_].empty_air != false) block_["ea"] = world_->blocks[i_].empty_air;
				if (world_->blocks[i_].open_to_public != false) block_["otp"] = world_->blocks[i_].open_to_public;
				if (world_->blocks[i_].owner_id != 0) block_["loi"] = world_->blocks[i_].owner_id;
				if (world_->blocks[i_].admins.size() != 0) {
					json block_admins_ = json::array();
					for (int i_2 = 0; i_2 < world_->blocks[i_].admins.size(); i_2++) {
						json admin_;
						admin_["uid"] = world_->blocks[i_].admins[i_2];
						block_admins_.push_back(admin_);
					}
					block_["ad"] = block_admins_;
				}
				if (world_->blocks[i_].build_only != false) block_["bo"] = world_->blocks[i_].build_only;
				if (world_->blocks[i_].limit_admins != false) block_["la"] = world_->blocks[i_].limit_admins;
				if (world_->blocks[i_].crystals.size() != 0) block_["cr"] = world_->blocks[i_].crystals;
				if (world_->blocks[i_].weatherListID.size() != 0) block_["iwm"] = world_->blocks[i_].weatherListID;
				if (world_->blocks[i_].epoch_cycle != 600) block_["cyc"] = world_->blocks[i_].epoch_cycle;
				if (world_->blocks[i_].mannequin.c_head != 0 or world_->blocks[i_].mannequin.c_shirt != 0 or world_->blocks[i_].mannequin.c_pants != 0 or world_->blocks[i_].mannequin.c_feet != 0 or world_->blocks[i_].mannequin.c_mask != 0 or world_->blocks[i_].mannequin.c_hand != 0 or world_->blocks[i_].mannequin.c_back != 0 or world_->blocks[i_].mannequin.c_hair != 0 or world_->blocks[i_].mannequin.c_neck != 0) {
					block_["mq"] = world_->blocks[i_].mannequin;
				}
				if (world_->blocks[i_].donates.size() != 0) {
					json block_donates_ = json::array();
					for (int i_2 = 0; i_2 < world_->blocks[i_].donates.size(); i_2++) {
						json donate_;
						donate_["item"] = world_->blocks[i_].donates[i_2].item;
						donate_["count"] = world_->blocks[i_].donates[i_2].count;
						donate_["text"] = world_->blocks[i_].donates[i_2].text;
						donate_["name"] = world_->blocks[i_].donates[i_2].name;
						block_donates_.push_back(donate_);
					}
					block_["dnt"] = block_donates_;
				}
				if (world_->blocks[i_].r != 255) block_["r1"] = world_->blocks[i_].r;
				if (world_->blocks[i_].g != 128) block_["g1"] = world_->blocks[i_].g;
				if (world_->blocks[i_].b != 64) block_["b1"] = world_->blocks[i_].b;
				if (world_->blocks[i_].portrait.c_expression != 1 or world_->blocks[i_].portrait.c_hair_colour != 0 or world_->blocks[i_].portrait.c_skin != 0 or world_->blocks[i_].portrait.c_face != 0 or world_->blocks[i_].portrait.c_head != 0 or world_->blocks[i_].portrait.c_hair != 0) {
					block_["prs"] = world_->blocks[i_].portrait;
				}
				if (world_->blocks[i_].bunny_egg_progress != 0) block_["bep"] = world_->blocks[i_].bunny_egg_progress;
				if (world_->blocks[i_].heart_monitor != "") block_["hm"] = world_->blocks[i_].heart_monitor;
				if (world_->blocks[i_].shelf_1 != 0) block_["sh1"] = world_->blocks[i_].shelf_1;
				if (world_->blocks[i_].shelf_2 != 0) block_["sh2"] = world_->blocks[i_].shelf_2;
				if (world_->blocks[i_].shelf_3 != 0) block_["sh3"] = world_->blocks[i_].shelf_3;
				if (world_->blocks[i_].shelf_4 != 0) block_["sh4"] = world_->blocks[i_].shelf_4;
				//if (world_->blocks[i_].uranium) block_["uranium"] = world_->blocks[i_].uranium;
				//if (world_->blocks[i_].ice_water) block_["ice_water"] = world_->blocks[i_].ice_water;
				blocks_.push_back(block_);
			}

			if (f_saving_)
				for (int i_ = 0, uid = 0; i_ < world_->drop.size(); i_++)
					if (world_->drop[i_].id <= 0 || world_->drop[i_].x < 0 || world_->drop[i_].y < 0 ||
						world_->drop[i_].x > world_->width * 32 || world_->drop[i_].y >((world_->height - 1) * 32)) world_->drop.erase(world_->drop.begin() + i_);
			for (int i_ = 0; i_ < world_->drop.size(); i_++) {
				json drop_;
				drop_["i"] = world_->drop[i_].id;
				drop_["c"] = world_->drop[i_].count;
				drop_["u"] = (f_saving_ ? i_ : world_->drop[i_].uid);
				drop_["x"] = world_->drop[i_].x;
				drop_["y"] = world_->drop[i_].y;
				drops_.push_back(drop_);
			}
			for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
				json sbox1_;
				sbox1_["i"] = world_->sbox1[i_].id;
				sbox1_["c"] = world_->sbox1[i_].count;
				sbox1_["x"] = world_->sbox1[i_].x;
				sbox1_["y"] = world_->sbox1[i_].y;
				sboxs1_.push_back(sbox1_);
			}
			for (int i_ = 0; i_ < world_->gscan.size(); i_++) {
				json gscan_;
				gscan_["x"] = world_->gscan[i_].x;
				gscan_["y"] = world_->gscan[i_].y;
				gscan_["world_public"] = world_->gscan[i_].world_public;
				gscan_["floating_public"] = world_->gscan[i_].floating_public;
				gscans_.push_back(gscan_);
			}
			for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) {
				json cctv_settings_;
				cctv_settings_["x"] = world_->cctv_settings[i_].x;
				cctv_settings_["y"] = world_->cctv_settings[i_].y;
				cctv_settings_["s1"] = world_->cctv_settings[i_].show_item_taking;
				cctv_settings_["s2"] = world_->cctv_settings[i_].show_item_dropping;
				cctv_settings_["s3"] = world_->cctv_settings[i_].show_people_entering;
				cctv_settings_["s4"] = world_->cctv_settings[i_].show_people_exiting;
				cctv_settings_["s5"] = world_->cctv_settings[i_].dont_show_owner;
				cctv_settings_["s6"] = world_->cctv_settings[i_].dont_show_admins;
				cctv_settings_["s7"] = world_->cctv_settings[i_].dont_show_noaccess;
				cctv_save_settings_.push_back(cctv_settings_);
			}
			for (int i_ = 0; i_ < world_->cctv.size(); i_++) {
				json cctv_;
				cctv_["x"] = world_->cctv[i_].x;
				cctv_["y"] = world_->cctv[i_].y;
				cctv_["l"] = world_->cctv[i_].logs;
				cctv_save_.push_back(cctv_);
			}
			for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
				json bulletin_;
				bulletin_["x"] = world_->bulletin[i_].x;
				bulletin_["y"] = world_->bulletin[i_].y;
				bulletin_["n"] = world_->bulletin[i_].name;
				bulletin_["t"] = world_->bulletin[i_].text;
				bulletins_.push_back(bulletin_);
			}
			for (int i_ = 0; i_ < world_->bulletins.size(); i_++) {
				json bulletin_settings_;
				bulletin_settings_["x"] = world_->bulletins[i_].x;
				bulletin_settings_["y"] = world_->bulletins[i_].y;
				bulletin_settings_["s1"] = world_->bulletins[i_].public_can_add;
				bulletin_settings_["s2"] = world_->bulletins[i_].hide_names;
				bulletin_s.push_back(bulletin_settings_);
			}
			for (int i_ = 0; i_ < world_->npc.size(); i_++) {
				json npc_;
				npc_["i"] = world_->npc[i_].id;
				npc_["x"] = world_->npc[i_].x;
				npc_["y"] = world_->npc[i_].y;
				npc_["ps"] = world_->npc[i_].projectile_speed;
				npc_["rf"] = world_->npc[i_].rate_of_fire;
				npc_["en"] = world_->npc[i_].enabled;
				npc_["kr"] = world_->npc[i_].kryptis;
				npc_["l"] = world_->npc[i_].last_;
				npc_["sm"] = world_->npc[i_].started_moving;
				npcs.push_back(npc_);
			}
			for (int i_ = 0; i_ < world_->machines.size(); i_++) {
				json machine_;
				machine_["i"] = world_->machines[i_].id;
				machine_["x"] = world_->machines[i_].x;
				machine_["y"] = world_->machines[i_].y;
				machine_["en"] = world_->machines[i_].enabled;
				machine_["ti"] = world_->machines[i_].target_item;
				machine_["l"] = world_->machines[i_].last_;
				machines.push_back(machine_);
			}
			save_["blocks"] = blocks_, save_["drop"] = drops_, save_["sbox1"] = sboxs1_, save_["gscan"] = gscans_, save_["sbull"] = bulletin_s, save_["sstv"] = cctv_save_settings_, save_["cctv"] = cctv_save_, save_["bulletin"] = bulletins_, save_["donate"] = donates_, save_["admins"] = admins_, save_["npc"] = npcs, save_["machine"] = machines;
			//cout << "saved world " << name_ << endl;
			ofstream w_("database/worlds/" + name_ + "_.json");
			if (w_.fail()) {
				cout << "world saving failed for " << name_ << endl;
				return;
			}
			w_ << save_ << endl;
			w_.close();
			if (erase) {
				bool dont_del = false;
				for (int i_ = 0; i_ < world_->machines.size(); i_++) {
					WorldMachines machine = world_->machines[i_];
					if (machine.enabled) {
						WorldBlock* itemas = &world_->blocks[machine.x + (machine.y * world_->width)];
						if (itemas->pr != 0 and machine.target_item != 0) {
							dont_del = true;
							break;
						}
					}
				}
				if (not dont_del) {
					/*
					map<string, vector<WorldNPC>>::iterator it;
					for (it = active_npc.begin(); it != active_npc.end(); it++) {
						if (it->first == world_->name) {
							it->second.clear();
							break;
						}
					}*/
					worlds.erase(worlds.begin() + id_);
				}
			}
		}
	}
	catch (exception& kontol) {
		cerr << "Failed to save " << name_ << " " << kontol.what() << endl;
	}
}

void get_players(const string& name_, int& c_, int& t_, int& net_, int& r_c) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->tankIDName == "") continue;
		if (not name_.empty() && pInfo(currentPeer)->world == name_) {
			if (not pInfo(currentPeer)->invis)
				c_++;
			if (pInfo(currentPeer)->netID >= net_)
				net_ = pInfo(currentPeer)->netID + 1;
			r_c++;
		}
		if (server_port == 1) t_ += 1 + rand() % 3 + 1;
		else t_ += 1;
	}
}

bool check_name(string& name_) {
	if (name_ == "EXIT") {
		name_ = "Exit from what? Press back if you're done playing.";
		return false;
	}
	for (char c : name_) if ((c < 'A' || c>'Z') && (c < '0' || c>'9')) {
		name_ = "Sorry, spaces and special characters are not allowed in world or door names.  Try again.";
		return false;
	}
	for (int i = 0; i < swear_words.size(); i++) {
		if (name_.find(swear_words[i]) != string::npos) {
			name_ = "DISNEYLAND";
			break;
		}
	}
	if (name_.size() < 1 || name_.size() >= 24) {
		name_ = "`4To reduce confusion, that is not a valid world name.``  Try another?";
		return false;
	} if (name_ == "") {
		name_ = "START";
	}
	return true;
}
bool check_blast(string& name_) {
	if (name_ == "EXIT" || name_ == "" || name_.size() < 1 || name_.size() >= 24) {
		return false;
	}
	for (char c : name_) if ((c < 'A' || c>'Z') && (c < '0' || c>'9')) {
		return false;
	}
	for (int i = 0; i < swear_words.size(); i++) {
		if (name_.find(swear_words[i]) != string::npos) return false;
	}
	return true;
}
bool onlyDigit(string& text_) {
	for (char c : text_) if ((c < '0' || c>'9')) {
		return false;
	}
}
long long last_active_update = 0;
vector<string> active_worlds;
void form_emoji(ENetPeer* peer, bool notification = false, int timeout = 0) {
	if (notification) {
		gamepacket_t p(timeout);
		p.Insert("OnAddNotification");
		p.Insert("interface/large/friend_button.rttex");
		p.Insert("You've unlocked some new `$Growmojis``!");
		p.Insert("audio/hub_open.wav");
		p.Insert(0);
		p.CreatePacket(peer);
	}
	{
		gamepacket_t p;
		p.Insert("OnEmoticonDataChanged");
		p.Insert(0);
		p.Insert(pInfo(peer)->growmoji + "(yes)|Ă|" + (pInfo(peer)->supp == 2 ? "1" : "0") + 
			"&(no)|ă|" + (pInfo(peer)->supp != 0 ? "1" : "0") + "&" + (pInfo(peer)->supp == 2 ? 
				"(love)|Ą|1" : "(love)|Ą|0") + "&" + (pInfo(peer)->supp != 0 ? "(shy)|Ć|1&(wink)|ć|1" : 
					"(shy)|Ć|0&(wink)|ć|0") + "&(tongue)|Ĉ|" + (pInfo(peer)->level >= 5 ? "1" : "0") + 
			"&(agree)|ĉ|" + (pInfo(peer)->friends.size() >= 20 ? "1" : "0") + "&(music)|Č|" + (pInfo(peer)->supp != 0 ? 
				"1" : "0") + "&(build)|č|" + (pInfo(peer)->friends.size() >= 50 ? "1" : "0") + "&(megaphone)|Ď|" 
			+ (pInfo(peer)->supp == 2 ? "1" : "0") + "&" + (pInfo(peer)->level >= 5 ? "(sigh)|ď|1&(mad)|Đ|1&(wow)|đ|1"
				: "(sigh)|ď|0&(mad)|Đ|0&(wow)|đ|0") + "&(dance)|Ē|" + (pInfo(peer)->friends.size() >= 40 ? "1" : "0") + 
			"&(see-no-evil)|ē|" + (pInfo(peer)->friends.size() >= 30 ? "1" : "0") + "&(heart)|ĕ|" + (pInfo(peer)->supp == 2 ? "1" : "0") + "&(kiss)|Ę|" + (pInfo(peer)->friends.size() >= 10 ? "1" : "0") + "&(lol)|Ě|" + (pInfo(peer)->supp != 0 ? "1" : "1") + "&(smile)|Ā|" + (pInfo(peer)->level >= 5 ? "1" : "0") + "&(cool)|Ĝ|" + (pInfo(peer)->supp == 2 ? "1" : "0"));
		p.CreatePacket(peer);
	}
}
bool includesint(vector<int> vcs, int item) {
	if (find(vcs.begin(), vcs.end(), item) != vcs.end()) return 1;
	return 0;
}
void add_honors(string world) {
	if (world == "") return;
	string find = world;
	vector<pair<int, string>>::iterator p = find_if(top_points.begin(), top_points.end(), [find](const pair < int, string>& element) { return element.second == find; });
	if (p != top_points.end()) top_points[p - top_points.begin()].first++;
	else top_points.push_back(make_pair(1, find));
	vector<pair<int, string>>::iterator p2 = find_if(top_overall.begin(), top_overall.end(), [find](const pair < int, string>& element) { return element.second == find; });
	if (p2 != top_overall.end()) top_overall[p2 - top_overall.begin()].first++;
	else top_overall.push_back(make_pair(1, find));
}
bool toolavailable(ENetPeer* peer, int tool) {
	bool have = false;
	for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == tool) have = true;
	if (pInfo(peer)->dirt == 10 && tool != 1258 && tool != 0)
		return false;
	else
		switch (tool) {
		case 1258:
			return have;
		case 1266:
			return have && pInfo(peer)->labworked;
		case 1296:
			return pInfo(peer)->fixable && !pInfo(peer)->fixed;
		case 4316:
			return have && !pInfo(peer)->sounded;
		case 4318:
			return have && !pInfo(peer)->labworked;
		case 4312:
			return have && pInfo(peer)->heart > 0;
		case 1268:
			return have && pInfo(peer)->broken > 0;
		case 4308:
			return have && pInfo(peer)->shattered > 0 && pInfo(peer)->incisions > 0;
		case 4314:
			return have && pInfo(peer)->incisions > 0 && pInfo(peer)->bleeding > 0;
		default:
			return have;
		}
}

void add_cctv(ENetPeer* peer, string type, string extra) {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	WorldCCTV cctv_{};
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		for (int i2_ = 0; i2_ < world_->cctv_settings.size(); i2_++) {
			cctv_.logs = "";
			if (world_->cctv_settings[i2_].dont_show_owner && pInfo(peer)->tankIDName == world_->owner_name) break;
			if (world_->cctv_settings[i2_].dont_show_noaccess && pInfo(peer)->tankIDName != world_->owner_name and !guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end()) break;
			if (world_->cctv_settings[i2_].dont_show_admins && find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) != world_->admins.end()) break;
			if (type == "entered" && world_->cctv_settings[i2_].show_people_entering or type == "left" && world_->cctv_settings[i2_].show_people_exiting or type == "took" && world_->cctv_settings[i2_].show_item_taking or type == "dropped" && world_->cctv_settings[i2_].show_item_dropping) cctv_.logs = "\nadd_label_with_icon|small|`w" + pInfo(peer)->tankIDName + "`w " + type + "" + (extra == "" ? " " : " " + extra + " ") + "at " + to_string(newtime.tm_hour) + ":" + to_string(newtime.tm_min) + " on " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_wday) + "``|left|" + (type == "took" ? "18" : "1400") + "|";
			if (cctv_.logs != "") {
				if (world_->cctv.size() == 50) world_->cctv.erase(world_->cctv.begin() + 1);
				cctv_.x = world_->cctv_settings[i2_].x, cctv_.y = world_->cctv_settings[i2_].y;
				world_->cctv.push_back(cctv_);
			}
		}
	}
}

void shop_tab(ENetPeer* peer, string tab) {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	time_t currentTime;
	time(&currentTime);
	const auto localTime = localtime(&currentTime);
	/*
	if (pInfo(peer)->dev) Store += "\nadd_image_button|image_button|interface/large/gui_shop_grow_pass.rttex|bannerlayout|OPENDIALOG|battlepasspopup|";
	ifstream ifsz("WinterFest/Calendar.txt");
	string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
	int Total = atoi(content.c_str());
	float TotalPercent = (float)Total / 500;
	if (Total > 0) Store += "\nadd_button|winterfest_calendar_2022|`oWinterfest Calendar - 2022``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Winterfest Calendar - 2022.<CR><CR>`5Description:`` A wonderful Winterfest Calendar for 2022, jam-packed with joy and gifts to celebrate the holidays. Buying this item will give you access to exclusive Winterfest Club Items as they become available in store.|0|0|65000|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|||||" + to_string(((int)TotalPercent < 1 ? 1 : (int)TotalPercent)) + "% remaining||0|0|";
	else Store += "\nadd_button|winterfest_calendar_2022|`oWinterfest Calendar - 2022``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Winterfest Calendar - 2022.<CR><CR>`5Description:`` A wonderful Winterfest Calendar for 2022, jam-packed with joy and gifts to celebrate the holidays. Buying this item will give you access to exclusive Winterfest Club Items as they become available in store.|0|0|65000|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||0|interface/large/store_buttons/store_buttons34.rttex|1|0|Out of Stock||0|0|";
	string HaveGrowPass;
	ifstream Check("WinterFest/Bonanza/" + pInfo(peer)->tankIDName + ".txt");
	Check >> HaveGrowPass; Check.close();
	if (localTime->tm_mday == 3 || localTime->tm_mday == 10 || localTime->tm_mday == 17 || localTime->tm_mday == 24 || localTime->tm_mday == 31) {
		ifstream ifsz1("WinterFest/Bonanza.txt");
		string content1((std::istreambuf_iterator<char>(ifsz1)), (std::istreambuf_iterator<char>()));
		int Total1 = atoi(content1.c_str());
		float TotalPercent1 = (float)atoi(content1.c_str()) / 100;
		if (HaveGrowPass == "True") {
			if (Total1 > 0) Store += "\nadd_button|Diamond_Provider|`oDiamond Builders Bonanza``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Diamond Builders Bonanza.<CR><CR>`5Description:`` Eager to add some new diamond building materials to your construction stockpile? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `#Rare`` Diamond Dog and Diamond Warrior's Pauldrons amongst a heap of diamond blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch! <CR><CR>This item is available to Winterfest Club members only. Purchase the `2Winterfest 2022 Calendar`` to join the club.|0|1|45000|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|||||" + to_string(((int)TotalPercent1 < 1 ? 1 : (int)TotalPercent1)) + "% remaining||0|0|";
			else Store += "\nadd_button|Diamond_Provider|`oDiamond Builders Bonanza``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Diamond Builders Bonanza.<CR><CR>`5Description:`` Eager to add some new diamond building materials to your construction stockpile? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `#Rare`` Diamond Dog and Diamond Warrior's Pauldrons amongst a heap of diamond blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch! <CR><CR>This item is available to Winterfest Club members only. Purchase the `2Winterfest 2022 Calendar`` to join the club.|0|1|45000|0|||-1|-1||-1|-1||0|interface/large/store_buttons/store_buttons34.rttex|0|2|Out of Stock||0|0|";
		}
		else Store += "\nadd_button|Diamond_Provider|`oDiamond Builders Bonanza``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Diamond Builders Bonanza.<CR><CR>`5Description:`` Eager to add some new diamond building materials to your construction stockpile? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `#Rare`` Diamond Dog and Diamond Warrior's Pauldrons amongst a heap of diamond blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch! <CR><CR>This item is available to Winterfest Club members only. Purchase the `2Winterfest 2022 Calendar`` to join the club.|0|1|45000|0|||-1|-1||-1|-1||0|interface/large/store_buttons/store_buttons34.rttex|1|1|||0|0|";
	}
	else {
		if (HaveGrowPass == "True") Store += "\nadd_button|Diamond_Provider|`oDiamond Builders Bonanza``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Diamond Builders Bonanza.<CR><CR>`5Description:`` Eager to add some new diamond building materials to your construction stockpile? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `#Rare`` Diamond Dog and Diamond Warrior's Pauldrons amongst a heap of diamond blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch! <CR><CR>This item is available to Winterfest Club members only. Purchase the `2Winterfest 2022 Calendar`` to join the club.|0|1|45000|0|||-1|-1||-1|-1||0|interface/large/store_buttons/store_buttons34.rttex|0|2|||0|0|";
		else Store += "\nadd_button|Diamond_Provider|`oDiamond Builders Bonanza``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Diamond Builders Bonanza.<CR><CR>`5Description:`` Eager to add some new diamond building materials to your construction stockpile? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `#Rare`` Diamond Dog and Diamond Warrior's Pauldrons amongst a heap of diamond blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch! <CR><CR>This item is available to Winterfest Club members only. Purchase the `2Winterfest 2022 Calendar`` to join the club.|0|1|45000|0|||-1|-1||-1|-1||0|interface/large/store_buttons/store_buttons34.rttex|1|1|||0|0|";
	}
	
	
	if (localTime->tm_mday == 30 and Halloween) {
		Store += "\nadd_image_button|image_button|interface/large/gui_halloween_banner3.rttex|bannerlayout|OPENDIALOG|halloweenquestpopup|";
		Store += "\nadd_button|fist_of_vengeance|`oFist of Vengeance``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Fist of Vengeance.<CR><CR>`5Description:`` Become the knight of the darkness and strike down your foes with the Fist of Vengeance!|0|4|1000000|0|||0|0|interface/large/gui_shop_buybanner2.rttex|1|7||1||||||0|0|";
		Store += "\nadd_button|rt_grope_gem_halloween_bundle|`oHalloween Starter Pack``|interface/large/store_buttons/store_buttons39.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=QQZ4YPMYFSLV6&custom=63357431-09E4E6BB4A09329F8CE90CF2CCCA24D2|0|3|0||||-1|-1||-1|-1|`2You Get:`` 540,000 Gems, 25x Dark King's Offering, 5x Dark Tickets, 75x Gift of Growganoth, 1x Carved Pumpkin Hat, 1x Carved Pumpkin Onesie.<CR><CR>`5Description:`` Treat yourself with all the gems you could ever want and everything you need to give a scare this Halloween! The Carved Pumpkin Set will only be available from this pack in 2022. Get out there, we're \"rotting\" for you!|1||||||0|0|";
		Store += "\nadd_button|growganoth|`oGift of Growganoth Pack``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 10 Gifts of Growganoth.<CR><CR>`5Description:`` `4Available only during Halloween!`` Would you like to donate to the cause?  Give Growganoth a few gems, and it will reward you with vast power beyond imagining!  Or, perhaps, a box containing a random Halloween item.  Opening each is equivalent to feeding 1 item of rarity 75 into the Maw of Growganoth.  What you will get is random, so don't buy this unless you're ready to be surprised! Each gift has the chance of getting `#Dark King's Offering`` or any of it's Components, including the `#Rare Spooky Gift``! Only available for purchase during `2Halloween Week.`` This item is `#Untradeable.``|0|1|15000|0|||-1|-1||-1|-1||1||||||0|0|";
		Store += "\nadd_button|halloween_dummy|`oGo To Growganoth!``|interface/large/store_buttons/store_buttons39.rttex|OPENDIALOG&warp_player_into_halloween_world|3|3|0|0|||-1|-1||-1|-1||1||||||0|0|";
		Store += "\nadd_button|dark_ticket|`oDark Ticket``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Dark Ticket.<CR><CR>`5Description:`` Enter the Tomb of Growganoth at your own peril! Find the `5Sacrificial Wells`` to earn `5Corrupted Souls`` and locate the `5Corruption Altar`` to get rewards... beware of the darkness!|0|6|6000|0|||-1|-1||-1|-1||1||||||0|0|";
		Store += "\nadd_button|dark_mountains|`oDark Mountains``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Weather Machine - Dark Mountains.<CR><CR>`5Description:`` Bring some terror to your world with these mountains!|2|3|50000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|0|7||1||||||0|0|";
		Store += "\nadd_button|riding_raven|`oRiding Raven``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Riding Raven.<CR><CR>`5Description:`` Only the darkest magic could breed a raven so massive that you could ride on it. And Growganoth only permits such magic during `2Halloween Week``, so buy this now before Halloween is over! Riding on this bird gives you the ability to double-jump. Only available for purchase during `2Halloween Week``!|0|1|150000|0|||-1|-1||-1|-1||1||||||0|0|";
		Store += "\nadd_button|spirit_hat|`oSpiritual Resonator``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Spiritual Resonator.<CR><CR>`5Description:`` `4Available only during Halloween!`` This fantabulous contraption is worn on the head, where it sends out signals into the great beyond, attracting friendly spirits.  The ghost that follows you around when you wear this has a special ability - if you wear a pet leash on your wrist at the same time, the ghost will replace the pet, but imitate its abilities (such as breathing fire if you wear a Dragon Hand).|0|0|40000|0|||-1|-1||-1|-1||1||||||0|0|";
	}
	
	
	if (localTime->tm_mday == 15 and Harvest_Festival) {
		Store += "\nadd_button|mooncake_mag|`oMooncake Magnificence``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Mooncake Magnificence.<CR><CR>`5Description:`` A Magnificent Mooncake Pendant! When equipped, this magical pendant emits a balanced glow that responds in harmony with Balance Mooncakes. Whenever a Balance Mooncake is found, there is a chance of dropping up to X3 of them but also the item breaking. The item will only break when 2 or more Balance Mooncakes are dropped at a time. However, it repels Peace, Harmony, Prosperity and Longevity Mooncakes making them less likely to be found when harvesting trees.|0|7|5000|0|||-1|-1||-1|-1||1||||||0|0|";
		Store += "\nadd_button|mooncake_sale|`oMooncake Magnificence Sale!``|interface/large/store_buttons/store_buttons30.rttex|`2You Get:`` 3 Mooncake Magnificence.<CR><CR>`5Description:`` Congratulations! It's community sale time! A Pack of 3 Magnificent Mooncake Pendants! When equipped, this magical pendant emits a balanced glow that responds in harmony with Balance Mooncakes. Whenever a Balance Mooncake is found, there is a chance of dropping up to X3 of them but also the item breaking. The item will only break when 2 or more Balance Mooncakes are dropped at a time. However, it repels Peace, Harmony, Prosperity and Longevity Mooncakes making them less likely to be found when harvesting trees.|0|6|12500|0|||-1|-1||-1|-1||0|interface/large/store_buttons/store_buttons30.rttex|0|7|    0% achieved    ||0|0|";
		Store += "\nadd_button|mystical_lanten_hoa|`oMystical Lantern``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Mystical Lantern.<CR><CR>`5Description:`` Light the way on your journey.<CR><CR>`#This item is only available during Harvest Festival.``|2|1|300000|0|||-1|-1||-1|-1||1||||||0|0|";
		Store += "\nadd_button|offering_alter_hoa|`oOffering Table``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Offering Table.<CR><CR>`5Description:`` Offer 10 mooncakes on the table to receive 1 random reward from the Harvest Moon!<CR><CR>`#This item is only available during Harvest Festival.``|1|1|5000|0|||-1|-1||-1|-1||1||||||0|0|";
		Store += "\nadd_button|solar_collector|`oSolar Collector``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Solar Collector.<CR><CR>`5Description:`` Stick these amazing devices in your world. They take 24 hours to charge, and then the next seed you plant will be infused with solar energy, growing 25% instantly! They can be turned on and off with the wrench (or set to only affect splicing, or only affect planting, whatever you need!). `#Only available during Harvest Fest!`` `8Note: These items don't return to your backpack when broken, so place them carefully!``|0|3|8000|0|||-1|-1||-1|-1||1||||||0|0|";
		Store += "\nadd_button|harvest_pack|`oHarvest Blast``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` A Harvest Moon Blast.<CR><CR>`5Description:`` Celebrate the harvest with a new `2Harvest Moon Blast`` to create a world with a unique harvest moon sky, filled with random trees that are fully grown and ready to harvest!``)|0|6|10000|0|||-1|-1||-1|-1||1||||||0|0|";
	}
	
	//Store += "\nadd_button|mallet_of_sucelles|`oMallet of Sucelles``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Mallet of Sucelles.<CR><CR>`5Description:`` Whosoever is able to hold the mallet shall possess the power of Sucelles!``|1|1|1000000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|harp_of_aibell|`oHarp of Aibell``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Harp of Aibell.<CR><CR>`5Description:`` Softly creeping, a deadly sound plants in your brain, the sound of silence.``|2|1|1000000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|eye_of_balor|`oEye of Balor``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Eye of Balor.<CR><CR>`5Description:`` Wear the eye of the demon cyclops Balor and fight fire with well fire!``|3|1|1000000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|cauldron_dagda|`oCauldron of the Dagda``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Mallet of Sucelles.<CR><CR>`5Description:`` A mystical cauldron grants you good health!``|4|1|1000000|0|||-1|-1||-1|-1||1||||||0|0|";
	// RANDOM ZODIAC STORE LATER
	//Store += "\nadd_button|constellation_r|`oZodiac Year of the Rabbit``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Zodiac Year of the Rabbit.<CR><CR>`5Description:`` TayoPs born in the Year of the Rabbit are sensitive, romantic and kind. They are known to be faithful for those around them. Collecting all pieces of Zodiac animal may guide you to something.``|1|0|50000000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|constellation_t|`oZodiac Year of the Tiger``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Zodiac Year of the Tiger.<CR><CR>`5Description:`` TayoPs born in the Year of the Tiger are sensitive, romantic and kind. They are known to be faithful for those around them. Collecting all pieces of Zodiac animal may guide you to something.``|2|0|50000000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|constellation_p|`oZodiac Year of the Pig``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Zodiac Year of the Pig.<CR><CR>`5Description:`` TayoPs born in the Year of the Pig are sensitive, romantic and kind. They are known to be faithful for those around them. Collecting all pieces of Zodiac animal may guide you to something.``|3|0|50000000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|constellation_h|`oZodiac Year of the Horse`|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Zodiac Year of the Horse.<CR><CR>`5Description:`` TayoPs born in the Year of the Pig are sensitive, romantic and kind. They are known to be faithful for those around them. Collecting all pieces of Zodiac animal may guide you to something.``|4|0|50000000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|eldritch_wings|`oEldritch Wings``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Eldritch Wings.<CR><CR>`5Description:`` The Eldritch Wings is an unsplicable back item. Sponsored by iDems.``|1|3|25000000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|lightning_fist|`oMythical Lightning Fist``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Mythical Lightning Fist.<CR><CR>`5Description:`` Zap!!. banish everything into dust with your lightning fist!.``|0|3|70000000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|midnight_devil|`oMidnight Devil Wings``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Midnight Devil Wings.<CR><CR>`5Description:`` You don't jump higher than with normal wings, but man, you do look pretty cool.``|3|2|250000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|abundance_wing|`oAbundance Wings``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Abundance Wings.<CR><CR>`5Description:`` You don't jump higher than with normal wings, but man, you do look pretty cool.``|4|2|300000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "\nadd_button|mystery_box|`oMystery Box``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Mystery Box.<CR><CR>`5Description:`` There is chance to get `5Rare Items ``such as `wRoyal Items, Rayman's Fist, Magplant 5000, Growscan 9000 ``and many more.``|4|3|200000|0|||-1|-1||-1|-1||1||||||0|0|";
	//Store += "";
	//string gemsshop = "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|0|\nadd_big_banner||0|0||"/*"\nadd_button|9999wl|`o9,999 Premium World Locks``|game/store_gtps.rttex|https://sowl.co/LtAXz|0|13|0|0|$ USD 59.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#9,999 Premium World Locks``, `#19 Growtoken`` and `#15 Megaphone``.<CR><CR>`5Description:`` Get 9,999 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|5000wl|`o5000 Premium World Locks``|game/store_gtps.rttex|https://sowl.co/Jk3Gu|0|6|0|0|$ USD 32.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#5000 Premium World Locks`` and `#10 Growtoken``.<CR><CR>`5Description:`` Get 5000 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|1500wl|`o1500 Premium World Locks``|game/store_gtps.rttex|https://sowl.co/btmdUT|0|5|0|0|$ USD 14.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#1500 Premium World Locks`` and `#3 Growtoken``.<CR><CR>`5Description:`` Get 1500 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|500wl|`o500 Premium World Locks``|game/store_gtps.rttex|https://sowl.co/zq9kN|0|4|0|0|$ USD 4.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#500 Premium World Locks`` and `#1 Growtoken``.<CR><CR>`5Description:`` Get 500 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|100wl|`o100 Premium World Locks``|game/store_gtps.rttex|https://sowl.co/btUJWQ|0|3|0|0|$ USD 1.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#100 Premium World Locks``.<CR><CR>`5Description:`` Get 100 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|custom_item|`oCreate Custom Item``|game/store_gtps.rttex|https://sowl.co/Y9mQf|0|7|0|0|$ USD 24.99||-1|-1||0|0|`4It takes up to 12 hours to create your custom item!``<CR><CR>`2You Get:`` Your own custom item.<CR><CR>`5Description:`` Get Your own custom item. Item will be created in less then 12 hours.<CR><CR>You can decide `9item name``,`9description``,`9playmods``,`9everything about the item you create you decide!``|1||||||0|0|"*//*\nadd_button|rt_grope_battlepass_bundle01|Royal Grow Pass|interface/large/store_buttons/store_buttons37.rttex|https://privategt.com/purchase/|4|2|0||||-1|-1||-1|-1|`2You Get:`` 1 Royal Grow Pass Token.<CR><CR>`5Description:`` Play to earn points and level up your Grow Pass to earn rewards. Consume to earn exclusive `5Royal`` rewards as you level up your Grow Pass as well as unlocking all daily bonuses and exclusive `5Royal Perks`` for the entire month.|1||||||0|0|*/"";
	//gemsshop += "\nadd_button|rt_grope_battlepass_bundle01|Royal Grow Pass|interface/large/store_buttons/store_buttons37.rttex|https://discord.com/invite/nDD4QhyREc|4|2|0||||-1|-1||-1|-1|`2You Get:`` 1 Royal Grow Pass Token.<CR><CR>`5Description:`` Play to earn points and level up your Grow Pass to earn rewards. Consume to earn exclusive `5Royal`` rewards as you level up your Grow Pass as well as unlocking all daily bonuses and exclusive `5Royal Perks`` for the entire month. Upon consuming you will instantly receive `2300 Free`` points towards your pass progress. Note: The token is `#UNTRADEABLE``.|1||||||0|0|";
	// Valentine Event
	//gemsshop += "\nadd_button|valentine_goodies|`oValentine's Goodies``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 5 Golden Booty Chests and 1 Valentine's Card.<CR><CR>`5Description:`` Contains 5 Golden Booty Chests and a bonus Valentine's Card to share the love. Smash the Golden Booty Chests to find a random assortment of Valentine's surprises.|0|4|7500|0|||-1|-1||-1|-1||1||||||0|0|";
	//gemsshop += "\nadd_button|valentine|`oValentine's ``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 Weather Machine - Valentine's. <CR><CR>`5Description:`` Love is in the air! Send hearts sailing through pink and fluffy skies with this adorable weather machine and everyone will know what a romantic you are! It's a perma-item, is never lost when destroyed.|0|5|10000|0|||-1|-1||-1|-1||1||||||0|0|";
	ShopBuilder shop;
	if (tab == "tab1" || tab == "tab1_1" || tab == "tab1_2" || tab == "tab1_3" || tab == "tab1_4") {
		shop.set_description("Gems and VIP").enable_tabs(true)
			.add_tabs("main_menu", "Home", "interface/large/btn_shop_gtps.rttex", 1, 0)
			.add_tabs("locks_menu", "Locks And Stuff", "interface/large/btn_shop_gtps.rttex", 0, 1)
			.add_tabs("itempack_menu", "Item Packs", "interface/large/btn_shop_gtps.rttex", 0, 3)
			.add_tabs("bigitems_menu", "Awesome Items", "interface/large/btn_shop_gtps.rttex", 0, 4)
			.add_tabs("weather_menu", "Weather Machines", "interface/large/btn_shop_gtps.rttex", 0, 5)
			.add_tabs("token_menu", "Growtoken Items", "interface/large/btn_shop_gtps.rttex", 0, 2)
			.add_banner("interface/large/gui_shop_featured_header.rttex", 0, 1)
			//.add_gems_item("", "", "", "", 0, 0, 0)
			//.add_gems_item("constellation_h", "Zodiac Year of the Horse", "h_store_buttons", "TayoPs born in the Year of the Pig are sensitive, romantic and kind. They are known to be faithful for those around them. Collecting all pieces of Zodiac animal may guide you to something.", 4, 0, 50000000)
			//.add_gems_item("constellation_p", "Zodiac Year of the Pig", "h_store_buttons", "TayoPs born in the Year of the Tiger are sensitive, romantic and kind. They are known to be faithful for those around them. Collecting all pieces of Zodiac animal may guide you to something.", 3, 0, 50000000)
			//.add_gems_item("lightning_fist", "Mythical Lightning Fist", "h_store_buttons", "Zap!!. banish everything into dust with your lightning fist!.", 0, 3, 100000000)
			//.add_gems_item("eldritch_wings", "Eldritch Wings", "h_store_buttons", "The Eldritch Wings is an unsplicable back item. Sponsored by iDems.", 1, 3, 25000000)
			//.add_gems_item("midnight_devil", "Midnight Devil Wings", "h_store_buttons", "You don't jump higher than with normal wings, but man, you do look pretty cool.", 3, 2, 250000)
			//.add_gems_item("abundance_wing", "Abundance Wings", "h_store_buttons", "You don't jump higher than with normal wings, but man, you do look pretty cool.", 4, 2, 300000)
			//.add_gems_item("mystery_box", "Mystery Box", "h_store_buttons", "There is chance to get `5Rare Items ``such as `wRoyal Items, Rayman's Fist, Magplant 5000, Growscan 9000 ``and many more.", 4, 3, 200000);
			.add_banner("interface/large/gui_shop_featured_header.rttex", 0, 0)
			.add_big_banner("interface/large/gui_store_iap_message.rttex", "More custom item shop update soon! to purchase ranks & rare items you can type `1/shop`w!", 0, 0)
		//	.add_gems_item("9150", "Predator", "gtps_store1", "Beth's Villainous greatsword.", 1, 2, 350000000)
			//.add_gems_item("12598", items[12598].name, "gtps_store1", "Offer 10 Mooncakes on the table to receive 1 random reward from the Harvest Moon!", 2, 2, 50000)
			.add_button_dialog("casino_gachas", "Casino Coin Gacha", "gtps_store1", "casino_gacha", 1, 9)
			.add_button_dialog("redeem_open", "Redeeem a code", "gtps_store1", "redeem_open", 2, 0)
			//.add_gems_item("8530", "Magma Dragon Fist", "store_buttons1369", "June 2023: This fist allows you to do 1 hit and 6 far place/punch. What an amazing fists.", 0, 0, 1000000000, false)
			//.add_gems_item("demonic_blade", "Demonic Blade", "store_buttons6913", "May 2023: This blade allows you to do 1 hit on every block. You'll get a demonic blade with random color. Don't worry, it is the same at all (for the effect).", 0, 2, 1000000, false);
			;
		//.add_cash_item("growpass_month", "Royal Grow Pass", "store_buttons37", "	Play to earn points and level up your Grow Pass to earn rewards. Consume to earn exclusive `5Royal`` rewards as you level up your Grow Pass as well as unlocking all daily bonuses and exclusive `5Royal Perks`` for the entire month. Upon consuming you will instantly receive `2300 Free`` points towards your pass progress. Note: The token is `#UNTRADEABLE``.", 4, 2);
	}
	else if (tab == "tab2" || tab == "tab2_1") {
		shop.set_description("Player Items").enable_tabs(true)
			.add_tabs("main_menu", "Home", "interface/large/btn_shop_gtps.rttex", 0, 0)
			.add_tabs("locks_menu", "Locks And Stuff", "interface/large/btn_shop_gtps.rttex", 1, 1)
			.add_tabs("itempack_menu", "Item Packs", "interface/large/btn_shop_gtps.rttex", 0, 3)
			.add_tabs("bigitems_menu", "Awesome Items", "interface/large/btn_shop_gtps.rttex", 0, 4)
			.add_tabs("weather_menu", "Weather Machines", "interface/large/btn_shop_gtps.rttex", 0, 5)
			.add_tabs("token_menu", "Growtoken Items", "interface/large/btn_shop_gtps.rttex", 0, 2);
		if (pInfo(peer)->inv.size() < INV_MAX) {
			shop.add_gems_item("upgrade_backpack", "`0Upgrade Backpack`` (`w10 Slots``)", "store_buttons", "Sewing an extra pocket onto your backpack will allow you to store `$10`` additional item types.  How else are you going to fit all those toilets and doors?", 0, 1, 100 * ((((pInfo(peer)->inv.size() - 17) / 10) * ((pInfo(peer)->inv.size() - 17) / 10)) + 1));
		}
		shop.add_gems_item("clothes", "Clothes Pack", "store_buttons2", "Why not look the part? Some may even have special powers...", 0, 0, 25)
			.add_gems_item("rare_clothes", "Rare Clothes Pack", "store_buttons2", "Enjoy the garb of kings! Some may even have special powers...", 0, 1, 250)
			.add_gems_item("transmutabooth", "Transmutabooth", "store_buttons27", "Behold! A wondrous technological achievement from the innovative minds at GrowTech, the Transmutabooth allows you to merge clothing items, transferring the visual appearance of one onto another in the same slot! If you've ever wanted your Cyclopean Visor to look like Shades (while keeping its mod), now you can!", 0, 7, 100000)
			.add_gems_item("contact_lenses", "Contact Lens Pack", "store_buttons22", "Need a colorful new look? This pack includes 20 random Contact Lens colors (and may include Contact Lens Cleaning Solution, to return to your natural eye color)!", 0, 7, 15000)
			.add_gems_item("eye_drops", "Eye Drop Pack", "store_buttons17", "Need a fresh new look?  This pack includes a 10 random Eye Drop Colors (may include Eye Cleaning Solution, to leave your eyes sparkly clean)!", 0, 6, 30000)
			.add_gems_item("nyan_hat", "Turtle Hat", "store_buttons3", "It's the greatest hat ever. It bloops out bubbles as you run! `4Not available any other way!", 0, 2, 12500)
			.add_gems_item("tiny_horsie", "Tiny Horsie", "store_buttons3", "Tired of wearing shoes? Wear a Tiny Horsie instead! Or possibly a large dachshund, we're not sure. Regardless, it lets you run around faster than normal, plus you're on a horse! `4Not available any other way!", 0, 5, 12500)
			.add_gems_item("star_ship", "Pleiadian Star Ship", "store_buttons4", "Float on, my brother. It's all groovy. This star ship can't fly, but you can still zoom around in it, leaving a trail of energy rings and moving at enhanced speed. Sponsored by Pleiadian. `4Not available any other way!", 0, 3, 12500)
			.add_gems_item("dragon_hand", "Dragon Hand", "store_buttons5", "Call forth the dragons of legend!  With the Dragon Hand, you will command your own pet dragon. Instead of punching blocks or players, you can order your dragon to incinerate them! In addition to just being awesome, this also does increased damage, and pushes other players farther. `4Not available any other way!", 0, 1, 25000)
			.add_gems_item("corvette", "Little Red Corvette", "store_buttons6", "Cruise around the neighborhood in style with this sweet convertible. It moves at enhanced speed and leaves other Growtopians in your dust. `4Not available any other way!", 0, 1, 12500)
			.add_gems_item("stick_horse", "Stick Horse", "store_buttons6", "Nobody looks cooler than a person bouncing along on a stick with a fake horse head attached. NOBODY. `4Not available any other way!", 0, 3, 12500)
			.add_gems_item("ambulance", "Ambulance", "store_buttons7", "Rush to the scene of an accident while lawyers chase you in this speedy rescue vehicle. `4Not available any other way!", 0, 3, 12500)
			.add_gems_item("5480", "Rayman's Fist", "store_buttons6913", "January 2018: Rayman Fist + Globox! The perfect punch! Ever wanted to send a disembodied fist flying across the land like Rayman? Well, now you can! Land a blow like none other with this furious fist. It even comes with a friend: Globox!", 0, 1, 50000, false)
			.add_gems_item("9882", "Siroi Kumo", "gtps_store1", "Break everything easily with this sword! Giving 1 hit effect to all blocks. (`4Warning: This sword will break after 200 times it used (by punch).``)", 2, 1, 20000)
			.add_gems_item("raptor", "Riding Raptor", "store_buttons7", "Long thought to be extinct, it turns out that these dinosaurs are actually alive and easily tamed. And riding one lets you run around faster than normal! `4Not available any other way!", 0, 7, 12500)
			.add_gems_item("owl", "Mid-Pacific Owl", "store_buttons10", "This owl is a bit lazy - if you stop moving around, he'll land on your head and fall asleep. Dedicated to the students of the Mid-Pacific Institute. `4Not available any other way!", 0, 1, 15000)
			.add_gems_item("unicorn", "Unicord Garland", "store_buttons10", "Prance about in the fields with your very own pet unicorn! It shoots `1R`2A`3I`4N`5B`6O`7W`8S``. `4Not available any other way!", 0, 4, 25000)
			.add_gems_item("starboard", "StarBoard", "store_buttons11", "Hoverboards are here at last! Zoom around Growtopia on this brand new model, which is powered by fusion energy (that means stars spit out of the bottom). Moves faster than walking. Sponsored by Miwsky, Chudy, and Dawid. `4Not available any other way!", 0, 1, 15000)
			.add_gems_item("motorcycle", "Growley Motorcycle", "store_buttons11", "The coolest motorcycles available are Growley Dennisons. Get a sporty blue one today! It even moves faster than walking, which is pretty good for a motorcycle. `4Not available any other way!", 0, 6, 25000)
			.add_gems_item("monkey_on_back", "Monkey On Your Back", "store_buttons13", "Most people work really hard to get rid of these, but hey, if you want one, it's available! `4But not available any other way!`` Sponsored by SweGamerHD's subscribers, Kizashi, and Inforced. `#Note: This is a neck item, not a back item. He's grabbing your neck!", 0, 2, 25000)
			.add_gems_item("carrot_sword", "Carrot Sword", "store_buttons13", "Razor sharp, yet oddly tasty. This can carve bunny symbols into your foes! `4Not available any other way!`` Sponsored by MrMehMeh.", 0, 3, 7500)
			.add_gems_item("red_bicycle", "Red Bicycle", "store_buttons13", "It's the environmentally friendly way to get around! Ride this bicycle at high speed hither and zither throughout Growtopia. `4Not available any other way!", 0, 5, 15000)
			.add_gems_item("fire_truck", "Fire Truck", "store_buttons14", "Race to the scene of the fire in this speedy vehicle! `4Not available any other way!", 0, 2, 25000)
			.add_gems_item("pet_slime", "Pet Slime", "store_buttons14", "What could be better than a blob of greasy slime that follows you around? How about a blob of greasy slime that follows you around and spits corrosive acid, melting blocks more quickly than a normal punch? `4Not available any other way!", 0, 4, 50000)
			.add_gems_item("dabstep_shoes", "Dabstep Low Top Sneakers", "store_buttons21", "Light up every footfall and move to a better beat with these dabulous shoes! When you're wearing these, the world is your dance floor! `4Not available any other way!", 0, 2, 15000)
			.add_gems_item("chicken_plow", "Chicken Plow", "h_store_buttons", "Ancient magic has unlocked the secrets of advance chicken farming! Now, for the first time, your chicken will PLANT seeds instead of eating them! (When equipped, will plant whatever seed you have selected as you move!) `4Not available any other way!", 3, 3, 500000)
			.add_gems_item("13196", "Rabbid Buddy", "store_buttons37", "Rabbids! Take the form of a Rabbid playing Growtopia dressup! To avoid refund fraud, this item has been made untradeable until July 5th, 2023.", 3, 6, 25000000)
			.add_gems_item("13220", "Aurora and Igniculus", "store_buttons37", "Igniculus is a whisp and a companion of Aurora in Child of Light. He is a bright blue firefly who helps Aurora on her journey.", 4, 6, 25000000)
			.add_gems_item("panda_set", "Panda Set", "store_buttons37", "Just Dance! Get dancin' on the floor with this extravagant panda!", 0, 7, 25000000)
			.add_gems_item("13190", "Dagger of Time", "store_buttons37", "More than a weapon, the Dagger of Time is the only container besides the Hourglass that is strong enough to hold the Sands of Time. Whoever wields the Dagger is granted the power to control Time, by using up the Sands within.", 1, 7, 25000000)
			.add_gems_item("13228", "Archangel Wings", "store_buttons37", "Might and Magic! Wear the wings of the Michael, the General of the Holy Falcon Empire and the most powerful archangel to ever exist! To avoid refund fraud, this item has been made untradeable until July 5th, 2023.", 2, 6, 25000000)
			.add_gems_item("13162", "Slopestyle Bike", "store_buttons37", "Riders Republic! Unbeatable for quick spins and fast tricks, the lightweight Slopestyle bike has got you covered!", 3, 7, 25000000)
			.add_gems_item("13164", "Iroquois Helmet", "store_buttons37", "Riders Republic! Perfect for high speed! Leave trails of smole behind you with the Iroquois helmet!", 4, 7, 25000000)
			.add_gems_item("dark", "Dark Assasin's Pack", "store_buttons36", "This pack contains The Brother Hood item, previously exclusive to the console versions of Growtopia. Also included are Dark Assassin's Vest, Cape, Trousers, Boots and Armguards!", 0, 3, 5000000)
			.add_gems_item("11546", "Mood Mask", "store_buttons37", "Happy? Angry? Curious? Wear this super advanced mask to tell the world how you're feeling!", 1, 6, 1000000)
			.add_gems_item("11132", "Noodle Bowl Hat", "store_buttons37", "A fine bowl of steaming hot noodles to wear on your head. Caution though, these are delicious so everyone might want a slurp from it!", 1, 0, 500000)
			.add_gems_item("11284", "Paper Wasp Pet", "store_buttons37", "Folded and creased to paper perfection. This wasp packs a very unique sting in its tail.", 0, 1, 500000)
			;
	}
	else if (tab == "tab3") {
		shop.set_description("World Buildings").enable_tabs(true)
			.add_tabs("main_menu", "Home", "interface/large/btn_shop_gtps.rttex", 0, 0)
			.add_tabs("locks_menu", "Locks And Stuff", "interface/large/btn_shop_gtps.rttex", 0, 1)
			.add_tabs("itempack_menu", "Item Packs", "interface/large/btn_shop_gtps.rttex", 1, 3)
			.add_tabs("bigitems_menu", "Awesome Items", "interface/large/btn_shop_gtps.rttex", 0, 4)
			.add_tabs("weather_menu", "Weather Machines", "interface/large/btn_shop_gtps.rttex", 0, 5)
			.add_tabs("token_menu", "Growtoken Items", "interface/large/btn_shop_gtps.rttex", 0, 2)
			.add_gems_item("world_lock", "World Lock", "store_buttons", "Become the undisputed ruler of your domain with one of these babies.  It works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.``  `wRecycles for 200 Gems.", 0, 7, 2000)
			.add_gems_item("world_lock_10_pack", "World Lock Pack", "store_buttons18", "10-pack of World Locks. Become the undisputed ruler of up to TEN kingdoms with these babies. Each works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.`` `wEach recycles for 200 Gems.", 0, 3, 20000)
			.add_gems_item("1796", "Diamond Lock", "gtps_store1", "A lock with 100 World Locks inside.", 0, 11, 200000)
			.add_gems_item("7188", "Blue Gem Lock", "gtps_store1", "A lock with 100 Diamond Locks (10,000 World Locks) inside.", 1, 11, 20000000)
			.add_gems_item("small_lock", "Small Lock", "store_buttons", "Protect up to `$10`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.", 1, 3, 50)
			.add_gems_item("big_lock", "Big Lock", "store_buttons", "Protect up to `$48`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.", 1, 1, 200)
			.add_gems_item("huge_lock", "Huge Lock", "store_buttons", "Protect up to `$200`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.", 0, 4, 500)
			.add_gems_item("builders_lock", "Builder's Lock", "store_buttons17", "Protect up to `$200`` tiles. Wrench the lock to limit it - it can either only allow building, or only allow breaking! `5It's a perma-item, is never lost when destroyed.", 0, 2, 50000)
			.add_gems_item("3898", "Telephone", "gtps_store1", "Resolve your issue with this item. You'll be able to connect to a random salesman and our Crazy Jim!", 1, 7, 100)
			.add_gems_item("rare_seed_pack", "Rare Seed Pack", "store_buttons", "You'll get 5 randomly chosen rare seeds. Expect some wondrous crops with these!", 1, 7, 1000)
			.add_gems_item("door_mover", "Door Mover", "store_buttons8", "Unsatisfied with your world's layout?  This one-use device can be used to move the White Door to any new location in your world, provided there are 2 empty spaces for it to fit in. Disappears when used. `2Only usable on a world you have World Locked.", 0, 6, 5000)
			.add_gems_item("vending_machine", "Vending Machine", "store_buttons13", "Tired of interacting with human beings? Try a Vending Machine! You can put a stack of items inside it, set a price in World Locks, and people can buy from the machine while you sit back and rake in the profits! `5It's a perma-item, is never lost when destroyed, and it is not available any other way.", 0, 6, 8000)
			.add_gems_item("2580", "Change of Address", "store_buttons12", "Don't like the name of your world? You can use up one of these to trade your world's name with the name of any other world that you own. You must have a `2World Lock`` in both worlds. Go lock up that empty world with the new name you want and swap away!", 0, 6, 20000)
			.add_gems_item("1280", "Birth Certificate", "store_buttons7", "A little white-out, a little scribbling, and voila, you'll have a new name! Use this item to change your TayoPsID permanently. Can only be used once every 30 days. Requires a TayoPsID. Is consumed when used.", 0, 6, 20000)
			.add_gems_item("digi_vend", "Digivend Machine", "store_buttons29", "Get with the times and go digital! This wired vending machine can connect its contents to Vending Hubs AND the multiversal economy, providing a unified shopping experience along with price checks to help you sell your goods! All that, and still no human-related hassle! Use your wrench on this to stock it with an item and set a price in World Locks. Other players will be able to buy from it! Only works in World-Locked worlds.", 0, 2, 12000)
			.add_gems_item("signal_jammer", "Signal Jammer", "store_buttons", "Get off the grid!Install a `$Signal Jammer``! A single punch will cause it to whir to life, tireless hiding your worldand its population from pesky snoopers - only those who know the world name will be able to enter. `5It's a perma - item, is never lost when destroyed.", 1, 6, 2000)
			.add_gems_item("punch_jammer", "Punch Jammer", "store_buttons7", "Tired of getting bashed around ? Set up a Punch Jammer in your world, and people won't be able to punch each other! Can be turned on and off as needed. `5It's a perma - item, is never lost when destroyed.", 0, 4, 15000)
			.add_gems_item("zombie_jammer", "Zombie Jammer", "store_buttons7", "Got a parkour or race that you don't want slowed down? Turn this on and nobody can be infected by zombie bites in your world. It does not prevent direct infection by the g-Virus itself though. `5It's a perma - item, is never lost when destroyed.", 0, 5, 15000)
			.add_gems_item("guardian_pineapple", "Guardian Pineapple", "h_store_buttons", "When activated(punch to activate), this jealous pineapple prevents anyone from using Consumable items in your world. `5It's a perma - item, is never lost when destroyed.", 0, 6, 250000)
			.add_gems_item("surg_blast", "Surgworld Blast", "store_buttons27", "Your gateway to a world of medical wonders! SurgWorld is a place of care and healing, with all kinds of interesting blocks, top tips on how to treat people with surgery, and an increased chance of getting maladies while you work! Also comes with 1 Caduceaxe to extract Vaccine Drops from blocks. `6Warning:`` May break when extracting vaccine.", 0, 2, 10000)
			.add_gems_item("sea_blast", "Undersea Blast", "store_buttons9", "Explore the ocean! This advanced device will terraform a new world set up like the bottom of the ocean, with a special ocean background, and special blocks like Seaweed, Coral, Jellyfish, Sharks, and maybe a special surprise... Remember, by using this you are creating a NEW world by typing in a new name. You can't convert an existing world to an ocean, that would be dangerous.", 0, 7, 15000)
			//.add_gems_item("farm_blast", "Farm Blast", "h_store_buttons", "Your gateway to a Farm World.", 0, 7, 100000)
			//.add_gems_item("1402", "Thermonuclear Blast", "store_buttons8", "This supervillainous device will blast you to a new world that has been scoured completely empty - it contains nothing but Bedrock and a White Door.Remember: When using this, you are creating a NEW world by typing in a new name.It would be irresponsible to let you blow up an entire existing world.", 0, 5, 15000)
			.add_gems_item("beach", "Beach Blast + 100 Fireworks Pack", "store_gtps", "It's hot out there! Don't you want to go to the beach ? Now you can make your own beach with a Beach Blast device and the 100 Fireworks needed to power it.The Beach Blast creates a brand new world set up as a beach, full of cool new Summer items. As a bonus, you'll get a Summer Surprise and a chance of a Ultra White Fragment or Ultra Purple Fragment too! (available during Summerfest week only!)", 2, 0, 20000)
			//.add_gems_item("5176", "Unknown Dimension Blast", "store_gtps", "July 2023: Say hi to the new blast, once you clicked it, it will create a 200x200 world in an unknown dimension and teleports you there.", 2, 1, 100000000)
			.add_gems_item("5638", "MAGPLANT 5000", "store_buttons6913", "February 2018: Tired of picking up things with your puny human hands only to put them down later? With the awesome power of MAGNETS, these woes will be a thing of the past! GrowTech inc. proudly presents the MAGPLANT 5000, an all-in-one item-collecting and planting masterpiece. Simply target the machine to the seed or block of your choosing, and it will collect and store any that drop in your world! Only collects items from breaking blocks and harvesting! It's a perma-item, is never lost when destroyed.", 0, 0, 300000, false)
			.add_gems_item("antigravity_generator", "Antigravity Generator", "store_buttons17", "Disables gravity in your world when activated!Well, it reduces gravity, and lets everybody jump as much as they want!`5It's a perma - item - never lost when destroyed!`4Not available any other way!``", 0, 3, 225000)
			.add_gems_item("building_blocks_machine", "Building Blocks Machine", "store_buttons26", "Eager to add some new building materials to your construction stockpile ? Tired of collecting them from random worlds and weirdos ? Well, pop this beauty in your worldand it'll start cranking out awesome blocks in no time! Contains the `5RARE Creepy Baby Block and Digital Dirt`` amongst a heap of other new blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch!", 0, 3, 8000)
			.add_gems_item("guild_name", "Guild Name Changer", "store_buttons23", "Tired of people making fun of your guild because of one silly spelling error ? Or maybe just looking for a change ? Use this and get a second shot at it!", 0, 6, 500000)
			.add_gems_item("grow_spray", "5-pack of Grow Spray Fertilizer", "store_buttons", "Why wait?!  Treat yourself to a `$5-pack`` of amazing `wGrow Spray Fertilizer`` by GrowTech Corp.  Each bottle instantly ages a tree by `$1 hour``.", 0, 6, 100)
			.add_gems_item("deluxe_grow_spray", "Deluxe Grow Spray", "store_buttons11", "GrowTech's new `$Deluxe`` `wGrow Spray`` instantly ages a tree by `$24 hours`` per bottle! That's somewhere around 25 times as much as regular Grow Spray!", 0, 2, 450)
			.add_gems_item("surg", "Surgical Kit", "store_buttons7", "Get all the tools you need to become Chief of Surgery at Growtopia General Hospital! `#Rare`` Heart Monitor that lets people know when you are online, Hospital Bed that lets you perform surgery on anybody laying (or standing) on it, Med-a-Checks to identify patients with maladies, The Train-E bot to practice on, and 5 each of the thirteen different Surgical Tools you'll need to do that surgery!", 0, 2, 12000)
			.add_gems_item("fishin_pack", "Fishin' Pack", "store_buttons14", "Relax and sit by the shore... this pack includes a Fishing Rod, Wiggly Worms for bait, Hand Drill, Nuclear Detonator, and a `#Rare`` Tackle Box which provides you with more free bait every two days, Fish Tanks, and a `#Rare`` Fish Tank Port to put the fish you catch into your fish tank!", 0, 0, 10000)
			//.add_gems_item("hair_dye", "Hair Dye Pack", "h_store_buttons", "Pour this gunk on your head if you want your hair to be colorful! It may require multiple applications to achieve the desired color, or mixing with other dyes. The dye interacts with your natural hair color, so some colors may simply be impossible to achieve.", 3, 5, 25000)
			.add_gems_item("geiger", "Geiger Counter", "store_buttons12", "With this fantabulous device, you can detect radiation around you. It bleeps red, then yellow, then green as you get closer to the source. Who knows what you might find? `4Not available any other way!", 0, 1, 25000)
			.add_gems_item("zombie_pack", "Zombie Defense Pack", "store_buttons4", "The zombie invasion has come! Protect yourself with all the esential zombie fighting gear and best of all, you get an Antidote to cure yourself! Also includes the deadly g-Virus itself to infect your friends with!", 0, 4, 10000)
			.add_gems_item("fossil_pack", "Paleontologist's Kit", "store_buttons16", "If you want to dig up fossils, this is the kit for you! Includes everything you need: 5 Fossil Brushes, a Rock Hammer and a Rock Chisel, a Blue Hardhat for safety, and a Rare `#Fossil Prep Station`` to get your fossils ready for display.", 0, 0, 20000)
			.add_gems_item("ssp_200_pack", "Small Seed Collection Pack", "store_buttons35", "Open each one for `$5`` randomly chosen seeds a piece, including 1 rare seed per pack! Who knows what you'll get?!", 1, 3, 10000);
	}
	else if (tab == "tab4") {
		shop.set_description("Activities").enable_tabs(true)
			.add_tabs("main_menu", "Home", "interface/large/btn_shop_gtps.rttex", 0, 0)
			.add_tabs("locks_menu", "Locks And Stuff", "interface/large/btn_shop_gtps.rttex", 0, 1)
			.add_tabs("itempack_menu", "Item Packs", "interface/large/btn_shop_gtps.rttex", 0, 3)
			.add_tabs("bigitems_menu", "Awesome Items", "interface/large/btn_shop_gtps.rttex", 1, 4)
			.add_tabs("weather_menu", "Weather Machines", "interface/large/btn_shop_gtps.rttex", 0, 5)
			.add_tabs("token_menu", "Growtoken Items", "interface/large/btn_shop_gtps.rttex", 0, 2)
			.add_banner("interface/large/gui_shop_featured_header.rttex", 0, 1)
			.add_banner("interface/large/gui_shop_featured_header.rttex", 0, 0)
			.add_big_banner("interface/large/gui_store_iap_message.rttex", "More custom item shop update soon! to purchase ranks & rare items you can type `1/shop`w!", 0, 0)
			.add_gems_item("12400", "Sage Hair", "gtps_store1", "Wanted to look cooler? Wear this hair and you'll look like sage.", 0, 0, 2000000)
			.add_gems_item("10932", "Dracula Wings", "gtps_store1", "These wings will make you look like a Dracula.", 0, 1, 10000000)
			.add_gems_item("13562", "Aqua Non La", "gtps_store1", "What a cool hat, looks like it was made from diamonds.", 0, 2, 2000000)
			.add_gems_item("13564", "Kage Non La", "gtps_store1", "What a cool hat, it turned you to a Kage.", 0, 3, 2000000)
			.add_gems_item("13566", "White Captain's Hat", "gtps_store1", "Ajojing ala ala ajojing.", 0, 4, 2000000)
			.add_gems_item("13572", "Fallen Angel-Devil Wings", "gtps_store1", "A fallen angel wing.", 0, 5, 5000000)
			.add_gems_item("9896", "Trazer's Dark Scythe", "gtps_store1", "A dark scythe.", 0, 6, 5000000)
			.add_gems_item("9830", "Chaos Sword", "gtps_store1", "A cursed sword.", 0, 7, 5000000)
			.add_gems_item("9812", "Sword of Sun", "gtps_store1", "A light sword.", 0, 8, 8000000)
			.add_gems_item("9500", "Eldritch Sword", "gtps_store1", "A blue flame sword.", 0, 9, 10000000)
			.add_gems_item("9884", "Miku's Anime Hair", "gtps_store1", "Just a normal anime hair.", 0, 10, 1000000)
			.add_gems_item("8530", "Magma Dragon's Fist", "gtps_store1", "This fist allow you to put 6 far and 1 hit punch, what a puwerful fist!.", 1, 0, 1000000000)
			.add_gems_item("10938", "Ecalipsebane Scepter", "gtps_store1", "A cursed sword.", 1, 1, 10000000)
			.add_gems_item("9150", "Predator", "gtps_store1", "Beth's Villainous greatsword.", 1, 2, 15000000)
			.add_gems_item("5160", "Deathly Scythe", "gtps_store1", "Fallen Angel's Scythe that use to take everyone souls.", 1, 3, 15000000)
			.add_gems_item("5172", "Red Demonic Blade", "gtps_store1", "A old Demon King's Blade that can give you 1 hit punch.", 1, 4, 1000000)
			.add_gems_item("5174", "Purple Demonic Blade", "gtps_store1", "A old Demon King's Blade that can give you 1 hit punch.", 1, 5, 1000000)
			.add_gems_item("10940", "Amesthyst Axe", "gtps_store1", "An Axe with unknown power.", 1, 6, 8900000)
			;
		/*
		item_add.push_back({ 12400, 2000000 });
		item_add.push_back({ 10932, 10000000 });
		item_add.push_back({ 13562, 2000000 });
		item_add.push_back({ 13564, 2000000 });
		item_add.push_back({ 13566, 2000000 });
		item_add.push_back({ 9896, 5000000 });
		item_add.push_back({ 9830, 5000000 });
		item_add.push_back({ 13572, 5000000 });
		item_add.push_back({ 9812, 8000000 });
		item_add.push_back({ 9500, 10000000 });
		item_add.push_back({ 9884, 1000000 });

		for (auto& shop : item_add) {
			if (filesystem::exists(format("database/shop/-{}.json", shop.id)))
				continue;
			// {"itemai":[[1180, 1]],"g":40000,"p":"Spiritual Resonator"}
			ofstream w_(format("database/shop/-{}.json", shop.id));
			json j;
			j["itemai"] = { {shop.id, 1} };
			j["p"] = items[shop.id].name;
			j["g"] = shop.price;
			w_ << j << endl;
			w_.close();
		}
		*/
	}
	else if (tab == "tab5") {
		shop.set_description("Creativity").enable_tabs(true)
			.add_tabs("main_menu", "Home", "interface/large/btn_shop_gtps.rttex", 0, 0)
			.add_tabs("locks_menu", "Locks And Stuff", "interface/large/btn_shop_gtps.rttex", 0, 1)
			.add_tabs("itempack_menu", "Item Packs", "interface/large/btn_shop_gtps.rttex", 0, 3)
			.add_tabs("bigitems_menu", "Awesome Items", "interface/large/btn_shop_gtps.rttex", 0, 4)
			.add_tabs("weather_menu", "Weather Machines", "interface/large/btn_shop_gtps.rttex", 1, 5)
			.add_tabs("token_menu", "Growtoken Items", "interface/large/btn_shop_gtps.rttex", 0, 2)
			//.add_gems_item("arm_guy", "Waving Inflatable Arm Guy", "store_buttons35", "Great for showing everyone all the amazing things you have to offer! Also just great fun to be around.", 1, 2, 5000)
			.raw("\nadd_button|race_pack|`oRacing Action Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 1 Racing Start Flag, 1 Racing End Flag, 2 Checkpoints, 2 Big Old Sideways Arrows, 1 Big Old Up Arrow, 1 Big Old Down Arrow, 1 WristBand, 1 HeadBand, 1 Sports Ball Jersey and 1 Air Robinsons.<CR><CR>`5Description:`` Get all you need to host races in your worlds! You'll win the races too, with new Air Robinsons that make you run faster!|0|7|1250|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|music_pack|`oComposer's Pack``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 20 Sheet Music: Blank, 20 Sheet Music: Piano Note, 20 Sheet Music: Bass Note, 20 Sheet Music Drums, 5 Sheet Music: Sharp Piano, 5 Sheet Music: Flat Piano, 5 Sheet Music: Flat Bass and 5 Sheet Music: Sharp Bass .<CR><CR>`5Description:`` With these handy blocks, you'll be able to compose your own music, using your World-Locked world as a sheet of music. Requires a World Lock (sold separately!).|0|0|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|school_pack|`oEducation Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 10 ChalkBoards, 3 School Desks, 20 Red Bricks, 1 Bulletin Board, 10 Pencils, 1 Growtopia Lunchbox, 1 Grey Hair Bun, 1 Apple and 1 Random School Uniform Item.<CR><CR>`5Description:`` If you want to build a school in Growtopia, here's what you need!|0|0|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dungeon_pack|`oDungeon Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 20 Grimstone, 20 Blackrock Wall, 20 Iron Bars, 3 Jail Doors, 3 Skeletons, 1 Headsman's Axe, 1 Worthless Rags. 5 Torches and a `#Rare Iron Mask!``.<CR><CR>`5Description:`` Lock up your enemies in a dank dungeon! Of course they can still leave whenever they want. But they won't want to, because it looks so cool! Iron Mask muffles your speech!|0|1|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fantasy_pack|`oFantasy Pack``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Mystical Wizard Hat Seed, 1 Wizards Robe, 1 Golden Sword, 1 Elvish Longbow, 10 Barrels, 3 Tavern Signs, 3 Treasure Chests and 3 Dragon Gates.<CR><CR>`5Description:`` Hear ye, hear ye! It's a pack of magical wonders!|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|vegas_pack|`oVegas Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 10 Neon Lights, 1 Card Block Seed, 1 `#Rare Pink Cadillac`` 4 Flipping Coins, 1 Dice Block, 1 Gamblers Visor, 1 Slot Machine, 1 Roulette Wheel and 1 Showgirl Hat, 1 Showgirl top and 1 Showgirl Leggins.<CR><CR>`5Description:`` What happens in Growtopia stays in Growtopia!|0|5|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|farm_pack|`oFarm Pack``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Cow, 1 Chicken, 10 Wheat, 10 Barn Block, 10 Red Wood Walls, 1 Barn Door, 1 Straw Hat, 1 Overalls, 1 Pitchfork, 1 Farmgirl Hair, 1 `#Rare`` `2Dear John Tractor``.<CR><CR>`5Description:`` Put the `2Grow`` in Growtopia with this pack, including a Cow you can milk, a Chicken that lays eggs and a farmer's outfit. Best of all? You get a `#Rare`` `2Dear John Tractor`` you can ride that will mow down trees!|0|0|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|science_pack|`oMad Science Kit``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Science Station, 1 Laboratory, 1 LabCoat, 1 Combover Hair, 1 Goggles, 5 Chemical R, 10 Chemical G, 5 Chemical Y, 5 Chemical B, 5 Chemical P and 1 `#Rare`` `2Death Ray``.<CR><CR>`5Description:`` It's SCIENCE! Defy the natural order with a Science Station that produces chemicals, a Laboratory in which to mix them and a full outfit to do so safely! You'll also get a starter pack of assorted chemicals. Mix them up! Special bonus: A `#Rare`` `2Death Ray`` to make your science truly mad!|0|3|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|city_pack|`oCity Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 10 Sidewalks, 3 Street Signs, 3 Streetlamps, 10 Gothic Building tiles, 10 Tenement Building tiles, 10 Fire Escapes, 3 Gargoyles, 10 Hedges, 1 Blue Mailbox, 1 Fire Hydrant and A `#Rare`` `2ATM Machine``.<CR><CR>`5Description:`` Life in the big city is rough but a `#Rare`` `2ATM Machine`` that dishes out gems once a day is very nice!|0|0|8000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|west_pack|`oWild West Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Cowboy Hat, 1 Cowboy Boots, 1 War Paint, 1 Face Bandana, 1 Sheriff Vest, 1 Layer Cake Dress,  1 Corset, 1 Kansas Curls, 10 Western Building 1 Saloon Doors, 5 Western Banners, 1 Buffalo, 10 Rustic Fences, 1 Campfire and 1 Parasol.<CR><CR>`5Description:`` Yippee-kai-yay! This pack includes everything you need to have wild time in the wild west! The Campfire plays cowboy music, and the `#Parasol`` lets you drift down slowly. Special bonus: A `#Rare`` `2Six Shooter`` to blast criminals with!|0|2|4000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|astro_pack|`oAstro Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Astronaut Helmet, 1 Space Suit, 1 Space Pants, 1 Moon Boots, 1 Rocket Thruster, 1 Solar Panel, 6 Space Connectors, 1 Porthole, 1 Compu Panel, 1 Forcefield and 1 `#Rare`` `2Zorbnik DNA``.<CR><CR>`5Description:`` Boldly go where no Growtopian has gone before with an entire Astronaut outfit. As a special bonus, you can have this `#Rare`` `2Zorbnik DNA`` we found on a distant planet. It doesn't do anything by itself, but by trading with your friends, you can collect 10 of them, and then... well, who knows?|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|prehistoric_pack|`oPrehistoric Pack``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Caveman Club, 1 Cave Woman Hair, 1 Caveman Hair, 1 Sabertooth Toga, 1 Fuzzy Bikini Top, 1 Fuzzy Bikni Bottom, 1 Cavewoman Outfit, 10 Cliffside, 5 Rock Platforms, 1 Cave Entrance, 3 Prehistoric Palms and 1 `#Rare Sabertooth Growtopian``.<CR><CR>`5Description:`` Travel way back in time with this pack, including full Caveman and Cavewoman outfits and `#Rare Sabertooth Growtopian`` (that's a mask of sorts). Unleash your inner monster!|0|0|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|shop_pack|`oShop Pack``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 4 Display Boxes, 1 For Sale Sign, 1 Gem Sign, 1 Exclamation Sign, 1 Shop Sign, 1 Open Sign, 1 Cash Register, 1 Mannequin and 1 Security Camera.<CR><CR>`5Description:`` Run a fancy shop with these new items! Advertise your wares with an Open/Closed Sign you can switch with a punch, a Cash Register, a Mannequin you can dress up to show off clothing, and a `#Rare`` Security Camera, which reports when people enter and take items!|0|7|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|home_pack|`oHome Pack``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Television, 4 Couches, 2 Curtains, 1 Wall Clock, 1 Microwave, 1 Meaty Apron, 1 Ducky Pants, 1 Ducky top and 1 Eggs Benedict.<CR><CR>`5Description:`` Welcome home to Growtopia! Decorate with a Television, Window Curtains, Couches, a `#Rare`` Wall Clock that actually tells time, and a Microwave to cook in. Then dress up in a Meaty Apron and Ducky Pajamas to sit down and eat Eggs Benedict, which increases the amount of XP you earn!|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cinema_pack|`oCinema Pack``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Clapboard, 1 Black Beret, 1 3D Glasses, 6 Theater Curtains, 6 Marquee Blocks, 1 Director's Chair, 4 Theater Seats, 6 Movie Screens, 1 Movie Camera and 1 `#Rare GHX Speaker``.<CR><CR>`5Description:`` It's movie time! Everything you need for the big screen experience including a `#Rare GHX Speaker`` that plays the score from Growtopia: The Movie.|0|2|3000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|adventure_pack|`oAdventure Pack``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 4 Gateways to Adventure, 4 Path Markers, 1 Lazy Cobra, 1 Adventure Brazier, 4 Adventure Barriers, 1 Rope, 1 Torch, 1 Key, 1 Golden Idol, 1 `#Rare Adventuring Mustache``, 1 Explorer's Ponytail and 1 Sling Bag .<CR><CR>`5Description:`` Join Dr. Exploro and her father (also technically Dr. Exploro) as they seek out adventure! You can make your own adventure maps with the tools in this pack.|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rockin_pack|`oRockin' Pack``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 3 `#Rare Musical Instruments`` Including A Keytar, a Bass Guitar and Tambourine, 1 Starchild Make Up, 1 Rockin' Headband, 1 Leopard Leggings, 1 Shredded Ts-Shirt, 1 Drumkit, 6 Stage Supports, 6 Mega Rock Speakers and 6 Rock n' Roll Wallpaper.<CR><CR>`5Description:`` ROCK N' ROLL!!! Play live music in-game! We Formed a Band! Growtopia makes me want to rock out.|0|0|5000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|game_pack|`oGame Pack``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 `#Rare Game Generator``,  4 Game Blocks, 4 Game Flags, 4 Game Graves and 4 Game Goals.<CR><CR>`5Description:`` Growtopia's not all trading and socializing! Create games for your friends with the Game Pack (and a lot of elbow grease).|0|6|50000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|superhero|`oSuperhero Pack``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Mask, 1 Shirt, 1 Boots, 1 Tights, 1 Cape, `#Rare Super Logos`` or `#Rare Utility Belt`` and 1 `2Phone Booth``.<CR><CR>`5Description:`` Battle the criminal element in Growtopia with a complete random superhero outfit including a cape that lets you double jump. Each of these items comes in one of six random colors. You also get one of 5 `#Rare`` Super Logos, which automatically match the color of any shirt you wear or a `#Rare`` Utility Belt... of course use the `2Phone Booth`` to change into your secret identity!|0|0|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fashion_pack|`oFashion Pack``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 3 Random Clothing Items, 3 Jade Blocks and 1 `#Rare Spotlight``.<CR><CR>`5Description:`` The hottest new looks for the season are here now with 3 random Fashion Clothing (dress, shoes, or purse), Jade Blocks to pose on, and a `#Rare`` Spotlight to shine on your fabulousness.|0|0|3000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|sportsball_pack|`oSportsball Pack``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 2 Basketball Hoops, 2 Sporty Goals, 5 Stadiums, 5 Crowded Stadiums, 10 Field Grass, 1 Football Helmet, 1 Growies Cap, 1 Ref's Jersey, 1 World Cup Jersey, 1 `#Rare Sports Item`` or `#Rare Growmoji!``.<CR><CR>`5Description:`` We like sports and we don't care who knows! This pack includes everything you need to get sporty! Use the Sports Items to launch Sportsballs at each other.|0|1|10000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|firefighter|`oFirefighter Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Yellow Helmet, 1 Yellow Jacket, 1 Yellow Pants, 1 Firemans Boots, 1 Fire Hose, and 1 `#Rare Firehouse`` .<CR><CR>`5Description:`` Rescue Growtopians from the fire! Includes a full Yellow Firefighter Outfit, Fire Hose and a `#Rare Firehouse``, which will protect your own world from fires.|0|1|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|steampack|`oSteampack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 10 Steam Tubes, 2 Steam Stompers, 2 Steam Organs, 2 Steam Vents, 2 Steam Valves and 1 `#Rare Steampunk Top Hat``.<CR><CR>`5Description:`` Steam! It's a wondrous new technology that lets you create paths of Steam Blocks, then jump on a Steam Stomper to launch a jet of steam through the path, triggering steam-powered devices. Build puzzles, songs, parkour challenges, and more!|0|6|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|paintbrush|`oPainter's Pack``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 `#Rare Paintbrush`` and 20 Random Colored Paint Buckets.<CR><CR>`5Description:`` Want to paint your world? This pack includes 20 buckets of random paint colors (may include Varnish, to clean up your messes)! You can paint any block in your world different colors to personalize it.|0|1|15000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|paleo_kit|`oPaleontologist's Kit``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 5 Fossil Brushes, 1 Rock Hammer, 1 Rock Chisel, 1 Blue Hardhat and 1 `#Rare Fossil Prep Station``.<CR><CR>`5Description:`` If you want to dig up fossils, this is the kit for you! Includes everything you need! Use the prepstation to get your fossils ready for display.|0|0|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|robot_starter_pack|`oCyBlocks Starter Pack``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 `5Rare ShockBot`` and 10 random movement commands.<CR><CR>`5Description:`` CyBlocks Starter Pack includes one `5Rare`` ShockBot and 10 random movement commands to use with it. `5ShockBot`` is a perma-item, is never lost when destroyed.|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|robot_command_pack|`oCyBlocks Command Pack``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 10 Random CyBlock Commands.<CR><CR>`5Description:`` Grants 10 random CyBlock Commands to help control your CyBots!|0|2|1000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|robot_pack|`oCyBot Pack``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 1 `5Rare CyBot``!<CR><CR>`5Description:`` Grants one random `5Rare`` CyBot! Use CyBlock Commands to send these mechanical monsters into action! `5Note: Each CyBot is a perma-item, and will never be lost when destroyed.``|0|3|7500|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|gang_pack|`oGangland Style``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 1 Fedora, 1 Dames Fedora, 1 Pinstripe Suit with Pants, 1 Flapper Headband with Dress, 1 Cigar, 1 Tommy Gun, 1 Victola and 10 Art Deco Blocks .<CR><CR>`5Description:`` Step into the 1920's with a Complete Outfit, a Tommygun, a Victrola that plays jazz music, and 10 Art Deco Blocks. It's the whole package!|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0\nadd_button|harvest_pack|`oHarvest Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 00A Harvest Moon Blast.<CR><CR>`5Description:`` Celebrate the harvest with a new `2Harvest Moon Blast`` to create a world with a unique harvest moon sky, filled with random trees that are fully grown and ready to harvest!``)|0|4|1000000|0|||-1|-1||-1|-1||1||||||0|0|\n|0|0|\n");
	}
	else if (tab == "tab6") {
		shop.set_description("Growtokens").enable_tabs(true)
			.add_tabs("main_menu", "Home", "interface/large/btn_shop_gtps.rttex", 0, 0)
			.add_tabs("locks_menu", "Locks And Stuff", "interface/large/btn_shop_gtps.rttex", 0, 1)
			.add_tabs("itempack_menu", "Item Packs", "interface/large/btn_shop_gtps.rttex", 0, 3)
			.add_tabs("bigitems_menu", "Awesome Items", "interface/large/btn_shop_gtps.rttex", 0, 4)
			.add_tabs("weather_menu", "Weather Machines", "interface/large/btn_shop_gtps.rttex", 0, 5)
			.add_tabs("token_menu", "Growtoken Items", "interface/large/btn_shop_gtps.rttex", 1, 2)
			.raw("\nadd_button|xp_potion|`oExperience Potion``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Experience Potion.<CR><CR>`5Description:`` This `#Untradeable`` delicious fizzy drink will make you smarter! 10,000 XP smarter instantly, to be exact.|0|2|-5|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|megaphone|`oMegaphone``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Megaphone.<CR><CR>`5Description:`` You like broadcasting messages, but you're not so big on spending gems? Buy a Megaphone with Growtokens! Each Megaphone can be used once to send a super broadcast to all players in the game.|0|7|-1|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|i_love_dirt_shirt|`oI love Dirt Shirt``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 I love Dirt Shirt.<CR><CR>`5Description:`` Some people like things to be clean, you're not one of them are you? This item is `#Untradeable``.|4|0|-5|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|mini_mod|`oMini-Mod``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Mini-Mod.<CR><CR>`5Description:`` Oh no, it's a Mini-Mod! Punch him to activate (you'll want to punch him!). When activated, he won't allow anyone to drop items in your world.|0|0|-10|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|derpy_star|`oDerpy Star Block``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Derpy Star Block.<CR><CR>`5Description:`` DER IM A SUPERSTAR. This is a fairly ordinary block, except for the derpy star on it. Note: it is not permanent, and it doesn't drop seeds. So use it wisely!|0|3|-15|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|2218|`oMighty Snow Rod``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Mighty Snow Rod.<CR><CR>`5Description:`` Become the living embodiment of the winter with this deadly weapon! It blasts bricks with frost, smashing them more easily than a punch. Buy it today, before WinterFest ends and you can't get it for another year! Sponsored by iiStyloMilo, Bambam46, and MartinMan007's Subscribers.|0|4|-15|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dirt_gun|`oBLYoshi's Free Dirt``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 BLYoshi's Free Dirt.<CR><CR>`5Description:`` \"Free\" might be stretching it, but hey, once you buy this deadly rifle, you can spew out all the dirt you want for free! Note: the dirt is launched at high velocity and explodes on impact. Sponsored by BLYoshi.|0|4|-20|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|nothingness|`oWeather Machine - Nothingness``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Weather Machine - Nothingness.<CR><CR>`5Description:`` Tired of all that fancy weather?  This machine will turn your world completely black. Yup, that's it. Not a single pixel in the background except pure blackness.|0|3|-25|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|doodad|`oDoodad``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Doodad.<CR><CR>`5Description:`` I have no idea what this thing does. It's something electronic? Maybe?|0|5|-30|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|crystal_cape|`oCrystal Cape``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Crystal Cape.<CR><CR>`5Description:`` This cape is woven of pure crystal, which makes it pretty uncomfortable. But it also makes it magical! It lets you double-jump off of an imaginary Crystal Block in mid-air. Sponsored by Edvoid20, HemeTems, and Aboge.|0|5|-45|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|focused_eyes|`oFocused Eyes``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Focused Eyes.<CR><CR>`5Description:`` This `#Untradeable`` item lets you shoot electricity from your eyes! Wear them with pride, and creepiness.|0|4|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|grip_tape|`oGrip Tape``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Grip Tape.<CR><CR>`5Description:`` This is handy for wrapping around the handle of a weapon or tool. It can improve your grip, as well as protect you from cold metal handles. If you aren't planning to craft a weapon that requires Grip Tape, this does you no good at all!|0|5|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cat_eyes|`oCat Eyes``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Cat Eyes.<CR><CR>`5Description:`` Wow, pawesome! These new eyes are the cat's meow, and the purrfect addition to any style.|0|5|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|riding_cloud|`oRiding Cloud``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Riding Cloud.<CR><CR>`5Description:`` Bringing the sky to the ground! This item is `#Untradeable``.|3|1|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|grow_boy|`oGrowBoy``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Growboy.<CR><CR>`5Description:`` Bask in the nostalgic green screened goodness of the Growboy! A portable gaming device that packs a punch. Now you're playing with GrowPower! Note: The Growboy is `#UNTRADEABLE``.|0|2|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|night_vision|`oNight Vision Goggles``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Night Vision Goggles.<CR><CR>`5Description:`` Scared of the dark? We have a solution. You can wear these goggles just to look cool, but if you also happen to have a D Battery (`4batteries not included``) on you, you will be able to see through darkness like it's not even there! Each D Battery can power your goggles for 1 minute. `2If you are in a world you own, the goggles will not require batteries!`` Note: you can't turn the goggles off without removing them, so you'll be wasting your battery if you wear them in daylight while carrying D Batteries.|0|3|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|muddy_pants|`oMuddy Pants``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Muddy Pants.<CR><CR>`5Description:`` Well, this is just a pair of muddy pants. But it does come with a super secret bonus surprise that is sure to blow your mind!|0|7|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|piranha|`oCuddly Piranha``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Cuddly Piranha.<CR><CR>`5Description:`` This friendly pet piranha won't stay in its bowl!  It just wants to snuggle with your face!|0|0|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|tsed|`oTactical Stealth Espionage Device``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Tactical Stealth Espionage Device.<CR><CR>`5Description:`` This is Growtech's latest innovation on tactical espionage! Using the latest in scientific breakthroughs this device allows you to seamlessly disguise yourself as... a cardboard box! Note: The Tactical Stealth Espionage Device is `#UNTRADEABLE``.|0|1|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|puddy_leash|`oPuddy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puddy Leash.<CR><CR>`5Description:`` Puddy is a friendly little kitten who will follow you around forever.|0|7|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|anime_action_hair|`oAnime Action Hair``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Anime Action Hair.<CR><CR>`5Description:`` Lights, camera, ANIME ACTION HAIR! Feel the power from root to tip every time you punch! This item is `#Untradeable``.|4|1|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|golden_axe|`oGolden Pickaxe``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Golden Pickaxe.<CR><CR>`5Description:`` Get your own sparkly pickaxe! This `#Untradeable`` item is a status symbol! Oh sure, it isn't any more effective than a normal pickaxe, but it sparkles!|0|1|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|puppy_leash|`oPuppy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puppy Leash.<CR><CR>`5Description:`` Get your own pet puppy! This little dog will follow you around forever, never wavering in her loyalty, thus making her `#Untradeable``.|0|4|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|meow_ears|`oMeow Ears``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Meow Ears.<CR><CR>`5Description:`` Meow's super special ears that everyone can now get! Note: These ears are `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|frosty_hair|`oFrosty Hair``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Frosty Hair.<CR><CR>`5Description:`` Coldplay is cold, but you can be freezing! Note: The frosty hair is `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zerkon_helmet|`oEvil Space Helmet``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Evil Space Helmet.<CR><CR>`5Description:`` Zerkon commands a starship too small to actually board - pah, time to rule the galaxy properly! Note: The evil space helmet is `#UNTRADEABLE``.|0|6|-200|0|||-1|-1||-1|-1||1||||||0|0|"
				"\nadd_button|burning_face|`oBurning Face``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Burning Face.<CR><CR>`5Description:`` Eldritch has a burning sensation. Note: The burning face is `#UNTRADEABLE``.|0|4|-200|0|||-1|-1||-1|-1||1||||||0|0|"
				//"\nadd_button|dark_cult_hood|`oDark Cult Hood``|interface/large/store_buttons/h_store_buttons.rttex|`2You Get:`` 1 Dark Cult Hood.<CR><CR>`5Description:`` When you reach level 7 in the cult, like Jairrocket, your eyes get glowy. Note: The dark cult hood is `#UNTRADEABLE``.|0|5|-200|0|||-1|-1||-1|-1||1||||||0|0|"
				"\nadd_button|seils_magic_orb|`oSeil's Magic Orbs``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Seil's Magic Orbs.<CR><CR>`5Description:`` Seil is some kind of evil wizard, now you can be too! Note: These magic orbs are `#UNTRADEABLE``.|0|7|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|atomic_shadow_scythe|`oAtomic Shadow Scythe``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Atomic Shadow Scythe.<CR><CR>`5Description:`` AtomicShadow might actually be evil, now you can try it out! Note: The shadow scythe is `#UNTRADEABLE``.|0|5|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|poseidon_diggers_trident|`oPoseidon's Digger's Trident``|interface/large/store_buttons/store_buttons25.rttex|`2You Get:`` 1 Poseidon's Digger's Trident.<CR><CR>`5Description:`` A gift from the gods. This may appear to be a humble trident, but in fact it has the power of Poseidon himself. It can smash `8Deep Sand`` or `8Ocean Rock`` in a single hit. Unfortunately, you don't get to wield the full might of Poseidon... the trident is worthless at smashing anything else. Note: The trident is `#UNTRADEABLE``.|0|6|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|really_dangerous_pet_llama|`oReally Dangerous Pet Llama``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Really Dangerous Pet Llama.<CR><CR>`5Description:`` This Llama is ready for anything Growtopia throws at it! Armed with a silo of Growtech Missiles, experimental Growtech hardened steel armor and a rather snazzy helmet (Llama's own) this Llama is Dangerous with a capital D! Note: This Really Dangerous Pet Llama is `#UNTRADEABLE``.|0|0|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|leopard_shawl|`oSnow Leopard Shawl``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Snow Leopard Shawl.<CR><CR>`5Description:`` Made of the finest Faux Snow Leopard Fur. This Shawl is infused with the spirit of a mighty Snow Leopard!|1|4|-100|0|||-1|-1||-1|-1||1||||||0|0|\n|0|0|\n");
	}
	enet_peer_send(peer, 0, Variant{ "OnStoreRequest" }.push(shop.to_string()).pack());
}

void save_player(Player*, bool);
void world_menu(ENetPeer* peer) {
	long long time_now = time(nullptr);
	string WOTW = "";
	ifstream getWOTW("wotw.txt");
	if (getWOTW.is_open()) {
		getline(getWOTW, WOTW);
	}
	getWOTW.close();
	if (WOTW.empty()) WOTW = "START";
	if (last_active_update - time_now <= 0 or active_worlds.size() == 0) {
		if (worlds.size() > 0) {
			last_active_update = time_now + 60;
			active_worlds.clear();
			for (int i_ = 0; i_ < worlds.size(); i_++) {
				World world_ = worlds[i_];
				int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
				get_players(world_.name, w_c, s_c, net_, r_c);
				if (w_c == 0) continue;
				if (world_.nuked or not check_name(world_.name)) continue;
				if (find(active_worlds.begin(), active_worlds.end(), world_.name) == active_worlds.end()) 
					active_worlds.push_back(world_.name);
			}
		}
	}
	string recently_visited = "", featured_worlds = "", c_active_worlds = "\nadd_floater|" + WOTW + "|Ļ WOTW|0|0.5|3529161471";
	{
		int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
		get_players("LOCKE", w_c, s_c, net_, r_c);
		c_active_worlds += "\nadd_floater|LOCKE|LOCKE|" + to_string(w_c) + "|0.5|3529161471";
	}
	for (auto it = pInfo(peer)->last_visited_worlds.rbegin(); it != pInfo(peer)->last_visited_worlds.rend(); ++it) 
		recently_visited += "\nadd_floater|" + *it + "||0.5|3417414143";
	// Active Worlds
	for (int i_ = 0; i_ < active_worlds.size(); i_++) {
		string name_ = active_worlds[i_];
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) {
				int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
				get_players(active_worlds[i_], w_c, s_c, net_, r_c);
				c_active_worlds += "\nadd_floater|" + active_worlds[i_] + "|" + active_worlds[i_] + "|" + to_string(w_c) + "|0.512250|" + (world_->verified ? "970467" : "3529161471");
			}
		}
	}
	if (c_active_worlds.empty()) c_active_worlds += "\nadd_floater|START|START|0|0.5|3529161471";
	c_active_worlds += pInfo(peer)->worlds_owned.size() != 0 ? "\nadd_heading|My Worlds<CR>|" : "";
	for (int w_ = 0; w_ < pInfo(peer)->worlds_owned.size(); w_++) {
		int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
		get_players(pInfo(peer)->worlds_owned[w_], w_c, s_c, net_, r_c);
		c_active_worlds += "\nadd_floater|" + pInfo(peer)->worlds_owned[w_] + "|" + pInfo(peer)->worlds_owned[w_] + "|" + to_string(w_c) + "|0.5|2147418367";
	}
	int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
	get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
	gamepacket_t p;
	p.Insert("OnRequestWorldSelectMenu"), p.Insert("add_filter|\nadd_heading|Top Worlds<CR>|" + c_active_worlds + "" + (recently_visited != "" ? "\nadd_heading|Recently Visited Worlds<CR>|" + recently_visited + "" : "") + "\n"), p.CreatePacket(peer);
	gamepacket_t p5;
	string OnlineCount = "";
	OnlineCount = setGems(s_c);
	ofstream w_("online.txt");
	if (w_.fail()) {
		cout << "Failed to read online.txt" << endl;
		return;
	}
	w_ << OnlineCount << endl;
	w_.close();
	p5.Insert("OnConsoleMessage"), p5.Insert("Where would you like to go? (`w" + setGems(s_c) + "`` online)"), p5.CreatePacket(peer);
}

string cleanup_(string strText) {
	string temp = "";
	for (int i = 0; i < strText.size(); ++i) {
		if ((strText[i] >= 'a' && strText[i] <= 'z') || (strText[i] >= 'A' && strText[i] <= 'Z')) {
			temp = temp + strText[i];
		}
		else {
			temp = temp + " ";
		}
	}
	return temp;
}
bool has_playmod(Player* p_, string name_) {
	name_ = replace_str2(cleanup_(to_lower(name_)), " ", "_");
	vector<string> player_playmods{};
	player_playmods.push_back(items[p_->hair].playmod);
	player_playmods.push_back(items[p_->shirt].playmod);
	player_playmods.push_back(items[p_->pants].playmod);
	player_playmods.push_back(items[p_->feet].playmod);
	player_playmods.push_back(items[p_->face].playmod);
	player_playmods.push_back(items[p_->hand].playmod);
	player_playmods.push_back(items[p_->back].playmod);
	player_playmods.push_back(items[p_->mask].playmod);
	player_playmods.push_back(items[p_->necklace].playmod);
	player_playmods.push_back(items[p_->ances].playmod);
	if (p_->ghost) player_playmods.push_back("Ghost in the Shell");
	if (p_->Cheat_AB) player_playmods.push_back("Cheat Active: Antibounce");
	if (p_->Cheat_AF) player_playmods.push_back("Cheat Active: Auto Farm");
	if (p_->Cheat_Speed) player_playmods.push_back("Cheat Active: Super Speed");
	if (p_->Cheat_Jump) player_playmods.push_back("Cheat Active: Super Jump");
	if (p_->Cheat_FastPull) player_playmods.push_back("Cheat Active: Fast Pull");
	if (p_->Cheat_FastDrop) player_playmods.push_back("Cheat Active: Fast Drop");
	if (p_->Cheat_FastTrash) player_playmods.push_back("Cheat Active: Fast Trash");
	if (p_->Cheat_AutoCollect) player_playmods.push_back("Cheat Active: Auto Collect");
	if (p_->Cheat_FastSpin) player_playmods.push_back("Cheat Active: Fast Spin");
	//if (p_->Cheat_Spam) player_playmods.push_back("Cheat Active: Auto Spam");
	if (p_->wolf_world) player_playmods.push_back("Howlin' Mad");
	if (p_->b_s != 0) player_playmods.push_back("Duct Tape");
	for (int i_ = 0; i_ < player_playmods.size(); i_++) {
		if (player_playmods[i_].empty()) continue;
		string playmod = replace_str2(cleanup_(to_lower(player_playmods[i_])), " ", "_");
		if (playmod.find(name_) != string::npos)
			return true;
	}
	for (PlayMods peer_playmod : p_->playmods) {
		Playmod playmod = info_about_playmods[peer_playmod.id];
		string playmod_name = replace_str2(cleanup_(to_lower(playmod.name)), " ", "_");
		//cout << "playmod data of has_playmod: \n";
		//print_info_pmod(playmod);
		if (playmod_name.find(name_) != string::npos) {
			return true;
		}
	}
	return false;
}
int form_state(Player* p_) {
	int state_ = 0;
	try {
		string name_ = p_->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (!world_->X_2) state_ |= (world_->X_1 || has_playmod(p_, "double jump") || has_playmod(p_, "hoveration!") || has_playmod(p_, "Spirit Form") || has_playmod(p_, "aurora") || has_playmod(p_, "Jump: Enchantment") || has_playmod(p_, "Flame On") and !world_->X_2) << 1;
			state_ |= has_playmod(p_, "Ghost in the Shell") << 0;
			state_ |= has_playmod(p_, "The One Ring") << 2;
			state_ |= has_playmod(p_, "Mark of Growganoth") << 4;
			state_ |= has_playmod(p_, "Halo!") << 7;
			state_ |= has_playmod(p_, "Cheat Active: Antibounce") << 9;
			state_ |= has_playmod(p_, "Cheat Active: Antibounce") << 10;
			// Kebal Lava 9
			// Kebal Spike 10
			// Freeze 11
			state_ |= has_playmod(p_, "Go to HELL!!") << 12;
			state_ |= has_playmod(p_, "duct tape") << 13;
			// coffe 14
			state_ |= has_playmod(p_, "Lucky") << 15;
			// zombie 16
			// on fire (cabe) 17
			// berbayang 18
			state_ |= has_playmod(p_, "Irradiated") << 19;
			state_ |= p_->spotlight << 20;
			// pine flag + color 21
			// pine flag 22
			state_ |= p_->hs << 24;
			// Super Pineaple Magic 25
			// Ballon Replent 26
			// Dry basah kena air 27
			// Neon Gum 28-31
			if (world_->X_1 || has_playmod(p_, "double jump") || has_playmod(p_, "hoveration!") || has_playmod(p_, "Spirit Form") || has_playmod(p_, "aurora") || has_playmod(p_, "Jump: Enchantment") || has_playmod(p_, "Flame On") and !world_->X_2) p_->Double_Jump = true;
			if (has_playmod(p_, "Lupus")) p_->surgery_type = 28;
			if (has_playmod(p_, "Moldy Guts")) p_->surgery_type = 25;
			if (has_playmod(p_, "Ecto-Bones")) p_->surgery_type = 24;
			if (has_playmod(p_, "Chaos Infection")) p_->surgery_type = 27;
			if (has_playmod(p_, "Fatty Liver")) p_->surgery_type = 26;
			if (has_playmod(p_, "Brainworms")) p_->surgery_type = 23;
			if (has_playmod(p_, "Antidote!")) {
				for (int i_ = 0; i_ < p_->playmods.size(); i_++) {
					if (p_->playmods[i_].id == 41 || p_->playmods[i_].id == 49 || p_->playmods[i_].id == 48 || p_->playmods[i_].id == 71 || p_->playmods[i_].id == 72 || p_->playmods[i_].id == 73 || p_->playmods[i_].id == 4 || p_->playmods[i_].id == 16 || p_->playmods[i_].id == 17 || p_->playmods[i_].id == 19 || p_->playmods[i_].id == 27 || p_->playmods[i_].id == 42) p_->playmods[i_].time = 1;
				}
			}
			for (PlayMods peer_playmod : p_->playmods) {
				if (info_about_playmods.find(peer_playmod.id) != info_about_playmods.end())
				{
					Playmod playmod = info_about_playmods[peer_playmod.id];
					int special_id = playmod.state;
					//cout << "Playmod info of form_state:\n";
					//print_info_pmod(playmod);
					if (special_id != 0) {
						state_ |= true << special_id;
					}
				}
			}
		}
	}
	catch (out_of_range) {
		return false;
	}
	return state_;
}
string process_till(std::string const& s)
{
	std::string::size_type pos = s.find('/');
	if (pos != std::string::npos)
	{
		return s.substr(0, pos);
	}
	else
	{
		return s;
	}
}
int form_type_player(Player* p_) {
	int state_ = 0;
	state_ |= has_playmod(p_, "Red Winterfest Crown!") << 0;
	state_ |= has_playmod(p_, "Green Winterfest Crown!") << 1;
	state_ |= has_playmod(p_, "Silver Winterfest Crown!") << 2;
	state_ |= has_playmod(p_, "Gold Winterfest Crown!") << 3;
	if (p_->mask == 5712) state_ |= 1 << p_->wild;
	if (p_->feet == 10044) state_ |= 1 << p_->golem;
	if (p_->hand == 6028) state_ |= 1 << 10;
	if (p_->necklace == 6120) state_ |= 1 << 12;
	if (p_->hand == 6262) state_ |= 1 << 13;
	// 20 Erl Healing Rune
	if (p_->shirt == 7584) state_ |= 1 << (21 + (p_->sprite == 0 ? 1 : p_->sprite));
	return state_;
}
void update_clothes(ENetPeer* peer) {
	if (pInfo(peer)->world == "") return;
	try {
		if (!pInfo(peer)->fixrw) pInfo(peer)->fixrw = true, pInfo(peer)->Wing_Value = 104912, pInfo(peer)->Wing_Color_0_Value = 3356909055, pInfo(peer)->Wing_Metal_0_Value = 4282965247, pInfo(peer)->Wing_Color_1_Value = 723421695, pInfo(peer)->Wing_Metal_1_Value = 1059267327;
		string name_ = pInfo(peer)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			gamepacket_t p(0, pInfo(peer)->netID);
			{
				p.Insert("OnSetClothing");
				p.Insert((float)pInfo(peer)->hair, (float)pInfo(peer)->shirt, (float)pInfo(peer)->pants); // hair shirt pants
				p.Insert((float)pInfo(peer)->feet, (pInfo(peer)->hideseek.Hiders ? (float)pInfo(peer)->hideseek.playerBlock : (float)pInfo(peer)->face), (float)pInfo(peer)->hand); // feet face hand
				p.Insert((float)pInfo(peer)->back, (float)pInfo(peer)->mask, (float)pInfo(peer)->necklace); // back mask neck

				bool set_skin = false;
				for (PlayMods peer_playmod : pInfo(peer)->playmods) {
					if (set_skin) break;
					Playmod playmod = info_about_playmods[peer_playmod.id];
					string special_id = playmod.skin;
					//cout << "playmod data of update_clothes: \n";
					//print_info_pmod(playmod);
					if (not special_id.empty()) {
						char* endptr = NULL;
						unsigned int skin_ = strtoll(special_id.c_str(), &endptr, 10);
						p.Insert((pInfo(peer)->ghost ? -2450 : skin_));
						set_skin = true;
					}
				} if (not set_skin) {
					p.Insert((pInfo(peer)->ghost ? -2450 : (has_playmod(pInfo(peer), "ninja stealth") ? 1684300950 : pInfo(peer)->skin))); // 1684300950
				}
				p.Insert((float)pInfo(peer)->ances, 0, 0);
				PlayerMoving data{
					pInfo(peer)->netID,
					0,
					0x14,
					0,
					form_state(pInfo(peer)),
					0,
					0,
					0,
					1200,
					(has_playmod(pInfo(peer), "cupid's firepower") ? float(-300) : (has_playmod(pInfo(peer), "fists o' fury") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Cloak of Falling Waters") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Punch Power") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Heavenly") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Marshmallow Strike") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Legendary!") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Party Blaster") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Wheelin' n' Dealin") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Phase Blaster") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Wizardly Force") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Dragondead") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Ring of Force") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Protected") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Demon Control") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Fire Hose") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Deadly") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Frankenpunch") and !world_->X_8 ? 500 : (has_playmod(pInfo(peer), "Dragonborn") and !world_->X_8 ? 500 : (world_->X_7 ? 500 : (has_playmod(pInfo(peer), "devouring souls") ? -300 : 200))))))))))))))))))))),
					(world_->X_11 and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Cheat Active: Super Speed") and !world_->X_12 ? float(700) : (has_playmod(pInfo(peer), "speedy") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Sparkling for battle!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Saddled Up!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "MAGnificent!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Pine-ch Buggy") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Smoog") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Tank Driver") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Infinite") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Raptor Legs") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Chaos Corruption!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Legendary!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Neon Nerves") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "putt putt putt") ? 150 : (has_playmod(pInfo(peer), "fleet of foot") and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Infected!") ? float(150) : 250))))))))))))))))),
					(has_playmod(pInfo(peer), "Cheat Active: Super Jump") ? float(600) : has_playmod(pInfo(peer), "Floating!") ? -30 : (has_playmod(pInfo(peer), "high jump") and !world_->X_4 or world_->X_3 ? float(700) : 1000))
				};
				pInfo(peer)->High_Jump = (has_playmod(pInfo(peer), "Floating!") ? true : (has_playmod(pInfo(peer), "high jump") and !world_->X_4 or world_->X_3 ? true : false));
				pInfo(peer)->Punch_Power = (has_playmod(pInfo(peer), "fists o' fury") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Cloak of Falling Waters") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Punch Power") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Heavenly") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Marshmallow Strike") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Legendary!") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Party Blaster") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Wheelin' n' Dealin") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Phase Blaster") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Wizardly Force") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Dragondead") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Ring of Force") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Protected") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Demon Control") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Fire Hose") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Deadly") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Frankenpunch") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "Dragonborn") and !world_->X_8 ? true : (world_->X_7 ? true : false)))))))))))))))))));
				pInfo(peer)->Punch_Range = (world_->X_9 || has_playmod(pInfo(peer), "punch range") || has_playmod(pInfo(peer), "Cloak of Falling Waters") || has_playmod(pInfo(peer), "Acorns!") || has_playmod(pInfo(peer), "Burning Eyes") || has_playmod(pInfo(peer), "Eye Beam") || has_playmod(pInfo(peer), "Whipped Up") || has_playmod(pInfo(peer), "Pumpkin Smashing") || has_playmod(pInfo(peer), "Fishy") || has_playmod(pInfo(peer), "Cool") || has_playmod(pInfo(peer), "Demonic Force") || has_playmod(pInfo(peer), "Dragon Knight's Spear") || has_playmod(pInfo(peer), "Legendary!") || has_playmod(pInfo(peer), "Electric Arrows") || has_playmod(pInfo(peer), "Fire Hose") || has_playmod(pInfo(peer), "Cupid's Firepower") || has_playmod(pInfo(peer), "Flaming Arrows") || has_playmod(pInfo(peer), "Legendary Swordmaster") || has_playmod(pInfo(peer), "Flame On!") || has_playmod(pInfo(peer), "Fiery Pet") || has_playmod(pInfo(peer), "Super-Duper Pineapple Power!") || has_playmod(pInfo(peer), "Poseidon's Power") || has_playmod(pInfo(peer), "Silver Shimmer Bow") || has_playmod(pInfo(peer), "Devouring Souls") || has_playmod(pInfo(peer), "Sharing Flowers") || has_playmod(pInfo(peer), "Squirt Gun") || has_playmod(pInfo(peer), "Throwing Spear") || has_playmod(pInfo(peer), "Winter Frost Bow") || has_playmod(pInfo(peer), "Yo!") || pInfo(peer)->hand == 11094 || pInfo(peer)->hand == 9800 and !world_->X_10 ? true : false);
				pInfo(peer)->Speedy = (world_->X_11 and !world_->X_12 ? true : (has_playmod(pInfo(peer), "speedy") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Sparkling for battle!") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Saddled Up!") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "MAGnificent!") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Pine-ch Buggy") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Smoog") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Tank Driver") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Infinite") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Raptor Legs") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Chaos Corruption!") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Legendary!") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "Neon Nerves") and !world_->X_12 ? true : (has_playmod(pInfo(peer), "fleet of foot") and !world_->X_12 ? true : false))))))))))))));
				pInfo(peer)->Build_Range = (world_->X_13 and !world_->X_14 ? true : (has_playmod(pInfo(peer), "build range") and !world_->X_8 ? true : (has_playmod(pInfo(peer), "build range") and !world_->X_14 ? true : (has_playmod(pInfo(peer), "energized horn") || pInfo(peer)->hand == 9758 || pInfo(peer)->hand == 11094 and !world_->X_14 ? true : false))));
				pInfo(peer)->Speedy_In_Water = world_->X_15 || has_playmod(pInfo(peer), "I'm On A Shark!") || has_playmod(pInfo(peer), "Speedy in Water") || has_playmod(pInfo(peer), "XP Buff: Wolf Worlds") || has_playmod(pInfo(peer), "A Little Fishy") || has_playmod(pInfo(peer), "Will of the Wild") and pInfo(peer)->wild == 8 || has_playmod(pInfo(peer), "Slightly Damp") and !world_->X_16 ? true : false;
				BYTE* raw = packPlayerMoving(&data);
				int e_ = 8421376 + (items[pInfo(peer)->hand].effect != 0 ? items[pInfo(peer)->hand].effect : items[pInfo(peer)->necklace].effect != 0 ? items[pInfo(peer)->necklace].effect : items[pInfo(peer)->back].effect != 0 ? items[pInfo(peer)->back].effect : items[pInfo(peer)->face].effect != 0 ? items[pInfo(peer)->face].effect : items[pInfo(peer)->mask].effect != 0 ? items[pInfo(peer)->mask].effect : items[pInfo(peer)->hair].effect != 0 ? items[pInfo(peer)->hair].effect : items[pInfo(peer)->feet].effect != 0 ? items[pInfo(peer)->feet].effect : items[pInfo(peer)->shirt].effect != 0 ? items[pInfo(peer)->shirt].effect : items[pInfo(peer)->pants].effect != 0 ? items[pInfo(peer)->pants].effect : items[pInfo(peer)->ances].effect != 0 ? items[pInfo(peer)->ances].effect : 0);
				if (pInfo(peer)->punched != 0) e_ = 8421376 + pInfo(peer)->punched;
				memcpy(raw + 1, &e_, 3); //16777218
				uint8_t e2 = (world_->X_13 and !world_->X_14 ? 129 : (has_playmod(pInfo(peer), "build range") and !world_->X_8 ? 129 : (has_playmod(pInfo(peer), "build range") and !world_->X_14 ? 129 : (has_playmod(pInfo(peer), "energized horn") || pInfo(peer)->hand == 9758 and !world_->X_14 ? 129 : pInfo(peer)->hand == 11094 ? 131 : 128))));
				uint8_t e3 = (world_->X_9 || has_playmod(pInfo(peer), "punch range") || has_playmod(pInfo(peer), "Cloak of Falling Waters") || has_playmod(pInfo(peer), "Acorns!") || has_playmod(pInfo(peer), "Burning Eyes") || has_playmod(pInfo(peer), "Eye Beam") || has_playmod(pInfo(peer), "Whipped Up") || has_playmod(pInfo(peer), "Pumpkin Smashing") || has_playmod(pInfo(peer), "Fishy") || has_playmod(pInfo(peer), "Cool") || has_playmod(pInfo(peer), "Demonic Force") || has_playmod(pInfo(peer), "Dragon Knight's Spear") || has_playmod(pInfo(peer), "Legendary!") || has_playmod(pInfo(peer), "Electric Arrows") || has_playmod(pInfo(peer), "Fire Hose") || has_playmod(pInfo(peer), "Cupid's Firepower") || has_playmod(pInfo(peer), "Flaming Arrows") || has_playmod(pInfo(peer), "Legendary Swordmaster") || has_playmod(pInfo(peer), "Flame On!") || has_playmod(pInfo(peer), "Fiery Pet") || has_playmod(pInfo(peer), "Super-Duper Pineapple Power!") || has_playmod(pInfo(peer), "Poseidon's Power") || has_playmod(pInfo(peer), "Silver Shimmer Bow") || has_playmod(pInfo(peer), "Devouring Souls") || has_playmod(pInfo(peer), "Sharing Flowers") || has_playmod(pInfo(peer), "Squirt Gun") || has_playmod(pInfo(peer), "Throwing Spear") || has_playmod(pInfo(peer), "Winter Frost Bow") || has_playmod(pInfo(peer), "Yo!") || pInfo(peer)->hand == 9800 and !world_->X_10 ? 129 : pInfo(peer)->hand == 11094 ? 131 : 128);
				memcpy(raw + 2, &e2, 1);
				memcpy(raw + 3, &e3, 1);

				int flag = form_type_player(pInfo(peer));
				memcpy(raw + 12, &flag, 4);
				float waterspeed = world_->X_15 || has_playmod(pInfo(peer), "I'm On A Shark!") || has_playmod(pInfo(peer), "Cheat Active: Super Speed") || has_playmod(pInfo(peer), "Speedy in Water") || has_playmod(pInfo(peer), "XP Buff: Wolf Worlds") || has_playmod(pInfo(peer), "A Little Fishy") || has_playmod(pInfo(peer), "Will of the Wild") and pInfo(peer)->wild == 8 || has_playmod(pInfo(peer), "Slightly Damp") and !world_->X_16 ? 310.0f : 125.0f;
				memcpy(raw + 16, &waterspeed, 4);
				if (pInfo(peer)->hair_color != 0xFFFFFFFF) *(uint32_t*)(raw + 44) = pInfo(peer)->hair_color;
				if (pInfo(peer)->eye_drop != 0xFFFFFFFF) *(uint32_t*)(raw + 48) = pInfo(peer)->eye_drop;
				if (pInfo(peer)->eye_lenses != 0xFFFFFFFF) *(uint32_t*)(raw + 8) = pInfo(peer)->eye_lenses;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						{
							if (pInfo(peer)->guild_id != 0) {
								uint32_t guild_id = pInfo(peer)->guild_id;
								uint32_t my_role = 0;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									for (GuildMember search_member : guild_information->guild_members) {
										if (search_member.member_name == pInfo(peer)->tankIDName) {
											my_role = search_member.role_id;
											break;
										}
									}
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnGuildDataChanged");
									//p.Insert(pInfo(peer)->guild_id);
									p.Insert(50478);
									p.Insert(79289404);
									p.Insert((65536 * guild_information->guild_mascot[0]) + guild_information->guild_mascot[1]);
									p.Insert(my_role);
									p.CreatePacket(currentPeer);
								}
							}
						}
						{
							if (pInfo(peer)->transmute.size() > 0 or pInfo(peer)->temptransmute.size() > 0 or pInfo(peer)->updtrans) {
								string transmute = "";
								pInfo(peer)->updtrans = false;
								for (int i = 0; i < pInfo(peer)->transmute.size(); i++) {
									transmute.append(pInfo(peer)->transmute[i] + ",");
								}
								for (int i = 0; i < pInfo(peer)->temptransmute.size(); i++) {
									string temp = explode("|", pInfo(peer)->temptransmute[i])[0];
									if (i < 1) transmute.append(";" + temp + ",");
									else transmute.append(temp + ",");
								}
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnTransmutateLinkDataModified");
								p.Insert(transmute);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->invis == false && pInfo(peer)->b_p != 0 && pInfo(peer)->b_i != 0) {
								gamepacket_t p5(0, pInfo(peer)->netID);
								p5.Insert("OnBillboardChange"), p5.Insert(pInfo(peer)->netID), p5.Insert(pInfo(peer)->b_i), p5.Insert(pInfo(peer)->b_a), p5.Insert(pInfo(peer)->b_p), p5.Insert(pInfo(peer)->b_w);
								p5.CreatePacket(currentPeer);
							}
						}
						{
							if (pInfo(peer)->necklace == 11818) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnScarfOfSeasons"), p.Insert(pInfo(peer)->i_11818_1), p.Insert(pInfo(peer)->i_11818_2), p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->pants == 10914) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnChangePureBeingMode"), p.Insert(pInfo(peer)->pure_shadow);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->feet == 10666) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnChangeAirBalloonStyle"), p.Insert(pInfo(peer)->grow_air_ballon);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->feet == 12636) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnFlagMay2019");
								p.Insert(pInfo(peer)->flagmay);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->ances == 12634) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnEqAura"), p.Insert(pInfo(peer)->eq_a);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->back == 12640) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnMinokawaWings"), p.Insert((pInfo(peer)->MKP and !pInfo(peer)->MKW ? 1 : (pInfo(peer)->MKP and pInfo(peer)->MKW ? 2 : 0)));
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->necklace == 10246) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnDaylightDragon");
								p.Insert(DaylightDragon.param1);
								p.Insert(DaylightDragon.param2);
								p.Insert(DaylightDragon.param3);
								p.Insert(DaylightDragon.param4);
								p.Insert(DaylightDragon.param5);
								p.Insert(DaylightDragon.param6);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->back == 10182) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPianoWingsUpdate");
								p.Insert(pInfo(peer)->m_note);
								p.Insert(pInfo(peer)->m_volume);
								p.Insert(0);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->back == 10424) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnRiftCape");
								p.Insert(pInfo(peer)->Cape_Value);
								p.Insert(pInfo(peer)->Cape_Collor_0_Value);
								p.Insert(pInfo(peer)->Cape_Collor_1_Value);
								p.Insert(pInfo(peer)->Cape_Collar_0_Value);
								p.Insert(pInfo(peer)->Cape_Collar_1_Value);
								p.Insert(pInfo(peer)->Cycle_Time);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->back == 11478) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnRiftWings");
								p.Insert(pInfo(peer)->Wing_Value);
								p.Insert(pInfo(peer)->Wing_Color_0_Value);
								p.Insert(pInfo(peer)->Wing_Color_1_Value);
								p.Insert(pInfo(peer)->Wing_Metal_0_Value);
								p.Insert(pInfo(peer)->Wing_Metal_1_Value);
								p.Insert(pInfo(peer)->Wing_Cycle_Time);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->hair == 10674) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnCernuousMask");
								p.Insert(pInfo(peer)->Aura_Season);
								p.Insert(pInfo(peer)->Trail_Season);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->necklace == 11748) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnBannerBandolier"), p.Insert(pInfo(peer)->Banner_Item);
								p.Insert(pInfo(peer)->Banner_Flag);
								p.CreatePacket(currentPeer);
							}
							if (pInfo(peer)->hair == 12958) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnInfinityCrown");
								p.Insert(pInfo(peer)->Crown_Value);
								p.Insert(pInfo(peer)->Crown_Cycle_Time);
								p.Insert(to_string(pInfo(peer)->Crown_Value_0_0) + "," + to_string(pInfo(peer)->Crown_Value_0_1) + "," + to_string(pInfo(peer)->Crown_Value_0_2));
								p.Insert(to_string(pInfo(peer)->Crown_Value_1_0) + "," + to_string(pInfo(peer)->Crown_Value_1_1) + "," + to_string(pInfo(peer)->Crown_Value_1_2));
								p.CreatePacket(currentPeer);
							}
						}
						{
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnFlagMay2019"), p.Insert(pInfo(peer)->flagmay);
							p.CreatePacket(currentPeer);
						}
						{
							// 1
							gamepacket_t p2(0, pInfo(peer)->netID); // Dan ini
							p2.Insert("OnCountryState"), p2.Insert(pInfo(peer)->country + "|showGuild" + (pInfo(peer)->lvl125 ? "|maxLevel" : "") + (pInfo(peer)->donor ? "|donor" : "") + (pInfo(currentPeer)->ttBadge ? "|ttBadge" : "") + (pInfo(currentPeer)->ccBadge ? "|ccBadge" : "") + (pInfo(peer)->master ? "|master" : ""));
							p2.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p3(0, pInfo(peer)->netID);
							p3.Insert("OnSetRoleSkinsAndIcons"), p3.Insert(pInfo(peer)->roleSkin), p3.Insert(pInfo(peer)->roleIcon), p3.Insert(0);
							p3.CreatePacket(currentPeer);
						}
						p.CreatePacket(currentPeer);
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						if (pInfo(peer)->netID != pInfo(currentPeer)->netID) {
							{
								if (pInfo(currentPeer)->guild_id != 0) {
									uint32_t guild_id = pInfo(currentPeer)->guild_id;
									uint32_t my_role = 0;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										for (GuildMember search_member : guild_information->guild_members) {
											if (search_member.member_name == pInfo(currentPeer)->tankIDName) {
												my_role = search_member.role_id;
												break;
											}
										}
										gamepacket_t p(0, pInfo(currentPeer)->netID);
										p.Insert("OnGuildDataChanged");
										p.Insert(pInfo(currentPeer)->guild_id);
										p.Insert(79289404);
										p.Insert((65536 * guild_information->guild_mascot[0]) + guild_information->guild_mascot[1]);
										p.Insert(my_role);
										p.CreatePacket(peer);
									}
								}
							}
							{
								if (pInfo(currentPeer)->transmute.size() > 0 or pInfo(currentPeer)->temptransmute.size() > 0 or pInfo(currentPeer)->updtrans) {
									string transmute = "";
									pInfo(currentPeer)->updtrans = false;
									for (int i = 0; i < pInfo(currentPeer)->transmute.size(); i++) {
										transmute.append(pInfo(currentPeer)->transmute[i] + ",");
									}
									for (int i = 0; i < pInfo(peer)->temptransmute.size(); i++) {
										string temp = explode("|", pInfo(currentPeer)->temptransmute[i])[0];
										if (i < 1) transmute.append(";" + temp + ",");
										else transmute.append(temp + ",");
									}
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnTransmutateLinkDataModified");
									p.Insert(transmute);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->invis == false && pInfo(currentPeer)->b_p != 0 && pInfo(currentPeer)->b_i != 0) {
									gamepacket_t p5(0, pInfo(currentPeer)->netID);
									p5.Insert("OnBillboardChange"), p5.Insert(pInfo(currentPeer)->netID), p5.Insert(pInfo(currentPeer)->b_i), p5.Insert(pInfo(currentPeer)->b_a), p5.Insert(pInfo(currentPeer)->b_p), p5.Insert(pInfo(currentPeer)->b_w);
									p5.CreatePacket(peer);
								}
							}
							{
								if (pInfo(currentPeer)->necklace == 11818) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnScarfOfSeasons"), p.Insert(pInfo(currentPeer)->i_11818_1), p.Insert(pInfo(currentPeer)->i_11818_2), p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->pants == 10914) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnChangePureBeingMode"), p.Insert(pInfo(currentPeer)->pure_shadow);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->feet == 10666) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnChangeAirBalloonStyle"), p.Insert(pInfo(currentPeer)->grow_air_ballon);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->feet == 12636) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnFlagMay2019");
									p.Insert(pInfo(currentPeer)->flagmay);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->ances == 12634) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnEqAura"), p.Insert(pInfo(currentPeer)->eq_a);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->back == 12640) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnMinokawaWings"), p.Insert((pInfo(currentPeer)->MKP and !pInfo(currentPeer)->MKW ? 1 : (pInfo(currentPeer)->MKP and pInfo(currentPeer)->MKW ? 2 : 0)));
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->necklace == 10246) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnDaylightDragon");
									p.Insert(DaylightDragon.param1);
									p.Insert(DaylightDragon.param2);
									p.Insert(DaylightDragon.param3);
									p.Insert(DaylightDragon.param4);
									p.Insert(DaylightDragon.param5);
									p.Insert(DaylightDragon.param6);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->back == 10182) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnPianoWingsUpdate");
									p.Insert(pInfo(currentPeer)->m_note);
									p.Insert(pInfo(currentPeer)->m_volume);
									p.Insert(0);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->back == 10424) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnRiftCape");
									p.Insert(pInfo(currentPeer)->Cape_Value);
									p.Insert(pInfo(currentPeer)->Cape_Collor_0_Value);
									p.Insert(pInfo(currentPeer)->Cape_Collor_1_Value);
									p.Insert(pInfo(currentPeer)->Cape_Collar_0_Value);
									p.Insert(pInfo(currentPeer)->Cape_Collar_1_Value);
									p.Insert(pInfo(currentPeer)->Cycle_Time);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->back == 11478) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnRiftWings");
									p.Insert(pInfo(currentPeer)->Wing_Value);
									p.Insert(pInfo(currentPeer)->Wing_Color_0_Value);
									p.Insert(pInfo(currentPeer)->Wing_Color_1_Value);
									p.Insert(pInfo(currentPeer)->Wing_Metal_0_Value);
									p.Insert(pInfo(currentPeer)->Wing_Metal_1_Value);
									p.Insert(pInfo(currentPeer)->Wing_Cycle_Time);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->hair == 10674) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnCernuousMask");
									p.Insert(pInfo(currentPeer)->Aura_Season);
									p.Insert(pInfo(currentPeer)->Trail_Season);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->necklace == 11748) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnBannerBandolier"), p.Insert(pInfo(currentPeer)->Banner_Item);
									p.Insert(pInfo(currentPeer)->Banner_Flag);
									p.CreatePacket(peer);
								}
								if (pInfo(currentPeer)->hair == 12958) {
									gamepacket_t p(0, pInfo(currentPeer)->netID);
									p.Insert("OnInfinityCrown");
									p.Insert(pInfo(currentPeer)->Crown_Value);
									p.Insert(pInfo(currentPeer)->Crown_Cycle_Time);
									p.Insert(to_string(pInfo(currentPeer)->Crown_Value_0_0) + "," + to_string(pInfo(currentPeer)->Crown_Value_0_1) + "," + to_string(pInfo(currentPeer)->Crown_Value_0_2));
									p.Insert(to_string(pInfo(currentPeer)->Crown_Value_1_0) + "," + to_string(pInfo(currentPeer)->Crown_Value_1_1) + "," + to_string(pInfo(currentPeer)->Crown_Value_1_2));
									p.CreatePacket(peer);
								}
							}
							{
								gamepacket_t p(0, pInfo(currentPeer)->netID);
								p.Insert("OnFlagMay2019"), p.Insert(pInfo(currentPeer)->flagmay);
								p.CreatePacket(peer);
							}
							{
								// 2
								gamepacket_t p2(0, pInfo(currentPeer)->netID); //Perhatikan ini, Harus bisa di bedakan currentPeer dan peer ygy
								p2.Insert("OnCountryState"), p2.Insert(pInfo(currentPeer)->country + "|showGuild" + (pInfo(currentPeer)->lvl125 ? "|maxLevel" : "") + (pInfo(currentPeer)->donor ? "|donor" : "") + (pInfo(currentPeer)->ttBadge ? "|ttBadge" : "") + (pInfo(currentPeer)->ccBadge ? "|ccBadge" : "") + (pInfo(currentPeer)->master ? "|master" : ""));
								p2.CreatePacket(peer);
							}
							{
								gamepacket_t p3(0, pInfo(currentPeer)->netID);
								p3.Insert("OnSetRoleSkinsAndIcons"), p3.Insert(pInfo(currentPeer)->roleSkin), p3.Insert(pInfo(currentPeer)->roleIcon), p3.Insert(0);
								p3.CreatePacket(peer);
							}
							gamepacket_t p(0, pInfo(currentPeer)->netID);
							if (!pInfo(currentPeer)->hideseek.Hiders) {
								p.Insert("OnSetClothing");
								p.Insert((float)pInfo(currentPeer)->hair, (float)pInfo(currentPeer)->shirt, (float)pInfo(currentPeer)->pants); // hair shirt pants
								p.Insert((float)pInfo(currentPeer)->feet, (float)pInfo(currentPeer)->face, (float)pInfo(currentPeer)->hand); // feet face hand 
								p.Insert((float)pInfo(currentPeer)->back, (float)pInfo(currentPeer)->mask, (float)pInfo(currentPeer)->necklace); // back mask neck
								bool set_skin = false;
								for (PlayMods peer_playmod : pInfo(currentPeer)->playmods) {
									if (set_skin) break;
									Playmod playmod = info_about_playmods[peer_playmod.id];
									string special_id = playmod.skin;
									//cout << "another playmod info of update_clothes: \n";
									//print_info_pmod(playmod);
									if (not special_id.empty()) {
										char* endptr = NULL;
										unsigned int skin_ = strtoll(special_id.c_str(), &endptr, 10);
										p.Insert((pInfo(currentPeer)->ghost ? -2450 : skin_));
										set_skin = true;
									}
								}
							} if (not set_skin) {
								p.Insert((pInfo(currentPeer)->ghost ? -2450 : (has_playmod(pInfo(currentPeer), "ninja stealth") ? 1684300950 : pInfo(currentPeer)->skin)));
							}
							p.Insert((float)pInfo(currentPeer)->ances, 0, 0);
							p.CreatePacket(peer);
						}
						else if (pInfo(currentPeer)->hideseek.InGame && pInfo(currentPeer)->hideseek.Hiders) {
							p.Insert("OnSetClothing");
							p.Insert((float)0, (float)0, (float)0); // hair shirt pants
							p.Insert((float)0, (float)pInfo(currentPeer)->hideseek.playerBlock, (float)0); // feet face hand 
							p.Insert((float)0, (float)0, (float)0); // back mask neck
							p.Insert(5);
							p.Insert((float)0, 0, 0);
							p.CreatePacket(peer);
						}
						PlayerMoving data{
							pInfo(currentPeer)->netID,
							0,
							0x14,
							0,
							form_state(pInfo(currentPeer)),
							0,
							0,
							0,
							1200,
							(has_playmod(pInfo(currentPeer), "cupid's firepower") ? float(-300) : (has_playmod(pInfo(currentPeer), "fists o' fury") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Cloak of Falling Waters") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Punch Power") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Heavenly") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Marshmallow Strike") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Legendary!") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Party Blaster") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Wheelin' n' Dealin") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Phase Blaster") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Wizardly Force") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Dragondead") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Ring of Force") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Protected") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Demon Control") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Fire Hose") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Deadly") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Frankenpunch") and !world_->X_8 ? 500 : (has_playmod(pInfo(currentPeer), "Dragonborn") and !world_->X_8 ? 500 : (world_->X_7 ? 500 : (has_playmod(pInfo(currentPeer), "devouring souls") ? -300 : 200))))))))))))))))))))),
							(world_->X_11 and !world_->X_12 ? float(310) : (has_playmod(pInfo(peer), "Cheat Active: Super Speed") and !world_->X_12 ? float(700) : (has_playmod(pInfo(currentPeer), "speedy") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Sparkling for battle!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Saddled Up!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "MAGnificent!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Pine-ch Buggy") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Smoog") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Tank Driver") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Infinite") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Raptor Legs") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Chaos Corruption!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Legendary!") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Neon Nerves") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "putt putt putt") ? 150 : (has_playmod(pInfo(currentPeer), "fleet of foot") and !world_->X_12 ? float(310) : (has_playmod(pInfo(currentPeer), "Infected!") ? float(150) : 250))))))))))))))))),
							(has_playmod(pInfo(currentPeer), "Cheat Active: Super Jump") ? float(600) : has_playmod(pInfo(currentPeer), "Floating!") ? -30 : (has_playmod(pInfo(currentPeer), "high jump") and !world_->X_4 or world_->X_3 ? float(700) : 1000))
						};
						pInfo(currentPeer)->High_Jump = (has_playmod(pInfo(currentPeer), "Floating!") ? true : (has_playmod(pInfo(currentPeer), "high jump") and !world_->X_4 or world_->X_3 ? true : false));
						pInfo(currentPeer)->Punch_Power = (has_playmod(pInfo(currentPeer), "fists o' fury") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Cloak of Falling Waters") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Punch Power") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Heavenly") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Marshmallow Strike") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Legendary!") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Party Blaster") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Wheelin' n' Dealin") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Phase Blaster") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Wizardly Force") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Dragondead") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Ring of Force") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Protected") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Demon Control") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Fire Hose") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Deadly") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Frankenpunch") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "Dragonborn") and !world_->X_8 ? true : (world_->X_7 ? true : false)))))))))))))))))));
						pInfo(currentPeer)->Punch_Range = (world_->X_9 || has_playmod(pInfo(currentPeer), "punch range") || has_playmod(pInfo(currentPeer), "Cloak of Falling Waters") || has_playmod(pInfo(currentPeer), "Acorns!") || has_playmod(pInfo(currentPeer), "Burning Eyes") || has_playmod(pInfo(currentPeer), "Eye Beam") || has_playmod(pInfo(currentPeer), "Whipped Up") || has_playmod(pInfo(currentPeer), "Pumpkin Smashing") || has_playmod(pInfo(currentPeer), "Fishy") || has_playmod(pInfo(currentPeer), "Cool") || has_playmod(pInfo(currentPeer), "Demonic Force") || has_playmod(pInfo(currentPeer), "Dragon Knight's Spear") || has_playmod(pInfo(currentPeer), "Legendary!") || has_playmod(pInfo(currentPeer), "Electric Arrows") || has_playmod(pInfo(currentPeer), "Fire Hose") || has_playmod(pInfo(currentPeer), "Cupid's Firepower") || has_playmod(pInfo(currentPeer), "Flaming Arrows") || has_playmod(pInfo(currentPeer), "Legendary Swordmaster") || has_playmod(pInfo(currentPeer), "Flame On!") || has_playmod(pInfo(currentPeer), "Fiery Pet") || has_playmod(pInfo(currentPeer), "Super-Duper Pineapple Power!") || has_playmod(pInfo(currentPeer), "Poseidon's Power") || has_playmod(pInfo(currentPeer), "Silver Shimmer Bow") || has_playmod(pInfo(currentPeer), "Devouring Souls") || has_playmod(pInfo(currentPeer), "Sharing Flowers") || has_playmod(pInfo(currentPeer), "Squirt Gun") || has_playmod(pInfo(currentPeer), "Throwing Spear") || has_playmod(pInfo(currentPeer), "Winter Frost Bow") || has_playmod(pInfo(currentPeer), "Yo!") || pInfo(currentPeer)->hand == 11094 || pInfo(currentPeer)->hand == 9800 and !world_->X_10 ? true : false);
						pInfo(currentPeer)->Speedy = (world_->X_11 and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "speedy") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Sparkling for battle!") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Saddled Up!") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "MAGnificent!") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Pine-ch Buggy") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Smoog") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Tank Driver") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Infinite") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Raptor Legs") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Chaos Corruption!") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Legendary!") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "Neon Nerves") and !world_->X_12 ? true : (has_playmod(pInfo(currentPeer), "fleet of foot") and !world_->X_12 ? true : false))))))))))))));
						pInfo(currentPeer)->Build_Range = (world_->X_13 and !world_->X_14 ? true : (has_playmod(pInfo(currentPeer), "build range") and !world_->X_8 ? true : (has_playmod(pInfo(currentPeer), "build range") and !world_->X_14 ? true : (has_playmod(pInfo(currentPeer), "energized horn") || pInfo(currentPeer)->hand == 9758 || pInfo(currentPeer)->hand == 11094 and !world_->X_14 ? true : false))));
						pInfo(currentPeer)->Speedy_In_Water = world_->X_15 || has_playmod(pInfo(currentPeer), "I'm On A Shark!") || has_playmod(pInfo(currentPeer), "Speedy in Water") || has_playmod(pInfo(currentPeer), "XP Buff: Wolf Worlds") || has_playmod(pInfo(currentPeer), "A Little Fishy") || has_playmod(pInfo(currentPeer), "Will of the Wild") and pInfo(currentPeer)->wild == 8 || has_playmod(pInfo(currentPeer), "Slightly Damp") and !world_->X_16 ? true : false;
						BYTE* raw_ = packPlayerMoving(&data);
						int e_ = 8421376 + (items[pInfo(currentPeer)->hand].effect != 0 ? items[pInfo(currentPeer)->hand].effect : items[pInfo(currentPeer)->necklace].effect != 0 ? items[pInfo(currentPeer)->necklace].effect : items[pInfo(currentPeer)->back].effect != 0 ? items[pInfo(currentPeer)->back].effect : items[pInfo(currentPeer)->face].effect != 0 ? items[pInfo(currentPeer)->face].effect : items[pInfo(currentPeer)->mask].effect != 0 ? items[pInfo(currentPeer)->mask].effect : items[pInfo(currentPeer)->hair].effect != 0 ? items[pInfo(currentPeer)->hair].effect : items[pInfo(currentPeer)->feet].effect != 0 ? items[pInfo(currentPeer)->feet].effect : items[pInfo(currentPeer)->shirt].effect != 0 ? items[pInfo(currentPeer)->shirt].effect : items[pInfo(currentPeer)->pants].effect != 0 ? items[pInfo(currentPeer)->pants].effect : items[pInfo(currentPeer)->ances].effect != 0 ? items[pInfo(currentPeer)->ances].effect : 0);
						if (pInfo(currentPeer)->punched != 0) e_ = 8421376 + pInfo(currentPeer)->punched;
						memcpy(raw_ + 1, &e_, 3); //16777218
						uint8_t e2 = (world_->X_13 and !world_->X_14 ? 129 : (has_playmod(pInfo(currentPeer), "build range") and !world_->X_8 ? 129 : (has_playmod(pInfo(currentPeer), "build range") || has_playmod(pInfo(currentPeer), "energized horn") and !world_->X_14 ? 129 : (pInfo(currentPeer)->hand == 11094 and !world_->X_14 ? 131 : 128))));
						uint8_t e3 = (world_->X_9 || has_playmod(pInfo(currentPeer), "punch range") || has_playmod(pInfo(currentPeer), "Cloak of Falling Waters") || has_playmod(pInfo(currentPeer), "Acorns!") || has_playmod(pInfo(currentPeer), "Burning Eyes") || has_playmod(pInfo(currentPeer), "Eye Beam") || has_playmod(pInfo(currentPeer), "Whipped Up") || has_playmod(pInfo(currentPeer), "Pumpkin Smashing") || has_playmod(pInfo(currentPeer), "Fishy") || has_playmod(pInfo(currentPeer), "Cool") || has_playmod(pInfo(currentPeer), "Demonic Force") || has_playmod(pInfo(currentPeer), "Dragon Knight's Spear") || has_playmod(pInfo(currentPeer), "Legendary!") || has_playmod(pInfo(currentPeer), "Electric Arrows") || has_playmod(pInfo(currentPeer), "Fire Hose") || has_playmod(pInfo(currentPeer), "Cupid's Firepower") || has_playmod(pInfo(currentPeer), "Flaming Arrows") || has_playmod(pInfo(currentPeer), "Legendary Swordmaster") || has_playmod(pInfo(currentPeer), "Flame On!") || has_playmod(pInfo(currentPeer), "Fiery Pet") || has_playmod(pInfo(currentPeer), "Super-Duper Pineapple Power!") || has_playmod(pInfo(currentPeer), "Poseidon's Power") || has_playmod(pInfo(currentPeer), "Silver Shimmer Bow") || has_playmod(pInfo(currentPeer), "Devouring Souls") || has_playmod(pInfo(currentPeer), "Sharing Flowers") || has_playmod(pInfo(currentPeer), "Squirt Gun") || has_playmod(pInfo(currentPeer), "Throwing Spear") || has_playmod(pInfo(currentPeer), "Winter Frost Bow") || has_playmod(pInfo(currentPeer), "Yo!") || pInfo(currentPeer)->hand == 9800 and !world_->X_10 ? 129 : pInfo(currentPeer)->hand == 11094 ? 131 : 128);
						memcpy(raw_ + 2, &e2, 1);
						memcpy(raw_ + 3, &e3, 1);

						int flag = form_type_player(pInfo(currentPeer));
						memcpy(raw_ + 12, &flag, 4);
						float waterspeed = world_->X_15 || has_playmod(pInfo(currentPeer), "I'm On A Shark!") || has_playmod(pInfo(currentPeer), "Cheat Active: Super Speed") || has_playmod(pInfo(currentPeer), "Speedy in Water") || has_playmod(pInfo(currentPeer), "XP Buff: Wolf Worlds") || has_playmod(pInfo(currentPeer), "A Little Fishy") || has_playmod(pInfo(currentPeer), "Will of the Wild") and pInfo(currentPeer)->wild == 8 || has_playmod(pInfo(currentPeer), "Slightly Damp") and !world_->X_16 ? 310.0f : 125.0f;
						memcpy(raw_ + 16, &waterspeed, 4);
						if (pInfo(currentPeer)->hair_color != 0xFFFFFFFF) *(uint32_t*)(raw_ + 44) = pInfo(currentPeer)->hair_color;
						if (pInfo(currentPeer)->eye_drop != 0xFFFFFFFF) *(uint32_t*)(raw_ + 48) = pInfo(currentPeer)->eye_drop;
						if (pInfo(currentPeer)->eye_lenses != 0xFFFFFFFF) *(uint32_t*)(raw_ + 8) = pInfo(currentPeer)->eye_lenses;
						send_raw(peer, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
						delete[]raw_;
					}
				}
			}
		}
	}
	catch (out_of_range) {
		return;
	}
}
inline void Send_Xenonite_Talk2(ENetPeer* peer, string Name, bool toall = false) {
	string name_ = Name, Text = "";
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name) {
				if (world_->X_1 && !pInfo(toall ? currentPeer : peer)->Double_Jump) Text += "`2Double Jump granted!`` ";
				if (world_->X_2 && pInfo(toall ? currentPeer : peer)->Double_Jump) Text += "`6Double Jump blocked!`` ";
				if (world_->X_3 && !pInfo(toall ? currentPeer : peer)->High_Jump) Text += "`2High Jump granted!`` ";
				if (world_->X_4 && pInfo(toall ? currentPeer : peer)->High_Jump) Text += "`6High Jump blocked!`` ";
				if (world_->X_5 && !has_playmod(pInfo(toall ? currentPeer : peer), "Fireproof")) Text += "`2Heat Resist granted!`` ";
				if (world_->X_6 && has_playmod(pInfo(toall ? currentPeer : peer), "Fireproof")) Text += "`6Heat Resist blocked!`` ";
				if (world_->X_7 && !pInfo(toall ? currentPeer : peer)->Punch_Power) Text += "`2Strong Punch granted!`` ";
				if (world_->X_8 && pInfo(toall ? currentPeer : peer)->Punch_Power) Text += "`6Strong Punch blocked!`` ";
				if (world_->X_9 && !pInfo(toall ? currentPeer : peer)->Punch_Range) Text += "`2Long Punch granted!`` ";
				if (world_->X_10 && pInfo(toall ? currentPeer : peer)->Punch_Range) Text += "`6Long Punch blocked!`` ";
				if (world_->X_11 && !pInfo(toall ? currentPeer : peer)->Speedy) Text += "`2Super Speed granted!`` ";
				if (world_->X_12 && pInfo(toall ? currentPeer : peer)->Speedy) Text += "`6Super Speed blocked!`` ";
				if (world_->X_13 && !pInfo(toall ? currentPeer : peer)->Build_Range) Text += "`2Long Build granted!`` ";
				if (world_->X_14 && pInfo(toall ? currentPeer : peer)->Build_Range) Text += "`6Long Build blocked!`` ";
				if (world_->X_15 && !pInfo(toall ? currentPeer : peer)->Speedy_In_Water) Text += "`2Speedy in Water granted!`` ";
				if (world_->X_16 && pInfo(toall ? currentPeer : peer)->Speedy_In_Water) Text += "`6Speedy in Water blocked!`` ";
				if (world_->X_17 && !has_playmod(pInfo(toall ? currentPeer : peer), "punch damage")) Text += "`2Punch Damage granted!`` ";
				if (world_->X_18 && has_playmod(pInfo(toall ? currentPeer : peer), "punch damage")) Text += "`6Punch Damage blocked!`` ";
				if (Text != "") {
					gamepacket_t p, p1;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(toall ? currentPeer : peer)->netID);
					p.Insert("Xenonite has changed everyone's powers! " + Text);
					p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					p1.Insert("OnConsoleMessage");
					p1.Insert("Xenonite has changed everyone's powers! " + Text);
					p1.CreatePacket(toall ? currentPeer : peer);
				}
				update_clothes(toall ? currentPeer : peer);
			}
		}
	}
}
inline void Send_Xenonite_Update(ENetPeer* peer) {
	string name_ = pInfo(peer)->world, Text = "";
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (world_->X_1 && !has_playmod(pInfo(peer), "double jump")) Text += "`2Double Jump granted!`` ";
		if (world_->X_2 && has_playmod(pInfo(peer), "double jump")) Text += "`6Double Jump blocked!`` ";
		if (world_->X_3 && !has_playmod(pInfo(peer), "high jump")) Text += "`2High Jump granted!`` ";
		if (world_->X_4 && has_playmod(pInfo(peer), "high jump")) Text += "`6High Jump blocked!`` ";
		if (world_->X_5 && !has_playmod(pInfo(peer), "Fireproof")) Text += "`2Heat Resist granted!`` ";
		if (world_->X_6 && has_playmod(pInfo(peer), "Fireproof")) Text += "`6Heat Resist blocked!`` ";
		if (world_->X_7 && !has_playmod(pInfo(peer), "Punch Power")) Text += "`2Strong Punch granted!`` ";
		if (world_->X_8 && has_playmod(pInfo(peer), "Punch Power")) Text += "`6Strong Punch blocked!`` ";
		if (world_->X_9 && !has_playmod(pInfo(peer), "punch range")) Text += "`2Long Punch granted!`` ";
		if (world_->X_10 && has_playmod(pInfo(peer), "punch range")) Text += "`6Long Punch blocked!`` ";
		if (world_->X_11 && !has_playmod(pInfo(peer), "speedy")) Text += "`2Super Speed granted!`` ";
		if (world_->X_12 && has_playmod(pInfo(peer), "speedy")) Text += "`6Super Speed blocked!`` ";
		if (world_->X_13 && !has_playmod(pInfo(peer), "Build Range")) Text += "`2Long Build granted!`` ";
		if (world_->X_14 && has_playmod(pInfo(peer), "Build Range")) Text += "`6Long Build blocked!`` ";
		if (world_->X_15 && !has_playmod(pInfo(peer), "Speedy in Water")) Text += "`2Speedy in Water granted!`` ";
		if (world_->X_16 && has_playmod(pInfo(peer), "Speedy in Water")) Text += "`6Speedy in Water blocked!`` ";
		if (world_->X_17 && !has_playmod(pInfo(peer), "punch damage")) Text += "`2Punch Damage granted!`` ";
		if (world_->X_18 && has_playmod(pInfo(peer), "punch damage")) Text += "`6Punch Damage blocked!`` ";
		if (Text != "") {
			if (!world_->xenonite) world_->xenonite = true;
			gamepacket_t p, p1;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
			p.Insert("Xenonite has changed everyone's powers! " + Text);
			p.Insert(0), p.Insert(1), p.CreatePacket(peer);
			p1.Insert("OnConsoleMessage");
			p1.Insert("Xenonite has changed everyone's powers! " + Text);
			p1.CreatePacket(peer);
		}
	}
	update_clothes(peer);
}
inline void SendParticleEffect(ENetPeer* peer, int x, int y, int size, int id, int delay)
{
	PlayerMoving datx{};
	datx.packetType = 0x11;
	datx.x = x;
	datx.y = y;
	datx.YSpeed = id;
	datx.XSpeed = size;
	datx.plantingTree = delay;
	BYTE* raw = packPlayerMoving(&datx);
	send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
	delete[]raw;
}
void unequip_(ENetPeer* p_, const int id_) {
	if (pInfo(p_)->hideseek.InGame && global::algorithm::hideseek.GameStarted) {
		Algorithm::send_console(p_, "`1HIDE-SEEK: `oYou can't equip/unequip any clothes till' the match game is finished!");
		return;
	}
	if (pInfo(p_)->flagmay != 256 and items[id_].flagmay != 256) pInfo(p_)->flagmay = 256;
	bool stat_ = 0;
	ItemDB item_ = items[id_];
	switch (items[id_].clothType) {
	case ClothTypes::ANCES:
		if (pInfo(p_)->ances == id_)
			pInfo(p_)->ances = 0, stat_ = 1;
		break;
	case ClothTypes::BACK:
		if (pInfo(p_)->back == id_)
			pInfo(p_)->back = 0, stat_ = 1;
		break;
	case ClothTypes::FACE:
		if (pInfo(p_)->face == id_)
			pInfo(p_)->face = 0, stat_ = 1;
		break;
	case ClothTypes::FEET:
		if (pInfo(p_)->feet == id_)
			pInfo(p_)->feet = 0, stat_ = 1;
		break;
	case ClothTypes::HAIR:
		if (pInfo(p_)->hair == id_)
			pInfo(p_)->hair = 0, stat_ = 1;
		break;
	case ClothTypes::HAND:
		if (pInfo(p_)->hand == id_)
			pInfo(p_)->hand = 0, stat_ = 1;
		break;
	case ClothTypes::MASK:
		if (pInfo(p_)->mask == id_)
			pInfo(p_)->mask = 0, stat_ = 1;
		break;
	case ClothTypes::NECKLACE:
		if (pInfo(p_)->necklace == id_)
			pInfo(p_)->necklace = 0, stat_ = 1;
		break;
	case ClothTypes::PANTS:
		if (pInfo(p_)->pants == id_)
			pInfo(p_)->pants = 0, stat_ = 1;
		break;
	case ClothTypes::SHIRT:
		if (pInfo(p_)->shirt == id_)
			pInfo(p_)->shirt = 0, stat_ = 1;
		break;
	default:
		break;
	}
	if (stat_) {
		update_clothes(p_);
		packet_(p_, "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0");
	}
	else if (id_ == 12636) {
		gamepacket_t p(0, pInfo(p_)->netID);
		p.Insert("OnFlagMay2019");
		p.Insert(pInfo(p_)->flagmay = (pInfo(p_)->flagmay == 16777472 ? 256 : 16777472));
		p.CreatePacket(p_);
	}
	if (stat_ and item_.on_remove != "" or id_ == 2286 and pInfo(p_)->hand == 2286 or id_ == 2204 and pInfo(p_)->hand == 2204) {
		packet_(p_, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		if (id_ == 2204) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Geiger Counter removed. (`$Geiger Counting`` mod removed)");
			p.CreatePacket(p_);
		}
		else if (id_ == 2286 and pInfo(p_)->geiger_ < 100) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Geiger Counter is no longer charging! (`$Charging Geiger Counter`` mod removed)");
			p.CreatePacket(p_);
			pInfo(p_)->geiger_ = 0;
		}
		else {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert(item_.on_remove + (item_.playmod != "" ? " (`$" + item_.playmod + "`` mod removed)" : ""));
			p.CreatePacket(p_);
		}
	}
}

void cancel_trade(ENetPeer* p_, bool confirm_cancel = false, bool busy_ = false) {
	bool found = false;
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == pInfo(p_)->world) {
			if (pInfo(currentPeer)->netID == pInfo(p_)->trading_with and pInfo(p_)->netID == pInfo(currentPeer)->trading_with) {
				found = true;
				pInfo(currentPeer)->block_trade = false, pInfo(currentPeer)->accept_the_offer = false, pInfo(currentPeer)->trading_with = -1, pInfo(currentPeer)->trade_items.clear();
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					if (not confirm_cancel) {
						World* world_ = &worlds[p - worlds.begin()];
						{
							if (busy_) {
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + "`` is too busy to trade!");
									p.CreatePacket(currentPeer), p.CreatePacket(p_);
								}
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + "`` is too busy to trade!");
								p.CreatePacket(currentPeer), p.CreatePacket(p_);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + "`` has canceled the trade");
								p.CreatePacket(currentPeer);
							}
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("`6[```4Trade canceled by " + (not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + "``!```6]``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("`6[```4Trade canceled by " + (not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + "``!```6]``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`6[```4Trade canceled by " + (not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + "``!```6]``");
							p.CreatePacket(p_), p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("`6[```4Trade canceled by " + (not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + "``!```6]``");
							p.CreatePacket(p_), p.CreatePacket(currentPeer);
						}
					}
					gamepacket_t p;
					p.Insert("OnForceTradeEnd");
					p.CreatePacket(currentPeer);
					if (busy_) {
						p.CreatePacket(p_);
					}
				}
				pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
				return;
			}
		}
	}
	if (busy_) {
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->tankIDName) + " is too busy to trade!");
			p.CreatePacket(p_);
		}
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->tankIDName) + " is too busy to trade!");
		p.CreatePacket(p_);
	}
	else if (pInfo(p_)->trade_accept) {
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert("The other person left the trade!");
		p.CreatePacket(p_);
	}
	if (not found) {
		gamepacket_t p;
		p.Insert("OnForceTradeEnd");
		p.CreatePacket(p_);
	}
	pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
}
void respawn_player(ENetPeer* peer, int const& delay = 0, bool const& onKilled = false, bool const& resetCheckpoint = false) {
	if (pInfo(peer)->trading_with != -1) cancel_trade(peer, false, true);
	if (pInfo(peer)->lastRespawn >= Algorithm::get_epoch_time()) return;
	pInfo(peer)->lastRespawn = Algorithm::get_epoch_time() + 1 + delay / 1000;
	string name_ = pInfo(peer)->world;
	int w_ = 100;
	//get_world(name_);
	vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (paa != worlds.end()) {
		World* worldInfo = &worlds[paa - worlds.begin()];
		if (worldInfo == nullptr) return;
		int& x = pInfo(peer)->c_x;
		int& y = pInfo(peer)->c_y;
		w_ = worldInfo->width;
		if (resetCheckpoint || items[worldInfo->blocks[x + y * worldInfo->width].fg].blockType != BlockTypes::CHECKPOINT) {
			if (not pInfo(peer)->izanagi) {
				for (int i = 0; i < worldInfo->width * worldInfo->height; i++) {
					if (items[worldInfo->blocks[i].fg].blockType == BlockTypes::MAIN_DOOR) {
						x = i % worldInfo->width;
						y = i / worldInfo->width;
						break;
					}
				}
			}
		}
		ENetPacket* unfreezePacket = Variant{ "OnSetFreezeState" }.push(0).pack(pInfo(peer)->netID, 2000 + delay);
		ENetPacket* freezePacket = Variant{ "OnSetFreezeState" }.push(pInfo(peer)->izanagi ? 0 : 2).pack(pInfo(peer)->netID, delay);
		ENetPacket* setPosPacket = Variant{ "OnSetPos" }.push(Vector2{ static_cast<float>(x) * 32.f, static_cast<float>(y) * 32.f }).pack(pInfo(peer)->netID, 2000 + delay);
		ENetPacket* onKilledPacket = Variant{ "OnKilled" }.pack(pInfo(peer)->netID, delay);
		ENetPacket* sfxPacket = Variant{ "OnPlayPositioned" }.push("audio/teleport.wav").pack(pInfo(peer)->netID, 2000 + delay);
		ENetPacket* respawnPosPacket = Variant{ "SetRespawnPos" }.push(x + y * w_).pack(pInfo(peer)->netID, 2000 + delay);

		enet_peer_send(peer, 0, respawnPosPacket);

		enet_peer_send(peer, 0, unfreezePacket);
		enet_peer_send(peer, 0, freezePacket);

		enet_peer_send(peer, 0, setPosPacket);

		if (onKilled)
			enet_peer_send(peer, 0, onKilledPacket);

		enet_peer_send(peer, 0, sfxPacket);
	}
}
void save_player(Player*, bool);
int modify_inventory(ENetPeer* p_, const int i_, int& c_, bool upd_inv_visuals = true, bool force_return = false, bool log_activity = true) {
	if (c_ > 200 or i_ <= 0 or i_ == 112 or i_ >= items.size()) return -1;
	//if (i_ == 32 || i_ == 18 || i_ == 1424 || i_ == 5640) log_activity = false;
	if (c_ == 0) upd_inv_visuals = false;
	int ori_ = c_;
	Player* k_ = pInfo(p_);
	int last_free_ = -1;
	for (int a_ = 0; a_ < k_->inv.size(); a_++) {
		if (k_->inv[a_].id == i_) {
			if (k_->inv[a_].count + c_ <= 200) {
				if (c_ < 0 and k_->inv[a_].count + c_ < 0) return -1;
				if (k_->inv[a_].count + c_ == 0) {
					if (pInfo(p_)->b_i == k_->inv[a_].id) {
						gamepacket_t p5(0, pInfo(p_)->netID);
						p5.Insert("OnBillboardChange"), p5.Insert(pInfo(p_)->netID), p5.Insert(pInfo(p_)->b_i = 0), p5.Insert(pInfo(p_)->b_a = 0), p5.Insert(pInfo(p_)->b_p), p5.Insert(pInfo(p_)->b_w);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(p_)->world != pInfo(currentPeer)->world) continue;
							p5.CreatePacket(currentPeer);
						}
					}
					if (items[k_->inv[a_].id].blockType == BlockTypes::CLOTHING)
						unequip_(p_, k_->inv[a_].id);
					//if (pInfo(p_)->flagmay == 1929) pInfo(p_)->flagmay = 256;
					if (pInfo(p_)->flagmay != 256 and items[k_->inv[a_].id].flagmay != 256) pInfo(p_)->flagmay = 256;
					//send_devlogs(pInfo(p_)->tankIDName, format("modified their inventory: Removed {} {}", k_->inv[a_].count, items[k_->inv[a_].id].name));
					k_->inv[a_].id = 0, k_->inv[a_].count = 0;
					goto s_;
				}
				if (items[k_->inv[a_].id].blockType != FISH) k_->inv[a_].count += c_;
				//send_devlogs(pInfo(p_)->tankIDName, format("modified their inventory: Added {} {}", k_->inv[a_].count, items[k_->inv[a_].id].name));
				if (c_ == 0) {
					c_ = k_->inv[a_].count;
					//log_activity = false;
					return -1;
				}
				c_ = k_->inv[a_].count;
			}
			else {
				if (force_return)
					c_ = k_->inv[a_].count;
				return -1;
			}
			goto s_;
		}
		else if (k_->inv[a_].id == 0 and last_free_ == -1) {
			last_free_ = a_;
		}
		if (a_ + 1 == k_->inv.size()) {
			if (last_free_ != -1 and c_ > 0) {
				k_->inv[last_free_].id = i_, k_->inv[last_free_].count = c_;
				goto s_;
			}
			return -1;
		}
	}
s_:

	if (upd_inv_visuals and c_ != 0) {
		PlayerMoving data_{};
		data_.packetType = 13, data_.plantingTree = i_;
		BYTE* raw = packPlayerMoving(&data_);
		raw[(ori_ < 0 ? 2 : 3)] = ori_ < 0 ? (ori_ * -1) : ori_;
		send_raw(p_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		//if (log_activity) send_devlogs(pInfo(p_)->tankIDName + "'s inventory", format("`6was modified in world ({}), info: {}{} {}``", pInfo(p_)->world, i_ == 242 || i_ == 1796 || i_ == 7188 ? "`2" : "`6", c_, items[i_].name));
		delete[]raw;
	}
	save_player(pInfo(p_), false);
	return 0;
}

namespace ghosts {
	void claim(ENetPeer* peer, int const& level) {
		if (level < 1 || level > 10) return;

		int added = 1;

		for (int i = 0; i < ghosts::rewardsItems.size(); i++) {
			if (i + 1 == level) modify_inventory(peer, ghosts::rewardsItems[i], added);
		}
	}
}
namespace snacks {
	void claim(ENetPeer* peer, int const& level) {
		if (level < 1 || level > 10) return;

		int added = 1;

		for (int i = 0; i < snacks::rewardsItems.size(); i++) {
			if (i + 1 == level) modify_inventory(peer, snacks::rewardsItems[i], added);
		}
	}
}
namespace valentine {
	void claim(ENetPeer* peer, int const& number) {
		if (number < 1 || number > valentine::rewardsItems.size()) return;

		int added = 1;

		modify_inventory(peer, valentine::rewardsItems[number], added);
	}
}

inline void classic_bank_show(ENetPeer* peer, bool transfer = false, int errTransfer = -1) {
	if (!transfer) {
		int DLCount = 0, BGLCount = 0, WLCount = 0;
		modify_inventory(peer, 7188, BGLCount), modify_inventory(peer, 1796, DLCount), modify_inventory(peer, 242, WLCount);
		DialogBuilder dialog("`o");
		dialog.add_label_icon(true, 242, "`wClassic Bank``");
		if (errTransfer == -2) dialog.add_textbox("`4Invalid Locks amount");
		dialog.add_smalltext("Safe your locks inside `9Classic Bank``. it's 100% safe and makes your transaction more simple by withdrawing your Locks nor transfering your Locks at the time you want to do the transaction without any tax!")
			.add_textbox("You currently holding:");
		if (BGLCount != 0) dialog.add_label_icon(false, 7188, setGems(BGLCount) + " Blue Gem Lock");
		if (DLCount != 0) dialog.add_label_icon(false, 1796, setGems(DLCount) + " Diamond Lock");
		if (WLCount != 0) dialog.add_label_icon(false, 242, setGems(WLCount) + " World Lock");
		if (BGLCount + DLCount + WLCount == 0) dialog.add_smalltext("You are currently not carrying any Locks");
		dialog.add_textbox("In your inventory");
		if (DLCount >= 100) dialog.add_small_font_button("convert_dl", "Convert Diamond Lock to Blue Gem Lock");
		dialog.add_spacer(false);
		if (pInfo(peer)->lockInBank >= 1) {
			int WLInBank = 0, DLInBank = 0, BGLInBank = 0;
			DLInBank = pInfo(peer)->lockInBank / 100;
			WLInBank = pInfo(peer)->lockInBank - (DLInBank * 100);
			if (DLInBank >= 100) {
				BGLInBank = pInfo(peer)->lockInBank / 10000;
				DLInBank -= 100 * BGLInBank;
			}
			if (BGLCount >= 1 || DLCount >= 1 || WLCount >= 1) {
				dialog.add_textbox("You are currently have:");
				if (BGLInBank != 0) dialog.add_label_icon(false, 7188, setGems(BGLInBank) + " Blue Gem Lock");
				if (DLInBank != 0) dialog.add_label_icon(false, 1796, setGems(DLInBank) + " Diamond Lock");
				if (WLInBank != 0) dialog.add_label_icon(false, 242, setGems(WLInBank) + " World Lock");
				dialog.add_textbox("Inside the `9Classic Bank``")
					.add_button("transfer_from_bank", "Transfer Locks")
					.add_spacer(false)
					.add_smalltext("Deposit or Withdraw Locks")
					.add_text_input(3, "lock_amount", "Amount: ", "")
					.add_button("deposit_lock", "Deposit")
					.add_button("withdraw_lock", "Withdraw");
			}
			else {
				dialog.add_textbox("You are currently have:");
				if (BGLInBank != 0) dialog.add_label_icon(false, 7188, setGems(BGLInBank) + " Blue Gem Lock");
				if (DLInBank != 0) dialog.add_label_icon(false, 1796, setGems(DLInBank) + " Diamond Lock");
				if (WLInBank != 0) dialog.add_label_icon(false, 242, setGems(WLInBank) + " World Lock");
				dialog.add_textbox("Inside the `9Classic Bank``")
					.add_button("transfer_from_bank", "Transfer Lock")
					.add_spacer(false)
					.add_smalltext("Withdraw Locks")
					.add_text_input(3, "lock_amount", "Amount: ", "")
					.add_button("withdraw_lock", "Withdraw");
			}
		}
		else {
			if (pInfo(peer)->lockInBank < 0) {
				dialog.add_textbox("You currently owe `5" + fixint(pInfo(peer)->lockInBank) + " ``Locks from the `9Classic Bank.`` Please pay it, or your account will be permanently `4suspended.``")
					.add_spacer(false)
					.add_smalltext("Deposit Locks")
					.add_text_input(3, "lock_amount", "Amount: ", "")
					.add_button("deposit_lock", "Deposit");
			}
			else if (BGLCount >= 1 || DLCount >= 1 || WLCount >= 1) {
				dialog.add_textbox("It appears that you don't have any Locks inside the `9Classic Bank.`")
					.add_spacer(false)
					.add_smalltext("Deposit Lock")
					.add_text_input(3, "lock_amount", "Amount: ", "")
					.add_button("deposit_lock", "Deposit");
			}
			else {
				dialog.add_textbox("It appears that you don't have any Locks inside the `9Classic Bank.`")
					.add_spacer(false)
					.add_textbox("You do not have any Locks to deposit into the `9Classic Bank``. Locks are valuable items that can be acquired through various quests and challenges. Deposit Locks to earn interest and keep them safe. Acquiring more Locks will help you progress in the game and unlock exclusive rewards. Keep exploring and completing quests to increase your collection of Locks.");
			}
		}
		dialog.add_spacer(false).end_dialog("classic_bank", "Close", "").add_quick_exit();
		Algorithm::send_dialog(peer, dialog.to_string());
	}
	else {
		int WLInBank = 0, DLInBank = 0, BGLInBank = 0;
		DLInBank = pInfo(peer)->lockInBank / 100;
		WLInBank = pInfo(peer)->lockInBank - (DLInBank * 100);
		if (DLInBank >= 100) {
			BGLInBank = pInfo(peer)->lockInBank / 10000;
			DLInBank -= 100 * BGLInBank;
		}
		DialogBuilder dialog("`o");
		dialog.add_label_icon(true, 242, "`wTransfer Locks``");
		if (errTransfer == 0) dialog.add_textbox("`4The username you are trying to transfer to was not found or is currently offline!");
		else if (errTransfer == 1) dialog.add_textbox("`4You can only transfer 100,000 Locks at a time!");
		else if (errTransfer == 2) dialog.add_textbox("`4You don't have enough Locks to transfer that amount.");
		else if (errTransfer == 3) dialog.add_textbox("`4Invalid Locks amount");
		else if (errTransfer == 4) dialog.add_textbox("`4You can't transfer Locks to yourself!");
		dialog.add_smalltext("You are about to transfer the Locks in your `9Classic Bank ``account to another `9Classic Bank ``account. Please note that you can only transfer Locks to online players.<CR>`5Note: ``You can transfer up to 100,000 Locks at once.")
			.add_textbox("You are currently have:");
		if (BGLInBank != 0) dialog.add_label_icon(false, 7188, setGems(BGLInBank) + " Blue Gem Lock");
		if (DLInBank != 0) dialog.add_label_icon(false, 1796, setGems(DLInBank) + " Diamond Lock");
		if (WLInBank != 0) dialog.add_label_icon(false, 242, setGems(WLInBank) + " World Lock");
		dialog.add_textbox("Inside the `9Classic Bank``")
			.add_spacer(false)
			.add_smalltext("Transfer Locks")
			.add_text_input(18, "transfer_to", "Username: ", "")
			.add_text_input(6, "lock_amount", "Amount: ", "")
			.add_button("transfer_lock", "Transfer");
		dialog.add_spacer(false).end_dialog("classic_bank", "Cancel", "").add_quick_exit();
		Algorithm::send_dialog(peer, dialog.to_string());
	}
}
inline void show_recipe(ENetPeer* peer, vector<string>search) {
	if (search.size() == 0) return;
	if (pInfo(peer)->page_number > search.size()) pInfo(peer)->page_number = search.size() + 26;
	if (pInfo(peer)->page_number < 26) pInfo(peer)->page_number = 26;
	int type = 0, pages = 0;
	bool block = false;
	string error = "";
	if (not pInfo(peer)->page_item.empty() && pInfo(peer)->page_item.length() < 4) error = "\nadd_textbox|`4OOPS:`` You must enter atleast 4 characters.|", pInfo(peer)->page_item = "";
	if (search == splicing) type = 13;
	else if (search == combining) type = 912;
	else if (search == combusting) type = 3062;
	else if (search == crystals) type = 2244;
	string recipe = "", show_number = "", go_back = "";
	if (pInfo(peer)->page_item != "") {
		vector<string> search_item;
		for (int i = 0; i < search.size(); i++) {
			std::size_t pos = search[i].find("``");
			string search_through = "";
			if (pos != std::string::npos) {
				search_through = search[i].substr(0, pos + 1);
				if (to_lower(search_through).find(to_lower(pInfo(peer)->page_item)) != string::npos) search_item.push_back(search[i]);
			}
		}
		pages = search_item.size();
		if (search_item.size() == 0) recipe = "\nadd_label_with_icon|small|`wRecipe not found!``|left|20|";
		else {
			int search_through = pInfo(peer)->page_number;
			int minimal = 26;
			if (search_through >= pages) search_through = search_item.size();
			show_number = (pInfo(peer)->page_number == 26 ? "1" : to_string(pInfo(peer)->page_number - 26)) + "-" + to_string(search_through);
			if (search_item.size() >= 26) {
				for (int i = pInfo(peer)->page_number - 26; i < search_through; i++) recipe += search_item[i];
				if (search_through > 26) go_back = "\nadd_button|last_pg|`wPrevious Page``|";
			}
			else for (int i = 0; i < search_item.size(); i++) recipe += search_item[i];
		}
	}
	else {
		int search_through = pInfo(peer)->page_number, minimal = 26;
		if (search_through > search.size()) {
			int remove = search.size() - 26;
			if (remove < 26) pInfo(peer)->page_number = search.size() - remove;
			else   pInfo(peer)->page_number = remove;
			minimal = 0;
			show_number = to_string(pInfo(peer)->page_number) + "-" + to_string(search.size());
			block = true;
		}
		else {
			if (pInfo(peer)->page_number > search.size()) show_number = to_string(search.size()) + "-" + to_string(search_through);
			else show_number = (pInfo(peer)->page_number == 26 ? "1" : to_string(pInfo(peer)->page_number - 26)) + "-" + to_string(search_through);
		}
		for (int i = pInfo(peer)->page_number - minimal; i < (block ? search.size() : search_through); i++) recipe += search[i];
		if (search_through > 26) go_back = "\nadd_button|last_pg|`wPrevious Page``|";
	}
	string next_page = "\nadd_button|next_pg|`wNext Page``|", a = "";
	if (block) next_page = "";
	gamepacket_t p;
	p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_quick_exit\nadd_label_with_icon|big|`w" + a + (type == 13 ? "Splicing" : type == 912 ? "Combining" : type == 3062 ? "Combusting" : "Crystals") + " Recipes``|left|" + to_string(type) + "|" + error + "\nadd_text_input|query|Search Items|" + pInfo(peer)->page_item + "|32|\nadd_button|search|`wSearch``|\nadd_spacer|small|" + (pInfo(peer)->page_item != "" && pages == 0 ? "" : "\nadd_textbox|`wShowing results " + (show_number)+"/" + (pages == 0 ? to_string(search.size()) : to_string(pages)) + "|") + ((pInfo(peer)->page_item == "" && pages == 0) or (pInfo(peer)->page_number < pages and block == false) ? next_page : "") + go_back + "\n" + recipe + "\nadd_spacer|small|\nend_dialog|guide_book_" + (type == 13 ? "s" : type == 912 ? "c" : type == 3062 ? "f" : "r") + "||`wBack``|"), p.CreatePacket(peer);
}
void RandomizeCQuest(ENetPeer* p_) {
	if (pInfo(p_)->C_QuestKind != 0) return;
	if (pInfo(p_)->CQ) pInfo(p_)->CQ = false;
	int RandomQuest = rand() % 15 + 1;
	if (RandomQuest == 1) {
		pInfo(p_)->C_QuestKind = 1;
	GenerateAgain:
		int RandomItem = rand() % items.size() + 34;
		if (items[RandomItem].r_1 == 2035 || items[RandomItem].r_2 == 2035 || items[RandomItem].r_1 == 2037 || items[RandomItem].r_2 == 2037 || items[RandomItem].blockType == BlockTypes::LOCK || items[RandomItem].blockType == BlockTypes::SEED || items[RandomItem].r_1 == 0 || items[RandomItem].r_2 == 0 || items[RandomItem].properties & Property_Untradable || items[RandomItem].properties & Property_Mod || items[RandomItem].rarity == 999 || items[RandomItem].rarity >= 150) goto GenerateAgain;
		else {
			pInfo(p_)->C_DeliverID = RandomItem;
			pInfo(p_)->C_ProgressNeeded = rand() % 300 + 1;
		}
	}
	if (RandomQuest == 2) {
		int RandomProg = rand() % 20000;
		if (RandomProg <= 1000) RandomProg += 1000;
		pInfo(p_)->C_QuestKind = 2;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 3) {
		int RandomProg = rand() % 20000;
		if (RandomProg <= 1000) RandomProg += 1000;
		pInfo(p_)->C_QuestKind = 3;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 4) {
		int RandomProg = rand() % 2500;
		if (RandomProg <= 500) RandomProg += 500;
		pInfo(p_)->C_QuestKind = 4;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 5) {
		int RandomProg = rand() % 20000;
		if (RandomProg <= 1000) RandomProg += 1000;
		pInfo(p_)->C_QuestKind = 5;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 6) {
		int RandomProg = rand() % 10000;
		if (RandomProg <= 1000) RandomProg += 1000;
		pInfo(p_)->C_QuestKind = 6;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 7) {
		int RandomProg = rand() % 100000;
		if (RandomProg <= 20000) RandomProg += 20000;
		pInfo(p_)->C_QuestKind = 7;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 8) {
		int RandomProg = rand() % 200 + 1;
		pInfo(p_)->C_DeliverID = 242;
		pInfo(p_)->C_QuestKind = 8;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 9) {
		int RandomProg = rand() % 25 + 1;
		if (RandomProg <= 3) RandomProg += 5;
		pInfo(p_)->C_QuestKind = 9;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 10) {
		int RandomProg = rand() % 1000 + 1;
		pInfo(p_)->C_QuestKind = 10;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 11) {
		int RandomProg = rand() % 5 + 1;
		pInfo(p_)->C_QuestKind = 11;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 12) {
		int RandomProg = rand() % 15 + 1;
		if (RandomProg <= 3) RandomProg += 5;
		pInfo(p_)->C_QuestKind = 12;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 13) {
		int RandomProg = rand() % 25 + 1;
		if (RandomProg <= 3) RandomProg += 5;
		pInfo(p_)->C_QuestKind = 13;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 14) {
		int RandomProg = rand() % 3000 + 1;
		if (RandomProg <= 200) RandomProg += 400;
		pInfo(p_)->C_QuestKind = 14;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 15) {
		int RandomProg = rand() % 10 + 1;
		pInfo(p_)->C_QuestKind = 15;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
}

void SendCarnivalQuest(ENetPeer* p_, int delay) {
	if (!pInfo(p_)->C_QuestActive) return;
	if (pInfo(p_)->CQ) pInfo(p_)->CQ = false;
	try {
		string step = to_string(pInfo(p_)->C_QuestStep);
		string quest_info = "", current_progress = "", deliver = "", extra = "";
		int QuestKind = pInfo(p_)->C_QuestKind, ProgressNeeded = pInfo(p_)->C_ProgressNeeded, item = pInfo(p_)->C_DeliverID;
		// QuestKind 1 = Deliver
		// QuestKind 2 = Harvest
		// QuestKind 3 = Plant Rarity
		// QuestKind 4 = Break Block
		// QuestKind 5 = Break Rarity Block
		// QuestKind 6 = Earn XP
		// QuestKind 7 = Deliver Gems
		// QuestKind 8 = Deliver World Lock
		// QuestKind 9 = Perform Surgery
		// QuestKind 10 = Harvest Provider
		// QuestKind 11 = Earn Growtoken
		// QuestKind 12 = Shatter Crystal
		// QuestKind 13 = Geiger Counter
		// QuestKind 14 = Fishing lb fish
		// QuestKind 15 = DNA Splicing
		if (QuestKind == 0) {
			RandomizeCQuest(p_);
			return;
		}
		switch (QuestKind) {
		case 1: {
			quest_info = "Your task is to bring me " + fixint(ProgressNeeded) + " of them " + items[item].ori_name + " things!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "You have none to deliver!";
			int adaBrp = 0;
			modify_inventory(p_, item, adaBrp);
			if (adaBrp != 0) {
				if (pInfo(p_)->C_QuestProgress + adaBrp > ProgressNeeded) adaBrp = ProgressNeeded - pInfo(p_)->C_QuestProgress;
				deliver = "Deliver " + fixint(adaBrp) + " " + items[item].ori_name + "";
			}
			break;
		}
		case 2: {
			quest_info = "You must pluck " + fixint(ProgressNeeded) + " rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
			extra = "\nadd_smalltext|`o(For example, if you smash a rarity-50 tree and get 3 fruit from it, you get 150 points)|";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I will go pick fruit!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "The fruit is no more!";
			}
			break;
		}
		case 3: {
			quest_info = "You must plant " + fixint(ProgressNeeded) + " rarity worth of trees!";
			extra = "\nadd_smalltext|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I will go plant more!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I have planted them all!";
			}
			break;
		}
		case 4: {
			quest_info = "You must crush " + fixint(ProgressNeeded) + " blocks for me! I don't care what kind!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "Keep on smashing!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I bashed 'em good!";
			}
			break;
		}
		case 5: {
			quest_info = "You must pummel " + fixint(ProgressNeeded) + " rarity worth of blocks! Destroy!";
			extra = "\nadd_smalltext|(For example, if you smash a block of rarity 50, you get 50 points. A Dirt block is 1 point because it is rarity 1)|";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I will go smash more!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "No block can beat me!";
			}
			break;
		}
		case 6: {
			quest_info = "Here's a freeform quest for you - I don't care what you do, just earn " + fixint(ProgressNeeded) + " XP doing it!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I'm on my way!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I have learned!";
			}
			break;
		}
		case 7: {
			quest_info = "It's traditional to grease the palm of an old carnie such as myself if you want to loosen up one of these rings in the hopes of it falling into your pocket... What I mean by that is, give me " + fixint(ProgressNeeded) + " Gems. Now.";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "You have none to deliver!";
			int adaBrp = pInfo(p_)->gems;
			if (adaBrp != 0) {
				if (pInfo(p_)->C_QuestProgress + adaBrp > ProgressNeeded) adaBrp = ProgressNeeded - pInfo(p_)->C_QuestProgress;
				deliver = "Deliver " + fixint(adaBrp) + " Gems";
			}
			break;
		}
		case 8: {
			quest_info = "Your task is to bring me " + fixint(ProgressNeeded) + " of them World Lock things!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "You have none to deliver!";
			int adaBrp = 0;
			modify_inventory(p_, 242, adaBrp);
			if (adaBrp != 0) {
				if (pInfo(p_)->C_QuestProgress + adaBrp > ProgressNeeded) adaBrp = ProgressNeeded - pInfo(p_)->C_QuestProgress;
				deliver = "Deliver " + fixint(ProgressNeeded) + " " + items[242].ori_name + "";
			}
			break;
		}
		case 9: {
			quest_info = "Do some good for the world. Save " + fixint(ProgressNeeded) + " ailing Growtopians by performing surgery!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "You haven't helped enough!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "Saving lives is what I do";
			}
			break;
		}
		case 10: {
			quest_info = "I need you to go pick up some groceries for me. Collect " + fixint(ProgressNeeded) + " items from Providers.";
			extra = "\nadd_smalltext|(Providers are items like Science Stations and Cows, that give you an item on a regular basis)|";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I'm on my way!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I'm a cow-puncher!";
			}
			break;
		}
		case 11: {
			quest_info = "Prove your skill! Earn " + fixint(ProgressNeeded) + " Growtokens! You can keep the Growtokens, I'm more popular than you can imagine!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I will quest onward!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I am talented!";
			}
			break;
		}
		case 12: {
			quest_info = "I want you to achieve inner peace. Shatter " + fixint(ProgressNeeded) + " crystals that are in harmonic resonance.";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I'm on my way!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "Does your hand hurt?";
			}
			break;
		}
		case 13: {
			quest_info = "Let's see how good you are at finding stuff. Go collect " + fixint(ProgressNeeded) + " radioactive items with a Geiger Counter. You can keep them!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I'm on my way!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "These feel warm!";
			}
			break;
		}
		case 14: {
			quest_info = "I hate fish. Could you go catch " + fixint(ProgressNeeded) + "lbs of fish? You can keep them, I just wanna know they suffered.";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "Get them no-good fish!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I caught em!";
			}
			break;
		}
		case 15: {
			quest_info = "Splice DNA into " + fixint(ProgressNeeded) + " prehistoric thing for me! You can keep them, I just want to see them brought back to life.";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "Go make life from rocks!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I made em!";
			}
			break;
		}
		}
		gamepacket_t p(delay);
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Ring``|left|1900|\nadd_smalltext|`o(Step " + step + "/10)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_smalltext|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nadd_spacer|small|\nadd_textbox|If you had 5 rings of the same type maybe we could have made a deal...|\nadd_spacer|small|\nend_dialog|carnival|Goodbye!||");
		p.CreatePacket(p_);
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_honor(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "honor") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1: {
				quest_info = "I challenge you to bring me 2,000 of those Sand thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 442, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Sand";
				}
				break;
			}
			case 2: {
				quest_info = "I challenge you to bring me 100 of those Portraits thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 3818, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100) adaBrp = 100 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Portrait";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{
				quest_info = "I challenge you to bring me 600 of those Display Box thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/600)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1422, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Display Box";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 6:
			{
				quest_info = "Prove your skill! Earn 28 Growtokens in whatever way you want!<CR>You can keep the Growtokens, I'm not a greedy wizard.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/28)";
				deliver = "I will quest onward!";
				if (pInfo(p_)->quest_progress >= 28) {
					current_progress = "(Current progress 28/28)";
					deliver = "I am talented!";
				}
				break;
			}
			case 7:
			{
				quest_info = "I challenge you to bring me 3 of those Golden Diaper thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1462, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Golden Diaper";
				}
				break;
			}
			case 8:
			{
				quest_info = "Here's a freeform quest for you - I don't care what you do, just earn 10,000 XP doing it!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 10000) {
					current_progress = "(Current progress 10,000/10,000)";
					deliver = "I have learned!";
				}
				break;
			}
			case 9:
			{
				quest_info = "I challenge you to bring me 1,000 of those Tombstone thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 784, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Tombstone";
				}
				break;
			}
			case 10:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just spot me like 100,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "You have none to deliver!";
				int adaBrp = pInfo(p_)->gems;
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100000) adaBrp = 100000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + fixint(adaBrp) + " Gems";
				}
				break;
			}
			case 11:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 12:
			{
				quest_info = "Do some good for the world. Save 100 ailing Growtopians by performing surgery!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You haven't helped enough!";
				if (pInfo(p_)->quest_progress >= 100) {
					current_progress = "(Current progress 100/100)";
					deliver = "Saving lives is what I do";
				}
				break;
			}
			case 13:
			{
				quest_info = "I need you to pick up some groceries for me. Collect 1,000 items from Providers.";
				extra = "\nadd_label|small|`o(Providers are items like Science Stations and Cows, that give you an item on a regular basis)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 1000) {
					current_progress = "(Current progress 1,000/1,000)";
					deliver = "I'm a cow-puncher!";
				}
				break;
			}
			case 14:
			{
				quest_info = "I challenge you to bring me 3 of those Golden Heart Crystal thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1458, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Golden Heart Crystal";
				}
				break;
			}
			case 15:
			{
				quest_info = "You must pluck 100,000 rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
				extra = "\nadd_label|small|`o(For example, if you smash a rarity 50 tree and get 3 fruit from it, you will get 150 points)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go pick fruit!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "The fruit is no more!";
				}
				break;
			}
			case 16:
			{
				quest_info = "I challenge you to bring me 1 of those Growie Award thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1614, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Growie Award";
				}
				break;
			}
			case 17:
			{
				quest_info = "I challenge you to bring me 3 of those Super Firework thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1680, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Super Firework";
				}
				break;
			}
			case 18:
			{
				quest_info = "I challenge you to bring me a pairs of Rainbow Wings thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1672, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Rainbow Wings";
				}
				break;
			}
			case 19:
			{
				quest_info = "I challenge you to bring me 3 of those Birth Certificate thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1280, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Birth Certificate";
				}
				break;
			}
			case 20:
			{
				quest_info = "And finally, i dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1794, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Legendary Orb";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For Honor``|left|1790|\nadd_textbox|`o(Step " + step + "/20)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_fire(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "fire") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1: {
				quest_info = "I challenge you to bring me 2,000 of those Lava thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 4, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Lava";
				}
				break;
			} // CONTINUE AFTER FIXING SHIT
			case 2: {
				quest_info = "I challenge you to bring me 10 of those Paintbrushes!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 3494, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Paintbrush";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{
				quest_info = "I challenge you to bring me 600 of those Dragon Gate thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/600)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 598, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Dragon Gate";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 6:
			{
				quest_info = "Prove your skill! Earn 28 Growtokens in whatever way you want!<CR>You can keep the Growtokens, I'm not a greedy wizard.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/28)";
				deliver = "I will quest onward!";
				if (pInfo(p_)->quest_progress >= 28) {
					current_progress = "(Current progress 28/28)";
					deliver = "I am talented!";
				}
				break;
			}
			case 7:
			{
				quest_info = "I challenge you to bring me 10 of those Dragon Hand thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 900, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Dragon Hand";
				}
				break;
			}
			case 8:
			{
				quest_info = "Here's a freeform quest for you - I don't care what you do, just earn 10,000 XP doing it!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 10000) {
					current_progress = "(Current progress 10,000/10,000)";
					deliver = "I have learned!";
				}
				break;
			}
			case 9:
			{
				quest_info = "I challenge you to bring me 1,000 of those Dragon Tail thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1114, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Dragon Tail";
				}
				break;
			}
			case 10:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just spot me like 100,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "You have none to deliver!";
				int adaBrp = pInfo(p_)->gems;
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100000) adaBrp = 100000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + fixint(adaBrp) + " Gems";
				}
				break;
			}
			case 11:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 12:
			{
				quest_info = "Do some good for the world. Save 100 ailing Growtopians by performing surgery!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You haven't helped enough!";
				if (pInfo(p_)->quest_progress >= 100) {
					current_progress = "(Current progress 100/100)";
					deliver = "Saving lives is what I do";
				}
				break;
			}
			case 13:
			{
				quest_info = "I need you to pick up some groceries for me. Collect 1,000 items from Providers.";
				extra = "\nadd_label|small|`o(Providers are items like Science Stations and Cows, that give you an item on a regular basis)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 1000) {
					current_progress = "(Current progress 1,000/1,000)";
					deliver = "I'm a cow-puncher!";
				}
				break;
			}
			case 14:
			{
				quest_info = "I challenge you to bring me 5 of those Ice Dragon Hand thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1378, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Ice Dragon Hand";
				}
				break;
			}
			case 15:
			{
				quest_info = "You must pluck 100,000 rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
				extra = "\nadd_label|small|`o(For example, if you smash a rarity 50 tree and get 3 fruit from it, you will get 150 points)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go pick fruit!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "The fruit is no more!";
				}
				break;
			}
			case 16:
			{
				quest_info = "I challenge you to bring me 1 of those Ultra Trophy 3000 thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 394, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Ultra Trophy 3000";
				}
				break;
			}
			case 17:
			{
				quest_info = "I challenge you to bring me 5 of those Black Crystal Dragon!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 2212, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Black Crystal Dragon";
				}
				break;
			}
			case 18:
			{
				quest_info = "I challenge you to bring me 2 of those Devil Wings thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1206, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2) adaBrp = 2 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Devil Wings";
				}
				break;
			}
			case 19:
			{
				quest_info = "I challenge you to bring me a pairs of Teeny Devil Wings thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 3120, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Teeny Devil Wings";
				}
				break;
			}
			case 20:
			{
				quest_info = "And finally, i dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1794, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Legendary Orb";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For Fire``|left|1790|\nadd_textbox|`o(Step " + step + "/20)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_steel(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "steel") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1: {
				quest_info = "I challenge you to bring me 2,000 of those Chemical G thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 914, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Chemical G";
				}
				break;
			}
			case 2: {
				quest_info = "I challenge you to bring me 3 of those Robotic Lock thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 2950, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Robotic Lock";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{
				quest_info = "I challenge you to bring me 600 of those Robot Wants Dubstep thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/600)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 254, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Robot Wants Dubstep";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 6:
			{
				quest_info = "Prove your skill! Earn 28 Growtokens in whatever way you want!<CR>You can keep the Growtokens, I'm not a greedy wizard.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/28)";
				deliver = "I will quest onward!";
				if (pInfo(p_)->quest_progress >= 28) {
					current_progress = "(Current progress 28/28)";
					deliver = "I am talented!";
				}
				break;
			}
			case 7:
			{
				quest_info = "I challenge you to bring me 10 of those Edison Zoomster thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1274, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Edison Zoomster";
				}
				break;
			}
			case 8:
			{
				quest_info = "Here's a freeform quest for you - I don't care what you do, just earn 10,000 XP doing it!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 10000) {
					current_progress = "(Current progress 10,000/10,000)";
					deliver = "I have learned!";
				}
				break;
			}
			case 9:
			{
				quest_info = "I challenge you to bring me 1,000 of those High Tech Block thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 324, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " High Tech Block";
				}
				break;
			}
			case 10:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just spot me like 100,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "You have none to deliver!";
				int adaBrp = pInfo(p_)->gems;
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100000) adaBrp = 100000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + fixint(adaBrp) + " Gems";
				}
				break;
			}
			case 11:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 12:
			{
				quest_info = "Do some good for the world. Save 100 ailing Growtopians by performing surgery!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You haven't helped enough!";
				if (pInfo(p_)->quest_progress >= 100) {
					current_progress = "(Current progress 100/100)";
					deliver = "Saving lives is what I do";
				}
				break;
			}
			case 13:
			{
				quest_info = "I need you to pick up some groceries for me. Collect 1,000 items from Providers.";
				extra = "\nadd_label|small|`o(Providers are items like Science Stations and Cows, that give you an item on a regular basis)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 1000) {
					current_progress = "(Current progress 1,000/1,000)";
					deliver = "I'm a cow-puncher!";
				}
				break;
			}
			case 14:
			{
				quest_info = "I challenge you to bring me 3 of those Bride Of Reanimator Remote thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1250, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Bride Of Reanimator Remote";
				}
				break;
			}
			case 15:
			{
				quest_info = "You must pluck 100,000 rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
				extra = "\nadd_label|small|`o(For example, if you smash a rarity 50 tree and get 3 fruit from it, you will get 150 points)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go pick fruit!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "The fruit is no more!";
				}
				break;
			}
			case 16:
			{
				quest_info = "I challenge you to bring me 1 of those Mint Julep thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1602, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Mint Julep";
				}
				break;
			}
			case 17:
			{
				quest_info = "I challenge you to bring me 5 of those Kerjigger Thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1354, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Kerjigger";
				}
				break;
			}
			case 18:
			{
				quest_info = "I challenge you to bring me 5 of those Doohickey thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1396, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Doohickey";
				}
				break;
			}
			case 19:
			{
				quest_info = "I challenge you to bring me 5 of those Doodad thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1492, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Doodad";
				}
				break;
			}
			case 20:
			{
				quest_info = "And finally, i dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1794, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Legendary Orb";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For Steel ``|left|1790|\nadd_textbox|`o(Step " + step + "/20)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_kamish(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "Ruler Sword") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1: {
					quest_info = "You must crush 50,000 blocks! Destroy!";
					current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
					deliver = "You are not yet worthy!";
					if (pInfo(p_)->quest_progress >= 50000) {
						current_progress = "Current progress 50,000/50,000)";
						deliver = "I have slain them all!";
					}
					break;
				}
			case 2: {
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 3:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just show me like 2,000,000,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,000,000,000)";
				int adaBrp = 2000000000 - pInfo(p_)->quest_progress;
				if (adaBrp > 0) {
					deliver = "I need "+to_string(adaBrp)+" more gems";
				}
				else {
					deliver = "Next step!";
				}
				break;
			}
			case 4:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 100,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 100000) {
				current_progress = "(Current progress 100,000/100,000)";
				deliver = "I have planted them all!";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For `4Kamish Sword``|left|1790|\nadd_textbox|`o(Step " + step + "/5)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}


void send_QuestView_heavens(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "heavens") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1: {
				quest_info = "I challenge you to bring me 1,000 of those Clouds thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 728, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Clouds";
				}
				break;
			}
			case 2: {
				quest_info = "I challenge you to bring me 1 of those Pegasus Wings thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 9760, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Pegasus Wings";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{
				quest_info = "I challenge you to bring me 600 of those Fairy Wings thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/600)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 156, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Fairy Wings";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For `4Kamish Sword``|left|1790|\nadd_textbox|`o(Step " + step + "/5)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_blade(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "blade") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1: {
				quest_info = "I challenge you to bring me 1,000 of those Iron Bars thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 684, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Iron Bars";
				}
				break;
			}
			case 2: {
				quest_info = "I challenge you to bring me 10 of those Geiger Counter thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 2204, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Geiger Counter";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{
				quest_info = "I challenge you to bring me 600 of those Golden Sword thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/600)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 604, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Golden Sword";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 6:
			{
				quest_info = "Prove your skill! Earn 28 Growtokens in whatever way you want!<CR>You can keep the Growtokens, I'm not a greedy wizard.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/28)";
				deliver = "I will quest onward!";
				if (pInfo(p_)->quest_progress >= 28) {
					current_progress = "(Current progress 28/28)";
					deliver = "I am talented!";
				}
				break;
			}
			case 7:
			{
				quest_info = "I challenge you to bring me 3 of those Heavenly Scythe thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 2386, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Heavenly Scythe";
				}
				break;
			}
			case 8:
			{
				quest_info = "Here's a freeform quest for you - I don't care what you do, just earn 10,000 XP doing it!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 10000) {
					current_progress = "(Current progress 10,000/10,000)";
					deliver = "I have learned!";
				}
				break;
			}
			case 9:
			{
				quest_info = "I challenge you to bring me 800 of those Headsman's Axe thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/800)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 690, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 800) adaBrp = 800 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Headsman's Axe";
				}
				break;
			}
			case 10:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just spot me like 100,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "You have none to deliver!";
				int adaBrp = pInfo(p_)->gems;
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100000) adaBrp = 100000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + fixint(adaBrp) + " Gems";
				}
				break;
			}
			case 11:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 12:
			{
				quest_info = "I seem to have lost some mystic energy. Could you go find 100 radioactive items with a Geiger Counter? You can keep them, I just want the energy.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You haven't found enough!";
				if (pInfo(p_)->quest_progress >= 100) {
					current_progress = "(Current progress 100/100)";
					deliver = "Have some radiation";
				}
				break;
			}
			case 13:
			{
				quest_info = "I need you to pick up some groceries for me. Collect 1,000 items from Providers.";
				extra = "\nadd_label|small|`o(Providers are items like Science Stations and Cows, that give you an item on a regular basis)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 1000) {
					current_progress = "(Current progress 1,000/1,000)";
					deliver = "I'm a cow-puncher!";
				}
				break;
			}
			case 14:
			{
				quest_info = "I challenge you to bring me 20 of those Flamesaber thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/20)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 810, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 20) adaBrp = 20 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Flamesaber";
				}
				break;
			}
			case 15:
			{
				quest_info = "You must pluck 100,000 rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
				extra = "\nadd_label|small|`o(For example, if you smash a rarity 50 tree and get 3 fruit from it, you will get 150 points)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go pick fruit!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "The fruit is no more!";
				}
				break;
			}
			case 16:
			{
				quest_info = "I challenge you to bring me 1 of those Golden Apple thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 2002, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Golden Apple";
				}
				break;
			}
			case 17:
			{
				quest_info = "I challenge you to bring me 25 of those Carrot Sword Thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/25)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 2908, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 25) adaBrp = 25 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Carrot Sword";
				}
				break;
			}
			case 18:
			{
				quest_info = "I challenge you to bring me 1 of those Black Balrog's Tail Thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10334, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Black Balrog's Tail";
				}
				break;
			}
			case 19:
			{
				quest_info = "I challenge you to bring me 1,000 of those Sword thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 94, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Sword";
				}
				break;
			}
			case 20:
			{
				quest_info = "And finally, i dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1794, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Legendary Orb";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For Blade``|left|1790|\nadd_textbox|`o(Step " + step + "/20)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_candour(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "candour") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1:
			{
				quest_info = "I challenge you to bring me 2,000 of those Chemical Y thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 924, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Chemical Y";
				}
				break;
			}
			case 2:
			{
				quest_info = "I challenge you to bring me 50 of those Adventurer's Whip thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 4778, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 50) adaBrp = 50 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Adventurer's Whip";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{ //should be changed #1
				quest_info = "I challenge you to bring me 1000 of those Golden Block thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 260, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Golden Block";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 6:
			{
				quest_info = "Prove your skill! Earn 28 Growtokens in whatever way you want!<CR>You can keep the Growtokens, I'm not a greedy wizard.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/28)";
				deliver = "I will quest onward!";
				if (pInfo(p_)->quest_progress >= 28) {
					current_progress = "(Current progress 28/28)";
					deliver = "I am talented!";
				}
				break;
			}
			case 7:
			{
				quest_info = "I challenge you to bring me 10 of those Super Squirt Gun Jetpack thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 4880, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Super Squirt Gun Jetpack";
				}
				break;
			}
			case 8:
			{
				quest_info = "Here's a freeform quest for you - I don't care what you do, just earn 10,000 XP doing it!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 10000) {
					current_progress = "(Current progress 10,000/10,000)";
					deliver = "I have learned!";
				}
				break;
			}
			case 9:
			{
				quest_info = "I challenge you to bring me 5 of those Soul Stones thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 5202, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Soul Stones";
				}
				break;
			}
			case 10:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just spot me like 100,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "You have none to deliver!";
				int adaBrp = pInfo(p_)->gems;
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100000) adaBrp = 100000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + fixint(adaBrp) + " Gems";
				}
				break;
			}
			case 11:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 12:
			{
				quest_info = "I seem to have lost some mystic energy. Could you go find 100 radioactive items with a Geiger Counter? You can keep them, I just want the energy.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You haven't found enough!";
				if (pInfo(p_)->quest_progress >= 100) {
					current_progress = "(Current progress 100/100)";
					deliver = "Have some radiation";
				}
				break;
			}
			case 13:
			{
				quest_info = "I hate fish. Could you go catch 2,500lbs of fish? You can keep them, I just wanna know they suffered.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,500)";
				deliver = "Get them no-good fish!";
				if (pInfo(p_)->quest_progress >= 2500) {
					current_progress = "(Current progress 2,500/2,500)";
					deliver = "I caught em!";
				}
				break;
			}
			case 14:
			{
				quest_info = "I challenge you to bring me 3 of those Celestial Lance thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 5276, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Celestial Lance";
				}
				break;
			}
			case 15:
			{
				quest_info = "You must pluck 100,000 rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
				extra = "\nadd_label|small|`o(For example, if you smash a rarity 50 tree and get 3 fruit from it, you will get 150 points)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go pick fruit!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "The fruit is no more!";
				}
				break;
			}
			case 16:
			{
				quest_info = "I challenge you to bring me 3 of those Hooves of Cernunnos thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10678, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Hooves of Cernunnos";
				}
				break;
			}
			case 17:
			{
				quest_info = "I challenge you to bring me 3 of those Golden Talaria Thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 5650, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Golden Talaria";
				}
				break;
			}
			case 18:
			{
				quest_info = "I challenge you to bring me 1 of those Ultra Trophy 3000 thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 394, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Ultra Trophy 3000";
				}
				break;
			}
			case 19:
			{
				quest_info = "I challenge you to bring me 3 of those Ancestral Totems of Wisdom thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 5078, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Ancestral Totems of Wisdom";
				}
				break;
			}
			case 20:
			{
				quest_info = "And finally, i dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1794, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Legendary Orb";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For Candour ``|left|1790|\nadd_textbox|`o(Step " + step + "/20)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_thesky(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "thesky") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1:
			{
				quest_info = "I challenge you to bring me 2,000 of those Obsidian thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 5042, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Obsidian";
				}
				break;
			}
			case 2:
			{
				quest_info = "I challenge you to bring me 100 of those Fossil thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 3936, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100) adaBrp = 100 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Fossil";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{
				quest_info = "I challenge you to bring me 1,000 of those Knight Helmet thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1736, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Knight Helmet";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 6:
			{
				quest_info = "Prove your skill! Earn 28 Growtokens in whatever way you want!<CR>You can keep the Growtokens, I'm not a greedy wizard.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/28)";
				deliver = "I will quest onward!";
				if (pInfo(p_)->quest_progress >= 28) {
					current_progress = "(Current progress 28/28)";
					deliver = "I am talented!";
				}
				break;
			}
			case 7:
			{
				quest_info = "I challenge you to bring me 10 of those Blanket Cape thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 2982, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Blanket Cape";
				}
				break;
			}
			case 8:
			{
				quest_info = "Here's a freeform quest for you - I don't care what you do, just earn 10,000 XP doing it!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 10000) {
					current_progress = "(Current progress 10,000/10,000)";
					deliver = "I have learned!";
				}
				break;
			}
			case 9:
			{
				quest_info = "I challenge you to bring me 800 of those Blazing Electro Wing thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/800)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1936, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 800) adaBrp = 800 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Blazing Electro Wing";
				}
				break;
			}
			case 10:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just spot me like 100,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "You have none to deliver!";
				int adaBrp = pInfo(p_)->gems;
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100000) adaBrp = 100000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + fixint(adaBrp) + " Gems";
				}
				break;
			}
			case 11:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 12:
			{
				quest_info = "Do some good for the world. Save 100 ailing Growtopians by performing surgery!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You haven't helped enough!";
				if (pInfo(p_)->quest_progress >= 100) {
					current_progress = "(Current progress 100/100)";
					deliver = "Saving lives is what I do";
				}
				break;
			}
			case 13:
			{
				quest_info = "I hate fish. Could you go catch 2,500lbs of fish? You can keep them, I just wanna know they suffered.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,500)";
				deliver = "Get them no-good fish!";
				if (pInfo(p_)->quest_progress >= 2500) {
					current_progress = "(Current progress 2,500/2,500)";
					deliver = "I caught em!";
				}
				break;
			}
			case 14:
			{
				quest_info = "I challenge you to bring me 10 of those Autumn Wing thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1824, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Autumn Wing";
				}
				break;
			}
			case 15:
			{
				quest_info = "You must pluck 100,000 rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
				extra = "\nadd_label|small|`o(For example, if you smash a rarity 50 tree and get 3 fruit from it, you will get 150 points)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go pick fruit!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "The fruit is no more!";
				}
				break;
			}
			case 16:
			{
				quest_info = "I challenge you to bring me 1 of those Golden Dragon Statue thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 4302, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Golden Dragon Statue";
				}
				break;
			}
			case 17:
			{
				quest_info = "I challenge you to bring me 5 of those Chaos Dragon Thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 7762, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Chaos Dragon";
				}
				break;
			}
			case 18:
			{
				quest_info = "I challenge you to bring me 1 of those Draconic Wing thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 5754, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Draconic Wing";
				}
				break;
			}
			case 19:
			{
				quest_info = "I challenge you to bring me 10 of those Dragon Knight's Chestplate thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 7728, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Dragon Knight's Chestplate";
				}
				break;
			}
			case 20:
			{
				quest_info = "And finally, i dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1794, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Legendary Orb";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Sky ``|left|1790|\nadd_textbox|`o(Step " + step + "/20)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_theowl(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "theowl") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1:
			{
				quest_info = "I challenge you to bring me 2,000 of those Clouds Wallpaper thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 8206, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Clouds Wallpaper";
				}
				break;
			}
			case 2:
			{
				quest_info = "I challenge you to bring me 1,500 of those Fissure thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,500)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 5032, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1500) adaBrp = 1500 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Fissure";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{
				quest_info = "I challenge you to bring me 50 of those Owl Mask thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10160, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 50) adaBrp = 50 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Owl Mask";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 6:
			{
				quest_info = "Prove your skill! Earn 28 Growtokens in whatever way you want!<CR>You can keep the Growtokens, I'm not a greedy wizard.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/28)";
				deliver = "I will quest onward!";
				if (pInfo(p_)->quest_progress >= 28) {
					current_progress = "(Current progress 28/28)";
					deliver = "I am talented!";
				}
				break;
			}
			case 7:
			{
				quest_info = "I challenge you to bring me 50 of those Alaskan King Crab Crown thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 11152, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 50) adaBrp = 50 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Alaskan King Crab Crown";
				}
				break;
			}
			case 8:
			{
				quest_info = "Here's a freeform quest for you - I don't care what you do, just earn 10,000 XP doing it!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 10000) {
					current_progress = "(Current progress 10,000/10,000)";
					deliver = "I have learned!";
				}
				break;
			}
			case 9:
			{
				quest_info = "I challenge you to bring me 10 of those Sun Shooter Bow thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10130, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Sun Shooter Bow";
				}
				break;
			}
			case 10:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just spot me like 100,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "You have none to deliver!";
				int adaBrp = pInfo(p_)->gems;
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100000) adaBrp = 100000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + fixint(adaBrp) + " Gems";
				}
				break;
			}
			case 11:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 12:
			{
				quest_info = "Do some good for the world. Save 100 ailing Growtopians by performing surgery!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You haven't helped enough!";
				if (pInfo(p_)->quest_progress >= 100) {
					current_progress = "(Current progress 100/100)";
					deliver = "Saving lives is what I do";
				}
				break;
			}
			case 13:
			{
				quest_info = "I hate fish. Could you go catch 2,500lbs of fish? You can keep them, I just wanna know they suffered.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,500)";
				deliver = "Get them no-good fish!";
				if (pInfo(p_)->quest_progress >= 3000) {
					current_progress = "(Current progress 2,500/2,500)";
					deliver = "I caught em!";
				}
				break;
			}
			case 14:
			{
				quest_info = "I challenge you to bring me 1 of those Golden Silk Scarf thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10634, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Golden Silk Scarf";
				}
				break;
			}
			case 15:
			{
				quest_info = "You must pluck 100,000 rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
				extra = "\nadd_label|small|`o(For example, if you smash a rarity 50 tree and get 3 fruit from it, you will get 150 points)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go pick fruit!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "The fruit is no more!";
				}
				break;
			}
			case 16:
			{
				quest_info = "I challenge you to bring me 2 of those Snow Leopard Tail thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 7416, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2) adaBrp = 2 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Snow Leopard Tail";
				}
				break;
			}
			case 17:
			{
				quest_info = "I challenge you to bring me 3 of those Ultraviolet Aura Thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 11050, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Ultraviolet Aura";
				}
				break;
			}
			case 18:
			{
				quest_info = "I challenge you to bring me 1 of those Lil Growpeep's Baaaa Blaster thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10724, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Lil Growpeep's Baaaa Blaster";
				}
				break;
			}
			case 19:
			{
				quest_info = "I challenge you to bring me 1 of those Draconic Soul Aura thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10576, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Draconic Soul Aura";
				}
				break;
			}
			case 20:
			{
				quest_info = "And finally, i dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1794, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Legendary Orb";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Owl ``|left|1790|\nadd_textbox|`o(Step " + step + "/20)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_mech(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "mech") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1:
			{
				quest_info = "I challenge you to bring me 2,000 of those Dwarven Background thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2,000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 9390, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Dwarven Background";
				}
				break;
			}
			case 2:
			{
				quest_info = "I challenge you to bring me 2,000 of those Lava Lamp thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/2000)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 5044, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Lava Lamp";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{
				quest_info = "I challenge you to bring me 600 of those Floating Hand thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/600)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10786, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Floating Hand";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 6:
			{
				quest_info = "Prove your skill! Earn 28 Growtokens in whatever way you want!<CR>You can keep the Growtokens, I'm not a greedy wizard.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/28)";
				deliver = "I will quest onward!";
				if (pInfo(p_)->quest_progress >= 28) {
					current_progress = "(Current progress 28/28)";
					deliver = "I am talented!";
				}
				break;
			}
			case 7:
			{
				quest_info = "I challenge you to bring me 15 of those Monster Truck thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/15)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 8952, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 15) adaBrp = 15 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Monster Truck";
				}
				break;
			}
			case 8:
			{
				quest_info = "Here's a freeform quest for you - I don't care what you do, just earn 10,000 XP doing it!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 10000) {
					current_progress = "(Current progress 10,000/10,000)";
					deliver = "I have learned!";
				}
				break;
			}
			case 9:
			{
				quest_info = "I challenge you to bring me 10 of those Matrix Aura thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10332, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Matrix Aura";
				}
				break;
			}
			case 10:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just spot me like 100,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "You have none to deliver!";
				int adaBrp = pInfo(p_)->gems;
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100000) adaBrp = 100000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + fixint(adaBrp) + " Gems";
				}
				break;
			}
			case 11:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 12:
			{
				quest_info = "I seem to have lost some mystic energy. Could you go find 100 radioactive items with a Geiger Counter? You can keep them, I just want the energy.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You haven't found enough!";
				if (pInfo(p_)->quest_progress >= 100) {
					current_progress = "(Current progress 100/100)";
					deliver = "Have some radiation";
				}
				break;
			}
			case 13:
			{
				quest_info = "I need you to pick up some groceries for me. Collect 1,000 items from Providers.";
				extra = "\nadd_label|small|`o(Providers are items like Science Stations and Cows, that give you an item on a regular basis)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 1000) {
					current_progress = "(Current progress 1,000/1,000)";
					deliver = "I'm a cow-puncher!";
				}
				break;
			}
			case 14:
			{
				quest_info = "I challenge you to bring me 3 of those Spike Juice thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1662, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Spike Juice";
				}
				break;
			}
			case 15:
			{
				quest_info = "You must pluck 100,000 rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
				extra = "\nadd_label|small|`o(For example, if you smash a rarity 50 tree and get 3 fruit from it, you will get 150 points)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go pick fruit!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "The fruit is no more!";
				}
				break;
			}
			case 16:
			{
				quest_info = "I challenge you to bring me 3 of those Ambu-Lance thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/3)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 11076, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Ambu-Lance";
				}
				break;
			}
			case 17:
			{
				quest_info = "I challenge you to bring me 1 of those Mining Mech Thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 9376, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Mining Mech";
				}
				break;
			}
			case 18:
			{
				quest_info = "I challenge you to bring me 1 of those Phoenix Armor thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 11008, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Phoenix Armor";
				}
				break;
			}
			case 19:
			{
				quest_info = "I challenge you to bring me 1 of those Volcanic Cape thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10806, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Volcanic Cape";
				}
				break;
			}
			case 20:
			{
				quest_info = "And finally, i dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1794, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Legendary Orb";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Mech ``|left|1790|\nadd_textbox|`o(Step " + step + "/20)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void send_QuestView_zodiac(ENetPeer* p_) {
	if (!pInfo(p_)->quest_active) return;
	try {
		pInfo(p_)->choosing_quest = "";
		if (pInfo(p_)->lastquest == "zodiac") {
			string step = to_string(pInfo(p_)->quest_step);
			string quest_info = "";
			string current_progress = "";
			string deliver = "";
			string extra = "";
			switch (pInfo(p_)->quest_step) {
			case 1:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Rabbit thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 13064, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Rabbit";
				}
				break;
			}
			case 2:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Tiger thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 11620, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Tiger";
				}
				break;
			}
			case 3:
			{
				quest_info = "You must crush 5,000 blocks! Destroy!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/5,000)";
				deliver = "You are not yet worthy!";
				if (pInfo(p_)->quest_progress >= 5000) {
					current_progress = "Current progress 5,000/5,000)";
					deliver = "I have slain them all!";
				}
				break;
			}
			case 4:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Horse thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10600, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Horse";
				}
				break;
			}
			case 5:
			{
				quest_info = "You must plant 50,000 rarity worth of trees! Bring life to this land!";
				extra = "\nadd_label|small|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/50,000)";
				deliver = "I will go plant more!";
				if (pInfo(p_)->quest_progress >= 50000) {
					current_progress = "(Current progress 50,000/50,000)";
					deliver = "I have planted them all!";
				}
				break;
			}
			case 6:
			{
				quest_info = "Prove your skill! Earn 28 Growtokens in whatever way you want!<CR>You can keep the Growtokens, I'm not a greedy wizard.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/28)";
				deliver = "I will quest onward!";
				if (pInfo(p_)->quest_progress >= 28) {
					current_progress = "(Current progress 28/28)";
					deliver = "I am talented!";
				}
				break;
			}
			case 7:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Goat thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10602, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Goat";
				}
				break;
			}
			case 8:
			{
				quest_info = "Here's a freeform quest for you - I don't care what you do, just earn 10,000 XP doing it!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/10,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 10000) {
					current_progress = "(Current progress 10,000/10,000)";
					deliver = "I have learned!";
				}
				break;
			}
			case 9:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Monkey thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10604, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Monkey";
				}
				break;
			}
			case 10:
			{
				quest_info = "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes`o! So if you could just spot me like 100,000 Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "You have none to deliver!";
				int adaBrp = pInfo(p_)->gems;
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 100000) adaBrp = 100000 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + fixint(adaBrp) + " Gems";
				}
				break;
			}
			case 11:
			{
				quest_info = "You must crush 100,000 rarity worth of blocks! Destroy!";
				extra = "\nadd_label|small|`o(For example, if you smash a block of rarity 50, you get 50 points. A dirt block is 1 point because it is rarity 1)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go smash more!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "No blocks can beat me!";
				}
				break;
			}
			case 12:
			{
				quest_info = "I seem to have lost some mystic energy. Could you go find 100 radioactive items with a Geiger Counter? You can keep them, I just want the energy.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100)";
				deliver = "You haven't found enough!";
				if (pInfo(p_)->quest_progress >= 100) {
					current_progress = "(Current progress 100/100)";
					deliver = "Have some radiation";
				}
				break;
			}
			case 13:
			{
				quest_info = "I need you to pick up some groceries for me. Collect 1,000 items from Providers.";
				extra = "\nadd_label|small|`o(Providers are items like Science Stations and Cows, that give you an item on a regular basis)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1,000)";
				deliver = "I'm on my way!";
				if (pInfo(p_)->quest_progress >= 1000) {
					current_progress = "(Current progress 1,000/1,000)";
					deliver = "I'm a cow-puncher!";
				}
				break;
			}
			case 14:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Rooster thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10606, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Rooster";
				}
				break;
			}
			case 15:
			{
				quest_info = "You must pluck 100,000 rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
				extra = "\nadd_label|small|`o(For example, if you smash a rarity 50 tree and get 3 fruit from it, you will get 150 points)|left|";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/100,000)";
				deliver = "I will go pick fruit!";
				if (pInfo(p_)->quest_progress >= 100000) {
					current_progress = "(Current progress 100,000/100,000)";
					deliver = "The fruit is no more!";
				}
				break;
			}
			case 16:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Dog thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10608, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Dog";
				}
				break;
			}
			case 17:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Pig Thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10610, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Pig";
				}
				break;
			}
			case 18:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Rat thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10612, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Rat";
				}
				break;
			}
			case 19:
			{
				quest_info = "I challenge you to bring me 1 of those Zodiac Year of the Ox thingies!";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 10614, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Zodiac Year of the Ox";
				}
				break;
			}
			case 20:
			{
				quest_info = "And finally, i dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
				current_progress = "(Current progress " + fixint(pInfo(p_)->quest_progress) + "/1)";
				deliver = "You have none to deliver!";
				int adaBrp = 0;
				modify_inventory(p_, 1794, adaBrp);
				if (adaBrp != 0) {
					if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
					deliver = "Deliver " + to_string(adaBrp) + " Legendary Orb";
				}
				break;
			}
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest Of The Constellation``|left|1790|\nadd_textbox|`o(Step " + step + "/20)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_textbox|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nend_dialog|legendary_wizard|Goodbye!||");
			p.CreatePacket(p_);
		}
	}
	catch (out_of_range& e) {
		tayo_warn(e.what());
	}
}

void update_gem_item_(World* world_, WorldDrop drop_, int target_) {
	for (int i_ = 0; i_ < world_->drop.size(); i_++) {
		if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16 and world_->drop[i_].id == 112) {
			if (world_->drop[i_].count == target_) {
				PlayerMoving data_{};
				data_.packetType = 14, data_.netID = -2, data_.plantingTree = world_->drop[i_].uid;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[]raw;
				world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
			}
		}
	}
}

int get_drop_count(int item, WorldDrop drop, World* world_) {
	int result = 0;
	for (int i_ = 0; i_ < world_->drop.size(); i_++) {
		if (abs(world_->drop[i_].y - drop.y) <= 16 and abs(world_->drop[i_].x - drop.x) <= 16 and world_->drop[i_].id == item) {
			result += world_->drop[i_].count;
		}
	}
	return result;
}

void dropas_(World* world_, WorldDrop drop_, int net_id = -1) {
	//if (drop_.y < 0 || drop_.x < 0 || drop_.id == 0) return;
	if (drop_.id == 745 || drop_.id == 747 || drop_.id == 749) drop_.id = 743;
	if (drop_.id == 629 || drop_.id == 631 || drop_.id == 633 || drop_.id == 635 || drop_.id == 637 || drop_.id == 639 || drop_.id == 641 || drop_.id == 643 || drop_.id == 645 || drop_.id == 647 || drop_.id == 649) drop_.id = 627;
	if (drop_.id == 112) {
		// gems merging
		int c_ = 0;
		for (int i_ = 0; i_ < world_->drop.size(); i_++) {
			if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16 and world_->drop[i_].id == 112) {
				c_ += world_->drop[i_].count;
			}
		}
		if (c_ != 0) {
			int b_hgem_ = c_ >= 1000 ? c_ / 1000 : 0, b_purple_ = c_ - (b_hgem_ * 1000) >= 100 ? (c_ - (b_hgem_ * 1000)) / 100 : 0, b_green_ = c_ - (b_hgem_ * 1000) - (b_purple_ * 100) >= 50 ? (c_ - (b_hgem_ * 1000) - (b_purple_ * 100)) / 50 : 0, b_red_ = c_ - (b_purple_ * 100) - (b_hgem_ * 1000) - (b_green_ * 50) >= 10 ? (c_ - (b_purple_ * 100) - (b_hgem_ * 1000) - (b_green_ * 50)) / 10 : 0, b_blue_ = c_ - (b_green_ * 50) - (b_purple_ * 100) - (b_hgem_ * 1000) - (b_red_ * 10) >= 5 ? (c_ - (b_green_ * 50) - (b_purple_ * 100) - (b_hgem_ * 1000) - (b_red_ * 10)) / 5 : 0, b_yellow_ = c_ - (b_red_ * 10) - (b_green_ * 50) - (b_purple_ * 100) - (b_hgem_ * 1000) - (b_blue_ * 5) > 0 ? (c_ - (b_red_ * 10) - (b_green_ * 50) - (b_purple_ * 100) - (b_hgem_ * 1000) - (b_blue_ * 5)) / 1 : 0;
			//int b_ggem_ = get_drop_count(5136, drop_, world_) >= 100 ? get_drop_count(5136, drop_, world_) / 100 : 0;
			c_ += drop_.count;
			int hgem_ = c_ >= 1000 ? c_ / 1000 : 0, purple_ = c_ - (hgem_ * 1000) >= 100 ? (c_ - (hgem_ * 1000)) / 100 : 0, green_ = c_ - (hgem_ * 1000) - (purple_ * 100) >= 50 ? (c_ - (hgem_ * 1000) - (purple_ * 100)) / 50 : 0, red_ = c_ - (purple_ * 100) - (hgem_ * 1000) - (green_ * 50) >= 10 ? (c_ - (purple_ * 100) - (hgem_ * 1000) - (green_ * 50)) / 10 : 0, blue_ = c_ - (green_ * 50) - (purple_ * 100) - (hgem_ * 1000) - (red_ * 10) >= 5 ? (c_ - (green_ * 50) - (purple_ * 100) - (hgem_ * 1000) - (red_ * 10)) / 5 : 0, yellow_ = c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (hgem_ * 1000) - (blue_ * 5) > 0 ? (c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (hgem_ * 1000) - (blue_ * 5)) / 1 : 0;
			//int ggem_ = hgem_ >= 100 ? hgem_ / 100 : 0;
			if (blue_ > b_blue_ or blue_ == 0 and b_blue_ != 0) {
				drop_.count = 5;
				update_gem_item_(world_, drop_, 1);
			}
			if (red_ > b_red_ or red_ == 0 and b_red_ != 0) {
				drop_.count = 10;
				update_gem_item_(world_, drop_, 5);
			}
			if (green_ > b_green_ or green_ == 0 and b_green_ != 0) {
				drop_.count = 50;
				update_gem_item_(world_, drop_, 10);
			}
			if (purple_ > b_purple_ or purple_ == 0 and b_purple_ != 0) {
				drop_.count = 100;
				update_gem_item_(world_, drop_, 50);
			}
			if (hgem_ > b_hgem_) {
				drop_.count - 1000;
				update_gem_item_(world_, drop_, 100);
				drop_.id = 5136;
				drop_.count = 1;
				for (int i_ = 0; i_ < world_->drop.size(); i_++) {
					if (world_->drop[i_].id == 0) continue;
					if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16 and world_->drop[i_].id == drop_.id and world_->drop[i_].count < 200) {
						int truksta_iki_200 = 200 - world_->drop[i_].count;
						if (drop_.count > truksta_iki_200 or world_->drop[i_].count + drop_.count <= 200) {
							int drop_atskirai = drop_.count - truksta_iki_200;
							if (world_->drop[i_].count + drop_.count <= 200) {
								world_->drop[i_].count += drop_.count;
								drop_.count = 0;
								goto lad;
							}
							drop_.count = drop_atskirai;
							world_->drop[i_].count = 200;
						lad:
							PlayerMoving data_{};
							data_.packetType = 14, data_.netID = -3, data_.plantingTree = world_->drop[i_].id;
							data_.x = world_->drop[i_].x, data_.y = world_->drop[i_].y;
							int32_t item = world_->drop[i_].uid;
							float val = world_->drop[i_].count;
							BYTE* raw = packPlayerMoving(&data_);
							memcpy(raw + 8, &item, 4);
							memcpy(raw + 16, &val, 4);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[]raw;
							break;
						}
					}
				}
			}
			/*
			* if (hgem_ > b_hgem_) {
				drop_.count - 100000;
				update_gem_item_(world_, drop_, 100);
				drop_.id = 9148;
				drop_.count = 1;
				for (int i_ = 0; i_ < world_->drop.size(); i_++) {
					if (world_->drop[i_].id == 0) continue;
					if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16 and world_->drop[i_].id == drop_.id and world_->drop[i_].count < 200) {
						int truksta_iki_200 = 200 - world_->drop[i_].count;
						if (drop_.count > truksta_iki_200 or world_->drop[i_].count + drop_.count <= 200) {
							int drop_atskirai = drop_.count - truksta_iki_200;
							if (world_->drop[i_].count + drop_.count <= 200) {
								world_->drop[i_].count += drop_.count;
								drop_.count = 0;
								goto lad_;
							}
							drop_.count = drop_atskirai;
							world_->drop[i_].count = 200;
						lad_:
							PlayerMoving data_{};
							data_.packetType = 14, data_.netID = -3, data_.plantingTree = world_->drop[i_].id;
							data_.x = world_->drop[i_].x, data_.y = world_->drop[i_].y;
							int32_t item = world_->drop[i_].uid;
							float val = world_->drop[i_].count;
							BYTE* raw = packPlayerMoving(&data_);
							memcpy(raw + 8, &item, 4);
							memcpy(raw + 16, &val, 4);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[]raw;
							break;
						}
					}
				}
			}
		*/
			/*
			if (ngem_ > b_ngem_) {
				drop_.count - 100000;
				update_gem_item_(world_, drop_, 100);
				drop_.id = 9148;
				drop_.count = 1;
				for (int i_ = 0; i_ < world_->drop.size(); i_++) {
					if (world_->drop[i_].id == 0) continue;
					if (world_->drop[i_].id == 5136 and abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16) {
						if (world_->drop[i_].count >= 100) {

						}
					}
					if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16 and world_->drop[i_].id == drop_.id and world_->drop[i_].count < 200) {
						int truksta_iki_200 = 200 - world_->drop[i_].count;
						if (drop_.count > truksta_iki_200 or world_->drop[i_].count + drop_.count <= 200) {
							int drop_atskirai = drop_.count - truksta_iki_200;
							if (world_->drop[i_].count + drop_.count <= 200) {
								world_->drop[i_].count += drop_.count;
								drop_.count = 0;
								goto lads;
							}
							drop_.count = drop_atskirai;
							world_->drop[i_].count = 200;
						lads:
							PlayerMoving data_{};
							data_.packetType = 14, data_.netID = -3, data_.plantingTree = world_->drop[i_].id;
							data_.x = world_->drop[i_].x, data_.y = world_->drop[i_].y;
							int32_t item = world_->drop[i_].uid;
							float val = world_->drop[i_].count;
							BYTE* raw = packPlayerMoving(&data_);
							memcpy(raw + 8, &item, 4);
							memcpy(raw + 16, &val, 4);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[]raw;
							break;
						}
					}
				}
			}
			*/
		}
	}
	else {
		if (items[drop_.id].blockType != BlockTypes::FISH) {
			for (int i_ = 0; i_ < world_->drop.size(); i_++) {
				if (world_->drop[i_].id == 0) continue;
				if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16 and world_->drop[i_].id == drop_.id and world_->drop[i_].count < 200) {
					int truksta_iki_200 = 200 - world_->drop[i_].count;
					if (drop_.count > truksta_iki_200 or world_->drop[i_].count + drop_.count <= 200) {
						int drop_atskirai = drop_.count - truksta_iki_200;
						if (world_->drop[i_].count + drop_.count <= 200) {
							world_->drop[i_].count += drop_.count;
							drop_.count = 0;
							goto update;
						}
						drop_.count = drop_atskirai;
						world_->drop[i_].count = 200;
					update:
						PlayerMoving data_{};
						data_.packetType = 14, data_.netID = -3, data_.plantingTree = world_->drop[i_].id;
						data_.x = world_->drop[i_].x, data_.y = world_->drop[i_].y;
						int32_t item = world_->drop[i_].uid;
						float val = world_->drop[i_].count;
						BYTE* raw = packPlayerMoving(&data_);
						memcpy(raw + 8, &item, 4);
						memcpy(raw + 16, &val, 4);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw;
						break;
					}
				}
			}
		}
	}
	if (drop_.count != 0) {
		world_->drop.push_back(drop_);
		PlayerMoving data_{};
		data_.packetType = 14, data_.x = drop_.x, data_.y = drop_.y, data_.netID = -1, data_.plantingTree = drop_.id;
		float val = drop_.count;
		int32_t item = net_id;
		BYTE val2 = 0;
		BYTE* raw = packPlayerMoving(&data_);
		memcpy(raw + 8, &item, 4);
		memcpy(raw + 16, &val, 4);
		memcpy(raw + 1, &val2, 1);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name) {
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
		}
		delete[]raw;
	}
}
void cheat_purchase(ENetPeer* peer, int quest) {
	int price = 0;
	string cheat_name;
	DialogBuilder db{ "`o" };
	switch (quest) {
	case 1: {
		cheat_name = "Autofarm Cheat";
		price = 100000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_af) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				pInfo(peer)->gems -= price;
				pInfo(peer)->unlocked_af = true;
				pInfo(peer)->unlocked_ci = true;
				db.add_textbox(format("You've successfully purchased {}! Now, you have {}.", cheat_name, setGems(pInfo(peer)->gems)))
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	/*
	case 2: {
		cheat_name = "Autospam Cheat";
		price = 500000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_as) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				pInfo(peer)->gems -= price;
				pInfo(peer)->unlocked_as = true;
				pInfo(peer)->unlocked_ci = true;
				db.add_textbox(format("You've successfully purchased {}! Now, you have {}.", cheat_name, setGems(pInfo(peer)->gems)))
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	*/
	case 3: {
		cheat_name = "Fast Spin Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_fs) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				pInfo(peer)->gems -= price;
				pInfo(peer)->unlocked_fs = true;
				pInfo(peer)->unlocked_ci = true;
				db.add_textbox(format("You've successfully purchased {}! Now, you have {}.", cheat_name, setGems(pInfo(peer)->gems)))
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 5: {
		cheat_name = "Hide Chats Cheat";
		price = 20000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_hc) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				pInfo(peer)->gems -= price;
				pInfo(peer)->unlocked_hc = true;
				pInfo(peer)->unlocked_ci = true;
				db.add_textbox(format("You've successfully purchased {}! Now, you have {}.", cheat_name, setGems(pInfo(peer)->gems)))
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 6: {
		cheat_name = "Auto Collect Gems Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_at) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				pInfo(peer)->gems -= price;
				pInfo(peer)->unlocked_at = true;
				pInfo(peer)->unlocked_ci = true;
				db.add_textbox(format("You've successfully purchased {}! Now, you have {}.", cheat_name, setGems(pInfo(peer)->gems)))
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 7: {
		cheat_name = "Fast Drop Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_fd) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				pInfo(peer)->gems -= price;
				pInfo(peer)->unlocked_fd = true;
				pInfo(peer)->unlocked_ci = true;
				db.add_textbox(format("You've successfully purchased {}! Now, you have {}.", cheat_name, setGems(pInfo(peer)->gems)))
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 8: {
		cheat_name = "Fast Trash Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_ft) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				pInfo(peer)->gems -= price;
				pInfo(peer)->unlocked_ft = true;
				pInfo(peer)->unlocked_ci = true;
				db.add_textbox(format("You've successfully purchased {}! Now, you have {}.", cheat_name, setGems(pInfo(peer)->gems)))
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 9: {
		cheat_name = "Fast Pull Cheat";
		price = 200000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_fp) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				pInfo(peer)->gems -= price;
				pInfo(peer)->unlocked_fp = true;
				pInfo(peer)->unlocked_ci = true;
				db.add_textbox(format("You've successfully purchased {}! Now, you have {}.", cheat_name, setGems(pInfo(peer)->gems)))
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 10: {
		cheat_name = "Antibounce Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_ab) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				pInfo(peer)->gems -= price;
				pInfo(peer)->unlocked_ab = true;
				pInfo(peer)->unlocked_ci = true;
				db.add_textbox(format("You've successfully purchased {}! Now, you have {}.", cheat_name, setGems(pInfo(peer)->gems)))
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	default: break;
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert(db.to_string());
	p.CreatePacket(peer);
	Algorithm::set_bux(peer);
	save_player(pInfo(peer), false);
}

string cheat_offer(ENetPeer* peer, int quest) {
	int price = 0;
	string cheat_name;
	DialogBuilder db{ "`o" };
	switch (quest) {
	case 1: {
		cheat_name = "Autofarm Cheat";
		price = 100000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_af) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	/*
	case 2: {
		cheat_name = "Autospam Cheat";
		price = 500000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_as) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	*/
	case 3: {
		cheat_name = "Fast Spin Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_fs) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	/*
	* case 4: {
		cheat_name = "Hide Player Cheat";
		price = 20000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_hp) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	*/
	case 5: {
		cheat_name = "Hide Chats Cheat";
		price = 20000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_hc) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 6: {
		cheat_name = "Auto Collect Gems Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_at) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 7: {
		cheat_name = "Fast Drop Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_fd) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 8: {
		cheat_name = "Fast Trash Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_ft) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 9: {
		cheat_name = "Fast Pull Cheat";
		price = 200000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_af) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	case 10: {
		cheat_name = "Antibounce Cheat";
		price = 50000;
		db.add_label_icon(true, 4368, cheat_name);
		if (pInfo(peer)->unlocked_ab) {
			db.add_textbox("Seems like you have already have this cheat, so you can't purchase it again.");
		}
		else {
			if (pInfo(peer)->gems < price) {
				db.add_textbox(format("You're about to purchase the {}, but you have {} gems short.", cheat_name, setGems(price - pInfo(peer)->gems)));
			}
			else {
				db.add_textbox(format("You're about to purchase the {}, the price is {}. Click 'Purchase' to purchase Autofarm Cheat", cheat_name, setGems(price)))
					.add_button(format("purchase_cheat_{}", quest), "Purchase")
					.add_button("53785", "`wBack``");
			}
		}
		db.end_dialog("3898", "`wHang Up``", "");
		break;
	}
	default: return "";
	}
	return db.to_string();
}
inline void cheat_show(ENetPeer* peer) {
	DialogBuilder dialog;
	dialog.add_custom_textbox("To use cheat simply check the checkbox of the cheat you want to enable and press \"OK\".<CR>Auto Farming cheat will be turned off if you leave the world.", "medium")
		.add_spacer(false)
		.add_smalltext("`7When enabled select any item from your backpack that you want to farm, place it somewhere and autofarming begins until you ran out of blocks.<CR>This cheat places blocks for you, and farms them for you.")
		//.add_smalltext("`6NOTE: `wYou can only use it " + to_string(hour) + " hours per day. You have `9" + timeLeft + " `wof Auto-farming left today.")
		.add_checkbox(pInfo(peer)->Cheat_AF, "checkbox_cheat_autofarm", "Auto Farm")
		.add_smalltext("`7When enabled gems will be directly added to your account when you breaking blocks/harvesting trees.")
		.add_checkbox(pInfo(peer)->Cheat_AutoCollect, "checkbox_cheat_autocollect", "Auto Pickup Gems")
		.add_smalltext("`7When enabled grants you to immune from spike or lava.")
		.add_checkbox(pInfo(peer)->Cheat_AB, "checkbox_cheat_antibounce", "Antibounce")
		//.add_smalltext("`7When enabled grants you to move more faster.")
		//.add_checkbox(pInfo(peer)->Cheat_Speed, "checkbox_cheat_speed", "Super Speed")
		.add_smalltext("`7When enabled grants you to jump higher.")
		.add_checkbox(pInfo(peer)->Cheat_Jump, "checkbox_cheat_jump", "Super Jump")
		.add_spacer(false).add_custom_textbox("Miscellaneous", "medium")
		//.add_smalltext("`7When enabled you won't see any other characters inside a world.")
		//.add_checkbox(pInfo(peer)->Cheat_HideOther, "checkbox_cheat_hideother", "Hide Other's Character")
		.add_smalltext("`7When enabled you won't see any other's chat inside a world.")
		.add_checkbox(pInfo(peer)->Cheat_HideChat, "checkbox_cheat_hidechat", "Hide Other's Chat")
		.add_smalltext("`7When enabled and you wrench someone, it pulls them to you. Of course, you will need permission to do that in that world.")
		.add_checkbox(pInfo(peer)->Cheat_FastPull, "checkbox_cheat_fastpull", "Fast Pull")
		.add_smalltext("`4Warning: `wBecareful of this cheat turn it off immediately when you've done on using it.")
		.add_checkbox(pInfo(peer)->Cheat_FastDrop, "checkbox_cheat_fastdrop", "Fast Drop [Be Careful With This Cheat]")
		.add_checkbox(pInfo(peer)->Cheat_FastTrash, "checkbox_cheat_fasttrash", "Fast Trash [Be Careful With This Cheat]")
		.add_checkbox(pInfo(peer)->Cheat_FastSpin, "checkbox_cheat_fastspin", "Fast Spin")
		.add_spacer(false)
		.add_smalltext("`4Warning: `wSpammer``")
		//.add_text_input(3, "text_input_spam_delay", "Delay: (seconds)", to_string(pInfo(peer)->Cheat_Spam_Delay))
		//.add_text_input(120, "text_input_spam_chat", "Spam Text:", pInfo(peer)->Cheat_Spam_Text)
		//.add_checkbox(pInfo(peer)->Cheat_Spam, "checkbox_cheat_spam", "Auto spam [On / Off]")
		.add_spacer(false)
		.add_small_font_button("restore_default", "Restore to Default")
		.end_dialog("dialog_cheat_menu", "Cancel", "OK")
		.add_quick_exit();
	enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(dialog.to_string()).pack());
}
void add_peer_xp(ENetPeer* peer, int amount) {
	if (has_playmod(pInfo(peer), "Food: Extra XP") || has_playmod(pInfo(peer), "Extra XP...")) {
		int extraXP = 2;
		// clothing extra xp
		if (pInfo(peer)->ances == 5082) extraXP *= 2;
		if (pInfo(peer)->ances == 5162) extraXP *= 2.50;
		if (pInfo(peer)->ances == 5164) extraXP *= 2.80;
		if (pInfo(peer)->ances == 5166) extraXP *= 3;
		if (pInfo(peer)->ances == 5168) extraXP *= 3.50;
		if (pInfo(peer)->ances == 5170) extraXP *= 3.80;
		if (pInfo(peer)->hand == 1996) extraXP *= 2.80;
		
		if ((rand() % 25) + 1 == pInfo(peer)->ances != 0 ? items[pInfo(peer)->ances].chance : 7) {
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 49, data_.YSpeed = 49, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
			amount *= extraXP;
		}
	}
	if (pInfo(peer)->affinity_level == 3) amount *= 5;
	/*if (pInfo(peer)->hand == 9520) amount *= 100;
	if (pInfo(peer)->lock == 13200) {
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 49, data_.YSpeed = 49, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
		amount *= 28;
	}*/
	amount *= xp_event;
	if (pInfo(peer)->guild_id != 0) {
		uint32_t guild_id = pInfo(peer)->guild_id;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			uint32_t max_xp = guild_lvl[guild_information->guild_level - 1][0];
			if (guild_information->guild_xp < max_xp) {
				guild_information->guild_xp += amount;
				if (guild_information->guild_xp > max_xp) guild_information->guild_xp = max_xp;
			}
		}
	}
	pInfo(peer)->xp += amount;
	if (pInfo(peer)->udah_daftar == true) {
		pInfo(peer)->expray += amount;
	}
	int required = 50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2);
	int rayo = 50 * ((pInfo(peer)->raylvl * pInfo(peer)->raylvl) + 2);
	if (pInfo(peer)->udah_daftar == true) {
		if (pInfo(peer)->raylvl < 50) {
			if (pInfo(peer)->expray >= rayo) {
				pInfo(peer)->raylvl++;
				pInfo(peer)->expray -= rayo;
				Algorithm::send_bubble(peer, pInfo(peer)->netID, pInfo(peer)->tankIDName + " Rayman Quest is up Level to " + to_string(pInfo(peer)->raylvl));
			}
		}
	}
	if (pInfo(peer)->level < 2048) {
		if (pInfo(peer)->xp >= required) {
			pInfo(peer)->level++;
			pInfo(peer)->xp -= required;
			if (thedaytoday == 4) pInfo(peer)->gems += 500;
			pInfo(peer)->gems += 500;
			{
				gamepacket_t p;
				p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(0), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
				if (pInfo(peer)->supp >= 2) {
					p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
				}
				p.CreatePacket(peer);
			}
			if (pInfo(peer)->level == 5) form_emoji(peer, true);
			{
				int give = 0;
				modify_inventory(peer, 2278, give);
				if (pInfo(peer)->level >= 50 && give <= 0) {
					if (modify_inventory(peer, 2278, give = 1) == -1) {}
					else {
						gamepacket_t p, p2;
						p.Insert("OnAddNotification"), p.Insert("interface/large/friend_button.rttex"), p.Insert("You've unlocked `$Mini-You``!"), p.Insert("audio/hub_open.wav"), p.Insert(0), p.CreatePacket(peer);
						p2.Insert("OnConsoleMessage"), p2.Insert("You've unlocked `$Mini-You``!"), p2.CreatePacket(peer);
					}
				}
			}
			gamepacket_t p, p2;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` is now level " + to_string(pInfo(peer)->level) + "!");
			p2.Insert("OnConsoleMessage"), p2.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` is now level " + to_string(pInfo(peer)->level) + "!");
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				p.CreatePacket(currentPeer);
				p2.CreatePacket(currentPeer);
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
		}
	}
	// XP QUEST
	if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 6 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
		pInfo(peer)->C_QuestProgress += amount;
		if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
			pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
	}
	if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 8 && pInfo(peer)->quest_progress < 10000) {
		pInfo(peer)->quest_progress += amount;
		if (pInfo(peer)->quest_progress >= 10000) {
			pInfo(peer)->quest_progress = 10000;
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
	}
}

void add_fishing_xp(ENetPeer* peer, int amount) {
	pInfo(peer)->ff_xp += amount;
	int required = 5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2);
	if (pInfo(peer)->ff_xp >= 5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2)) {
		pInfo(peer)->ff_lvl++;
		pInfo(peer)->ff_xp -= required;
		pInfo(peer)->gems += 500;
		{
			gamepacket_t p;
			p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(0), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
			if (pInfo(peer)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
			p.CreatePacket(peer);
		}
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` Fishing is now level " + to_string(pInfo(peer)->ff_lvl) + "!"), p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage"), p2.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` Fishing is now level " + to_string(pInfo(peer)->ff_lvl) + "!");
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer), send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
	}
}

void stop_fishing(ENetPeer* peer, bool fail, string error) {
	if (pInfo(peer)->fishing_used != 0) {
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
		p2.Insert("OnConsoleMessage");
		if (error == "") {
			if (pInfo(peer)->last_fish_catch + pInfo(peer)->fish_seconds < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) p.Insert("There was nothing on the line!"), p2.Insert("There was nothing on the line!");
			else {
				bool fish = false, fullinv = false;
				add_peer_xp(peer, items[pInfo(peer)->fishing_used].rarity);
				add_fishing_xp(peer, 1);
				if (pInfo(peer)->fishing_used != 3020 and pInfo(peer)->fish_water == "cave")
					items[pInfo(peer)->fishing_used].randomitem.push_back(3814);

				int giveitem = items[pInfo(peer)->fishing_used].randomitem[rand() % items[pInfo(peer)->fishing_used].randomitem.size()], c_ = 1;
				vector<int> list;
				vector<int> trashes{9164, 9494};
				/*
				if (pInfo(peer)->hand == 10262) {
					for (int i__ = 0; i__ < items[pInfo(peer)->fishing_used].randomitem.size(); i__++) if (items[items[pInfo(peer)->fishing_used].randomitem[i__]].blockType == BlockTypes::FISH) list.push_back(items[pInfo(peer)->fishing_used].randomitem[i__]);
					giveitem = list[rand() % list.size()];
				}
				*/
				if (rand() % 100 < 2)
					giveitem = pInfo(peer)->fish_water == "uranium" ? 9496 : pInfo(peer)->fish_water == "ice" ? 9488 : 9160;
				if (rand() % 100 < 3)
					giveitem = trashes[rand() % trashes.size()];
				if (rand() % 100000 < 4 and pInfo(peer)->fish_water.empty())
					giveitem = 9162;

				if (rand() % 8 < 4 && global::events::valentine) {
					int randomGets = rand() % 100 + 50;

					Algorithm::send_console(peer, std::format("`o>> You've received a `w{} Valentine's Chocolate `ofrom fishing.", randomGets));

					pInfo(peer)->valentine.chocolates += randomGets;
				}

				if (items[giveitem].blockType == BlockTypes::FISH) {
					int max_ = 0;
					if (pInfo(peer)->hand == 3010) 
						max_ = (items[giveitem].fish_max_lb + 1 >= 60 ? 60 : items[giveitem].fish_max_lb + 1);
					if (pInfo(peer)->hand == 3040)
						max_ = (items[giveitem].fish_max_lb + 1 >= 140 ? 140 : items[giveitem].fish_max_lb + 1);
					if (pInfo(peer)->hand == 10262)
						max_ = items[giveitem].fish_max_lb;

					fish = true;
					int gen = rand() % max_;
					c_ = gen <= 0 ? 1 : gen;
				}
				if (pInfo(peer)->hand == 3040 or thedaytoday == 0 and fish) {
					c_ *= 1.25;
					if (c_ > items[giveitem].fish_max_lb) c_ = items[giveitem].fish_max_lb;
				}
				//if (fish) grow4good(peer, false, "fish", c_);
				PlayerMoving data_{};
				data_.x = pInfo(peer)->f_x * 32, data_.y = pInfo(peer)->f_y * 32, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = giveitem, data_.punchY = pInfo(peer)->netID;
				int32_t to_netid = pInfo(peer)->netID;
				BYTE* raw = packPlayerMoving(&data_);
				raw[3] = 5;
				memcpy(raw + 8, &to_netid, 4);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
				if (fish) 
					for (int i_ = 0, remove = 0; i_ < pInfo(peer)->inv.size(); i_++) 
					if (pInfo(peer)->inv[i_].id == giveitem) fullinv = true;
				int give = 1;
				if (fullinv == false && fish == false && modify_inventory(peer, giveitem, give) == 0) {
				}
				else fullinv = true;
				if (fullinv || fish) {
					string name_ = pInfo(peer)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldDrop drop_block_{};
						drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17, drop_block_.id = giveitem, drop_block_.count = c_, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
						dropas_(world_, drop_block_);
					}
				}
				p.Insert("You caught a `2" + (fish ? to_string(c_) + " lb. " : "") + "" + items[giveitem].name + "!``"), p2.Insert("You caught a `2" + (fish ? to_string(c_) + " lb. " : "") + "" + items[giveitem].name + "!``");
				if (items[giveitem].blockType == FISH and giveitem == fish_id) {
					long long timed = time(nullptr);
					long long playmod_time = 0;

					for (int i = 0; i < pInfo(peer)->playmods.size(); i++)
						if (pInfo(peer)->playmods[i].id == 126)
							playmod_time = pInfo(peer)->playmods[i].time;

					//int sex = (pInfo(peer)->fishing_begin + pInfo(peer)->fishing_until - timed) / 1000;
					int sex = (playmod_time - timed) / 1000;
					pInfo(peer)->fishing_score += c_;
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnCountdownStart"), p.Insert(sex), p.Insert(pInfo(peer)->fishing_score);
					p.CreatePacket(peer);

					for (int i = 0; i < tournament_board.size(); i++)
						if ((tournament_board[i].first) == (pInfo(peer)->uid))
							tournament_board[i] = make_pair(pInfo(peer)->uid, pInfo(peer)->fishing_score);
				}
				if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 14 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
					pInfo(peer)->C_QuestProgress += c_;
					if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
				if (pInfo(peer)->quest_active == true && pInfo(peer)->quest_step == 13 && pInfo(peer)->quest_progress < 2500 and pInfo(peer)->lastquest == "candour" || pInfo(peer)->lastquest == "thesky" || pInfo(peer)->lastquest == "theowl") {
					pInfo(peer)->quest_progress += c_;
					if (pInfo(peer)->quest_progress >= 2500) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
			}
		}
		else p.Insert(error), p2.Insert(error);
		pInfo(peer)->fishing_used = 0, pInfo(peer)->last_fish_catch = 0, pInfo(peer)->fish_water.clear();
		FishMoving data_{};
		data_.stopped_fishing = 2, data_.netID = pInfo(peer)->netID, data_.x = pInfo(peer)->f_x, data_.y = pInfo(peer)->f_y;
		BYTE* raw = packFishMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
		p.CreatePacket(peer), p2.CreatePacket(peer);
	}
}

void equip_clothes(ENetPeer* p_, int item) {
	if (pInfo(p_)->hideseek.InGame && global::algorithm::hideseek.GameStarted) {
		Algorithm::send_console(p_, "`1HIDE-SEEK: `oYou can't equip/unequip any clothes till' the match game is finished!");
		return;
	}
	int c_ = 0;
	modify_inventory(p_, item, c_);
	if (c_ == 0) return;
	if (pInfo(p_)->ances == item or pInfo(p_)->back == item
		or pInfo(p_)->feet == item or pInfo(p_)->face == item
		or pInfo(p_)->hair == item or pInfo(p_)->hand == item
		or pInfo(p_)->mask == item or pInfo(p_)->necklace == item
		or pInfo(p_)->pants == item or pInfo(p_)->shirt == item) {
		//if (pInfo(p_)->flagmay == 1929) pInfo(p_)->flagmay = 256;
		if (pInfo(p_)->flagmay != 256 and items[item].flagmay != 256) pInfo(p_)->flagmay = 256;
		unequip_(p_, item);
	}
	else {
		if (items[item].flagmay == 0 or items[item].flagmay != NULL) pInfo(p_)->flagmay = items[item].flagmay;
		if (item == 8304) {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMagic Magnet``|left|8304|\nadd_spacer|small|" + (string(pInfo(p_)->Magnet_Item != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(p_)->Magnet_Item].name + "``|left|" + to_string(pInfo(p_)->Magnet_Item) + "|" : "")) + "\nadd_item_picker|magic_compass_item|`wSelect Item``|Choose an item to pickup!|\nadd_button|clear_item|Clear|noflags|0|0|\nadd_spacer|small|\nend_dialog|magic_compass|Close||");
			p.CreatePacket(p_);
		}
		else if (item == 12636) {
			gamepacket_t p(0, pInfo(p_)->netID);
			p.Insert("OnFlagMay2019");
			p.Insert(pInfo(p_)->flagmay = (pInfo(p_)->flagmay == 16777472 ? 256 : 16777472));
			p.CreatePacket(p_);
		}
		else if (item == 7584) {
			pInfo(p_)->sprite++;
			if (pInfo(p_)->sprite > 3) pInfo(p_)->sprite = 1;
		}
		else if (item == 5712) {
			pInfo(p_)->wild++;
			if (pInfo(p_)->wild > 8) pInfo(p_)->wild = 6;
		}
		else if (item == 10044) {
			pInfo(p_)->golem++;
			if (pInfo(p_)->golem > 8) pInfo(p_)->golem = 6;
		}
		else if (item == 10914) pInfo(p_)->pure_shadow = (pInfo(p_)->pure_shadow == 1 ? 0 : 1);
		else if (item == 10666) {
			pInfo(p_)->grow_air_ballon++;
			if (pInfo(p_)->grow_air_ballon > 3) pInfo(p_)->grow_air_ballon = 0;
		}
		ClothTypes type_ = items[item].clothType;
		if (type_ == ClothTypes::ANCES)
			pInfo(p_)->ances = item;
		else if (type_ == ClothTypes::BACK)
			pInfo(p_)->back = item;
		else if (type_ == ClothTypes::FEET)
			pInfo(p_)->feet = item;
		else if (type_ == ClothTypes::FACE)
			pInfo(p_)->face = item;
		else if (type_ == ClothTypes::HAIR)
			pInfo(p_)->hair = item;
		else if (type_ == ClothTypes::HAND)
			pInfo(p_)->hand = item;
		else if (type_ == ClothTypes::MASK)
			pInfo(p_)->mask = item;
		else if (type_ == ClothTypes::NECKLACE)
			pInfo(p_)->necklace = item;
		else if (type_ == ClothTypes::PANTS)
			pInfo(p_)->pants = item;
		else if (type_ == ClothTypes::SHIRT)
			pInfo(p_)->shirt = item;
		if (items[item].on_equip != "") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert(items[item].on_equip + (items[item].playmod != "" ? " (`$" + items[item].playmod + "`` mod added)" : "")), p.CreatePacket(p_);
		}
		packet_(p_, "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0");
		update_clothes(p_);
		if (pInfo(p_)->fishing_used != 0)stop_fishing(p_, true, "Sit still if you wanna fish!");
		if (item == 3172 && has_playmod(pInfo(p_), "Malpractice")) {
			for (int i_ = 0; i_ < pInfo(p_)->playmods.size(); i_++) if (pInfo(p_)->playmods[i_].id == 88) pInfo(p_)->playmods[i_].time = 1;
			gamepacket_t p, p2;
			p.Insert("OnConsoleMessage"), p.Insert("`2Your briefs have stunned the judge!``"), p.CreatePacket(p_);
			p2.Insert("OnTalkBubble"), p2.Insert(pInfo(p_)->netID), p2.Insert("`2Your briefs have stunned the judge!``"), p2.CreatePacket(p_);
			int remove = -1;
			modify_inventory(p_, 3172, remove);
		}
	}
	Send_Xenonite_Update(p_);
}

int alloc_(World* world_, WorldBlock* block_) {
	if (items[block_->fg].blockType == SEED) return 0;
	if (items[block_->fg].vipentrance) {
		return (block_->admins.size() * 4) + world_->width - 1;
	}
	else if (items[block_->fg].blockType == BlockTypes::LOCK) {
		if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
			return (block_->admins.size() * 4) + 99;
		}
		return (world_->admins.size() * 4) + 99;
	}
	return 99;
}
int form_visual(BYTE*& blc, WorldBlock block_, World world_, ENetPeer* peer, bool case_ = true, bool show = false, int x1 = -1, int y1 = -1) {
	uint32_t ySize = world_.blocks.size() / world_.width, xSize = world_.blocks.size() / ySize, square = world_.blocks.size();
	if (not case_) {
		*(__int16*)(blc) = block_.fg;
		*(__int16*)(blc + 2) = block_.bg;
		*(__int32*)(blc + 4) = block_.flags;
	}
	if (items[block_.fg].donation || items[block_.fg].mailbox || block_.fg == 3918 || block_.fg == 3928 || block_.fg == 3922 || block_.fg == 1908 || block_.fossil) {
		*(int*)(blc + 4) = block_.flags;
		*(__int8*)(blc + 8) = 12;
		/*
		int test_ = (show ? (block_.flags | 0x00400000) : block_.flags); // jeigu kazkas yra tada 0x00400000;
		memcpy(blc + 4, &test_, 4);
		BYTE btype = 12;
		memcpy(blc + 8, &btype, 1);*/
		if (case_) {
			blc += 8;
			return 8;
		}
	}
	else if (items[block_.fg].kranken) {
		int model_ = block_.kranken_pattern;
		int rgb = (block_.b << 24) | (block_.g << 16) | (block_.r << 8);
		int w_ = rgb + 255;
		*(__int8*)(blc + 8) = 0x50;
		*(__int8*)(blc + 9) = model_;
		*(__int8*)(blc + 13) = w_;
		/*
		* BYTE btype = 0x50;
		memcpy(blc + 8, &btype, 1);
		memcpy(blc + 9, &model_, 4);
		memcpy(blc + 13, &w_, 4);
		*/
		if (case_) {
			blc += 9;
			return 9;
		}
	}
	else if (items[block_.fg].bulletin_board || items[block_.fg].storage_box) {
		*(__int8*)(blc + 8) = 6;
		/*
		BYTE btype = 6;
		memcpy(blc + 8, &btype, 1);*/
		if (case_) {
			blc += 8;
			return 8;
		}
	}
	else if (items[block_.fg].xeno) {
		*(__int8*)(blc + 8) = 53;
		/*
		BYTE btype = 53;
		memcpy(blc + 8, &btype, 1);*/
		if (case_) {
			blc += 9;
			return 9;
		}
	}
	else if (items[block_.fg].bunny_egg) {
		*(__int8*)(blc + 8) = 15;
		*(__int16*)(blc + 9) = block_.bunny_egg_progress;
		/*
		BYTE btype = 15;
		memcpy(blc + 8, &btype, 1);
		memcpy(blc + 9, &block_.bunny_egg_progress, 4);*/
		if (case_) {
			blc += 5;
			return 5;
		}
	}
	else if (items[block_.fg].dshelf) {
		*(__int8*)(blc + 8) = 43;
		*(__int16*)(blc + 9) = block_.shelf_1;
		*(__int16*)(blc + 13) = block_.shelf_2;
		*(__int16*)(blc + 17) = block_.shelf_3;
		*(__int16*)(blc + 21) = block_.shelf_4;
		/*
		BYTE btype = 43;
		memcpy(blc + 8, &btype, 1);
		memcpy(blc + 9, &block_.shelf_1, 4);
		memcpy(blc + 13, &block_.shelf_2, 4);
		memcpy(blc + 17, &block_.shelf_3, 4);
		memcpy(blc + 21, &block_.shelf_4, 4);*/
		if (case_) {
			blc += 17;
			return 17;
		}
	}
	else if (items[block_.fg].heart_monitor) {
		*(__int8*)(blc + 8) = 11;
		{
			uint32_t detak = -1;
			for (int i = 0; i < monitors.size(); i++) {
				if (monitors[i].x == x1 and monitors[i].y == y1) {
					detak = monitors[i].active;
					break;
				}
			}
			*(__int16*)(blc + 9) = detak;
			if (detak) *(int*)(blc + 4) = block_.flags | 0x00400000;
		}
		*(__int16*)(blc + 13) = block_.heart_monitor.size();
		memcpy(blc + 15, block_.heart_monitor.c_str(), block_.heart_monitor.size());

		/*
		BYTE btype = 11;
		memcpy(blc + 8, &btype, 1);
		string monitor_text = block_.heart_monitor;
		{
			uint32_t detak = -1;
			for (int i = 0; i < monitors.size(); i++) {
				if (monitors[i].x == x1 and monitors[i].y == y1) {
					detak = monitors[i].active;
					break;
				}
			}
			memcpy(blc + 9, &detak, 4);
			int state_of_block = block_.flags | 0x00400000;
			if (detak) memcpy(blc + 4, &state_of_block, 4);
		}
		uint32_t dydis = uint32_t(monitoriaus_tekstas.size());
		memcpy(blc + 13, &dydis, 2);
		memcpy(blc + 15, monitoriaus_tekstas.c_str(), dydis);*/
		if (case_) {
			blc += 7 + block_.heart_monitor.size();
			return 7 + block_.heart_monitor.size();
		}
	}
	else if (items[block_.fg].trickster) {
		*(__int8*)(blc + 8) = 52;
		/*
				BYTE btype = 52;
				memcpy(blc + 8, &btype, 1);*/
		if (case_) {
			blc += 1;
			return 1;
		}
	}
	else if (items[block_.fg].vall_mount) {
		*(__int8*)(blc + 8) = 47;
		*(__int8*)(blc + 9) = 0;
		/*

		BYTE btype = 47;
		memcpy(blc + 8, &btype, 1);
		uint32_t sk = 0;
		memcpy(blc + 9, &sk, 4);*/
		if (case_) {
			blc += 8;
			return 8;
		}
	}
	else if (items[block_.fg].portrait) {
		*(__int8*)(blc + 8) = 48;
		*(__int16*)(blc + 9) = block_.txt.size();
		memcpy(blc + 11, block_.txt.c_str(), block_.txt.size());
		*(__int16*)(blc + 17) = block_.shelf_3;
		*(__int16*)(blc + 21) = block_.shelf_4;

		if (block_.portrait.c_skin == 0 and block_.portrait.c_face == 0 and block_.portrait.c_head == 0 and block_.portrait.c_hair == 0) {
		}
		else {
			*(__int16*)(blc + 11 + block_.txt.size()) = block_.portrait.c_expression;
			*(__int16*)(blc + 19 + block_.txt.size()) = block_.portrait.c_hair_colour;
			*(__int16*)(blc + 23 + block_.txt.size()) = block_.portrait.c_skin;
			*(__int16*)(blc + 27 + block_.txt.size()) = block_.portrait.c_face;
			*(__int16*)(blc + 29 + block_.txt.size()) = block_.portrait.c_head;
			*(__int16*)(blc + 31 + block_.txt.size()) = block_.portrait.c_hair;
		}

		/*
		BYTE btype = 48;
		memcpy(blc + 8, &btype, 1);
		string sign_tekstas = block_.txt;
		uint32_t dydis = uint32_t(sign_tekstas.size());
		memcpy(blc + 9, &dydis, 2);
		memcpy(blc + 11, sign_tekstas.c_str(), dydis);
		if (block_.portrait.c_skin == 0 and block_.portrait.c_face == 0 and block_.portrait.c_head == 0 and block_.portrait.c_hair == 0) {
		} else {
			memcpy(blc + 11 + dydis, &block_.portrait.c_expression, 4);
			memcpy(blc + 19 + dydis, &block_.portrait.c_hair_colour, 4);
			memcpy(blc + 23 + dydis, &block_.portrait.c_skin, 4);
			memcpy(blc + 27 + dydis, &block_.portrait.c_face, 2);
			memcpy(blc + 29 + dydis, &block_.portrait.c_head, 2);
			memcpy(blc + 31 + dydis, &block_.portrait.c_hair, 2);
		}*/
		if (case_) {
			blc += 7 + 15 + 3 + block_.txt.size();
			return 7 + 15 + 3 + block_.txt.size();
		}
	}
	else if (items[block_.fg].audio_rack) {
		*(__int8*)(blc + 8) = 56; // tileextra_type_audio_rack
		*(__int16*)(blc + 9) = block_.audio_notes.size();
		memcpy(blc + 11, block_.audio_notes.c_str(), block_.audio_notes.size());
		*(__int16*)(blc + 11 + block_.audio_notes.size()) = block_.audio_volume;

		if (case_) {
			blc += 7 + block_.audio_notes.size();
			return 7 + block_.audio_notes.size();
		}
	}
	else if (block_.fg == 1660) {
		*(__int8*)(blc + 8) = TILEEXTRA_TYPE_GAME_GENERATOR;
		/*
		*(__int16*)(blc + 9) = block_.game_label.size();
		memcpy(blc + 11, block_.game_label.c_str(), block_.game_label.size());
		*(__int8*)(blc + 11 + block_.game_label.size()) = block_.teams.size();
		*(__int32*)(blc + 12 + block_.game_label.size()) = block_.game_time;

		if (case_) {
			blc += 7 + block_.game_label.size();
			return 7 + block_.game_label.size();
		}
		*/
		if (case_) {
			blc += 17;
			return 17;
		}
	}
	else if (items[block_.fg].easel) {
		*(__int8*)(blc + 8) = 35;
		*(__int16*)(blc + 9) = block_.id;
		*(__int16*)(blc + 13) = block_.txt.size();
		memcpy(blc + 15, block_.txt.c_str(), block_.txt.size());

		/*
		BYTE btype = 0x23;
		memcpy(blc + 8, &btype, 1);
		memcpy(blc + 9, &block_.id, 4);
		string sign_tekstas = block_.txt;
		uint32_t dydis = uint32_t(sign_tekstas.size());
		memcpy(blc + 13, &dydis, 2);
		memcpy(blc + 15, sign_tekstas.c_str(), dydis);*/
		if (case_) {
			blc += 7 + block_.txt.size();
			return 7 + block_.txt.size();
		}
	}
	else if (items[block_.fg].mannequin) {
		*(__int8*)(blc + 8) = 14;
		*(__int16*)(blc + 9) = block_.txt.size();
		memcpy(blc + 11, block_.txt.c_str(), block_.txt.size());
		*(__int16*)(blc + 16 + block_.txt.size()) = block_.mannequin.c_hair;
		*(__int16*)(blc + 18 + block_.txt.size()) = block_.mannequin.c_shirt;
		*(__int16*)(blc + 20 + block_.txt.size()) = block_.mannequin.c_pants;
		*(__int16*)(blc + 22 + block_.txt.size()) = block_.mannequin.c_feet;
		*(__int16*)(blc + 24 + block_.txt.size()) = block_.mannequin.c_head;
		*(__int16*)(blc + 26 + block_.txt.size()) = block_.mannequin.c_hand;
		*(__int16*)(blc + 28 + block_.txt.size()) = block_.mannequin.c_back;
		*(__int16*)(blc + 30 + block_.txt.size()) = block_.mannequin.c_mask;
		*(__int16*)(blc + 32 + block_.txt.size()) = block_.mannequin.c_neck;

		/*
		BYTE btype = 14;
		memcpy(blc + 8, &btype, 1);
		string sign_tekstas = block_.txt;
		uint32_t dydis = uint32_t(sign_tekstas.size());
		memcpy(blc + 9, &dydis, 2);
		memcpy(blc + 11, sign_tekstas.c_str(), dydis);
		memcpy(blc + 16 + dydis, &block_.mannequin.c_hair, 2);
		memcpy(blc + 18 + dydis, &block_.mannequin.c_shirt, 2);
		memcpy(blc + 20 + dydis, &block_.mannequin.c_pants, 2);
		memcpy(blc + 22 + dydis, &block_.mannequin.c_feet, 2);
		memcpy(blc + 24 + dydis, &block_.mannequin.c_head, 2);
		memcpy(blc + 26 + dydis, &block_.mannequin.c_hand, 2);
		memcpy(blc + 28 + dydis, &block_.mannequin.c_back, 2);
		memcpy(blc + 30 + dydis, &block_.mannequin.c_mask, 2);
		memcpy(blc + 32 + dydis, &block_.mannequin.c_neck, 2);*/
		if (case_) {
			blc += 26 + block_.txt.size();
			return 26 + block_.txt.size();
		}
	}
	else if (items[block_.fg].vipentrance) {
		*(__int8*)(blc + 8) = 44;
		vector<int> vip_members;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_.name or currentPeer == peer) {
				if (block_.limit_admins or find(block_.admins.begin(), block_.admins.end(), pInfo(currentPeer)->uid) != block_.admins.end() or pInfo(currentPeer)->tankIDName == world_.owner_name or world_.owner_name.empty()) {
					vip_members.push_back(pInfo(currentPeer)->id);
				}
			}
		}
		*(__int16*)(blc + 14) = vip_members.size();
		for (int i = 0; i < vip_members.size(); i++) *(__int32*)(blc + 18 + (i * 4)) = vip_members[i];

		/*

			BYTE btype = 44;
			memcpy(blc + 8, &btype, 1);
			vector<int> vip_members;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == world_.name or currentPeer == peer) {
					if (block_.limit_admins or find(block_.admins.begin(), block_.admins.end(), pInfo(currentPeer)->tankIDName) != block_.admins.end() or pInfo(currentPeer)->tankIDName == world_.owner_name or world_.owner_name.empty()) {
						vip_members.push_back(pInfo(currentPeer)->id);
					}
				}
			}
			uint32_t sk = vip_members.size();
			memcpy(blc + 14, &sk, 1);
			for (int i = 0; i < vip_members.size(); i++) {
				memcpy(blc + 18 + (i * 4), &vip_members[i], 4);
			}*/
		if (case_) {
			blc += 10 + (vip_members.size() * 4);
			return 10 + (vip_members.size() * 4);
		}
	}

	else if (items[block_.fg].timer) {
		*(__int8*)(blc + 8) = 45;
		/*
			BYTE btype = 45;
			memcpy(blc + 8, &btype, 1);*/
		if (case_) {
			blc += 1;
			return 1;
		}
	}
	else if (items[block_.fg].trans) {
		*(__int8*)(blc + 8) = 19;
		/*
				BYTE btype = 19;
				memcpy(blc + 8, &btype, 1);*/
		if (case_) {
			blc += 19;
			return 19;
		}
	}
	else if (items[block_.fg].dnaproc) {
		*(__int8*)(blc + 8) = 19;
		/*
				BYTE btype = 19;
				memcpy(blc + 8, &btype, 1);*/
		if (case_) {
			blc += 19;
			return 19;
		}
	}
	else if (items[block_.fg].infinitymachine) {
		*(__int8*)(blc + 8) = 19;
		/*
				BYTE btype = 19;
				memcpy(blc + 8, &btype, 1);*/
		if (case_) {
			blc += 19;
			return 19;
		}
	}
	else if (items[block_.fg].spirit) {
		*(__int8*)(blc + 8) = 41;
		*(__int16*)(blc + 9) = block_.c_;

		/*
			BYTE btype = 41;
			memcpy(blc + 8, &btype, 1);
			uint32_t sk = block_.c_;
			memcpy(blc + 9, &sk, 4);*/
		if (case_) {
			blc += 5;
			return 5;
		}
	}
	else if (items[block_.fg].charger) {
		*(int*)(blc + 4) = block_.id != 0 ? 0x00400000 : block_.flags;
		*(__int8*)(blc + 8) = 57;
		*(int*)(blc + 9) = (block_.planted - time(nullptr) <= 0 ? 3600 : 3600 - (block_.planted - time(nullptr)));
		/*
			int test_ = block_.id != 0 ? 0x00400000 : block_.flags;
			memcpy(blc + 4, &test_, 4);
			BYTE btype = 57;
			memcpy(blc + 8, &btype, 1);
			long long time_ = time(nullptr);
			uint16_t sk = (block_.planted - time_ <= 0 ? 3600 : 3600 - (block_.planted - time_));
			memcpy(blc + 9, &sk, 2);*/
		if (case_) {
			blc += 5;
			return 5;
		}
	}
	else if (items[block_.fg].fossil_prep) { 
		*(int*)(blc + 4) = block_.id != 0 ? 0x00400000 : block_.flags;
		*(__int8*)(blc + 8) = 50;
		*(int*)(blc + 9) = (block_.planted - time(nullptr) <= 0 ? 5400 : 5400 - (block_.planted - time(nullptr)));

		if (case_) {
			blc += 5;
			return 5;
		}
	}
	/*
	else if (block_.fg == 3354) {
		*(__int8*)(blc + 8) = TILEEXTRA_TYPE_SEWING;
		*(__int16*)(blc + 9) = block_.id;

		if (case_) {

		}
	}
	*/
	else if (items[block_.fg].magplant or items[block_.fg].item_sucker) {
		switch (block_.fg) {
		case 5638: // magplant
		{
			int lock = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or not pInfo(currentPeer)->isIn) continue;
				if (pInfo(currentPeer)->world == world_.name || currentPeer == peer) {
					lock = pInfo(currentPeer)->lock;
				}
			}
			*(__int8*)(blc + 8) = 62;
			*(__int32*)(blc + 9) = block_.id;
			*(__int32*)(blc + 13) = block_.pr;
			*(__int8*)(blc + 17) = block_.enabled ? 1 : 0;
			*(__int8*)(blc + 18) = block_.magnetron ? 1 : 0;
			*(__int16*)(blc + 20) = get_mag_size(lock);
			/*
			uint8_t magnetronas_ijungtas = block_.magnetron ? 1 : 0;
			uint8_t active_ = block_.enabled ? 1 : 0;
			uint32_t block_id = block_.id;
			uint32_t item_count = block_.pr;
			uint32_t kiek_telpa = 5000;
			BYTE btype = 62;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &block_id, 4);
			memcpy(blc + 13, &item_count, 4);
			memcpy(blc + 17, &active_, 1);
			memcpy(blc + 18, &magnetronas_ijungtas, 1);
			memcpy(blc + 20, &kiek_telpa, 2);*/
			if (case_) {
				blc += 15;
				return 15;
			}
			break;
		}
		case 6948: case 6946:
		{
			int lock = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or not pInfo(currentPeer)->isIn) continue;
				if (pInfo(currentPeer)->world == world_.name || currentPeer == peer) {
					lock = pInfo(currentPeer)->lock;
				}
			}
			*(__int8*)(blc + 8) = 62;
			*(__int16*)(blc + 9) = block_.id;
			*(__int16*)(blc + 13) = block_.pr;
			*(__int8*)(blc + 17) = block_.enabled ? 1 : 0;
			*(__int16*)(blc + 21) = get_mag_size(lock);
			/*
			int max_telpa = 1500;
			int active_ = block_.enabled ? 1 : 0;
			int block_id = block_.id;
			int item_count = block_.pr;
			BYTE btype = 62;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &block_id, 4);
			memcpy(blc + 13, &item_count, 4);
			memcpy(blc + 17, &active_, 4);
			memcpy(blc + 21, &max_telpa, 4);*/
			if (case_) {
				blc += 15;
				return 15;
			}
			break;
		}
		case 6950: case 6952:
		{
			*(__int8*)(blc + 8) = block_.fg == 6950 ? 70 : 69;
			*(__int8*)(blc + 9) = block_.pr > 0 ? 1 : 0;
			*(__int16*)(blc + 13) = block_.pr;
			*(__int16*)(blc + 17) = block_.id;
			*(__int8*)(blc + 21) = block_.enabled ? 1 : 0;
			if (case_) {
				blc += 13;
				return 13;
			}
		}
		}
	}
	else {
		switch (items[block_.fg].blockType) {
		case BlockTypes::CRYSTAL:
		{
			*(__int8*)(blc + 8) = 20;
			*(__int8*)(blc + 9) = 0;
			memcpy(blc + 11, "", 0);
			*(__int16*)(blc + 17) = block_.id;
			*(__int8*)(blc + 21) = block_.enabled;

			/*
			BYTE btype = 20;
			memcpy(blc + 8, &btype, 1);
			string text = "";
			int l_ = (int)text.size();
			memcpy(blc + 9, &l_, 2);
			memcpy(blc + 11, text.c_str(), l_);*/
			if (case_) {
				blc += 3 + 0;
				return 3 + 0;
			}
			break;
		}
		case BlockTypes::WEATHER:
		{
			switch (block_.fg) {
			case 3694:
			{
				*(__int8*)(blc + 8) = 40;
				*(int*)(blc + 9) = (block_.b << 24) | (block_.g << 16) | (block_.r << 8);
				if (case_) {
					blc += 5;
					return 5;
				}
				break;
			}
			case 5000:
			{
				*(__int8*)(blc + 8) = 40;
				*(__int16*)(blc + 9) = (block_.id != 0 ? block_.id : 14);
				if (case_) {
					blc += 5;
					return 5;
				}
				break;
			}
			case 3832: case 5958:
			{
				uint8_t spin = block_.spin;
				*(__int8*)(blc + 8) = 49;
				*(__int16*)(blc + 9) = (block_.id != 0 ? block_.id : 2);
				*(__int16*)(blc + 13) = (block_.fg == 5958 ? block_.epoch_minute : block_.gravity);
				*(__int8*)(blc + 17) = spin | (block_.invert << 1);

				if (case_) {
					blc += 10;
					return 10;
				}
				break;
			}
			default:
			{
				if (items[block_.fg].ext_weather) {
					*(__int8*)(blc + 8) = 5;
					/*
					BYTE btype = 5;
					memcpy(blc + 8, &btype, 1);*/
					if (case_) {
						blc += 1;
						return 1;
					}
				}
			}
			}
			break;
		}
		case BlockTypes::VENDING:
		{
			*(int*)(blc + 9) = (block_.pr < 0 and block_.id != 0 && block_.c_ < (block_.pr * -1) ? 0 : block_.id);
			*(__int8*)(blc + 8) = 24;
			*(int*)(blc + 4) = (block_.pr < 0 and block_.id != 0 && block_.c_ < (block_.pr * -1) ? block_.flags | ((block_.c_ < (block_.pr * -1)) ? (block_.wl != 0 ? 0x02410000 : 0x00410000) : (block_.wl != 0 ? 0x02410000 : 0x00410000)) : block_.flags | (block_.id == 0 ? (block_.wl != 0 ? 0x02000000 : 0x00000000) : (block_.wl != 0 ? 0x02410000 : 0x00410000)));
			*(int*)(blc + 13) = (block_.pr < 0 and block_.id != 0 && block_.c_ < (block_.pr * -1) ? 0 : block_.pr);

			/*
			uint32_t item_id = block_.id;
			uint32_t item_price = block_.pr;
			uint32_t item_count = block_.c_;
			uint32_t vend_available_wls = block_.wl;
			int visual = block_.flags | ((int)item_id == 0 ? ((int)vend_available_wls != 0 ? 0x02000000 : 0x00000000) : ((int)vend_available_wls != 0 ? 0x02410000 : 0x00410000));
			if ((int)item_price < 0 and (int)item_id != 0) {
				if ((int)item_count < ((int)item_price * -1))
					item_id = 0, item_price = 0;
				visual = block_.flags | (((int)item_count < ((int)item_price * -1)) ? ((int)vend_available_wls != 0 ? 0x02410000 : 0x00410000) : ((int)vend_available_wls != 0 ? 0x02410000 : 0x00410000));
			}
			memcpy(blc + 4, &visual, 4);
			BYTE btype = 24;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &item_id, 4);
			memcpy(blc + 13, &item_price, 4);*/
			if (case_) {
				blc += 9;
				return 9;
			}
			break;
		}
		case BlockTypes::DISPLAY:
		{
			*(__int8*)(blc + 8) = 23;
			*(__int16*)(blc + 9) = block_.id;

			/*
			BYTE btype = 23;
			memcpy(blc + 8, &btype, 1);
			uint32_t id_ = block_.id;
			memcpy(blc + 9, &id_, 4);*/
			if (case_) {
				blc += 5;
				return 5;
			}
			break;
		}
		case BlockTypes::PROVIDER:
		{
			*(__int8*)(blc + 8) = 9;
			*(int*)(blc + 9) = time(nullptr) - block_.planted <= items[block_.fg].growTime ? time(nullptr) - block_.planted : items[block_.fg].growTime;

			/*
			BYTE btype = 9;
			memcpy(blc + 8, &btype, 1);
			uint32_t laikas = uint32_t((time(nullptr) - block_.planted <= items[block_.fg].growTime ? time(nullptr) - block_.planted : items[block_.fg].growTime));
			memcpy(blc + 9, &laikas, 4);*/
			if (case_) {
				blc += 5;
				return 5;
			}
			break;
		}
		case BlockTypes::RANDOM_BLOCK:
		{
			*(__int8*)(blc + 8) = 8;
			*(__int16*)(blc + 9) = block_.roll;

			/*
			BYTE btype = 8;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &block_.roll, 1);*/
			if (case_) {
				blc += 2;
				return 2;
			}
			break;
		}
		case BlockTypes::LOCK:
		{
			if (block_.open_to_public) {
				int new_ = 0x00800000;
				memcpy(blc + 4, &new_, 4);
			}
			BYTE btype = 3;
			memcpy(blc + 8, &btype, 1);
			uint8_t world_settings = world_.disable_music_blocks ? (world_.make_music_blocks_invisible ? 12345 : 1234) : (world_.make_music_blocks_invisible ? 100 : 0);
			if (world_.rainbows and block_.fg == 4802) world_settings += 128;
			uint32_t world_owner_id = -1;
			{
				uint8_t world_settings = 0;
				if (block_.fg == 202 or block_.fg == 204 or block_.fg == 206 or block_.fg == 4994) {
					if (block_.fg == 4994 and block_.build_only) world_settings |= 64;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (block_.owner_id == pInfo(currentPeer)->uid) {
							world_owner_id = pInfo(currentPeer)->id;
						}
					}
					uint32_t bpm_ = world_.music_bpm * -1; //world_.music_bpm * -1
					memcpy(blc + 9, &world_settings, 1);
					memcpy(blc + 10, &world_owner_id, 4);
					memcpy(blc + 18, &bpm_, 4);
				}
				else {
					uint8_t world_settings = 0;
					if (world_.disable_music_blocks) world_settings |= 16;
					if (world_.make_music_blocks_invisible) world_settings |= 32;
					if (world_.rainbows and block_.fg == 4802) world_settings |= 128;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (world_.owner_id == pInfo(currentPeer)->uid) {
							world_owner_id = pInfo(currentPeer)->id;
						}
					}
					uint32_t bpm_ = world_.music_bpm * -1; //world_.music_bpm * -1
					memcpy(blc + 9, &world_settings, 1);
					memcpy(blc + 10, &world_owner_id, 4);
					memcpy(blc + 18, &bpm_, 4);
				}
			}
			uint32_t admin_id = 0;
			uint32_t count_of_admins = 1;
			{
				if (block_.fg == 202 or block_.fg == 204 or block_.fg == 206 or block_.fg == 4994) {
					if (peer != NULL and find(block_.admins.begin(), block_.admins.end(), pInfo(peer)->uid) != block_.admins.end()) {
						memcpy(blc + 22, &pInfo(peer)->id, 4);
						count_of_admins++;
					} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_.name) {
							if (find(block_.admins.begin(), block_.admins.end(), pInfo(currentPeer)->uid) != block_.admins.end()) {
								if (count_of_admins == 1) {
									memcpy(blc + 22, &pInfo(currentPeer)->id, 4);
								}
								else {
									memcpy(blc + 22 + (count_of_admins * 4), &pInfo(currentPeer)->id, 4);
								}
								count_of_admins++;
								//if (count_of_admins > 7) break;
							}
						}
					}
				}
				else {
					if (peer != NULL and guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) != world_.admins.end()) {
						memcpy(blc + 22, &pInfo(peer)->id, 4);
						count_of_admins++;
					} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_.name) {
							if (guild_access(currentPeer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(currentPeer)->uid) != world_.admins.end()) {
								if (count_of_admins == 1) {
									memcpy(blc + 22, &pInfo(currentPeer)->id, 4);
								}
								else {
									memcpy(blc + 22 + (count_of_admins * 4), &pInfo(currentPeer)->id, 4);
								}
								count_of_admins++;
								//if (count_of_admins > 7) break;
							}
						}
					}
				}
				memcpy(blc + 14, &count_of_admins, 1);
			}
			if (block_.fg == 5814 and world_.guild_id != 0) {
				uint32_t guild_id = world_.guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (not case_) {
						memcpy(blc + 30 + (count_of_admins * 4), &guild_information->guild_mascot[0], 2);
						memcpy(blc + 30 + (count_of_admins * 4) + 2, &guild_information->guild_mascot[1], 2);
						memcpy(blc + 30 + (count_of_admins * 4) + 4, &guild_information->guild_level, 2);
						memcpy(blc + 30 + (count_of_admins * 4) + 8, &guild_information->unlocked_mascot, 1);
					}
					else {
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 4, &guild_information->guild_mascot[0], 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 6, &guild_information->guild_mascot[1], 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 8, &guild_information->guild_level, 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 12, &guild_information->unlocked_mascot, 1);
					}
					if (case_) {
						blc += 26 + (count_of_admins * 4);
						return 26 + (count_of_admins * 4);
					}
				}
			}
			else {
				if (case_) {
					blc += 10 + (count_of_admins * 4);
					return 10 + (count_of_admins * 4);
				}
			}
			break;
		}
		case BlockTypes::MAIN_DOOR:
		{
			*(__int8*)(blc + 8) = 1;
			*(__int16*)(blc + 9) = 4;
			memcpy(blc + 11, "EXIT", 4);

			/*
			BYTE btype = 1;
			memcpy(blc + 8, &btype, 1);
			string text = "EXIT";
			int l_ = (int)text.size();
			memcpy(blc + 9, &l_, 2);
			memcpy(blc + 11, text.c_str(), l_);*/
			if (case_) {
				blc += 4 + 4;
				return 4 + 4;
			}
			break;
		}
		case BlockTypes::SEED:
		{
			*(int*)(blc + 4) = block_.flags | 0x100000;
			*(__int8*)(blc + 8) = 4;
			*(int*)(blc + 9) = (time(nullptr) - block_.planted <= items.at(block_.fg).growTime ? time(nullptr) - block_.planted : items.at(block_.fg).growTime);
			*(__int16*)(blc + 13) = block_.fruit;

			/*
			int visual = block_.flags | 0x100000;
			memcpy(blc + 4, &visual, 4);
			BYTE data_type = 4;
			memcpy(blc + 8, &data_type, 1);
			uint32_t laikas = uint32_t((time(nullptr) - block_.planted <= items[block_.fg].growTime ? time(nullptr) - block_.planted : items[block_.fg].growTime));
			uint8_t count = uint8_t(block_.fruit);
			memcpy(blc + 9, &laikas, 4);
			memcpy(blc + 13, &count, 1);*/
			if (case_) {
				blc += 6;
				return 6;
			}
			break;
		}
		case BlockTypes::DOOR: case BlockTypes::PORTAL:
		{
			string duru_tekstas = (block_.txt.empty() ? (block_.door_destination.empty() ? "" : (block_.door_destination.find(":") != string::npos ? explode(":", block_.door_destination)[0] + "..." : block_.door_destination)) : block_.txt);
			*(__int8*)(blc + 8) = 1;
			*(__int16*)(blc + 9) = duru_tekstas.size();
			memcpy(blc + 11, duru_tekstas.c_str(), duru_tekstas.size());
			*(__int8*)(blc + 11 + duru_tekstas.size()) = (block_.open ? 0 : 0x08);

			/*
			BYTE data_type = 1;
			memcpy(blc + 8, &data_type, 1);
			string duru_tekstas = (block_.txt.empty() ? (block_.door_destination.empty() ? "" : (block_.door_destination.find(":") != string::npos ? explode(":", block_.door_destination)[0] + "..." : block_.door_destination)) : block_.txt);
			uint32_t dydis = uint32_t(duru_tekstas.size());
			memcpy(blc + 9, &dydis, 2);
			memcpy(blc + 11, duru_tekstas.c_str(), dydis);o
			uint8_t locked_ = (block_.open ? 0 : 0x08);
			memcpy(blc + 11 + dydis, &locked_, 1);*/
			if (case_) {
				blc += 4 + duru_tekstas.size();
				return 4 + duru_tekstas.size();
			}
			break;
		}
		case BlockTypes::DONATION: case BlockTypes::BULLETIN_BOARD:
		{
			*(__int32*)(blc + 4) = (block_.donates.size() > 0 ? block_.flags | 0x00400000 : block_.flags);
			*(__int8*)(blc + 8) = 12;
			if (case_) {
				blc += 8;
				return 8;
			}
			break;
		}
		case BlockTypes::SIGN:
		{
			*(__int8*)(blc + 8) = 2;
			*(int*)(blc + 9) = block_.txt.size();
			memcpy(blc + 11, block_.txt.c_str(), block_.txt.size());
			*(__int16*)(blc + 11 + block_.txt.size()) = 0;

			/*
			BYTE data_type = 2;
			memcpy(blc + 8, &data_type, 1);
			string sign_tekstas = block_.txt;
			uint32_t dydis = uint32_t(sign_tekstas.size());
			memcpy(blc + 9, &dydis, 2);
			memcpy(blc + 11, sign_tekstas.c_str(), dydis);
			uint32_t nzn_kas = 0;
			memcpy(blc + 11 + dydis, &nzn_kas, 1);*/
			if (case_) {
				blc += 7 + block_.txt.size();
				return 7 + block_.txt.size();
			}
			break;
		}
		}
	}
	return 0;
}

void upd_lock(WorldBlock block_2, World world_, ENetPeer* peer) {
	if (peer == nullptr) return;
	int l_x = block_2.lock_origin % world_.width;
	int l_y = block_2.lock_origin / world_.width;
	WorldBlock block_ = world_.blocks[l_x + (l_y * world_.width)];
	vector<WorldBlock> shadow_copy_2 = world_.blocks;
	vector<vector<int>> locked_tiles_around_lock{};
	vector<int> new_tiles{};
	new_tiles.push_back(l_x + (l_y * world_.width));
	try {
		for (int i2 = 0; i2 < new_tiles.size(); i2++) {
			int s_x_ = new_tiles.at(i2) % world_.width, s_y_ = new_tiles.at(i2) / world_.width;
			if (s_x_ < (world_.width - 1) and shadow_copy_2.at(s_x_ + 1 + (s_y_ * world_.width)).locked and shadow_copy_2.at(s_x_ + 1 + (s_y_ * world_.width)).lock_origin == (l_x + (l_y * world_.width))) {
				if (not shadow_copy_2.at(s_x_ + 1 + (s_y_ * world_.width)).scanned) {
					shadow_copy_2.at(s_x_ + 1 + (s_y_ * world_.width)).scanned = true;
					new_tiles.push_back(s_x_ + 1 + (s_y_ * world_.width));
					locked_tiles_around_lock.push_back({ s_x_ + 1, s_y_ });
				}
			} if (s_x_ > 0 and shadow_copy_2.at(s_x_ - 1 + (s_y_ * world_.width)).locked and shadow_copy_2.at(s_x_ - 1 + (s_y_ * world_.width)).lock_origin == (l_x + (l_y * world_.width))) {
				if (not shadow_copy_2.at(s_x_ - 1 + (s_y_ * world_.width)).scanned) {
					shadow_copy_2.at(s_x_ - 1 + (s_y_ * world_.width)).scanned = true;
					new_tiles.push_back(s_x_ - 1 + (s_y_ * world_.width));
					locked_tiles_around_lock.push_back({ s_x_ - 1, s_y_ });
				}
			} if (s_y_ < (world_.height - 1) and shadow_copy_2.at(s_x_ + ((s_y_ + 1) * world_.width)).locked and shadow_copy_2.at(s_x_ + ((s_y_ + 1) * world_.width)).lock_origin == (l_x + (l_y * world_.width))) {
				if (not shadow_copy_2.at(s_x_ + ((s_y_ + 1) * world_.width)).scanned) {
					shadow_copy_2.at(s_x_ + ((s_y_ + 1) * world_.width)).scanned = true;
					new_tiles.push_back(s_x_ + ((s_y_ + 1) * world_.width));
					locked_tiles_around_lock.push_back({ s_x_, s_y_ + 1 });
				}
			} if (s_y_ > 0 and shadow_copy_2.at(s_x_ + ((s_y_ - 1) * world_.width)).locked and shadow_copy_2.at(s_x_ + ((s_y_ - 1) * world_.width)).lock_origin == (l_x + (l_y * world_.width))) {
				if (not shadow_copy_2.at(s_x_ + ((s_y_ - 1) * world_.width)).scanned) {
					shadow_copy_2.at(s_x_ + ((s_y_ - 1) * world_.width)).scanned = true;
					new_tiles.push_back(s_x_ + ((s_y_ - 1) * world_.width));
					locked_tiles_around_lock.push_back({ s_x_, s_y_ - 1 });
				}
			}
		}
	}
	catch (out_of_range) {
	}
	int lock_size = locked_tiles_around_lock.size();
	if (locked_tiles_around_lock.size() != 0) {
		PlayerMoving data_{};
		data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
		data_.netID = peer == NULL ? -1 : (block_.owner_id == pInfo(peer)->uid ? pInfo(peer)->id : -1);
		data_.plantingTree = block_.fg;
		BYTE* raw;
		raw = packPlayerMoving(&data_, 112 + (locked_tiles_around_lock.size() * 2) + alloc_(&world_, &block_));
		int lalala = 8;
		memcpy(raw + 8, &lock_size, 2);
		memcpy(raw + 12, &lalala, 2);
		BYTE* blc = raw + 56;
		for (int i_ = 0; i_ < locked_tiles_around_lock.size(); i_++) {
			vector<int> update_tiles = locked_tiles_around_lock[i_];
			int x = update_tiles[0];
			int y = update_tiles[1];
			int sq_ = x + (y * world_.width);
			memcpy(blc + (i_ * 2), &sq_, 2);
			shadow_copy_2[x + (y * world_.width)].scanned = false;
		}
		PlayerMoving data_2{};
		data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
		BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(&world_, &block_));
		BYTE* blc2 = raw2 + 56;
		form_visual(blc2, block_, world_, peer, false);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) { //fix
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (world_.name == pInfo(currentPeer)->world) {
				send_raw(currentPeer, 4, raw, 112 + (locked_tiles_around_lock.size() * 2) + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
				send_raw(currentPeer, 4, raw2, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
			}
		}
		delete[] raw, blc;
		delete[] raw2, blc2;
	}
	else {
		PlayerMoving data_{};
		data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
		data_.netID = block_.owner_id == pInfo(peer)->uid ? pInfo(peer)->id : -1;
		data_.plantingTree = block_.fg;
		BYTE* raw = packPlayerMoving(&data_, 56);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (world_.name == pInfo(currentPeer)->world) {
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				PlayerMoving data_2{};
				data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
				BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(&world_, &block_));
				BYTE* blc2 = raw2 + 56;
				form_visual(blc2, block_, world_, currentPeer, false);
				send_raw(currentPeer, 4, raw2, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
				delete[] raw2, blc2;
			}
		}
		delete[] raw;
	}
}

struct Carnival
{
	bool game_active = false;
	string player_ = "";
	vector<string> player_queue_{};
	int punch_c = 0, score_ = 0;
	long long when_ = 0, until_ = 0;
};
vector<Carnival> carnival;

void bullseye_update(ENetPeer* peer, int x_, int y_, bool turn_off = false) { //carnival
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
		block_->flags = block_->flags | 0x00400000;
		if (turn_off) {
			block_->flags = block_->flags ^ 0x00400000;
		}
		PlayerMoving data_{};
		data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
		BYTE* blc = raw + 56;
		form_visual(blc, *block_, *world_, peer, false);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name) {
				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
			}
		}
		delete[] raw, blc;
		if (block_->locked) {
			upd_lock(*block_, *world_, peer);
		}
	}
}
void carnival_start(ENetPeer* peer, string game) { //carnival
	try {
		if (game == ":GAME1") {
			carnival[1].player_queue_.push_back(pInfo(peer)->tankIDName);
		}
		if (game == ":GAME2") {
			carnival[2].player_queue_.push_back(pInfo(peer)->tankIDName);
		}
	}
	catch (exception& e) {
		cout << e.what() << endl;
		return;
	}
}
void wipe_carnival(ENetPeer* peer) { //carnival
	try {
		for (int i = 0; i < carnival[1].player_queue_.size(); i++) {
			if (carnival[1].player_queue_.at(i) == pInfo(peer)->tankIDName and carnival[1].player_.empty()) {
				carnival[1].player_queue_.at(i).erase(), carnival[1].player_ = pInfo(peer)->tankIDName;
				carnival[1].when_ = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count(), carnival[1].until_ = 30 * 1000;
				pInfo(peer)->x = 70 * 32, pInfo(peer)->y = 70 * 32;
				pInfo(peer)->c_x = 70, pInfo(peer)->c_y = 53;
				gamepacket_t p(0, pInfo(peer)->netID), p2(0, pInfo(peer)->netID), p3;
				p.Insert("OnSetPos");	p2.Insert("OnCountdownStart");	p3.Insert("OnTalkBubble");
				p.Insert(float(70) * 32, float(53) * 32);	p2.Insert(30);	p3.Insert(pInfo(peer)->netID);
				p.CreatePacket(peer);	p2.Insert(0);	p3.Insert("`8Good Luck! `wScore 30 to win a prize!");
				p2.CreatePacket(peer);	p3.Insert(0);
				p3.CreatePacket(peer);

			}
		}
		for (int i = 0; i < carnival[2].player_queue_.size(); i++) {
			if (carnival[2].player_queue_.at(i) == pInfo(peer)->tankIDName and carnival[2].player_.empty()) {
				carnival[2].player_queue_.at(i).erase(), carnival[2].player_ = pInfo(peer)->tankIDName;
				carnival[2].when_ = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count(), carnival[2].until_ = 30 * 1000;
				pInfo(peer)->x = 70 * 32, pInfo(peer)->y = 70 * 32;
				pInfo(peer)->c_x = 70, pInfo(peer)->c_y = 53;
				gamepacket_t p(0, pInfo(peer)->netID), p2(0, pInfo(peer)->netID), p3;
				p.Insert("OnSetPos");	p2.Insert("OnCountdownStart");	p3.Insert("OnTalkBubble");
				p.Insert(float(70) * 32, float(53) * 32);	p2.Insert(30);	p3.Insert(pInfo(peer)->netID);
				p.CreatePacket(peer);	p2.Insert(0);	p3.Insert("`8Good Luck! `wScore 30 to win a prize!");
				p2.CreatePacket(peer);	p3.Insert(0);
				p3.CreatePacket(peer);
			}
		}
	}
	catch (exception& e) {
		cout << e.what() << endl;
		return;
	}
}
void carnival_end(ENetPeer* peer) { //carnival
	try {
		long long int time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		if (carnival[1].player_ == pInfo(peer)->tankIDName) {
			int actualseconds = (carnival[1].when_ + carnival[1].until_ - time) / 1000;
			if (actualseconds < 1) {
				vector<vector<int>> wht = { {67, 52}, {69, 52}, {71, 52}, {73, 52}, {68, 50}, {70, 50}, {72, 50}, {69, 48}, {71, 48}, {70, 46} };
				for (int i_ = 0; i_ < wht.size(); i_++) {
					bullseye_update(peer, wht[i_][0], wht[i_][1], true);
				}
				carnival[1].player_ = "", carnival[1].punch_c = 0, carnival[1].score_ = 0, carnival[1].when_ = 0, carnival[1].until_ = 0;
				pInfo(peer)->x = 75 * 32, pInfo(peer)->y = 75 * 32;
				pInfo(peer)->c_x = 75, pInfo(peer)->c_y = 51;
				vector<int> ids;
				if (rand() % 100 < 5) ids = { 6780 };
				else ids = { 1880, 1906 };


				int prize = ids[rand() % ids.size()];
				int c_ = 1;

				gamepacket_t p(0, pInfo(peer)->netID), p2, p3;
				p.Insert("OnSetPos");	p2.Insert("OnCountdownEnd");	p3.Insert("OnTalkBubble");
				p.Insert(float(75) * 32, float(51) * 32);	p3.Insert(pInfo(peer)->netID);
				p.CreatePacket(peer);
				p3.Insert(format("`8You won and got a `2{}``", items.at(prize).name));
				p2.CreatePacket(peer);
				p3.Insert(0);

				if (modify_inventory(peer, prize, c_) == 0) {
					p3.CreatePacket(peer);
				}
				else {
					string name_ = pInfo(peer)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldDrop drop_block_{};
						drop_block_.id = prize, drop_block_.count = c_, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
			}
		}
		if (carnival[2].player_ == pInfo(peer)->tankIDName) {
			int actualseconds = (carnival[2].when_ + carnival[2].until_ - time) / 1000;
			if (actualseconds < 1) {
				vector<int> ids;
				if (rand() % 100 < 5) ids = { 6780 };
				else ids = { 1880, 1906 };

				int prize = ids[rand() % ids.size()];
				int c_ = 1;

				vector<vector<int>> wht = { {67, 52}, {69, 52}, {71, 52}, {73, 52}, {68, 50}, {70, 50}, {72, 50}, {69, 48}, {71, 48}, {70, 46} };
				for (int i_ = 0; i_ < wht.size(); i_++) {
					bullseye_update(peer, wht[i_][0] + 36, wht[i_][1], true);
				}
				carnival[2].player_ = "", carnival[2].punch_c = 0, carnival[2].score_ = 0, carnival[2].when_ = 0, carnival[2].until_ = 0;
				pInfo(peer)->x = 75 * 32, pInfo(peer)->y = 51 * 32;
				pInfo(peer)->c_x = 75, pInfo(peer)->c_y = 51;
				gamepacket_t p(0, pInfo(peer)->netID), p2, p3;
				p.Insert("OnSetPos");	p2.Insert("OnCountdownEnd");	p3.Insert("OnTalkBubble");
				p.Insert(float(75) * 32, float(51) * 32);	p3.Insert(pInfo(peer)->netID);
				p.CreatePacket(peer);
				p3.Insert(format("`8You won and got a `2{}``", items.at(prize).name));
				p2.CreatePacket(peer);
				p3.Insert(0);

				if (modify_inventory(peer, prize, c_) == 0) {
					p3.CreatePacket(peer);
				}
				else {
					string name_ = pInfo(peer)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldDrop drop_block_{};
						drop_block_.id = prize, drop_block_.count = c_, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
			}
		}
	}
	catch (exception& e) {
		cout << e.what() << endl;
		return;
	}
}
void carnival_clear(ENetPeer* peer) {
	try {
		if (carnival[1].player_ == pInfo(peer)->tankIDName) {
			vector<vector<int>> wht = { {67, 52}, {69, 52}, {71, 52}, {73, 52}, {68, 50}, {70, 50}, {72, 50}, {69, 48}, {71, 48}, {70, 46} };
			for (int i_ = 0; i_ < wht.size(); i_++) {
				bullseye_update(peer, wht[i_][0], wht[i_][1], true);
			}
			gamepacket_t p2;
			p2.Insert("OnCountdownEnd");
			p2.CreatePacket(peer);
			carnival[1].player_ = "", carnival[1].punch_c = 0, carnival[1].score_ = 0, carnival[1].when_ = 0, carnival[1].until_ = 0;
		}
		if (carnival[2].player_ == pInfo(peer)->tankIDName) {
			vector<vector<int>> wht = { {67, 52}, {69, 52}, {71, 52}, {73, 52}, {68, 50}, {70, 50}, {72, 50}, {69, 48}, {71, 48}, {70, 46} };
			for (int i_ = 0; i_ < wht.size(); i_++) {
				bullseye_update(peer, wht[i_][0], wht[i_][1], true);
			}
			gamepacket_t p2;
			p2.Insert("OnCountdownEnd");
			p2.CreatePacket(peer);
			carnival[2].player_ = "", carnival[2].punch_c = 0, carnival[2].score_ = 0, carnival[2].when_ = 0, carnival[2].until_ = 0;
		}
	}
	catch (exception& e) {
		cout << e.what() << endl;
		return;
	}
}

void add_ipban(ENetPeer* peer) {
	vector<string> bans;
	ifstream ifs("database/ipban.json");
	if (ifs.is_open()) {
		json j;
		ifs >> j;
		vector<string> bans2 = j["ip"];
		bans = bans2;
	}
	bans.push_back(pInfo(peer)->ip);
	ofstream o("database/ipban.json");
	if (!o.is_open()) return;
	json j;
	j["ip"] = bans;
	o << j << endl;
	pInfo(peer)->bans.push_back("`6ON:`` `#" + pInfo(peer)->tankIDName + "`` `0(" + pInfo(peer)->requestedName + ") #" + to_string(pInfo(peer)->netID) + "`` IP BANNED: [" + pInfo(peer)->ip + "]");
}

void update_deviceban() {
	ofstream o("database/ridban.json");
	if (!o.is_open()) return;
	json j;
	j["rid"] = ridbans;
	o << j << endl;

	ofstream so("database/ipban.json");
	if (!so.is_open()) return;
	json js;
	js["ip"] = ipbans;
	so << js << endl;
}
void add_ridban(ENetPeer* peer) {
	vector<string> bans;
	ifstream ifs("database/ridban.json");
	if (ifs.is_open()) {
		json j;
		ifs >> j;
		vector<string> bans2 = j["rid"];
		bans = bans2;
	}
	bans.push_back(pInfo(peer)->rid);
	ofstream o("database/ridban.json");
	if (!o.is_open()) return;
	json j;
	j["rid"] = bans;
	o << j << endl;
	pInfo(peer)->bans.push_back("`6ON:`` `#" + pInfo(peer)->tankIDName + "`` `0(" + pInfo(peer)->requestedName + ") #" + to_string(pInfo(peer)->netID) + "`` Device BANNED: (" + pInfo(peer)->rid + ")");
}

string fixchar(string name) {
	string newS;
	for (char c : name) newS += (c >= 'A' && c <= 'Z') ? c - ('A' - 'a') : c;
	string ret;
	for (int i = 0; i < newS.length(); i++) if (newS[i] == '`') i++; else ret += newS[i];
	string ret2;
	for (char c : ret) if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) ret2 += c;
	return ret2;
}

string fixchar2(string name) {
	string ret;
	for (int i = 0; i < name.length(); i++) if (name[i] == '<@' || name[i] == '`' || name[i] == '`#' || name[i] == '``' || name[i] == '`0' || name[i] == '`8' || name[i] == '`6' || name[i] == '`9' || name[i] == '`4' || name[i] == '`2') i++; else ret += name[i];
	return ret;
}

string fixchar3(string str)
{
	string newS;
	for (char c : str) newS += (c >= 'A' && c <= 'Z') ? c - ('A' - 'a') : c;
	string ret;
	for (int i = 0; i < newS.length(); i++) if (newS[i] == '`') i++; else ret += newS[i];
	string ret2;
	for (char c : ret) if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) ret2 += c;
	int current = 0;
	for (int i = 0; i < ret2.length(); i++) {
		if (!isdigit(ret2[i])) {
			ret2[current] = ret2[i];
			current++;
		}
	}
	return ret2.substr(0, current);
}
bool state_check(ENetPeer* peer) {
	if (pInfo(peer)->x <= 0 and pInfo(peer)->y <= 0 and pInfo(peer)->characterState <= 0 and not pInfo(peer)->world.empty()) {
		pInfo(peer)->warn++;
		if (pInfo(peer)->warn >= 2) {
			pInfo(peer)->warn = 0, add_ipban(peer);
			return false;
		}
	}
	return true;
}
void add_modlogs(ENetPeer* peer, string bywho, string text, string timed) {
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert("CT:[FC]_>> `r>> [MOD-LOGS] from (``" + bywho + "```r) in [```$" + pInfo(peer)->world + "```r] > `r" + text + "" + (timed != "" ? " for " + timed + "``" : ""));
	string ban = "[MOD-LOGS] from(" + bywho + ") in [" + pInfo(peer)->world + "] > " + text + "" + (timed != "" ? " for " + timed + "" : "");
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->hide_logs) continue;
		if (pInfo(currentPeer)->mod == 0) continue;
		p.CreatePacket(currentPeer);
	}
}
void send_server_logs(string const& who, string const& content) {
	gamepacket_t packet;
	packet.Insert("OnConsoleMessage");
	packet.Insert(format("`5>> MOD-LOG: `o{} {}", who, content));
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->hide_logs) continue;
		if (pInfo(currentPeer)->mod) {
			packet.CreatePacket(currentPeer);
		}
	}
}
void send_logs(string const& content) {
	gamepacket_t packet;
	packet.Insert("OnConsoleMessage");
	packet.Insert(content);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->hide_logs) continue;
		if (pInfo(currentPeer)->mod) {
			packet.CreatePacket(currentPeer);
		}
	}
}
void send_user_logs(string const& who, string const& content) {
	gamepacket_t packet;
	packet.Insert("OnConsoleMessage");
	packet.Insert(format("`5{} `o{}", who, content));
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->hide_logs) continue;
		if (pInfo(currentPeer)->mod) {
			packet.CreatePacket(currentPeer);
		}
	}
}
inline void Send_Mod_Logs(string world, string bywho, string text, string timed) {
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert("CT:[FC]_>> `^>> `1TayoPs `^Logs from (``" + bywho + "```^) in [```$" + world + "```^] > `^" + text + "" + (timed != "" ? " for " + timed + "``" : ""));
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->hide_logs) continue;
		if (not pInfo(currentPeer)->mod) continue;
		p.CreatePacket(currentPeer);
	}
}
inline void Send_Mod_Logs2(string text) {
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert("CT:[FC]_>> `^>> `1TayoPs `^Logs from " + text);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->hide_logs) continue;
		if (not pInfo(currentPeer)->mod) continue;
		p.CreatePacket(currentPeer);
	}
}

void add_ban(ENetPeer* peer, long long int seconds, string reason, string bannedby, bool fake = false) {
	if (pInfo(peer)->b_t + (seconds * 1000) < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
		struct tm newtime;
		time_t now = time(0);
		localtime_s(&newtime, &now);
		//pInfo(peer)->logs.push_back("" + to_string(newtime.tm_mon + 1) + "/" + to_string(today_day) + "/2021 " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec) + " " + bannedby + " - >> Ban for " + to_string(seconds) + " seconds(" + reason + ")");
		if (not fake) {
			if (reason != "iDems") pInfo(peer)->bans.push_back("`6ON:`` `#" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` `0(" + pInfo(peer)->requestedName + ") #" + to_string(pInfo(peer)->netID) + "`` Time: " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " IP: " + pInfo(peer)->ip + " (banned by: " + bannedby + ", reason: " + reason + ") ");
			pInfo(peer)->b_s = (seconds * 1000);
			pInfo(peer)->b_r = reason;
			pInfo(peer)->b_b = bannedby;
			pInfo(peer)->b_t = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		}
		update_clothes(peer);
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oReality flickers as you begin to wake up. (`$Ban`` mod added, " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " left)");
			p.CreatePacket(peer);
			packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		}
		gamepacket_t p, p2;
		p.Insert("OnConsoleMessage");
		p.Insert((bannedby == "System" ? "`4**`` " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " `4AUTO-BANNED BY SYSTEM **`` (/rules to view rules)" : "`#**`` `$The Ancients`` have used `#Ban`` on ``" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + "`` `#**``"));
		p2.Insert("OnConsoleMessage");
		p2.Insert("`#**`` `$The Ancient Ones`` have `4banned`` " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + "`` `#**`` (`4/rules`` to see the rules!)");
		gamepacket_t p3(0, pInfo(peer)->netID);
		p3.Insert("OnPlayPositioned");
		p3.Insert("audio/keypad_hit.wav");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == pInfo(peer)->world) {
				p.CreatePacket(currentPeer), p3.CreatePacket(currentPeer);
			}
			else {
				p2.CreatePacket(currentPeer);
			}
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oWarning from `4System``: You've been `4BANNED`` from `1TayoPs`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
			p.CreatePacket(peer);
			{
				gamepacket_t p;
				p.Insert("OnAddNotification");
				p.Insert("interface/atomic_button.rttex");
				p.Insert("`wWarning from `4System``: You've been `4BANNED`` from `1TayoPs`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
				p.Insert("audio/hub_open.wav");
				p.Insert(0);
				p.CreatePacket(peer);
			}
		}
		enet_peer_disconnect_later(peer, 0);
	}
}

void add_mute(ENetPeer* peer, int seconds, string reason, string muttedby) {
	if (not has_playmod(pInfo(peer), "duct tape")) {
		PlayMods give_playmod{};
		give_playmod.id = 11;
		give_playmod.time = time(nullptr) + seconds;
		pInfo(peer)->playmods.push_back(give_playmod);
		pInfo(peer)->m_r = reason;
		update_clothes(peer);
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oDuct tape has covered your mouth! (`$Duct Tape`` mod added, " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " left)");
			p.CreatePacket(peer);
		}
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`#**`` `$The Ancient Ones`` have `4taped`` " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + "``'s mouth `#**`` (`4/rules`` to see the rules!)");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			p.CreatePacket(currentPeer);
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oWarning from `4Admin``: You've been `4duct-taped`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
			p.CreatePacket(peer);
			{
				gamepacket_t p;
				p.Insert("OnAddNotification");
				p.Insert("interface/atomic_button.rttex");
				p.Insert("`wWarning from `4Admin``: You've been `4duct-taped`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
				p.Insert("audio/hub_open.wav");
				p.Insert(0);
				p.CreatePacket(peer);
			}
		}
	}
}
void add_pFlag(ENetPeer* peer, int flagCode) {
	switch (flagCode) {
	case 0: {
		pInfo(peer)->Account_Notes.push_back("`o" + Algorithm::get_time() + ": >> Flagged for hacking (in " + pInfo(peer)->world + ") Type: NO_PATH_MOVE (Code " + to_string(flagCode) + ")");
	}
	case 1: {
		pInfo(peer)->Account_Notes.push_back("`o" + Algorithm::get_time() + ": >> Flagged for hacking (in " + pInfo(peer)->world + ") Type: PACKET_SPAM (Code " + to_string(flagCode) + ")");
	}
	case 2: {
		if (pInfo(peer)->totalFlag >= 3) {
			add_mute(peer, 10800, "Advertising Other Server", "System");
			pInfo(peer)->totalFlag = 0;
			pInfo(peer)->Account_Notes = {};
			pInfo(peer)->Account_Notes.push_back("`o" + Algorithm::get_time() + ": >> Flagged for advertising other server (in " + pInfo(peer)->world + ") Type: TEXT_SPAM (Code " + to_string(flagCode) + ")");
		}
	}
		  break;	  // ADD MORE CASE LATER
	}
}

void playsong(ENetPeer* peer, int songid) {
	if (songid > musics.size()) return;
	pInfo(peer)->songselected = songid;
	pInfo(peer)->songend = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count() + musics[songid].time;
	//if (songid != 10 and songid != 9) packet_(peer, "action|play_music\nfile|audio/mp3/song" + to_string(songid) + ".mp3\ndelayMS|0");
	if (songid == 1) packet_(peer, "action|play_music\nfile|audio/ogg/tayo.wav\ndelayMS|0");
	Algorithm::send_console(peer, "`2Now playing: `w" + musics[songid].name);
}
void spotify(ENetPeer* p_) {
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	string buttons = "";
	for (int i = 0; i < musics.size(); i++) {
		int fi = i + 1;
		string time = "";
		int second = musics[fi].time, minute = 0;
		while (second >= 60) {
			second -= 60;
			minute++;
		}
		time = (minute == 0 ? "" : to_string(minute) + ":") + (second < 10 ? to_string(second) + "0" : to_string(second));
		buttons += "\nadd_button|song*" + to_string(fi) + "|" + musics[fi].name + "`2 (" + time + ")|noflags|0|0|";
	}
	p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`2Spotify Music``|left|9492|\nadd_spacer|\nadd_textbox|`oWelcome to " + std::string(server_name) + " spotify you can listen to songs here, if you want to add your own song you will have to pay 1000 coins|\nadd_url_button|comment|`5Add my own song|noflags|http://discord.gg/" + std::string(server_name) + "|Wanna add your own song?|0|0|\nadd_spacer|small|\nadd_button|settings|Settings|noflags|0|0|\nadd_button|stopsong|Stop Playing|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`0Songs:|" + buttons + "\nend_dialog|spotify|close||\n");
	p.CreatePacket(p_);
}
void spotifysettings(ENetPeer* p_) {
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`2Spotify Settings``|left|9492|\nadd_spacer|\nadd_textbox|`oWelcome to " + std::string(server_name) + " spotify you can listen to songs here, if you want to add your own song you will have to pay 1000 coins|\nadd_checkbox|shuffle|Shuffle Songs|" + to_string(pInfo(p_)->shuffle) + "\nadd_checkbox|loop_song|Loop selected song|" + to_string(pInfo(p_)->loopsong) + "\nadd_spacer|small|\nend_dialog|asspotifysettings|Close|Save|\n");
	p.CreatePacket(p_);
}
void stopsong(ENetPeer* peer) {
	string n_ = pInfo(peer)->world;
	pInfo(peer)->songselected = 0;
	pInfo(peer)->songend = 0;
	Algorithm::send_overlay(peer, "You are stopped the song");
}
void SendRespawn(ENetPeer* peer, bool kickall, int instant, bool kill = false) {
	if (pInfo(peer)->world == "CARNIVAL" and carnival_open) carnival_clear(peer);
	if (pInfo(peer)->trading_with != -1) {
		cancel_trade(peer, false, true);
	}
	int width = 100;
	if (pInfo(peer)->respawn_time + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() || kickall) {
		pInfo(peer)->respawn_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		string name_ = pInfo(peer)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->c_x + (pInfo(peer)->c_y * world_->width)];
			uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
			width = world_->width;
			if (items[t_].blockType == BlockTypes::CHECKPOINT or items[t_].blockType == BlockTypes::MAIN_DOOR) {
			}
			else {
				if (not pInfo(peer)->izanagi) {
					int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize, square = (int)world_->blocks.size();
					for (int i_ = 0; i_ < square; i_++) {
						if (items[world_->blocks[i_].fg].blockType == BlockTypes::MAIN_DOOR) {
							pInfo(peer)->c_x = (i_ % xSize);
							pInfo(peer)->c_y = (i_ / xSize);
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("SetRespawnPos");
							p.Insert(i_);
							p.CreatePacket(peer);
							break;
						}
					}
				}
			}
		}
		{
			gamepacket_t p(0, pInfo(peer)->netID);
			p.Insert("OnSetFreezeState");
			p.Insert(pInfo(peer)->izanagi ? 0 : 2);
			p.CreatePacket(peer);
		}
		
		{
			gamepacket_t p(0, pInfo(peer)->netID);
			p.Insert("SetRespawnPos");
			p.Insert(pInfo(peer)->c_x + (pInfo(peer)->c_y * width));
			p.CreatePacket(peer);
		}
		{
			if (kill) {
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnKilled");
				p.CreatePacket(peer);
			}
		}
		if (not pInfo(peer)->izanagi)
		{
			gamepacket_t p((instant == 0 ? 2000 : 100), pInfo(peer)->netID);
			p.Insert("OnSetPos");
			p.Insert(float(pInfo(peer)->c_x) * 32, float(pInfo(peer)->c_y) * 32);
			p.CreatePacket(peer);
		}
		{
			gamepacket_t p((instant == 0 ? 2020 : 100), pInfo(peer)->netID);
			p.Insert("OnPlayPositioned");
			p.Insert("audio/teleport.wav");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					p.CreatePacket(currentPeer);
				}
			}
		}
		{
			gamepacket_t p((instant == 0 ? 2000 : 100), pInfo(peer)->netID);
			p.Insert("OnSetFreezeState");
			p.Insert(0);
			p.CreatePacket(peer);
		}
		if (pInfo(peer)->izanagi and not has_playmod(pInfo(peer), "Spikeproof")) {
			PlayMods new_mod{};
			new_mod.id = 121, new_mod.time = time(nullptr) + 3, new_mod.user = pInfo(peer)->tankIDName;
			pInfo(peer)->playmods.push_back(new_mod);
			Algorithm::send_console(peer, "Izanagi effects have been added to you for a while (Spike immune mod added, 3 secs left.)");
		}
	}
	save_player(pInfo(peer), false);
}

void end_surgery(ENetPeer* peer) {
	if (pInfo(peer)->surgery_started) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
			if (pInfo(peer)->surged_person != "" && pInfo(peer)->surged_person == pInfo(currentPeer)->tankIDName) SendRespawn(currentPeer, true, 0, 1);
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert("`7[```w" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `4failed to save`` " + pInfo(peer)->surged_display + " from " + pInfo(peer)->surgery_name + "!`7]``"), p.CreatePacket(currentPeer);
		}
		gamepacket_t p, p2;
		p.Insert("OnConsoleMessage"), p.Insert("`4The patient has succumbed to infection.`` `4YOUR MEDICAL LICENSE IS REVOKED!``"), p.CreatePacket(peer);
		p2.Insert("OnConsoleMessage"), p2.Insert("You are not allowed to perform surgery for a while! (`$Malpractice`` mod added, `$1 hour`` left)"), p2.CreatePacket(peer);
		if (pInfo(peer)->started_type != 30) {
			PlayMods new_playmod{};
			int seconds = 3600;
			if (thedaytoday == 6) seconds = 900;
			if (pInfo(peer)->pants == 3172) seconds = 0;
			if (pInfo(peer)->necklace == 8954) seconds *= 0.75;
			new_playmod.id = 88, new_playmod.time = time(nullptr) + seconds;
			pInfo(peer)->playmods.push_back(new_playmod);
			if (pInfo(peer)->pants == 3172) {
				gamepacket_t p, p2;
				p.Insert("OnConsoleMessage"), p.Insert("`2Your briefs have stunned the judge!``"), p.CreatePacket(peer);
				p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("`2Your briefs have stunned the judge!``"), p2.CreatePacket(peer);
				int remove = -1;
				modify_inventory(peer, 3172, remove);
			}
		}
		pInfo(peer)->surged_person = "";
		pInfo(peer)->surgery_started = false;
	}
}
void Start_PVP(ENetPeer* peer, ENetPeer* currentPeer) {
	pInfo(peer)->PVP_Ongoing = true; pInfo(currentPeer)->PVP_Ongoing = true;
	pInfo(peer)->PVP_Deactive = false; pInfo(currentPeer)->PVP_Deactive = true;
	pInfo(peer)->PVP_Time = time(nullptr) + 120; pInfo(currentPeer)->PVP_Time = 0;
	gamepacket_t p;
	p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
	p.Insert("The battle begins! You have 2 minutes, who score the most point won the game.");
	p.Insert(0), p.Insert(1);
	p.CreatePacket(peer);
	{
		gamepacket_t p;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(currentPeer)->netID);
		p.Insert("The battle begins! You have 2 minutes, who score the most point won the game.");
		p.Insert(0), p.Insert(1);
		p.CreatePacket(currentPeer);
	}
	{
		gamepacket_t p;
		p.Insert("OnSetMissionTimer");
		p.Insert(120);
		p.CreatePacket(peer); p.CreatePacket(currentPeer);
	}
	{
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`2BATTLE PVP``: Battle between " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` and " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` has begun!");
		for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
			if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL or pInfo(currentPeer2)->world != pInfo(peer)->world) continue;
			p.CreatePacket(currentPeer2);
			packet_(currentPeer2, "action|play_sfx\nfile|audio/gong.wav\ndelayMS|0");
		}
	}
}
void End_PVP(ENetPeer* peer, ENetPeer* currentPeer, bool exit = false) {
	string Winner = "";
	if (exit || pInfo(currentPeer)->PVP_Point > pInfo(peer)->PVP_Point) {
		Winner = pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``";
		pInfo(currentPeer)->gems += pInfo(peer)->PVP_Bet;
		gamepacket_t p;
		p.Insert("OnSetBux"); p.Insert(pInfo(currentPeer)->gems); p.Insert(0); p.Insert((pInfo(currentPeer)->supp >= 1) ? 1 : 0);
		if (pInfo(currentPeer)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
		p.CreatePacket(currentPeer);
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Congratulations! You won the game!");
			p.CreatePacket(currentPeer);
		}
		{
			gamepacket_t p;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(currentPeer)->netID);
			p.Insert("Congratulations! You won the game!");
			p.Insert(0), p.Insert(1);
			p.CreatePacket(currentPeer);
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Sadly! You lose the game!");
			p.CreatePacket(peer);
		}
	}
	else if (pInfo(currentPeer)->PVP_Point < pInfo(peer)->PVP_Point) {
		Winner = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
		pInfo(peer)->gems += pInfo(currentPeer)->PVP_Bet;
		gamepacket_t p;
		p.Insert("OnSetBux"); p.Insert(pInfo(peer)->gems); p.Insert(0); p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
		if (pInfo(peer)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
		p.CreatePacket(peer);
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Congratulations! You won the game!");
			p.CreatePacket(peer);
		}
		{
			gamepacket_t p;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
			p.Insert("Congratulations! You won the game!");
			p.Insert(0), p.Insert(1);
			p.CreatePacket(peer);
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Sadly! You lose the game!");
			p.CreatePacket(currentPeer);
			{
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(currentPeer)->netID);
				p.Insert("Sadly! You lose the game!");
				p.Insert(0), p.Insert(1);
				p.CreatePacket(currentPeer);
			}
		}
	}
	else if (pInfo(currentPeer)->PVP_Point == pInfo(peer)->PVP_Point) {
		Winner = "None, due the tie``";
		pInfo(peer)->gems += pInfo(currentPeer)->PVP_Bet;
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Sorry! You draw with your opponent!");
			p.CreatePacket(peer);
		}
		{
			gamepacket_t p;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
			p.Insert("Sorry! You draw with your opponent!");
			p.Insert(0), p.Insert(1);
			p.CreatePacket(peer);
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Sorry! You draw with your opponent!");
			p.CreatePacket(currentPeer);
			{
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(currentPeer)->netID);
				p.Insert("Sorry! You draw with your opponent!");
				p.Insert(0), p.Insert(1);
				p.CreatePacket(currentPeer);
			}
		}
	}
	{
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`2BATTLE PVP``: Battle between " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` and " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` winned by " + Winner + "!");
		for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
			if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL or pInfo(currentPeer2)->world != pInfo(peer)->world) continue;
			p.CreatePacket(currentPeer2);
			packet_(currentPeer2, "action|play_sfx\nfile|audio/gong.wav\ndelayMS|0");
		}
	}
	gamepacket_t p;
	p.Insert("HideTimer");
	p.CreatePacket(peer); p.CreatePacket(currentPeer);
	pInfo(peer)->PVP_Ongoing = false; pInfo(currentPeer)->PVP_Ongoing = false;
	pInfo(peer)->PVP_Deactive = false; pInfo(currentPeer)->PVP_Deactive = false;
	pInfo(peer)->PVP_Time = 0; pInfo(currentPeer)->PVP_Time = 0;
	pInfo(peer)->PVP_Bet = 0; pInfo(currentPeer)->PVP_Bet = 0;
	pInfo(peer)->PVP_netID = -1; pInfo(currentPeer)->PVP_netID = -1;
	pInfo(peer)->PVP_Point = 0; pInfo(currentPeer)->PVP_Point = 0;
	pInfo(peer)->PVP_Enemy = ""; pInfo(currentPeer)->PVP_Enemy = "";
}
void clear_tournament(ENetPeer*, bool);
void exit_(ENetPeer* peer, bool reset_ = false, bool del = true) {
	if (pInfo(peer)->got_tsukoyomi) {
		Algorithm::send_console(peer, "Oops, you can't do that.");
		return;
	}
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(currentPeer)->PVP_netID != pInfo(peer)->netID) continue;
		if (pInfo(peer)->PVP_Enemy == pInfo(currentPeer)->tankIDName) End_PVP(peer, currentPeer, true);
	}
	pInfo(peer)->PVP_Ongoing = false; pInfo(peer)->PVP_Deactive = false; pInfo(peer)->PVP_Time = 0; pInfo(peer)->PVP_Bet = 0; pInfo(peer)->PVP_netID = -1; pInfo(peer)->PVP_Point = 0; pInfo(peer)->PVP_Enemy = "";
	if (pInfo(peer)->world == "CARNIVAL" and carnival_open) carnival_clear(peer);
	end_surgery(peer);
	pInfo(peer)->World_Timed = 0; pInfo(peer)->WorldTimed = false;
	if (pInfo(peer)->invis == false) {
		add_cctv(peer, "left", "");
		packet_(peer, "action|play_sfx\nfile|audio/door_shut.wav\ndelayMS|0");
	}
	int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
	const string world_name = pInfo(peer)->world;
	if (!pInfo(peer)->mod && pInfo(peer)->ghost || !pInfo(peer)->admin && pInfo(peer)->ghost) pInfo(peer)->ghost = false;
	pInfo(peer)->x = -1, pInfo(peer)->y = -1, pInfo(peer)->lastx = -1, pInfo(peer)->lasty = -1, pInfo(peer)->world = "";
	pInfo(peer)->geiger_x = -1, pInfo(peer)->geiger_y = -1;
	if (not pInfo(peer)->izanagi)
		pInfo(peer)->spotlight = false;
	if (pInfo(peer)->kill_ >= 20 and (not pInfo(peer)->world.empty()))
	{
		for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
			if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL or pInfo(peer)->world != pInfo(currentPeer2)->world) continue;
			gamepacket_t p;
			p.Insert("OnSetCurrentWeather");
			p.Insert(get_world(pInfo(peer)->world).weather);
			p.CreatePacket(currentPeer2);
		}
	}
	if (pInfo(peer)->hideseek.InGame && !pInfo(peer)->hideseek.Seekers && !pInfo(peer)->hideseek.Hiders && !pInfo(peer)->hideseek.JoinGame) {
		global::algorithm::hideseek.Players--;

		if (pInfo(peer)->face == 3774) pInfo(peer)->face = 0;

		pInfo(peer)->hideseek.Seekers = false;
		pInfo(peer)->hideseek.Hiders = false;

		pData::Algorithm::loop_players([&](ENetPeer* currentPeer) {
			if (currentPeer != nullptr && pInfo(currentPeer)->hideseek.InGame) {
				enet_peer_send(currentPeer, 0, Variant{ "OnConsoleMessage" }.push(std::format("`1HIDE-SEEK: `w{} `ojust leave the game. [`w{}/15 `opeople left]", pInfo(peer)->tankIDName, setGems(global::algorithm::hideseek.Players))).pack());
			}
			});

		if (global::algorithm::hideseek.Players <= 0) global::algorithm::hideseek.LobbyTimers = 0;

		pInfo(peer)->hideseek.InGame = false;
	}
	else if (pInfo(peer)->hideseek.InGame && !pInfo(peer)->hideseek.Seekers && !pInfo(peer)->hideseek.Hiders && pInfo(peer)->hideseek.JoinGame) {
		pInfo(peer)->face = 0;
		pInfo(peer)->hideseek.JoinGame = false;
	}

	if (pInfo(peer)->hideseek.InGame && pInfo(peer)->hideseek.Hiders) {
		if (pInfo(peer)->face == 3774) pInfo(peer)->face = 0;
		global::algorithm::hideseek.Hiders--;

		if (global::algorithm::hideseek.Hiders <= 0) {
			global::algorithm::hideseek.SeekersWon = true;
			global::algorithm::hideseek.Timers = 0;
		}

		pData::Algorithm::loop_players([&](ENetPeer* currentPeer) {
			if (currentPeer != nullptr && pInfo(currentPeer)->hideseek.InGame) {
				enet_peer_send(currentPeer, 0, Variant{ "OnConsoleMessage" }.push(std::format("`1HIDE-SEEK: `w{} `ojust leave the game. [`w{}/{} `ohiders left]", pInfo(peer)->tankIDName, setGems(global::algorithm::hideseek.Hiders), setGems(global::algorithm::hideseek.Players))).pack());
			}
			});

		global::algorithm::hideseek.Players--;

		pInfo(peer)->hideseek.InGame = false;
		pInfo(peer)->hideseek.Seekers = false;
		pInfo(peer)->hideseek.Hiders = false;
	}

	if (pInfo(peer)->hideseek.InGame && pInfo(peer)->hideseek.Seekers && !global::algorithm::hideseek.HidersWon && !global::algorithm::hideseek.SeekersWon) {
		if (pInfo(peer)->face == 3774) pInfo(peer)->face = 0;
		global::algorithm::hideseek.HidersWon = true;
		global::algorithm::hideseek.Timers = 0;

		pInfo(peer)->hideseek.InGame = false;
		pInfo(peer)->hideseek.Seekers = false;
		pInfo(peer)->hideseek.Hiders = false;
	}
	pInfo(peer)->kill_ = 0;

	pInfo(peer)->ac_.clear();
	pInfo(peer)->Cheat_AF = false;
	pInfo(peer)->Cheat_AF_PunchX = 0;
	pInfo(peer)->Cheat_AF_PunchY = 0;
	pInfo(peer)->Cheat_AF_PlantingTree = 0;
	pInfo(peer)->Cheat_AF_isRunning = false;
	pInfo(peer)->isFacingLeft = false;
	pInfo(peer)->OnRace = false;
	pInfo(peer)->Race_Time = 0;
	pInfo(peer)->isStateUpdated = false;
	pInfo(peer)->pending_affinity = "";
	pInfo(peer)->pending_affinity_type = NO_AFFINITY;
	pInfo(peer)->fish_water.clear();
	for (int i = 0; i < pInfo(peer)->playmods.size(); i++)
		if (pInfo(peer)->playmods[i].id == 126)
			pInfo(peer)->playmods[i].time = 0;
	//Algorithm::RemovePeerAFDuration(peer);
	//pInfo(peer)->last_infected = 0;
	save_player(pInfo(peer), false);
	pInfo(peer)->justnowExit = true;
	get_players(world_name, w_c, s_c, net_, r_c);
	if (r_c == 0 and del) {
		/*
		map<string, vector<WorldNPC>>::iterator it;
		for (it = active_npc.begin(); it != active_npc.end(); it++) {
			if (it->first == world_name) {
				active_npc.erase(it, active_npc.end());
				break;
			}
		}
		*/
		for (int i = 0; i < worlds.size(); i++) {
			if (worlds[i].name == world_name) {
				save_world(world_name, false);
				worlds.erase(worlds.begin() + i);
				i--;
			}
		}
		for (int i = 0; i < monitors.size(); i++) {
			if (monitors[i].world_name == world_name) {
				monitors.erase(monitors.begin() + i);
				i--;
				//break; // gali buti daugiau nei vienas
			}
		}
	}
	else {
		bool sent = false;
		gamepacket_t p;
		p.Insert("OnRemove");
		p.Insert("netID|" + to_string(pInfo(peer)->netID) + "\n");
		gamepacket_t p2;
		p2.Insert("OnConsoleMessage");
		p2.Insert("`5<" + (not pInfo(peer)->d_name.empty() ? "`w" + pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + " ``left, `w" + to_string(w_c) + "`` others here>``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_name) continue;
			sent = true;
			p.CreatePacket(currentPeer);
			if (w_c <= 14 and not pInfo(peer)->invis) {
				packet_(currentPeer, "action|play_sfx\nfile|audio/door_shut.wav\ndelayMS|0");
				p2.CreatePacket(currentPeer);
			}
		}
	}
	if (not reset_) world_menu(peer);
}

string ReadAllTexts(string filename)
{
	string f;
	std::ifstream file(filename);
	stringstream strstr;
	strstr << file.rdbuf();
	f = strstr.str();
	file.close();
	return f;
}
string get_name(ENetPeer* peer) {
	return pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color + (pInfo(peer)->tankIDName.empty() ? pInfo(peer)->requestedName : pInfo(peer)->tankIDName) : pInfo(peer)->d_name;
}
void rayman_upgrade(ENetPeer* peer, int tab) {
	switch (tab) {
	case 1: {
		DialogBuilder p;
		p.add_label_icon(true, 5480, color(peer, "blue", "Rayman Upgrade"))
			.add_spacer(false)
			.add_textbox(color(peer, "black", get_name(peer)) + " `0Welcome to your journey")
			.add_smalltext("Hello welcome to Rayman Upgrade, in this page you need 1 rayman to registration of your journey, By clicking \START\ you will able to acces your next page with quest and mission, after complete the misson you will get 1 of item random of rayman")
			.add_spacer(false)
			.add_button("regis_ray", "Start");
		p.end_dialog("rayman_carrer", "Close", ""), p.add_quick_exit();
		Algorithm::send_dialog(peer, p.to_string());
	}
	case 2: {
		std::uint32_t jem = pInfo(peer)->expray;
		std::int16_t level = pInfo(peer)->raylvl;
		string texts = "";
		int required = 35 * ((pInfo(peer)->raylvl * pInfo(peer)->raylvl) + 2);
		DialogBuilder p;
		p.add_label_icon(true, 5480, color(peer, "blue", "Progres Rayman Upgrade"))
			.add_spacer(false)
			.add_smalltext("You need complete the level until level 50 to get a misson item")
			.add_textbox(color(peer, "cyan", get_name(peer)) + "`0 Your progres");
		if (pInfo(peer)->raylvl <= 50) {
			texts += format("`wXP: {}/{} Exp``", jem, required);
		}
		if (pInfo(peer)->raylvl <= 50) {
			p.raw(format("\nadd_custom_textbox|{} experience progress (Level {} / Level {}):|size:medium;color:168,62,60,255;icon:1488|", (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->tankIDName), pInfo(peer)->raylvl, 50));
			p.raw(format("\nadd_textured_progress_bar|interface/large/gui_event_bar.rttex|0|4|{}|{}|{}|relative|1|0.95|0|1000|64|0.005", texts, jem, required));
			p.add_spacer(false)
				.add_smalltext(color(peer, "green", "You can get exp by this bellow!"))
				.add_smalltext(color(peer, "normal", "* Farming"))
				.add_smalltext(color(peer, "normal", "* Fishing"))
				.add_smalltext(color(peer, "normal", "* Geiger"))
				.add_smalltext(color(peer, "normal", "* Harvest Trees"))
				.add_smalltext(color(peer, "normal", "* Provider"))
				.add_smalltext(color(peer, "normal", "* And More"));
		}
		p.end_dialog("rayman_carrer", "Good Luck", "");
		p.add_quick_exit();
		Algorithm::send_dialog(peer, p.to_string());
	}
	case 3: {
		std::uint32_t jem = pInfo(peer)->expray;
		string texts = "";
		int required = 35 * ((pInfo(peer)->raylvl * pInfo(peer)->raylvl) + 2);
		DialogBuilder p;
		p.add_label_icon(true, 5480, color(peer, "blue", "Deliver Quest Upgrade Rayman"))
			.add_spacer(false)
			.add_smalltext("Nicee, you are already complete the quest level to 50, after this you need the item for upgrade rayman random!")
			.add_textbox(color(peer, "cyan", get_name(peer)) + "`0 Your progres");
		if (pInfo(peer)->raylvl == 50 || pInfo(peer)->raylvl >= 49) {
			int adadl = 0, adasoul = 0, adaray = 0, adachand = 0;
			modify_inventory(peer, 1796, adadl);
			modify_inventory(peer, 5202, adasoul);
			modify_inventory(peer, 5480, adaray);
			modify_inventory(peer, 340, adachand);
			bool udhsoul = false, udhdl = false, udhray = false, udhchand = false;
			p.add_textbox(color(peer, "green", "Now is deliver quest and needed items quest"))
				.add_spacer(false);
			//soulstone
			if (adasoul < 1) {
				int Stone = 1, Have = 0;;
				Stone = modify_inventory(peer, 5202, Have);
				p.raw("\nadd_textbox|`8- The breath of life is meaningless to me. I solely desire that which is eternal - seek it from the madman. One will do.. (" + to_string(Have) + "/" + to_string(Stone) + ")``|left|");
				udhsoul = false;
			}
			else {
				p.raw("\nadd_textbox|`2- Soul Stone (OK!) ``|left|");
				udhsoul = true;
			}
			//dl
			if (adadl < 50) {
				int Stone = 50, Have = 0;;
				Stone = modify_inventory(peer, 1796, Have);
				p.raw("\nadd_textbox|`8- The blue of dreamed all players. One will do.. (" + to_string(Have) + "/" + to_string(Stone) + ")``|left|");
				udhdl = false;
			}
			else {
				p.raw("\nadd_textbox|`2- Diamond Lock (OK!) ``|left|");
				udhdl = true;
			}
			if (adaray < 1) {
				int Stone = 1, Have = 0;;
				Stone = modify_inventory(peer, 5480, Have);
				p.raw("\nadd_textbox|`8- Item of The Month with pet and 3 fars. One will do.. (" + to_string(Have) + "/" + to_string(Stone) + ")``|left|");
				udhray = false;
			}
			else {
				p.raw("\nadd_textbox|`2- Rayman Fist (OK!) ``|left|");
				udhray = true;
			}
			if (adachand < 200) {
				int Stone = 200, Have = 0;;
				Stone = modify_inventory(peer, 340, Have);
				p.raw("\nadd_textbox|`8- The Candle with glasses. One will do.. (" + to_string(Have) + "/" + to_string(Stone) + ")``|left|");
				udhchand = false;
			}
			else {
				p.raw("\nadd_textbox|`2- Chandelier (OK!) ``|left|");
				p.add_spacer(false);
				udhchand = true;
			}
			if (udhsoul == true && udhray == true && udhdl == true && udhchand == true) {
				p.add_textbox("You are already to upgrade rayman")
					.add_button("up_rayman", "Upgrade")
					.add_spacer(false);
			}
		}
		p.end_dialog("rayman_carrer", "Good Luck", "");
		p.add_quick_exit();
		Algorithm::send_dialog(peer, p.to_string());
	}
	default:
		return;
	}
}
inline void SendArtifactUpgrade(ENetPeer* peer, int AncesBeforeUpdate, int JumlahSoulStone, int IDAncesUpdate, int IDTambahan, int JumlahTambahan, int IDCrystalized, int JumlahCrystal) {
	string Dialog, DailyDialog = ReadAllTexts("database/Ancestral/DailyRiddles.txt");
	pInfo(peer)->AncesID = AncesBeforeUpdate;
	pInfo(peer)->Upgradeto = IDAncesUpdate;
	pInfo(peer)->HowmuchSoulStone = JumlahSoulStone;
	pInfo(peer)->IDCeles = IDTambahan;
	pInfo(peer)->JumlahCeles = JumlahTambahan;
	pInfo(peer)->IDCrystalized = IDCrystalized;
	pInfo(peer)->JumlahCrystalized = JumlahCrystal;
	int DailR;
	ifstream IDRiddle("database/Ancestral/IDDailyRiddles.txt");
	IDRiddle >> DailR;
	IDRiddle.close();
	pInfo(peer)->DailyRiddles = DailR;
	int SoulStone = 0, Crystalized = 0, Celestial = 0, Riddles = 0, HaveAnces = 0;
	modify_inventory(peer, 5202, SoulStone);
	modify_inventory(peer, IDCrystalized, Crystalized);
	modify_inventory(peer, IDTambahan, Celestial);
	modify_inventory(peer, DailR, Riddles);
	modify_inventory(peer, AncesBeforeUpdate, HaveAnces);
	Dialog += "\nadd_label_with_icon|big|`9Ancient Goddess``|left|5086|\nadd_spacer|small|";
	Dialog += "\nadd_textbox|`9You are upgrading to " + items[IDAncesUpdate].name + "``|left|\nadd_spacer|small|";
	Dialog += "\nadd_textbox|I will gift a part of my power to enhance your miraculous device, but in exchange, you must bring me the answers to my riddles:|left|\nadd_spacer|small|";
	Dialog += "\nadd_textbox|`2- " + items[AncesBeforeUpdate].name + " (OK!) ``|left|";
	if (SoulStone < JumlahSoulStone) {
		int Stone, Have = 0;;
		Stone = modify_inventory(peer, 5202, Have);
		Dialog += "\nadd_textbox|`8- The breath of life is meaningless to me. I solely desire that which is eternal - seek it from the madman. One will do.. (" + to_string(Have) + "/" + to_string(JumlahSoulStone) + ")``|left|";
	}
	else {
		Dialog += "\nadd_textbox|`2- Soul Stone (OK!) ``|left|";
	}
	if (Celestial < JumlahTambahan) {
		string NeedWhat, Howmuch;
		if (IDTambahan == 5104 || IDTambahan == 5106 && JumlahTambahan == 1) {
			Howmuch = "one";
		}
		else if (IDTambahan == 5104 || IDTambahan == 5106 && JumlahTambahan == 2) {
			Howmuch = "two";
		}
		else if (IDTambahan == 5104 || IDTambahan == 5106 && JumlahTambahan == 3) {
			Howmuch = "three";
		}
		else if (IDTambahan == 5204 && JumlahTambahan == 1) {
			Howmuch = "Once";
		}
		else if (IDTambahan == 5204 && JumlahTambahan == 2) {
			Howmuch = "twice";
		}
		else if (IDTambahan == 5204 && JumlahTambahan == 3) {
			Howmuch = "thrice";
		}
		if (IDTambahan == 5104) { // Celestial Kaleidoscope
			NeedWhat = "Reflect on this: what is the roll of the mirror? I want " + Howmuch + "";
		}
		else if (IDTambahan == 5106) { // Harmonic Chimes
			NeedWhat = "The Anemoi will play their song for you with this, and with " + Howmuch + ", so shall I.";
		}
		else if (IDTambahan == 5204) { // Plasma Globe
			NeedWhat = "Bind a storm within a sphere, and place it in my grasp. " + Howmuch + ".";
		}
		int Celes, Have = 0;
		Celes = modify_inventory(peer, IDTambahan, Have);
		Dialog += "\nadd_textbox|`8- " + NeedWhat + " (" + to_string(Have) + "/" + to_string(JumlahTambahan) + ")``|left|";
	}
	else {
		Dialog += "\nadd_textbox|`2- " + items[IDTambahan].name + " (OK!) ``|left|";
	}
	if (Crystalized < JumlahCrystal) {
		string NeedWhat, Howmuch;
		if (IDCrystalized == 5072 || IDCrystalized == 5074 || IDCrystalized == 7186 && JumlahCrystal == 1) {
			Howmuch = "once";
		}
		else if (IDCrystalized == 5072 || IDCrystalized == 5074 || IDCrystalized == 7186 && JumlahCrystal == 2) {
			Howmuch = "twice";
		}
		else if (IDCrystalized == 5070 || IDCrystalized == 5076 && JumlahCrystal == 1) {
			Howmuch = "one";
		}
		else if (IDCrystalized == 5070 || IDCrystalized == 5076 && JumlahCrystal == 2) {
			Howmuch = "twice";
		}
		if (IDCrystalized == 5070) { // Crystallized Reality
			NeedWhat = "That from which all things spring, yet forever buried. Bring me  " + Howmuch + ".";
		}
		else if (IDCrystalized == 5072) { // Crystallized Wealth
			NeedWhat = "You mortals all desire more of one thing. Find it, wrap it again in riches, and bring it to me, but only " + Howmuch + ".";
		}
		else if (IDCrystalized == 5074) { // Crystallized Brilliance
			NeedWhat = "If you're smart, you probably have plenty of this to spare. Just make sure you package it nicely - a well-wrapped gift to brighten my day, but only " + Howmuch + ".";
		}
		else if (IDCrystalized == 5076) { // Crystallized Nature
			NeedWhat = "In a world of growth, this is forever locked, and all the dearer for it. I'd like " + Howmuch + ".";
		}
		else if (IDCrystalized == 7186) { // Crystallized Time
			NeedWhat = "It flies without wings, is harmless but can kill you, and you can ask all day long about it and get different - but correct - answers! Bring the past, present, and future captured for all eternity... but only " + Howmuch + ".";
		}
		int Crystal, Have = 0;
		Crystal = modify_inventory(peer, IDCrystalized, Have);
		Dialog += "\nadd_textbox|`8- " + NeedWhat + " (" + to_string(Have) + "/" + to_string(JumlahCrystal) + ")``|left|";
	}
	else {
		Dialog += "\nadd_textbox|`2- " + items[IDCrystalized].name + " (OK!) ``|left|";
	}
	if (Riddles < 5) {
		int Dialy, Have = 0;
		Dialy = modify_inventory(peer, DailR, Have);
		Dialog += "\nadd_textbox|`8- " + DailyDialog + " (" + to_string(Have) + "/5)``|left|";
	}
	else {
		Dialog += "\nadd_textbox|`2- " + items[DailR].name + " (OK!) ``|left|";
	}
	Dialog += "\nadd_spacer|small|\nadd_smalltext|`3 The upgraded item will be untradeable``|left|\nadd_spacer|small|";
	if (HaveAnces >= 1 && SoulStone >= JumlahSoulStone && Crystalized >= JumlahCrystal && Celestial >= JumlahTambahan && Riddles >= 5) {
		Dialog += "\nadd_button|completecraft-" + to_string(IDAncesUpdate) + "|Complete the Ritual|noflags|0|0|";
	}
	else {
		Dialog += "\nadd_button|artifact_upgrade_return|I will get these items |noflags|0|0|";
	}
	Dialog += "\nend_dialog|artifact_upgrade|Return|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert(Dialog);
	p.CreatePacket(peer);
}
inline void SendAncestralUpdateChoose(ENetPeer* peer) {
	string Dialog;
	Dialog += "\nadd_label_with_icon|big|`9Ancient Goddess``|left|5086|\nadd_spacer|small|";
	int Red1 = 0, Red2 = 0, Red3 = 0, Red4 = 0, Red5 = 0, Wisdom1 = 0, Wisdom2 = 0, Wisdom3 = 0, Wisdom4 = 0, Wisdom5 = 0, Dimension1 = 0, Dimension2 = 0, Dimension3 = 0, Dimension4 = 0, Dimension5 = 0, Life1 = 0, Life2 = 0, Life3 = 0, Life4 = 0, Life5 = 0, Orb1 = 0, Orb2 = 0, Orb3 = 0, Orb4 = 0, Orb5 = 0;
	modify_inventory(peer, 5084, Red1), modify_inventory(peer, 5180, Red2), modify_inventory(peer, 5182, Red3), modify_inventory(peer, 5184, Red4), modify_inventory(peer, 5186, Red5);
	modify_inventory(peer, 5078, Wisdom1), modify_inventory(peer, 5126, Wisdom2), modify_inventory(peer, 5128, Wisdom3), modify_inventory(peer, 5130, Wisdom4), modify_inventory(peer, 5132, Wisdom5);
	modify_inventory(peer, 5080, Dimension1), modify_inventory(peer, 5144, Dimension2), modify_inventory(peer, 5146, Dimension3), modify_inventory(peer, 5148, Dimension4), modify_inventory(peer, 5150, Dimension5);
	modify_inventory(peer, 5082, Life1), modify_inventory(peer, 5162, Life2), modify_inventory(peer, 5164, Life3), modify_inventory(peer, 5166, Life4), modify_inventory(peer, 5168, Life5);
	modify_inventory(peer, 7166, Orb1), modify_inventory(peer, 7168, Orb2), modify_inventory(peer, 7170, Orb3), modify_inventory(peer, 7172, Orb4), modify_inventory(peer, 7174, Orb5);
	if (Red1 != 0 || Red2 != 0 || Red3 != 0 || Red4 != 0 || Red5 != 0 || Wisdom1 != 0 || Wisdom2 != 0 || Wisdom3 != 0 || Wisdom4 != 0 || Wisdom5 != 0 || Dimension1 != 0 || Dimension2 != 0 || Dimension3 != 0 || Dimension4 != 0 || Dimension5 != 0 || Life1 != 0 || Life2 != 0 || Life3 != 0 || Life4 != 0 || Life5 != 0 || Orb1 != 0 || Orb2 != 0 || Orb3 != 0 || Orb4 != 0 || Orb5) {
		Dialog += "\nadd_textbox|Greetings, mortal! It seems you have some ancient thing I can enhance through magic old. Tell me: Which would you like to mold? Choose wisely, for once I work my wonders, it will be bound to you for eternity...|left|\nadd_spacer|small|\nadd_textbox|Choose an upgrade:|left|\nadd_spacer|small|";
	}
	else {
		Dialog += "\nadd_textbox|Greetings, mortal! Oh dear... you don't seem to have any ancient relics on which I might work my wonders. *sigh* Perhaps another time...|left|";
	}
	if (Wisdom1 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5126|Upgrade to Ancestral Totem of Wisdom : Level 2|noflags|0|0|";
	}
	if (Wisdom2 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5128|Upgrade to Ancestral Totem of Wisdom : Level 3|noflags|0|0|";
	}
	if (Wisdom3 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5130|Upgrade to Ancestral Totem of Wisdom : Level 4|noflags|0|0|";
	}
	if (Wisdom4 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5132|Upgrade to Ancestral Totem of Wisdom : Level 5|noflags|0|0|";
	}
	if (Wisdom5 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5134|Upgrade to Ancestral Totem of Wisdom : Level 6|noflags|0|0|";
	}
	if (Dimension1 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5144|Upgrade to Ancestral Tesseract of Dimensions : Level 2|noflags|0|0|";
	}
	if (Dimension2 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5146|Upgrade to Ancestral Tesseract of Dimensions : Level 3|noflags|0|0|";
	}
	if (Dimension3 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5148|Upgrade to Ancestral Tesseract of Dimensions : Level 4|noflags|0|0|";
	}
	if (Dimension4 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5150|Upgrade to Ancestral Tesseract of Dimensions : Level 5|noflags|0|0|";
	}
	if (Dimension5 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5152|Upgrade to Ancestral Tesseract of Dimensions : Level 6|noflags|0|0|";
	}
	if (Life1 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5162|Upgrade to Ancestral Seed of Life : Level 2|noflags|0|0|";
	}
	if (Life2 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5164|Upgrade to Ancestral Seed of Life : Level 3|noflags|0|0|";
	}
	if (Life3 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5166|Upgrade to Ancestral Seed of Life : Level 4|noflags|0|0|";
	}
	if (Life4 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5168|Upgrade to Ancestral Seed of Life : Level 5|noflags|0|0|";
	}
	if (Life5 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5170|Upgrade to Ancestral Seed of Life : Level 6|noflags|0|0|";
	}
	if (Red1 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5180|Upgrade to Ancestral Lens of Riches : Level 2|noflags|0|0|";
	}
	if (Red2 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5182|Upgrade to Ancestral Lens of Riches : Level 3|noflags|0|0|";
	}
	if (Red3 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5184|Upgrade to Ancestral Lens of Riches : Level 4|noflags|0|0|";
	}
	if (Red4 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5186|Upgrade to Ancestral Lens of Riches : Level 5|noflags|0|0|";
	}
	if (Red5 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-5188|Upgrade to Ancestral Lens of Riches : Level 6|noflags|0|0|";
	}
	if (Orb1 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-7168|Upgrade to Ancestral Orb of Time : Level 2|noflags|0|0|";
	}
	if (Orb2 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-7170|Upgrade to Ancestral Orb of Time : Level 3|noflags|0|0|";
	}
	if (Orb3 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-7172|Upgrade to Ancestral Orb of Time : Level 4|noflags|0|0|";
	}
	if (Orb4 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-7174|Upgrade to Ancestral Orb of Time : Level 5|noflags|0|0|";
	}
	if (Orb5 != 0) {
		Dialog += "\nadd_small_font_button|upgrade-9212|Upgrade to Ancestral Orb of Time : Level 6|noflags|0|0|";
	}
	Dialog += "\nend_dialog|artifact_upgrade|Return|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert(Dialog);
	p.CreatePacket(peer);
}

void create_address_world(ENetPeer* peer, string name_, string currentworld_) {
	int rm = -1;
	name_ = to_upper(name_);
	currentworld_ = to_upper(currentworld_);
	get_world(name_); 
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World world_ = worlds[p - worlds.begin()];
		vector<World>::iterator p2 = find_if(worlds.begin(), worlds.end(), [currentworld_](const World& b) { return b.name == currentworld_; });
		if (p2 != worlds.end()) {
			World c_world_ = worlds[p2 - worlds.begin()];
			if (world_.owner_name != pInfo(peer)->tankIDName || c_world_.owner_name != pInfo(peer)->tankIDName) return;
			if (modify_inventory(peer, 2580, rm) == 0) {
				{
					{
						gamepacket_t p, p2, p3;
						p.Insert("OnAddNotification"), p.Insert("interface/large/jump_icon.rttex"), p.Insert("This world has just been renamed to `5" + name_ + "`` by the owner! (Please join it again)"), p.Insert("audio/gate_close.wav");
						p2.Insert("OnConsoleMessage"), p2.Insert("Ok, " + currentworld_ + " and " + name_ + " have swapped names!");
						p3.Insert("OnConsoleMessage"), p3.Insert("This world has just been renamed to `5" + name_ + "`` by the owner! (Please join it again)");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_.name or pInfo(currentPeer)->world == c_world_.name) {
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
								p3.CreatePacket(currentPeer);
								exit_(currentPeer, false);
							}
						}
					}
					for (int i = 0; i < worlds.size(); i++) {
						if (worlds[i].name == currentworld_ or worlds[i].name == name_) {
							save_world(worlds[i].name, false);
							worlds.erase(worlds.begin() + i);
							i--;
						}
					}
					string path_ = "database/worlds/" + world_.name + "_.json";
					string path_2 = "database/worlds/" + c_world_.name + "_.json";
					string path_4 = "database/worlds/t_" + world_.name + "_.json";
					string path_3 = "database/worlds/t_" + c_world_.name + "_.json";
					rename(path_2.c_str(), path_3.c_str()); // dabartini worlda i temp
					rename(path_.c_str(), path_4.c_str()); // i kuri keicia worlda i temp
					rename(path_3.c_str(), path_.c_str()); // temp i kuri keicia
					rename(path_4.c_str(), path_2.c_str()); // temp i dabartini
				}
			}
		}
	}
}

void add_surgery_xp(ENetPeer* peer, int amount) {
	pInfo(peer)->s_xp += amount;
	int required = 10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2);
	if (pInfo(peer)->s_xp >= 10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2)) {
		pInfo(peer)->s_lvl++;
		pInfo(peer)->s_xp -= required;
		pInfo(peer)->gems += 500;
		{
			gamepacket_t p;
			p.Insert("OnSetBux");
			p.Insert(pInfo(peer)->gems);
			p.Insert(0);
			p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
			if (pInfo(peer)->supp >= 2) {
				p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
			}
			p.CreatePacket(peer);
		}
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` Surgeon is now level " + to_string(pInfo(peer)->s_lvl) + "!");
		p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage");
		p2.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` Surgeon is now level " + to_string(pInfo(peer)->s_lvl) + "!");
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer);
			p2.CreatePacket(currentPeer);
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
	}
}

void add_role_xp(ENetPeer* peer, uint8_t amount, string eventname) {
	int required = 0;
	bool levelup = false;
	int nowlevel = 0;
	if (eventname == "provider") {
		pInfo(peer)->p_xp += amount;
		required = 75 * ((pInfo(peer)->p_lvl * pInfo(peer)->p_lvl) + 2);
		if (pInfo(peer)->p_xp >= 75 * ((pInfo(peer)->p_lvl * pInfo(peer)->p_lvl) + 2)) {
			pInfo(peer)->p_lvl++;
			nowlevel = pInfo(peer)->p_lvl;
			pInfo(peer)->p_xp -= required;
			levelup = true;
		}
		if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 10 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
			pInfo(peer)->C_QuestProgress++;
			if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
				pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
		}
		if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 13 && pInfo(peer)->quest_progress < 1000 and pInfo(peer)->lastquest == "honor" || pInfo(peer)->lastquest == "fire" || pInfo(peer)->lastquest == "steel" || pInfo(peer)->lastquest == "blade" || pInfo(peer)->lastquest == "mech" || pInfo(peer)->lastquest == "zodiac") {
			pInfo(peer)->quest_progress++;
			if (pInfo(peer)->quest_progress >= 1000) {
				pInfo(peer)->quest_progress = 1000;
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
		}
	}
	else if (eventname == "geiger") {
		pInfo(peer)->g_xp += amount;
		required = 5 * ((pInfo(peer)->g_lvl * pInfo(peer)->g_lvl) + 2);
		if (pInfo(peer)->g_xp >= 5 * ((pInfo(peer)->g_lvl * pInfo(peer)->g_lvl) + 2)) {
			pInfo(peer)->g_lvl++;
			nowlevel = pInfo(peer)->g_lvl;
			pInfo(peer)->g_xp -= required;
			levelup = true;
		}
		if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 13 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
			pInfo(peer)->C_QuestProgress++;
			if (pInfo(peer)->C_QuestProgress == pInfo(peer)->C_ProgressNeeded) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
		}
		if (pInfo(peer)->quest_active == true && pInfo(peer)->quest_step == 12 && pInfo(peer)->quest_progress < 100 and pInfo(peer)->lastquest == "blade" || pInfo(peer)->lastquest == "candour" || pInfo(peer)->lastquest == "mech" || pInfo(peer)->lastquest == "zodiac") {
			pInfo(peer)->quest_progress++;
			if (pInfo(peer)->quest_progress == 100) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
		}
	}
	else if (eventname == "farmer") {
		pInfo(peer)->t_xp += amount;
		required = 100 * ((pInfo(peer)->t_lvl * pInfo(peer)->t_lvl) + 2);
		if (pInfo(peer)->t_xp >= 100 * ((pInfo(peer)->t_lvl * pInfo(peer)->t_lvl) + 2)) {
			pInfo(peer)->t_lvl++;
			nowlevel = pInfo(peer)->t_lvl;
			pInfo(peer)->t_xp -= required;
			levelup = true;
		}
	}
	else if (eventname == "builder") {
		pInfo(peer)->bb_xp += amount;
		required = 100 * ((pInfo(peer)->bb_lvl * pInfo(peer)->bb_lvl) + 2);
		if (pInfo(peer)->bb_xp >= 100 * ((pInfo(peer)->bb_lvl * pInfo(peer)->bb_lvl) + 2)) {
			pInfo(peer)->bb_lvl++;
			nowlevel = pInfo(peer)->bb_lvl;
			pInfo(peer)->bb_xp -= required;
			levelup = true;
		}
	}
	else if (eventname == "fishing") {
		pInfo(peer)->ff_xp += amount;
		required = 5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2);
		if (pInfo(peer)->ff_xp >= 5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2)) {
			pInfo(peer)->ff_lvl++;
			nowlevel = pInfo(peer)->ff_lvl;
			pInfo(peer)->ff_xp -= required;
			levelup = true;
		}
	}
	else if (eventname == "surgeon") {
		pInfo(peer)->s_xp += amount;
		required = 10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2);
		if (pInfo(peer)->s_xp >= 10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2)) {
			pInfo(peer)->s_lvl++;
			nowlevel = pInfo(peer)->s_lvl;
			pInfo(peer)->s_xp -= required;
			levelup = true;
		}
		if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 9 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
			pInfo(peer)->C_QuestProgress++;
			if (pInfo(peer)->C_QuestProgress == pInfo(peer)->C_ProgressNeeded) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
		}
		if (pInfo(peer)->quest_active == true && pInfo(peer)->quest_step == 12 && pInfo(peer)->quest_progress < 100 and pInfo(peer)->lastquest == "honor" || pInfo(peer)->lastquest == "fire" || pInfo(peer)->lastquest == "steel" || pInfo(peer)->lastquest == "heavens" || pInfo(peer)->lastquest == "Ruler Sword" || pInfo(peer)->lastquest == "thesky" || pInfo(peer)->lastquest == "theowl") {
			pInfo(peer)->quest_progress++;
			if (pInfo(peer)->quest_progress == 100) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
		}
	}
	else if (eventname == "kit") {
		pInfo(peer)->xpKit += amount;
		required = 125 * ((pInfo(peer)->lvlKit * pInfo(peer)->lvlKit) + 2);
		if (pInfo(peer)->xpKit >= 125 * ((pInfo(peer)->lvlKit * pInfo(peer)->lvlKit) + 2)) {
			pInfo(peer)->lvlKit++;
			nowlevel = pInfo(peer)->lvlKit;
			pInfo(peer)->xpKit -= required;
			levelup = true;
		}
	}
	if (levelup) {
		pInfo(peer)->gems += 1000;
		{
			gamepacket_t p;
			p.Insert("OnSetBux");
			p.Insert(pInfo(peer)->gems);
			p.Insert(0);
			p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
			if (pInfo(peer)->supp >= 2) {
				p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
			}
			p.CreatePacket(peer);
		}
		gamepacket_t p, p2, p3;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` " + eventname == "kit" ? "MoonPass" : eventname + " quest is now level " + to_string(nowlevel) + "!");
		p2.Insert("OnConsoleMessage"), p2.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` " + eventname == "kit" ? "MoonPass" : eventname + " quest is now level " + to_string(nowlevel) + "!");
		p3.Insert("OnParticleEffect"), p3.Insert(46), p3.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer);
			p2.CreatePacket(currentPeer);
			p3.CreatePacket(currentPeer);
		}
	}
}

void load_surgery(ENetPeer* peer, uint16_t tool) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (tool != 0 && tool != 1296) {
			int got = 0;
			modify_inventory(peer, tool, got);
			if (got == 0) {
				end_surgery(peer);
				return;
			}
			if (pInfo(peer)->hand == 9068 && rand() % 100 < 10) {
			}
			else modify_inventory(peer, tool, got = -1);
		}
		bool has_tool = false;
		if (tool != 0) for (int i = 0; i < pInfo(peer)->available_surg_items.size(); i++) if (pInfo(peer)->available_surg_items[i] == tool) has_tool = true;
		if (tool == 0) has_tool = true;
		if (has_tool == false) pInfo(peer)->s = false;
		uint8_t skill = pInfo(peer)->surgery_skill;
		skill += 15;
		string surgery_fail_text = "", cured = "";
		if (has_playmod(pInfo(peer), "Calm Nerves") or has_playmod(pInfo(peer), "Spicey Skills")) skill *= 2;
		else {
			if (pInfo(peer)->hand == 6252) skill += 5;
			else if (pInfo(peer)->hand == 9068) skill += 5; // chance of not using surigcal tool
			if (pInfo(peer)->hair == 9592) skill += 5;
			if (pInfo(peer)->necklace == 3130) skill = 100;
		}
		if (skill >= 100) skill = 100;
		pInfo(peer)->s = rand() % 100 > (30 - skill / 4);
		if (pInfo(peer)->started_type == 30) pInfo(peer)->gems += 500;
		if (pInfo(peer)->hand == 8536 && pInfo(peer)->started_type == 27 || pInfo(peer)->started_type == 21 || pInfo(peer)->started_type == 22 || pInfo(peer)->started_type == 19 || pInfo(peer)->started_type == 18 || pInfo(peer)->started_type == 28 || pInfo(peer)->started_type == 23 || pInfo(peer)->started_type == 26 || pInfo(peer)->started_type == 24 || pInfo(peer)->started_type == 25) pInfo(peer)->s = true;
		if (tool == 999) pInfo(peer)->endtext = "giveup";
		if (tool != 0) {
			if (tool == 1258) {
				pInfo(peer)->spongUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->dirt = 0;
					cured = "mopped up the operating site.";
					pInfo(peer)->tooltext = "You mopped up the operating site.";
				}
				else
					pInfo(peer)->tooltext = "You somehow managed to eat the sponge.";
			}
			if (tool == 1260) {
				pInfo(peer)->scalpUsed += 1;
				if (pInfo(peer)->sleep == 0)
					pInfo(peer)->endtext = "You have cut the awake patient!";
				if (pInfo(peer)->incisions == pInfo(peer)->incneeded && pInfo(peer)->shattered == 0) {
					pInfo(peer)->tooltext = "You stabbed the patient in a vital organ!";
					pInfo(peer)->bleeding += 1;
					pInfo(peer)->s = false;
				}
				else {
					pInfo(peer)->incisions += 1;
					if (pInfo(peer)->s)
						pInfo(peer)->tooltext = "You've made a neat incision.";
					else
						pInfo(peer)->tooltext = "This will leave a nasty scar, but you managed to cut the right place.";
				}
			}
			if (tool == 1270) {
				pInfo(peer)->stitcUsed += 1;
				if (pInfo(peer)->s) {
					if (pInfo(peer)->incisions > 0) {
						cured = "stitched up an incision.";
						pInfo(peer)->tooltext = "You stitched up an incision.";
					}
					else if (pInfo(peer)->bleeding > 0) {
						cured = "bandaged some injuries.";
						pInfo(peer)->tooltext = "You bandaged some injuries.";
					}
					else
						pInfo(peer)->tooltext = "You tried to stitch your patient's mouth shut!.";
					if (pInfo(peer)->bleeding > 0)
						pInfo(peer)->bleeding -= 1;
					if (pInfo(peer)->incisions > 0)
						pInfo(peer)->incisions -= 1;
				}
				else
					pInfo(peer)->tooltext = "You somehow tied yourself up in stitches!";
			}
			if (tool == 1264) {
				pInfo(peer)->antisUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->site = min(pInfo(peer)->site + 20, 20);
					cured = "disinfected the operating site.";
				}
				else
					pInfo(peer)->tooltext = "You spilled antiseptic on your shoes. They are very clean now.";
			}
			if (tool == 1266) {
				pInfo(peer)->antibUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->fever -= 3;
					pInfo(peer)->tooltext = "You used antibiotics to reduce the patient's infection.";
					cured = "cured you with antibiotics.";
					if (pInfo(peer)->fever > -3)
						pInfo(peer)->antibs = true;
				}
				else {
					pInfo(peer)->fever += 1;
					pInfo(peer)->tooltext = "This is the wrong medication! The bacteria like it.";
				}
			}
			if (tool == 1268) {
				pInfo(peer)->splinUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->broken -= 1;
					cured = "splinted a broken bone.";
					pInfo(peer)->tooltext = "You splinted a broken bone.";
				}
				else
					pInfo(peer)->tooltext = "You ate a splint, good job!";
			}
			if (tool == 1262) {
				pInfo(peer)->anestUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->sleep += 10;
					cured = "falls into a deep sleep.";
					pInfo(peer)->tooltext = "The patient falls into a deep sleep.";
				}
				else
					pInfo(peer)->tooltext = "You end up inhaling all the anesthetic yourself. You feel woozy.";
			}
			if (tool == 4318) {
				pInfo(peer)->labkiUsed += 1;
				if (pInfo(peer)->s) {
					cured = "used a lab kit to discover you are suffering from " + pInfo(peer)->scantext;
					pInfo(peer)->labworked = true;
					if (pInfo(peer)->flu)
						pInfo(peer)->tooltext = "You performed lab work on the patient, and discovered they are suffering from " + pInfo(peer)->scantext;
					else
						pInfo(peer)->tooltext = "You performed lab work on the patient, and have antibiotics at the ready.";
				}
				else
					pInfo(peer)->tooltext = "You contaminated the sample.";
			}
			if (tool == 4316) {
				pInfo(peer)->ultraUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->sounded = true;
					if (pInfo(peer)->flu)
						pInfo(peer)->tooltext = "You scanned the patient , but didn't find any abnormal masses.";
					else {
						cured = "used a ultrasound to discover you are suffering from " + pInfo(peer)->scantext;
						pInfo(peer)->tooltext = "You scanned the patient with ultrasound, discovering they are suffering from " + pInfo(peer)->scantext;
					}
				}
				else
					pInfo(peer)->tooltext = "You scanned the nurse with your ultrasound!";
			}
			if (tool == 4308) {
				pInfo(peer)->pinsUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->shattered -= 1;
					pInfo(peer)->broken += 1;
					cured = "pinned a shattered bone together.";
					pInfo(peer)->tooltext = "You pinned a shattered bone together. Don't forget to splint it!";
				}
				else {
					pInfo(peer)->bleeding += 1;
					pInfo(peer)->tooltext = "You jabbed the pin through the artery!";
				}
			}
			if (tool == 4312) {
				pInfo(peer)->defibUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->heart = 0;
					cured = "used a defibrillator and shocken your life back!";
					pInfo(peer)->tooltext = "You shocked the patient back to life!";
				}
				else
					pInfo(peer)->tooltext = "You electrocuted yourself!";
			}
			if (tool == 4310) {
				pInfo(peer)->transUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->pulse = min(pInfo(peer)->pulse + 15, 40);
					cured = "tranfused several pints of blood into patient.";
					pInfo(peer)->tooltext = "You transfused several pints of blood into your patient.";
				}
				else
					pInfo(peer)->tooltext = "You spilled all of it! Kind of gross.";
			}
			if (tool == 4314) {
				pInfo(peer)->clampUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->bleeding -= 1;
					cured = "clamped up some blood vessels.";
					pInfo(peer)->tooltext = "You clamped up some blood vessels.";
				}
				else
					pInfo(peer)->tooltext = "The clamp fell out of your hand, oh well.";
			}
			if (tool == 1296) {
				if (pInfo(peer)->s) {
					pInfo(peer)->fixed = true;
					cured = pInfo(peer)->postext;
					pInfo(peer)->tooltext = pInfo(peer)->postext;
				}
				else
					pInfo(peer)->tooltext = "You screwed it up! Try again.";
			}
			if (cured != "") {
				if (pInfo(peer)->surged_person != "") {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(peer)->surged_person != pInfo(currentPeer)->tankIDName) continue;
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` " + cured), p2.CreatePacket(currentPeer);
					}
				}
				gamepacket_t p2;
				p2.Insert("OnConsoleMessage"), p2.Insert(cured), p2.CreatePacket(peer);
			}
			surgery_fail_text = pInfo(peer)->tooltext;
			// Making Glove available
			if (!pInfo(peer)->fixable && (pInfo(peer)->incisions == pInfo(peer)->incneeded) && pInfo(peer)->sounded) {
				pInfo(peer)->fixable = true;
				pInfo(peer)->tooltext += "\nadd_smalltext|`3" + pInfo(peer)->fixtext + "``|left|";
			}
			// Managing bleeding, site, dirt
			pInfo(peer)->dirt += pInfo(peer)->bleeding + pInfo(peer)->incisions;
			if (pInfo(peer)->dirt > 10)
				pInfo(peer)->dirt = 10;
			pInfo(peer)->site -= floor(pInfo(peer)->dirt / 3);
			if (pInfo(peer)->site < -25)
				pInfo(peer)->site = -25;
			if (pInfo(peer)->sleep == 0 && pInfo(peer)->incisions > 0)
				pInfo(peer)->bleeding += 1;
			if (pInfo(peer)->bleeding > 4)
				pInfo(peer)->bleeding = 4;

			// Managing temp, fever
			if (pInfo(peer)->fever < 0) {
				if (pInfo(peer)->fever > -0.06)
					pInfo(peer)->fever = 0;
				else if (!pInfo(peer)->antibs)
					pInfo(peer)->fever = (pInfo(peer)->fever - 3) / 2;
			}
			else if ((pInfo(peer)->site <= 2) && (pInfo(peer)->bleeding > 0) || (pInfo(peer)->site <= 4) && (pInfo(peer)->incisions > 0))
				pInfo(peer)->fever += 0.06;
			pInfo(peer)->temp += pInfo(peer)->fever;
			pInfo(peer)->temp = round(pInfo(peer)->temp * 100) / 100;
			if (pInfo(peer)->temp < 98.6)
				pInfo(peer)->temp = 98.6;
			pInfo(peer)->antibs = false;
			// Managing status, heart stopping
			if (((pInfo(peer)->sleep > 0) && (rand() % 100 < 5)) || (pInfo(peer)->heart > 0)) {
				pInfo(peer)->heart += 1;
			}
			else pInfo(peer)->sleep = max(pInfo(peer)->sleep - 1, 0);
			// Managing pulse
			pInfo(peer)->pulse -= pInfo(peer)->bleeding + min(pInfo(peer)->incisions, 1);
			// Checking for fail
			if (pInfo(peer)->pulse < 1 && pInfo(peer)->endtext == "")
				pInfo(peer)->endtext = "Your patient bled out!";
			else if (pInfo(peer)->temp >= 111)
				pInfo(peer)->endtext = "Your patient succumbed to infection!";
			else if (pInfo(peer)->heart == 3)
				pInfo(peer)->endtext = "You failed to resucicate your patient in time!";
			else if (pInfo(peer)->sleep > 15)
				pInfo(peer)->endtext = "You put your patient to sleep. Permanently!";
			else if ((pInfo(peer)->incisions == 0) && (pInfo(peer)->broken == 0) && (pInfo(peer)->shattered == 0) && pInfo(peer)->fixed && (pInfo(peer)->bleeding == 0) && (pInfo(peer)->temp < 101))
				pInfo(peer)->endtext = "success";

			// Tool text
			if (pInfo(peer)->s)
				pInfo(peer)->tooltext = "`3" + pInfo(peer)->tooltext + "``";
			else {
				pInfo(peer)->tooltext = "`3[```4Skill Fail (" + to_string(30 - pInfo(peer)->surgery_skill / 4) + "%)```3] `6" + pInfo(peer)->tooltext + "``";
				if (pInfo(peer)->surged_person != "") {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(peer)->surged_person != pInfo(currentPeer)->tankIDName) continue;
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert("[`4Skill Fail (" + to_string(30 - skill / 4) + "%)``] `6" + surgery_fail_text + "``"), p2.CreatePacket(currentPeer);
					}
				}
			}
		}

		// Diagnosed
		string diagnosed = "";
		if (!pInfo(peer)->sounded && !pInfo(peer)->flu || !pInfo(peer)->labworked && pInfo(peer)->flu)
			diagnosed += "`4The patient has not been diagnosed.``";
		else if (!pInfo(peer)->fixable || pInfo(peer)->flu || pInfo(peer)->incneeded == 0)
			diagnosed += (pInfo(peer)->pretext);
		else if (!pInfo(peer)->fixed) {
			diagnosed += (pInfo(peer)->fixtext);
		}
		else
			diagnosed += (pInfo(peer)->postext);
		// Pulse
		string pulse = "Pulse: ";
		if (pInfo(peer)->pulse < 11)
			pulse += "`4Extremely Weak``";
		else if (pInfo(peer)->pulse < 21)
			pulse += "`6Weak``";
		else if (pInfo(peer)->pulse < 31)
			pulse += "`3Steady``";
		else
			pulse += "`2Strong``";
		// Status
		string status = "Status: ";
		if (pInfo(peer)->heart > 0)
			status += "`4Heart stopped!``";
		else if (pInfo(peer)->sleep == 0)
			status += (pInfo(peer)->fixed ? "`3" : "`4") + a + "Awake``";
		else if (pInfo(peer)->sleep < 3)
			status += "`6Coming to``";
		else
			status += "`2Unconcsious``";
		// Temp
		string temp = "Temp: ";
		stringstream stream;
		stream << std::fixed << std::setprecision(1) << pInfo(peer)->temp;
		if (pInfo(peer)->temp < 100)
			temp += "`2" + stream.str() + "``";
		else if (pInfo(peer)->temp < 104)
			temp += "`3" + stream.str() + "``";
		else if (pInfo(peer)->temp < 106)
			temp += "`6" + stream.str() + "``";
		else
			temp += "`4" + stream.str() + "``";
		// Operation site
		string operation = "Operation site: ";
		if (pInfo(peer)->site < -3)
			operation += "`4Unsanitary``";
		else if (pInfo(peer)->site < -1)
			operation += "`6Unclean``";
		else if (pInfo(peer)->site < 1)
			operation += "`3Not sanitized``";
		else operation += "`2Clean``";
		// Dirt
		string dirt = "";
		if (pInfo(peer)->dirt == 10)
			dirt += "`4You can't see what you are doing!``";
		else if (pInfo(peer)->dirt > 4)
			dirt += "`6It is becoming hard to see your work.``";
		// Incisions
		string incisions = "Incisions: ";
		if (pInfo(peer)->incisions == 0)
			incisions += "`2" + to_string(pInfo(peer)->incisions) + "``";
		else
			incisions += "`3" + to_string(pInfo(peer)->incisions) + "``";
		// Bones
		string bones = "";
		if (pInfo(peer)->broken + pInfo(peer)->shattered > 0 && pInfo(peer)->sounded) {
			bones += "Bones: ";
			if (pInfo(peer)->broken > 0) {
				if (pInfo(peer)->broken > 2)
					bones += "`4" + to_string(pInfo(peer)->broken) + " broken``";
				else
					bones += "`6" + to_string(pInfo(peer)->broken) + " broken``";
			}
			if (pInfo(peer)->broken > 0 && pInfo(peer)->shattered > 0)
				bones += ", ";
			if (pInfo(peer)->shattered > 0) {
				if (pInfo(peer)->shattered > 2)
					bones += "`4" + to_string(pInfo(peer)->shattered) + " shattered``";
				else
					bones += "`6" + to_string(pInfo(peer)->shattered) + " shattered``";
			}
		}
		// Bleeding
		string bleeding = "";
		if (pInfo(peer)->bleeding > 0) {
			bleeding += "Patient is ";
			if (pInfo(peer)->bleeding == 1)
				bleeding += "losing blood `3slowly.``";
			else if (pInfo(peer)->bleeding == 4)
				bleeding += "losing blood `4Extremely Fast!``";
			else {
				bleeding += "losing blood `6losing `6blood!``";
			}
		}
		// Fever
		string fever = "";
		if (pInfo(peer)->fever > 0 && pInfo(peer)->temp > 100) {
			fever += "Patient's fever is ";
			if (pInfo(peer)->fever < 0.5)
				fever += "`3slowly `3rising.``";
			else if (pInfo(peer)->fever > 2)
				fever += "`4climbing `4fast!``";
			else {
				fever += "`6clim`6bing!``";
			}
		}
		// Special: heart stop and cut awake
		string heart_stopped = "";
		if (pInfo(peer)->heart == 1)
			heart_stopped += "`4The patient's `4heart `4has stopped!``";
		else if (pInfo(peer)->incisions > 0 && pInfo(peer)->sleep == 0)
			heart_stopped += "`4The patient `4screams and flails!``";

		// pInfo(peer)->
		string tools_available = "";
		// Availability
		//1
		int have = 0;
		pInfo(peer)->available_surg_items.clear();
		if (toolavailable(peer, 1258)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1258)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1258|`$Sponge``|noflags|1258|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1258);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//2
		if (toolavailable(peer, 1260)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1260)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1260|`$Scalpel``|noflags|1260|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1260);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//3
		if (toolavailable(peer, 1270)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1270)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1270|`$Stitches``|noflags|1270|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1270);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//4
		if (toolavailable(peer, 1266)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1266)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1266|`$Antibiotics``|noflags|1266|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1266);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//5
		if (toolavailable(peer, 1264)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1264)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1264|`$Antiseptic``|noflags|1264|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1264);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//6
		if (toolavailable(peer, 1296)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1296)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1296|`$Fix `$it!``|noflags|1296|1|";
			pInfo(peer)->available_surg_items.push_back(1296);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//7
		if (toolavailable(peer, 4316)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4316)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4316|`$Ultrasound``|noflags|4316|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4316);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//8
		if (toolavailable(peer, 4318)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4318)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4318|`$Lab `$Kit``|noflags|4318|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4318);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//9
		if (toolavailable(peer, 1262)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1262)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1262|`$Anesthetic``|noflags|1262|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1262);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//10
		if (toolavailable(peer, 1268)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1268)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1268|`$Spl`$int``|noflags|1268|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1268);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		if (toolavailable(peer, 4312)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4312)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4312|`$Defibrillator``|noflags|4312|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4312);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//11
		if (toolavailable(peer, 4308)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4308)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4308|`$Pins``|noflags|4308|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4308);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//12
		if (toolavailable(peer, 4314)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4314)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4314|`$Clamp``|noflags|4314|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4314);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//13
		if (toolavailable(peer, 4310)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4310)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4310|`$Transfusion``|noflags|4310|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4310);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";

		if (pInfo(peer)->endtext == "") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + (pInfo(peer)->surged_person == "" ? "Surg-E" : pInfo(peer)->surged_display) + "``|left|18|\nadd_smalltext|" + diagnosed + "|left|\nadd_smalltext|" + pulse + "    " + status + "|left|\nadd_smalltext|" + temp + "    " + operation + "|left|" + (dirt != "" ? "\nadd_smalltext|" + dirt + "|left|" : "") + "\nadd_smalltext|" + incisions + "    " + (bones != "" ? bones : "") + "|left|" + (fever != "" ? "\nadd_smalltext|" + fever + "|left|" : "") + "" + (bleeding != "" ? "\nadd_smalltext|" + bleeding + "|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->tooltext != "" ? "\nadd_smalltext|" + pInfo(peer)->tooltext + "|left|" : "") + "" + (heart_stopped != "" ? "\nadd_spacer|small|\nadd_smalltext|" + heart_stopped + "|left|" : "") + "\ntext_scaling_string|Defibrillator|" + tools_available + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|tool999|Give up!|noflags|0|0|\nend_dialog|surgery|||");
			p.CreatePacket(peer);
		}
		else
		{
			if (pInfo(peer)->hand == 8536 && pInfo(peer)->started_type == 27 || pInfo(peer)->started_type == 21 || pInfo(peer)->started_type == 22 || pInfo(peer)->started_type == 19 || pInfo(peer)->started_type == 18 || pInfo(peer)->started_type == 28 || pInfo(peer)->started_type == 23 || pInfo(peer)->started_type == 26 || pInfo(peer)->started_type == 24 || pInfo(peer)->started_type == 25) {
				int remove = -1;
				modify_inventory(peer, 8536, remove);
			}
			if (pInfo(peer)->endtext == "success") {
				pInfo(peer)->surgery_started = false;
				if (pInfo(peer)->surgery_skill < 100) pInfo(peer)->surgery_skill++;
				add_role_xp(peer, 1, "surgeon");
				if (pInfo(peer)->startedKit && pInfo(peer)->lvlKit < 50) add_role_xp(peer, rand() % 28, "kit");
				pInfo(peer)->surgery_done++;
				if (has_playmod(pInfo(peer), "Food: Surgery XP")) add_peer_xp(peer, (pInfo(peer)->hand == 7754 ? 450 * 1.3 : 150 * 1.3));
				else add_peer_xp(peer, (pInfo(peer)->hand == 7754 ? 450 : 150));
				if (pInfo(peer)->shirt == 8448 && pInfo(peer)->feet == 8550 && pInfo(peer)->hair == 8444 && pInfo(peer)->necklace == 8442 && pInfo(peer)->face == 8446 && pInfo(peer)->pants == 8450) pInfo(peer)->su_8552_1++;
				if (pInfo(peer)->su_8552_1 >= 2000 && pInfo(peer)->back == 8552) pInfo(peer)->su_8552_2++;
				if (pInfo(peer)->su_8552_1 >= 2000 && pInfo(peer)->mercy == false) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					int c_ = 1;
					if (modify_inventory(peer, 8552, c_) == 0) {
						pInfo(peer)->mercy = true;
						packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
						p.Insert("You received `2Angel of Mercy's Wings`` for completing 2,000 Surgeries while wearing Blinking Set!");
						gamepacket_t p2, p3;
						p2.Insert("OnConsoleMessage"), p2.Insert("You received `2Dr.Title`` for completing 3,000 Surgeries while wearing Angel Of Mercy Wings!"), p2.CreatePacket(peer);
						p3.Insert("OnParticleEffect"), p3.Insert(46), p3.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
						p.CreatePacket(peer);
					}
					else p.Insert("You have finished Angel of Mercy quest, but your inventory is full! Clear inventory and complete another surgery.");
					p.Insert(0), p.Insert(1), p.CreatePacket(peer);
				}
				if (pInfo(peer)->su_8552_2 >= 3000 && pInfo(peer)->drtitle == false) {
					pInfo(peer)->drtitle = true;
					packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					gamepacket_t p, p2, p3;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You received `2Dr.Title`` for completing 3,000 Surgeries while wearing Angel Of Mercy Wings!"), p.Insert(0), p.Insert(1);
					p2.Insert("OnConsoleMessage"), p2.Insert("You received `2Dr.Title`` for completing 3,000 Surgeries while wearing Angel Of Mercy Wings!");
					p3.Insert("OnParticleEffect"), p3.Insert(46), p3.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
					p3.CreatePacket(peer);
					p.CreatePacket(peer), p2.CreatePacket(peer);
				}
				vector<int> list{ 12466, 12468, 12470, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 2586, 782, 3536, 764, 4176 };
				if (pInfo(peer)->started_type == 27 || pInfo(peer)->started_type == 21 || pInfo(peer)->started_type == 22 || pInfo(peer)->started_type == 19 || pInfo(peer)->started_type == 18 || pInfo(peer)->started_type == 28 || pInfo(peer)->started_type == 23 || pInfo(peer)->started_type == 26 || pInfo(peer)->started_type == 24 || pInfo(peer)->started_type == 25) list.push_back(8534);
				int prize_to_pacient = list[rand() % list.size()];
				if (thedaytoday == 6 && rand() % 250 < 1) list = { 4334, 4330, 4326, 4328, 4324, 10570, 12224 };
				if (rand() % 200 < 1) list.insert(list.end(), { 3172,4322,10774,11770 });
				if (rand() % 450 < 1) list = { 12224, 4322 ,2976, 4080,11872, 3790, 4990, 8954, 1506, 1274, 1252, 2992, 3172, 10092, 11224, 9000, 10112, 10094 };
				if (rand() % 450 < 1) list = { 12292, 12294, 12342, 12372, 12444 };
				if (rand() % 2 < 1) {
					if (pInfo(peer)->started_type == 27) list.push_back(8442);
					if (pInfo(peer)->started_type == 21) list.push_back(8482);
					if (pInfo(peer)->started_type == 22) list.push_back(8486);
					if (pInfo(peer)->started_type == 19) list.push_back(8480);
					if (pInfo(peer)->started_type == 18) {
						list.push_back(8478);
						if (rand() % 3 < 1) list.insert(list.end(), { 8488,8452,8454 });
					}
					if (pInfo(peer)->started_type == 28 && rand() % 10 < 1)  list.insert(list.end(), { 8466,8468,8494 });
					if (pInfo(peer)->started_type == 23) {
						list.push_back(8444);
						if (rand() % 3 < 1) list.push_back(8492);
					}
					if (pInfo(peer)->started_type == 26) {
						list.push_back(8448);
						if (rand() % 3 < 1) list.insert(list.end(), { 8474,8476,8498 });
					}
					if (pInfo(peer)->started_type == 24) {
						list.push_back(8450);
						if (rand() % 3 < 1) list.insert(list.end(), { 8472,8496 });
					}
					if (pInfo(peer)->started_type == 25) {
						list.push_back(8550);
						if (rand() % 3 < 1) list.insert(list.end(), { 8458,8456,8490 });
					}
				}
				if (rand() % 5000 < 1) list = { 8284 };
				if (pInfo(peer)->started_type == 31) list.push_back(2900);
				if (rand() % 100 < 1) list.push_back(12566);
				if (rand() % 200 < 1) list.push_back(12568);
				int item = list[rand() % list.size()], got = 1;
				if (item == 1290) got = 10;
				if (item == 1294 || item == 1288 || item == 1292 || item == 1258 || item == 1268 || item == 1264 || item == 1266 || item == 1262 || item == 1260 || item == 1270 || item == 4318 || item == 4314 || item == 4308 || item == 4310 || item == 4316 || item == 4312) got = 5;
				gamepacket_t p, p2, p3;
				p.Insert("OnConsoleMessage");
				if (pInfo(peer)->surged_person == "") p.Insert("Hey, somebody left " + to_string(got) + " " + items[item].ori_name + " in this patient last time they operated!");
				else p.Insert("`w" + pInfo(peer)->surged_display + "``'s parents are so glad you saved their child that they give you " + to_string(got) + " " + items[item].ori_name + "!");
				p.CreatePacket(peer);
				p3.Insert("OnConsoleMessage"), p3.Insert("`2YOU `2SAVED YOUR `2PATIENT!`"), p3.CreatePacket(peer);
				p2.Insert("OnConsoleMessage"), p2.Insert("You got " + to_string(got) + " `2" + items[item].ori_name + "`` and a `3Caduceus``!"), p2.CreatePacket(peer);
				if (pInfo(peer)->surged_person != "") {
					gamepacket_t p, p2;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `2cured`` `0" + pInfo(peer)->surged_display + "`` of " + pInfo(peer)->surgery_name + "`7]``"), p.Insert(0), p.Insert(0);
					p2.Insert("OnConsoleMessage"), p2.Insert("`7[``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `2cured`` `0" + pInfo(peer)->surged_display + "`` of " + pInfo(peer)->surgery_name + "`7]``");
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
						if (pInfo(peer)->surged_person == pInfo(currentPeer)->tankIDName) {
							add_peer_xp(currentPeer, 500);
							int give_prize = got;
							if (modify_inventory(currentPeer, prize_to_pacient, give_prize) == 0) {
							}
							else {
								WorldDrop drop_block_{};
								drop_block_.id = prize_to_pacient, drop_block_.count = give_prize, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(currentPeer)->x + rand() % 17, drop_block_.y = (pInfo(currentPeer)->y * 32) + rand() % 17;
							}
							gamepacket_t p3;
							p3.Insert("OnConsoleMessage"), p3.Insert("You are healed! Celebrate your good health with 500 Gems and 1 " + items[prize_to_pacient].ori_name + "!"), p3.CreatePacket(currentPeer);
							gamepacket_t p;
							p.Insert("OnSetBux"), p.Insert(pInfo(currentPeer)->gems += 500), p.Insert(1), p.Insert((pInfo(currentPeer)->supp >= 1) ? 1 : 0);
							if (pInfo(currentPeer)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
							p.CreatePacket(currentPeer);
						}
						p.CreatePacket(currentPeer);
						p2.CreatePacket(currentPeer);
					}
				}
				int give_prize = 1;
				if (modify_inventory(peer, item, give_prize = got) == 0) {
				}
				else {
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = give_prize = got, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = (pInfo(peer)->y * 32) + rand() % 17;
				}
				give_prize = 1;
				if (modify_inventory(peer, 4298, give_prize = 1) == 0) {
				}
				else {
					int has_caduc = 0;
					modify_inventory(peer, 4298, has_caduc);
					if (modify_inventory(peer, 4300, give_prize = 2) == 0 and has_caduc >= 200) modify_inventory(peer, 4298, has_caduc = -199);
				}
				pInfo(peer)->surged_person = "", pInfo(peer)->surged_display = "";
			}
			else end_surgery(peer);
		}
	}
}

bool is_block_owner(ENetPeer* peer, World* world_, WorldBlock* block_, bool vend = false) {
	if (not block_->locked || pInfo(peer)->dev) return true;
	if (block_->locked) {
		WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
		if (block2_->owner_name == pInfo(peer)->tankIDName) return true;
	}
	return false;
}

bool block_access(ENetPeer* peer, World* world_, WorldBlock* block_, bool vend = false, bool admin_access = false) {
	if (world_->owner_name == pInfo(peer)->tankIDName || pInfo(peer)->dev) return true;
	if (vend) {
		if (world_->v_p) {
			if (not block_->locked && find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) != world_->admins.end()) return true;
		}
		if (block_->locked) {
			WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
			if (block2_->owner_name == pInfo(peer)->tankIDName) return true;
		}
		else if (world_->owner_name == "") return true;
	}
	else {
		if (block_->locked) {
			WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
			if (block2_->open_to_public || block2_->owner_name == pInfo(peer)->tankIDName || find(block2_->admins.begin(), block2_->admins.end(), pInfo(peer)->uid) != block2_->admins.end()) return true;
		}
		else {
			if (world_->owner_name == "" || world_->open_to_public) return true;
			if (admin_access == false) if (find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) != world_->admins.end()) return true;
		}
	}
	return false;
}

bool has_access(ENetPeer* peer, World* world_, WorldBlock* block_) {
	if (not block_->locked || pInfo(peer)->dev) return true;
	WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
	if (block2_->open_to_public || find(block2_->admins.begin(), block2_->admins.end(), pInfo(peer)->uid) != block2_->admins.end()) 
		return true;

	return false;
}

void offering_table(ENetPeer* peer, WorldBlock* block_ = NULL, string button = "", int item = 0, int count = 0, int slot = 0) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (block_ == NULL) block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * world_->width)];
		if (block_ != NULL) {
			if (block_access(peer, world_, block_)) {
				if (block_->fg == 12598) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (button == "") {
						if (item != 0) {
							if (block_->donates.size() < 10) {
								Donate donate_{};
								donate_.item = item, donate_.count = count, donate_.name = pInfo(peer)->tankIDName, donate_.text = "";
								block_->donates.push_back(donate_);
								modify_inventory(peer, item, count *= -1);
							}
						}
						int count = 0, all_ = 0;
						string list = "";
						for (int i_ = 0; i_ < block_->donates.size(); i_++, all_++) {
							count += block_->donates[i_].count;
							list += "\nadd_button_with_icon|slot_btn_" + to_string(i_) + "||frame|" + to_string(block_->donates[i_].item) + "|" + to_string(block_->donates[i_].count) + "|\nadd_custom_margin|x:-15;y:0|" + (i_ == 4 || i_ == 9 ? "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_margin|x:0;y:-15|" : "");
						}
						for (int i_ = all_; i_ < 10; i_++, all_++) list += "\nadd_button_with_icon|slot_btn_" + to_string(i_) + "||frame|982||\nadd_custom_margin|x:-15;y:0|" + (i_ == 4 || i_ == 9 ? "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_margin|x:0;y:-15|" : "");
						p.Insert("set_default_color|`w\nadd_label_with_icon|big|`wOffer Mooncakes to the Moon``|left|12598|\nadd_spacer|small|\nadd_textbox|Fill the table with 10 Mooncakes and offer them to the Moon to receive 1 random reward.|left|\nadd_textbox|Select a Mooncake to place on the table.|left|" + list + "\nadd_textbox|Total Mooncakes on table: `5" + to_string(count) + "``|left|\nadd_smalltext|You get 1 reroll for every 100 Mooncakes offered.| left |\nadd_smalltext|The current offering will get `5" + to_string(count / 100) + " rerolls``.| left |\nadd_spacer|small|\nadd_button|offer_btn|Offer Mooncakes|noflags|0|0|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Depending on the types of Mooncakes offered the rewards may vary. You can check the possible rewards that can be received from your current offering here:|left|\nadd_spacer|small|\nadd_button|reward_list_btn|Reward List|noflags|0|0|\nend_dialog|mooncake_altar_dialog|Close||");
					}
					else if (button == "reward") {
						string epic = "", rare = "", uncommon = "";
						vector<int> already_added, already_added2;
						if (block_->donates.size() > 0) {
							for (int i_ = 0; i_ < block_->donates.size(); i_++) {
								if (find(already_added.begin(), already_added.end(), block_->donates[i_].item) == already_added.end()) {
									already_added.push_back(block_->donates[i_].item);

									for (int i = 0; i < items[block_->donates[i_].item].rare.size(); i++) {
										if (find(already_added2.begin(), already_added2.end(), items[block_->donates[i_].item].rare[i]) == already_added2.end()) {
											already_added2.push_back(items[block_->donates[i_].item].rare[i]);
											rare += "\nadd_label_with_icon|small|`w" + items[items[block_->donates[i_].item].rare[i]].ori_name + "``|left|" + to_string(items[block_->donates[i_].item].rare[i]) + "|";
										}
									}
									for (int i = 0; i < items[block_->donates[i_].item].epic.size(); i++) {
										if (find(already_added2.begin(), already_added2.end(), items[block_->donates[i_].item].epic[i]) == already_added2.end()) {
											already_added2.push_back(items[block_->donates[i_].item].epic[i]);
											epic += "\nadd_label_with_icon|small|`w" + items[items[block_->donates[i_].item].epic[i]].ori_name + "``|left|" + to_string(items[block_->donates[i_].item].epic[i]) + "|";
										}
									}
									for (int i = 0; i < items[block_->donates[i_].item].uncommon.size(); i++) {
										if (find(already_added2.begin(), already_added2.end(), items[block_->donates[i_].item].uncommon[i]) == already_added2.end()) {
											already_added2.push_back(items[block_->donates[i_].item].uncommon[i]);
											uncommon += "\nadd_label_with_icon|small|`w" + items[items[block_->donates[i_].item].uncommon[i]].ori_name + "``|left|" + to_string(items[block_->donates[i_].item].uncommon[i]) + "|";
										}
									}
								}
							}
						}
						p.Insert("set_default_color|`w\nadd_label_with_icon|big|`wRewards table!``|left|12598|\nadd_spacer|small|\nadd_textbox|The following items my be received for the current offering:|left|" + a + (epic.empty() ? "" : "\nadd_spacer|small|\nadd_textbox|Epic|left|" + epic) + (rare.empty() ? "" : "\nadd_spacer|small|\nadd_textbox|Rare|left|" + rare) + "\nadd_spacer|small|\nadd_textbox|Uncommon|left|" + uncommon + "\nadd_label_with_icon|small|`wSunflower Pinwheel``|left|11270|\nadd_label_with_icon|small|`wTraditional Harvest Hat``|left|12622|\nadd_label_with_icon|small|`wTraditional Harvest Shirt``|left|12624|\nadd_label_with_icon|small|`wTraditional Harvest Dress``|left|12626|\nadd_spacer|small|\nadd_textbox|Common|left|\nadd_label_with_icon|small|`wChinese Lantern``|left|1054|\nadd_label_with_icon|small|`wScarecrow``|left|1064|\nadd_label_with_icon|small|`wSky Lantern``|left|1066|\nadd_label_with_icon|small|`wYellow Hanbok Top``|left|1070|\nadd_label_with_icon|small|`wPurple Hanbok Top``|left|1072|\nadd_label_with_icon|small|`wGreen Hanbok Top``|left|1074|\nadd_label_with_icon|small|`wPink Hanbok Skirt``|left|1076|\nadd_label_with_icon|small|`wBlue Hanbok Skirt``|left|1078|\nadd_label_with_icon|small|`wOrange Hanbok Skirt``|left|1080|\nadd_label_with_icon|small|`wYellow Hanbok Pants``|left|1082|\nadd_label_with_icon|small|`wPurple Hanbok Pants``|left|1084|\nadd_label_with_icon|small|`wGreen Hanbok Pants``|left|1086|\nadd_label_with_icon|small|`wMoon Block``|left|1834|\nadd_label_with_icon|small|`wHarvest Horn``|left|3868|\nadd_label_with_icon|small|`wBlue Hanbok Top``|left|3872|\nadd_label_with_icon|small|`wOrange Hanbok Top``|left|3874|\nadd_label_with_icon|small|`wBlue Hanbok Pants``|left|3876|\nadd_label_with_icon|small|`wOrange Hanbok Pants``|left|3878|\nadd_label_with_icon|small|`wGreen Hanbok Skirt``|left|3880|\nadd_label_with_icon|small|`wYellow Hanbok Skirt``|left|3882|\nadd_label_with_icon|small|`wSunflower Hair Pin``|left|3884|\nadd_label_with_icon|small|`wSheep``|left|3888|\nadd_label_with_icon|small|`wDragon Scales``|left|5098|\nadd_label_with_icon|small|`wLeaves``|left|5102|\nadd_label_with_icon|small|`wScarecrow Mask``|left|5118|\nadd_label_with_icon|small|`wZen Garden``|left|5198|\nadd_label_with_icon|small|`wMoon Palace``|left|12604|\nadd_label_with_icon|small|`wMoon Palace Roof``|left|12606|\nadd_label_with_icon|small|`wBuddy To He``|left|12608|\nadd_label_with_icon|small|`wMoon Palace Door``|left|12652|\nadd_spacer|small|\nadd_button|goto_maindialog|Thanks for the info|0|0|\nend_dialog|mooncake_reward_list_dialog|||");
					}
					else if (button == "reroll") {
						if (block_->offering_items.size() == 0) block_->offering_items = { 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,1834, 1834, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1834, 3868, 3872, 3874, 3876, 3878, 3880, 3882, 3884, 3888, 5098, 5102, 1062, 12604, 12604, 12604 };
						if (block_->bunny_egg_progress >= 100) {
							block_->bunny_egg_progress -= 100;
							if (block_->offering_items.size() == 0) block_->shelf_1 = 5118;
							else block_->shelf_1 = block_->offering_items[rand() % block_->offering_items.size()];
						}
						p.Insert("set_default_color|`w\nadd_label_with_icon|big|`wReward!``|left|12598|\nadd_spacer|small|\nadd_textbox|You received:|left|\nadd_label_with_icon|small|`w1 x " + items[block_->shelf_1].name + "``|left|" + to_string(block_->shelf_1) + "|\nadd_spacer|small|" + (block_->bunny_egg_progress > 100 ? "\nadd_textbox|You have " + to_string(block_->bunny_egg_progress / 100) + " rerolls remaining.|left|\nadd_button|reroll|Reroll|0|0|" : "") + "\nadd_button|take_reward|Claim Reward|0|0|" + (block_->bunny_egg_progress > 100 ? "\nadd_smalltext|`6Claiming the reward will forfeit any remaining rerolls.``|left|" : "") + "\nend_dialog|mooncake_reward_dialog|||");
					}
					else if (button == "offer") {
						int start_offer = 0;
						for (int i_ = 0; i_ < block_->donates.size(); i_++) start_offer += block_->donates[i_].count;
						if (start_offer >= 100 && block_->donates.size() >= 10) {
							block_->offering_items = { 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,1834, 1834, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1834, 3868, 3872, 3874, 3876, 3878, 3880, 3882, 3884, 3888, 5098, 5102, 1062, 12604, 12604, 12604 };
							block_->bunny_egg_progress = start_offer;
							vector<Donate>::iterator p3 = find_if(block_->donates.begin(), block_->donates.end(), [&](const Donate& a) { return a.item == 1096 || a.item == 7058 || a.item == 1828 || a.item == 11286; });
							if (p3 != block_->donates.end()) {
								Donate* found = &block_->donates[p3 - block_->donates.begin()];
								if (found->item == 1096) {
									vector<Donate>::iterator p2 = find_if(block_->donates.begin(), block_->donates.end(), [&](const Donate& a) { return a.item == 1828 || a.item == 11286 || a.item == 7058; });
									if (p2 != block_->donates.end()) {
										Donate* found2 = &block_->donates[p2 - block_->donates.begin()];
										if (found2->item == 1828)block_->offering_items.insert(block_->offering_items.end(), { 12380 });
										if (found2->item == 11286)block_->offering_items.insert(block_->offering_items.end(), { 12388 });
										if (found2->item == 7058)block_->offering_items.insert(block_->offering_items.end(), { 12390 });
									}
									if (rand() % 20 < 1)  block_->offering_items.insert(block_->offering_items.end(), { 12604, 12652, 12606, 12608, 12622, 12624, 12626 });
								}
							}
							for (int i_ = 0; i_ < block_->donates.size(); i_++) {
								int chance = 0;

								for (int i = 0; i < items[block_->donates[i_].item].epic.size(); i++) {
									if (rand() % 6500 - block_->donates[i_].count + items[block_->donates[i_].item].grindable_count < 1) {
										block_->offering_items.insert(block_->offering_items.end(), items[block_->donates[i_].item].epic[i]);
									}
								}
								for (int i = 0; i < items[block_->donates[i_].item].rare.size(); i++) {
									if (rand() % 4000 - block_->donates[i_].count + items[block_->donates[i_].item].grindable_count < 1) {
										block_->offering_items.insert(block_->offering_items.end(), items[block_->donates[i_].item].rare[i]);
									}
								}
								for (int i = 0; i < items[block_->donates[i_].item].uncommon.size(); i++) {
									if (rand() % 700 - block_->donates[i_].count + items[block_->donates[i_].item].grindable_count < 1) {
										block_->offering_items.insert(block_->offering_items.end(), items[block_->donates[i_].item].uncommon[i]);
										block_->offering_items.insert(block_->offering_items.end(), items[block_->donates[i_].item].uncommon[i]);
									}
								}
							}
							block_->donates.clear();
							block_->shelf_1 = block_->offering_items[rand() % block_->offering_items.size()];
							p.Insert("set_default_color|`w\nadd_label_with_icon|big|`wReward!``|left|12598|\nadd_spacer|small|\nadd_textbox|You received:|left|\nadd_label_with_icon|small|`w1 x " + items[block_->shelf_1].name + "``|left|" + to_string(block_->shelf_1) + "|\nadd_spacer|small|" + (block_->bunny_egg_progress >= 100 ? "\nadd_textbox|You have " + to_string(block_->bunny_egg_progress / 100) + " rerolls remaining.|left|\nadd_button|reroll|Reroll|0|0|" : "") + "\nadd_button|take_reward|Claim Reward|0|0|" + (block_->bunny_egg_progress >= 100 ? "\nadd_smalltext|`6Claiming the reward will forfeit any remaining rerolls.``|left|" : "") + "\nend_dialog|mooncake_reward_dialog|||");
						}
						else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wNot Enough Mooncakes``|left|1432|\nadd_textbox|You must fill the table before you can offer the Mooncakes.|left|\nadd_spacer|small|\nadd_button|goto_maindialog|OK|0|0|\nadd_spacer|small|\nend_dialog|altar_warning_dialog|||");
					}
					p.CreatePacket(peer);
				}
			}
		}
	}
}

bool setstats(ENetPeer* peer, int i, string surged, string surged_display) {
	if (pInfo(peer)->surgery_started) {
		end_surgery(peer);
		return false;
	}
	if (has_playmod(pInfo(peer), "Malpractice")) {
		gamepacket_t p;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(surged == "" ? "I know it's just a robot, but the authorities don't even trust you operating on that with your malpractice issues." : "You can't perform surgery right now."), p.CreatePacket(peer);
		return false;
	}
	if (i < 0 || i > 30) i = rand() % 30;
	pInfo(peer)->started_type = i;
	pInfo(peer)->surged_person = surged;
	pInfo(peer)->surged_display = surged_display;
	pInfo(peer)->surgery_world = pInfo(peer)->world;
	pInfo(peer)->surgery_started = true;
	pInfo(peer)->sounded = false;
	pInfo(peer)->labworked = false;
	pInfo(peer)->fixed = false;
	pInfo(peer)->fixable = false;
	pInfo(peer)->flu = false;
	pInfo(peer)->pulse = 40;
	pInfo(peer)->site = 0;
	pInfo(peer)->sleep = 0;
	pInfo(peer)->dirt = 0;
	pInfo(peer)->broken = 0;
	pInfo(peer)->shattered = 0;
	pInfo(peer)->incisions = 0;
	pInfo(peer)->bleeding = 0;
	pInfo(peer)->incneeded = 0;
	pInfo(peer)->heart = 0;
	pInfo(peer)->temp = 98.6;
	pInfo(peer)->fever = 0;
	pInfo(peer)->pretext = "";
	pInfo(peer)->fixtext = "";
	pInfo(peer)->postext = "";
	pInfo(peer)->scantext = "";
	pInfo(peer)->tooltext = "Patient is prepped for surgery.";
	pInfo(peer)->endtext = "";
	pInfo(peer)->s = true;

	pInfo(peer)->spongUsed = 0;
	pInfo(peer)->scalpUsed = 0;
	pInfo(peer)->stitcUsed = 0;
	pInfo(peer)->antibUsed = 0;
	pInfo(peer)->antisUsed = 0;
	pInfo(peer)->ultraUsed = 0;
	pInfo(peer)->labkiUsed = 0;
	pInfo(peer)->anestUsed = 0;
	pInfo(peer)->defibUsed = 0;
	pInfo(peer)->splinUsed = 0;
	pInfo(peer)->pinsUsed = 0;
	pInfo(peer)->clampUsed = 0;
	pInfo(peer)->transUsed = 0;
	pInfo(peer)->surgery_name = "";

	if (pInfo(peer)->surged_person == "") {
		string name_ = pInfo(peer)->surgery_world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * world_->width)];
			if (block_->fg == 4296 || block_->fg == 8558) {
				block_->fg = 0;
				update_tile(peer, pInfo(peer)->lastwrenchx, pInfo(peer)->lastwrenchy, 0, false, true);
			}
			else return false;
		}
	}

	switch (i) {
	case 0:
		pInfo(peer)->fixed = true;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->broken = 1;
		pInfo(peer)->pretext = "Patient broke his arm.";
		pInfo(peer)->scantext = "a broken arm! You found 1 broken bone.";
		pInfo(peer)->surgery_name = "a broken arm.";
		break;
	case 1:
		pInfo(peer)->fixed = true;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->broken = 1;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->pretext = "Patient broke his leg.";
		pInfo(peer)->scantext = "a broken leg! You found 1 broken bone and 1 shattered bone.";
		pInfo(peer)->surgery_name = "a broken leg.";
		break;
	case 2:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 2.5;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->pretext = "Patient is showing signs of the bird flu.";
		pInfo(peer)->scantext = "bird flu!";
		pInfo(peer)->surgery_name = "a bird flu!";
		break;
	case 3:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->fever = 3.6;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->pretext = "Patient is showing signs of the turtle flu.";
		pInfo(peer)->scantext = "turtle flu!";
		pInfo(peer)->surgery_name = "a turtle flu!";
		break;
	case 4:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 107.6;
		pInfo(peer)->fever = 2.4;
		pInfo(peer)->pretext = "Patient is showing signs of the monkey flu.";
		pInfo(peer)->scantext = "monkey flu!";
		pInfo(peer)->surgery_name = "a monkey flu!";
		break;
	case 5:
		pInfo(peer)->sounded = true;
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->pretext = "Patient wants a nose job.";
		pInfo(peer)->fixtext = "You have cut into nasal area.";
		pInfo(peer)->postext = "You rearranged their face!";
		pInfo(peer)->surgery_name = "a nose job.";
		break;
	case 6:
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->scantext = "a lung tumor!";
		pInfo(peer)->pretext = "Patient has a tumor in their lung.";
		pInfo(peer)->fixtext = "The lungs are now exposed.";
		pInfo(peer)->postext = "You excised the tumor!";
		pInfo(peer)->surgery_name = "a lung tumor!";
		break;
	case 7:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->scantext = "a heart attack!";
		pInfo(peer)->pretext = "Patient had a heart attack.";
		pInfo(peer)->fixtext = "The heart is now exposed for operating.";
		pInfo(peer)->postext = "You grafted in some nice new arteries!";
		pInfo(peer)->surgery_name = "a heart attack!";
		break;
	case 8:
		pInfo(peer)->incneeded = 5;
		pInfo(peer)->scantext = "a brain tumor!";
		pInfo(peer)->pretext = "Patient has a brain tumor, deep inside.";
		pInfo(peer)->fixtext = "You've finally found the tumor!";
		pInfo(peer)->postext = "You excised the tumor!";
		pInfo(peer)->surgery_name = "a brain tumor!";
		break;
	case 9:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 0.6;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->scantext = "a liver infection!";
		pInfo(peer)->pretext = "Patient has a liver infection.";
		pInfo(peer)->fixtext = "You've accessed the liver.";
		pInfo(peer)->postext = "You treated the source of the infection!";
		pInfo(peer)->surgery_name = "a liver infection!";
		break;
	case 10:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->fever = 1.2;
		pInfo(peer)->scantext = "kidney failure!";
		pInfo(peer)->pretext = "Patient suffers from kidney failure.";
		pInfo(peer)->fixtext = "You now have access to the bad kidney.";
		pInfo(peer)->postext = "You popped in a fresh new kidney!";
		pInfo(peer)->surgery_name = "kidney failure!";
		break;
	case 11:
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 1.2;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->scantext = "appendicitis!";
		pInfo(peer)->pretext = "Patient suffers from appendicitis.";
		pInfo(peer)->fixtext = "You now have access to the appendix.";
		pInfo(peer)->postext = "You yanked out the appendix!";
		pInfo(peer)->surgery_name = "appendicitis!";
		break;
	case 12:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->scantext = "swallowed World Lock!";
		pInfo(peer)->pretext = "Patient has swallowed a world lock.";
		pInfo(peer)->fixtext = "You've opened the stomach.";
		pInfo(peer)->postext = "You got the lock out!";
		pInfo(peer)->surgery_name = "a swallowed World Lock!";
		break;
	case 13:
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 100.4;
		pInfo(peer)->scantext = "a herniated disc!";
		pInfo(peer)->pretext = "Patient's spine is damaged.";
		pInfo(peer)->fixtext = "You've opened up the vertebrae.";
		pInfo(peer)->postext = "You repaired the disc!";
		pInfo(peer)->surgery_name = "a herniated disc!";
		break;
	case 14:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 100.58;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->shattered = 4;
		pInfo(peer)->scantext = "broken everything! You found 4 shattered bones.";
		pInfo(peer)->pretext = "Patient was run over by a truck.";
		pInfo(peer)->fixtext = "You've found gravel in the knees.";
		pInfo(peer)->postext = "You removed the gravel!";
		pInfo(peer)->surgery_name = "a broken everything!";
		break;
	case 15:
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->pulse = 20;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->bleeding = 4;
		pInfo(peer)->scantext = "a serious head injury!";
		pInfo(peer)->pretext = "Patient has a serious head injury.";
		pInfo(peer)->fixtext = "You've opened the skull.";
		pInfo(peer)->postext = "You reduced the swelling!";
		pInfo(peer)->surgery_name = "a serious head injury!";
		break;
	case 16:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->broken = 2;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->scantext = "serious trauma! You found 2 broken bones and 1 shattered bone.";
		pInfo(peer)->pretext = "Patient suffered serious trauma with a punctured lung.";
		pInfo(peer)->fixtext = "You found the lung puncture.";
		pInfo(peer)->postext = "You repaired it.";
		pInfo(peer)->surgery_name = "a serious trauma!";
		break;
	case 17:
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 4;
		pInfo(peer)->broken = 2;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->scantext = "massive trauma! You found 2 broken bones and 2 shattered bones.";
		pInfo(peer)->pretext = "Patient suffered massive trauma with internal bleeding.";
		pInfo(peer)->fixtext = "You found the internal bleed.";
		pInfo(peer)->postext = "You cauterized it.";
		pInfo(peer)->surgery_name = "a massive trauma!";
		break;
	case 18:
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->dirt = 15;
		pInfo(peer)->scantext = "torn punching muscle!";
		pInfo(peer)->pretext = "Patient has a torn punching muscle.";
		pInfo(peer)->fixtext = "You've accessed the arm muscles. ";
		pInfo(peer)->postext = "You patched the torn punching muscle! They should be back to punching in no time.";
		pInfo(peer)->surgery_name = "a torn punching muscle!";
		break;
	case 19:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 98.6;
		pInfo(peer)->dirt = 0;
		pInfo(peer)->fever = 0;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->scantext = "gem cuts!";
		pInfo(peer)->pretext = "Patient is bleeding from multiple gem-induced cuts.";
		pInfo(peer)->fixtext = "You've examined the wounds.";
		pInfo(peer)->postext = "You've stitches the gem cuts closed and stopped the bleeding.";
		pInfo(peer)->surgery_name = "gem cuts!";
		break;
	case 20:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->pulse = 20;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->dirt = 5;
		pInfo(peer)->scantext = "Grumbleteeth! You found 1 shattered bones.";
		pInfo(peer)->pretext = "Patient's teeth are chattering They sound angry.";
		pInfo(peer)->fixtext = "You removed grumbleteeth";
		pInfo(peer)->postext = "You've replaced the patient's angriest teeth and quited";
		pInfo(peer)->surgery_name = "Grumbleteeth!";
		break;
	case 21:
		pInfo(peer)->fixable = false;
		pInfo(peer)->temp = 98.6;
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->heart = 0;
		pInfo(peer)->fever = 1.56;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->scantext = "chicken feet! You found 2 shattered bones.";
		pInfo(peer)->pretext = "Patient feet have turned into chicken toes.";
		pInfo(peer)->fixtext = "You've insvestigated the feet.";
		pInfo(peer)->postext = "You fixed the patient feet. They look like normal blocky toes again!";
		pInfo(peer)->surgery_name = "chicken feet!";
		break;
	case 22:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->temp = 107.6;
		pInfo(peer)->fever = 1.2;
		pInfo(peer)->dirt = 2;
		pInfo(peer)->scantext = "Broken Heart! You found 2 shattered bones.";
		pInfo(peer)->pretext = "Patient suffered from a Broken Heart.";
		pInfo(peer)->fixtext = "You've revealed the heart.";
		pInfo(peer)->postext = "You've repaired the fractured in the patient's heart";
		pInfo(peer)->surgery_name = "Broken heart!";
		break;
	case 23:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 100.58;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->fever = 0.8;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 5;
		pInfo(peer)->scantext = "brain worms! You found 1 Shattered bone.";
		pInfo(peer)->pretext = "You've exposed the brain.";
		pInfo(peer)->fixtext = "You made a neat incision.";
		pInfo(peer)->postext = "You've shut down the worm party in the patient brain and cleared away their trash.";
		pInfo(peer)->surgery_name = "brain worms!";
		break;
	case 24:
		pInfo(peer)->incneeded = 0;
		pInfo(peer)->fixable = false;
		pInfo(peer)->temp = 98.6;
		pInfo(peer)->dirt = 0;
		pInfo(peer)->broken = 6;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->scantext = "ecto bones! You found 6 Broken bones and 2 Shattered bones.";
		pInfo(peer)->pretext = "You've exposed the ribs";
		pInfo(peer)->fixtext = "You made an incision";
		pInfo(peer)->postext = "You pinned down all patient major bones and dyed them back to their normal color.";
		pInfo(peer)->surgery_name = "ecto bones!";
		break;
	case 25:
		pInfo(peer)->fixable = false;
		pInfo(peer)->pulse = 20;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 1.98;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->scantext = "Moldy Guts! You found 1 shattered bone.";
		pInfo(peer)->pretext = "Patient suffers from Moldy Guts.";
		pInfo(peer)->fixtext = "You've openned the abdomen.";
		pInfo(peer)->postext = "You'e cleaned out the patient's internal organs and applied a light air freshener";
		pInfo(peer)->surgery_name = "Moldy Guts!";
		break;
	case 26:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->fever = 2.0;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->scantext = "fatty liver!";
		pInfo(peer)->pretext = "Patient suffered fatty liver.";
		pInfo(peer)->fixtext = "Patient poor diet has led to a high degree of fat build-up in their liver";
		pInfo(peer)->postext = "You pickup it.";
		pInfo(peer)->surgery_name = "fatty liver!";
		break;
	case 27:
		pInfo(peer)->fixed = false;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 105.6;
		pInfo(peer)->broken = 2;
		pInfo(peer)->fever = 2.6;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->scantext = "Chaos Infection! You found 2 Broken bones.";
		pInfo(peer)->pretext = "Patient suffered chaos infection.";
		pInfo(peer)->fixtext = "Patient poor diet has led to a high degree of fat build-up in their liver";
		pInfo(peer)->postext = "You removed it.";
		pInfo(peer)->surgery_name = "Chaos Infection!";
		break;
	case 28:
		pInfo(peer)->fixed = false;
		pInfo(peer)->incneeded = 4;
		pInfo(peer)->temp = 100.1;
		pInfo(peer)->broken = 2;
		pInfo(peer)->fever = 3.1;
		pInfo(peer)->sleep = 3;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->scantext = "Lupus! You found 2 Broken bones.";
		pInfo(peer)->pretext = "Patient suffered lupus.";
		pInfo(peer)->fixtext = "Chance of patient tearing skin, adding one extra incision";
		pInfo(peer)->postext = "You removed it.";
		pInfo(peer)->surgery_name = "Lupus!";
		break;
	case 29:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 105.7;
		pInfo(peer)->fever = 2.5;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->pretext = "Patient is showing signs of the COVID-19.";
		pInfo(peer)->scantext = "COVID-19!";
		pInfo(peer)->surgery_name = "a COVID-19!";
		break;
		/*
		case 30:
		pInfo(peer)->incneeded = 7;
		pInfo(peer)->temp = 102.6;
		pInfo(peer)->fever = 0.6;
		pInfo(peer)->scantext = "a Ebola! Patient is having seizure.";
		pInfo(peer)->pretext = "Patient has Ebola.";
		pInfo(peer)->fixtext = "You've finally cured the seizure!";
		pInfo(peer)->postext = "You made the pacient experience a seizure!";
		pInfo(peer)->surgery_name = "a Ebola!";
		break;
		*/
	}
	gamepacket_t p;
	p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` is performing surgery on " + pInfo(peer)->surged_display + "!`7]``"), p.Insert(0), p.Insert(0);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
		p.CreatePacket(currentPeer);
	}
	load_surgery(peer, 0);
	return true;
}


void hand_phone(ENetPeer* p_) {
	DialogBuilder p("`o");
	p.add_label_icon(true, 13862, "`0IQoo Pro 12");
	p.add_spacer(false);
	p.add_static_icon_button("spotify_list", 12358, "`wSpotify");
	p.add_custom_margin(25, 0);
	p.end_list();
	p.add_spacer(false);
	p.add_quick_exit().end_dialog("socialportal", "Continue", "");
	enet_peer_send(p_, 0, Variant{ "OnDialogRequest" }.push(p.to_string()).pack());
}

void send_growscan_floating(ENetPeer* peer, string search, string type) {
	int total_floating = 0, total_rarity = 0, total_super_item = 0, total_gems = 0;
	vector<pair<int, int>> founditems;
	string name_ = pInfo(peer)->world;
	string found_list = "";
	vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (px != worlds.end()) {
		World* world_ = &worlds[px - worlds.begin()];
		for (int i_ = 0; i_ < world_->drop.size(); i_++) {
			if (world_->drop[i_].id == 0) continue;
			if (world_->drop[i_].id != 0 || world_->drop[i_].x > 0 || world_->drop[i_].y > 0) {
				if (search == "start") {
					total_floating++;
					if (items[world_->drop[i_].id].rarity < 363) total_rarity += items[world_->drop[i_].id].rarity * world_->drop[i_].count;
					else if (items[world_->drop[i_].id].rarity == 999)total_super_item += world_->drop[i_].count;
					if (world_->drop[i_].id == 112) total_gems += world_->drop[i_].count;
				}
				else if (type == "1" or type == "2" and items[world_->drop[i_].id].blockType == BlockTypes::CLOTHING or type == "3" and items[world_->drop[i_].id].blockType == BlockTypes::CONSUMABLE or type == "4" and items[world_->drop[i_].id].blockType == BlockTypes::FOREGROUND or type == "5" and items[world_->drop[i_].id].blockType == BlockTypes::SEED or type == "6" and items[world_->drop[i_].id].blockType == BlockTypes::LOCK) {
					if (to_lower(items[world_->drop[i_].id].name).find(to_lower(search)) != string::npos) {
						bool copy = true;
						for (int i = 0; i < founditems.size(); i++) {
							if (founditems[i].first == world_->drop[i_].id) {
								founditems[i].second += world_->drop[i_].count;
								copy = false;
							}
						}
						if (copy) founditems.push_back(make_pair(world_->drop[i_].id, world_->drop[i_].count));
					}
				}
			}
		}
		for (int i = 0; i < founditems.size(); i++) found_list += to_string(founditems[i].first) + "," + to_string(founditems[i].second) + ",";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	if (search == "start") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|`wTotal number in world: " + to_string(total_floating) + "|left\nadd_textbox|`wTotal floating item rarity: " + to_string(total_rarity) + "|left|\nadd_textbox|`wTotal super rare items: " + to_string(total_super_item) + "|left|\nadd_textbox|`wTotal gems: " + to_string(total_gems) + "|left|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|search_1|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|search_2|Search Clothing|noflags|0|0|\nadd_button|search_3|Search Consumables|noflags|0|0|\nadd_button|search_4|Search Blocks and Backgrounds|noflags|0|0|\nadd_button|search_5|Search Seeds|noflags|0|0|\nadd_button|search_6|Search Locks|noflags|0|0|\nadd_button|search_1|Search Others|noflags|0|0|\nadd_spacer|small|\nadd_button|back_to_gscan|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
	else {
		if (found_list == "") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|floatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
		else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + found_list + "\nadd_spacer|small|\nadd_button|floatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
	}
	p.CreatePacket(peer);
}

void send_growscan_worldblocks(ENetPeer* peer, string search, string type) {
	int total_block = 0, total_background = 0, total_untradeable = 0, total_super_rare_item = 0, total_rarity = 0, total_fire = 0, total_water = 0, total_earth = 0, total_air = 0;
	string name_ = pInfo(peer)->world;
	string found_list = "";
	vector<pair<int, int>> founditems;
	vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (px != worlds.end()) {
		World* world_ = &worlds[px - worlds.begin()];
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (world_->blocks[i_].fg != 8 && world_->blocks[i_].fg != 6) {
				if (search == "start") {
					if (world_->blocks[i_].fg != 0) total_block++;
					if (world_->blocks[i_].bg != 0) total_background++;
					if (world_->blocks[i_].fg != 0 && items[world_->blocks[i_].fg].untradeable == 1 or world_->blocks[i_].bg != 0 && items[world_->blocks[i_].bg].untradeable == 1) total_untradeable++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].rarity >= 999 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].rarity >= 999) total_super_rare_item++;
					if (items[world_->blocks[i_].fg].rarity < 363 and items[world_->blocks[i_].fg].rarity != 999) if (world_->blocks[i_].fg != 0) total_rarity += items[world_->blocks[i_].fg].rarity;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 0 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 0) total_earth++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 1 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 1) total_fire++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 2 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 2) total_air++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 3 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 3) total_water++;
				}
				else if (type == "1" or type == "2" and items[world_->blocks[i_].fg].blockType == BlockTypes::FOREGROUND) {
					if (to_lower(items[world_->blocks[i_].fg].name).find(to_lower(search)) != string::npos || to_lower(items[world_->blocks[i_].bg].name).find(to_lower(search)) != string::npos) {
						if (world_->blocks[i_].fg != 0) {
							bool copy_fg = true;
							for (int i = 0; i < founditems.size(); i++) {
								if (founditems[i].first == world_->blocks[i_].fg) {
									founditems[i].second++;
									copy_fg = false;
								}
							}
							if (copy_fg) founditems.push_back(make_pair(world_->blocks[i_].fg, 1));
						}

						if (world_->blocks[i_].bg != 0) {
							bool copy_bg = true;
							for (int i = 0; i < founditems.size(); i++) {
								if (founditems[i].first == world_->blocks[i_].bg) {
									founditems[i].second++;
									copy_bg = false;
								}
							}
							if (copy_bg) founditems.push_back(make_pair(world_->blocks[i_].bg, 1));
						}
					}
				}
				else if (type == "3") {
					if (to_lower(items[world_->blocks[i_].fg].name).find(to_lower(search)) != string::npos || to_lower(items[world_->blocks[i_].bg].name).find(to_lower(search)) != string::npos) {
						if (world_->blocks[i_].bg != 0) {
							bool copy_bg = true;
							for (int i = 0; i < founditems.size(); i++) {
								if (founditems[i].first == world_->blocks[i_].bg) {
									founditems[i].second++;
									copy_bg = false;
								}
							}
							if (copy_bg) founditems.push_back(make_pair(world_->blocks[i_].bg, 1));
						}
					}
				}
				else if (type == "4") {
					if (to_lower(items[world_->blocks[i_].fg].name).find(to_lower(search)) != string::npos || to_lower(items[world_->blocks[i_].bg].name).find(to_lower(search)) != string::npos) {
						if (world_->blocks[i_].fg != 0 && items[world_->blocks[i_].fg].untradeable == 1 or world_->blocks[i_].bg != 0 && items[world_->blocks[i_].bg].untradeable == 1) {
							if (world_->blocks[i_].fg != 0) {
								bool copy_fg = true;
								for (int i = 0; i < founditems.size(); i++) {
									if (founditems[i].first == world_->blocks[i_].fg) {
										founditems[i].second++;
										copy_fg = false;
									}
								}
								if (copy_fg) founditems.push_back(make_pair(world_->blocks[i_].fg, 1));
							}

							if (world_->blocks[i_].bg != 0) {
								bool copy_bg = true;
								for (int i = 0; i < founditems.size(); i++) {
									if (founditems[i].first == world_->blocks[i_].bg) {
										founditems[i].second++;
										copy_bg = false;
									}
								}
								if (copy_bg) founditems.push_back(make_pair(world_->blocks[i_].bg, 1));
							}
						}
					}
				}
			}
		}
		for (int i = 0; i < founditems.size(); i++) found_list += to_string(founditems[i].first) + "," + to_string(founditems[i].second) + ",";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	if (search == "start") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_label|small|`wThis world contains|left\nadd_textbox|`wBlocks: " + to_string(total_block) + "``|\nadd_textbox|`wBackgrounds: " + to_string(total_background) + "``|\nadd_textbox|`wUntradeable blocks: " + to_string(total_untradeable) + "``|left|\nadd_textbox|`wSuper rare items: " + to_string(total_super_rare_item) + "|left|\nadd_textbox|`wTotal block rarity: " + to_string(total_rarity) + "``|left|\nadd_label_with_icon|small|`wFire: " + to_string(total_fire) + "|left|6020|\nadd_label_with_icon|small|`wWater: " + to_string(total_water) + "|left|6024|\nadd_label_with_icon|small|`wEarth: " + to_string(total_earth) + "|left|6018|\nadd_label_with_icon|small|`wAir: " + to_string(total_air) + "|left|6022|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|search_1|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|search_2|Search Blocks|noflags|0|0|\nadd_button|search_3|Search Backgrounds|noflags|0|0|\nadd_button|search_4|Search Untradeable|noflags|0|0|\nadd_spacer|small|\nadd_button|back_to_gscan|Back|noflags|0|0|\nend_dialog|statsblockworld|||\n");
	else {
		if (found_list == "") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No results found.|left|\nadd_spacer|small|\nadd_button|worldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
		else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_button|worldBlocks|Back|noflags|0|0|\nadd_spacer|small|\nadd_quick_exit|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + found_list + "\nadd_spacer|small|\nadd_button|worldBlocks|Back|noflags|0|0|\nend_dialog|statsblockworld|||\n");
	}
	p.CreatePacket(peer);
}

void cant_enter(ENetPeer* peer, string text, bool door, int delay) {
	gamepacket_t p2(delay);
	if (door) {
		gamepacket_t p(delay, pInfo(peer)->netID), p3(delay), p4(delay, pInfo(peer)->netID);
		p.Insert("OnSetFreezeState"), p.Insert(1), p.CreatePacket(peer);
		p3.Insert("OnZoomCamera"), p3.Insert((float)10000.000000), p3.Insert(1000), p3.CreatePacket(peer);
		p4.Insert("OnSetFreezeState"), p4.Insert(0), p4.CreatePacket(peer);
	}
	else {
		gamepacket_t p2;
		p2.Insert("OnFailedToEnterWorld"), p2.CreatePacket(peer);
	}
	p2.Insert("OnConsoleMessage"), p2.Insert(text), p2.CreatePacket(peer);
	pInfo(peer)->cancel_enter = true;
	return;
}

string get_name_by_uid(int uid) {
	string name = "";
	ifstream read("database/uids.json");
	if (read.is_open()) {
		json j;
		read >> j;
		if (j.find("uids") == j.end())
			return "";
		vector<pair<string, int>> uids = j.at("uids").get<vector<pair<string, int>>>();
		for (int i = 0; i < uids.size(); i++) {
			if (uids.at(i).second == uid)
				name = uids.at(i).first;
		}
		read.close();
	}
	return name;
}

int get_uid_by_name(string name) {
	int uid = 0;
	ifstream read("database/uids.json");
	if (read.is_open()) {
		json j;
		read >> j;
		if (j.find("uids") == j.end())
			return -1;
		vector<pair<string, int>> uids = j.at("uids").get<vector<pair<string, int>>>();
		for (int i = 0; i < uids.size(); i++) {
			if (uids.at(i).first == name)
				uid = uids.at(i).second;
		}
		read.close();
	}
	return uid;
}

void get_uid_by_name(string name, int& uid) {
	string path_ = "database/players/" + name + "_.json";
	ifstream read(path_.c_str(), ifstream::binary);
	if (read.is_open()) {
		json j;
		read >> j;
		uid = j["userID"].get<int>();
		read.close();
	}
}

void write_uid_data(Player* p_) {
	string name = "";
	vector<pair<string, int>> uids;
	ifstream read("database/uids.json");
	if (read.is_open()) {
		json j;
		read >> j;
		if (j.find("uids") == j.end())
			return;

		uids = j.at("uids").get<vector<pair<string, int>>>();
		read.close();
	}
	for (int i = 0; i < uids.size(); i++) {
		if (uids.at(i).second == p_->id || uids.at(i).first == p_->tankIDName)
		{
			uids.at(i).first = p_->tankIDName;
			uids.at(i).second = p_->id;
		}
		else {
			uids.push_back(make_pair(p_->tankIDName, p_->id));
		}
	}
	ofstream w_("database/uids.json");
	json j;
	j["uids"] = uids;
	w_ << j << endl;
	w_.close();
}

void write_uid_data(int uid, string name_) {
	vector<pair<string, int>> uids;
	ifstream read("database/uids.json");
	if (read.is_open()) {
		json j;
		read >> j;
		if (j.find("uids") == j.end())
			return;

		uids = j.at("uids").get<vector<pair<string, int>>>();
		read.close();
	}
	for (int i = 0; i < uids.size(); i++) {
		if (uids.at(i).second == uid || uids.at(i).first == name_)
		{
			uids.at(i).first = name_;
			uids.at(i).second = uid;
		}
		else {
			uids.push_back(make_pair(name_, uid));
		}
	}
	ofstream w_("database/uids.json");
	json j;
	j["uids"] = uids;
	w_ << j << endl;
	w_.close();
}
/*
bool process_uid(string name, int uid) {
	vector<pair<string, int>> uids;
	vector<string> reg_name;
	vector<int> reg_uid;
	ifstream read("database/uids.json");
	if (read.is_open()) {
		json j;
		read >> j;
		if (j.find("uids") == j.end())
			return false;

		uids = j.at("uids").get<vector<pair<string, int>>>();
		read.close();
	}
	for (int i = 0; i < uids.size(); i++) {
		reg_uid.push_back(uids[i].second);
		reg_name.push_back(uids[i].first);
	}

	return find(reg_uid.begin(), reg_uid.end(), uid) != reg_uid.end() ||
		find(reg_name.begin(), reg_name.end(), name) != reg_name.end();
}

bool process_uid(Player* player) {
	vector<pair<string, int>> uids;
	vector<string> reg_name;
	vector<int> reg_uid;
	ifstream read("database/uids.json");
	if (read.is_open()) {
		json j;
		read >> j;
		if (j.find("uids") == j.end())
			return false;

		uids = j.at("uids").get<vector<pair<string, int>>>();
		read.close();
	}
	for (int i = 0; i < uids.size(); i++) {
		reg_uid.push_back(uids[i].second);
		reg_name.push_back(uids[i].first);
	}

	return find(reg_uid.begin(), reg_uid.end(), player->uid) != reg_uid.end() ||
		find(reg_name.begin(), reg_name.end(), player->tankIDName) != reg_name.end();
}
*/
bool load_affinity(Player* p_) {
	string path_ = "database/affinity/" + to_lower(p_->tankIDName) + "_.json";
	if (_access_s(path_.c_str(), 0) == 0) {
		try {
			ifstream read(path_.c_str(), ifstream::binary);
			if (read.is_open())
			{
				json j;
				read >> j;
				p_->affinity_type = (AffinityType)j["affinity_type"].get<uint8_t>();
				p_->affinity_with = j["affinity_with"].get<int>();
				p_->affinity_level = j["affinity_level"].get<int>();
				read.close();
				return true;
			}
			return false;
		}
		catch (exception& e) {
			cout << e.what() << endl;
			return false;
		}
	}
	return false;
}

void load_affinity(int& uid, AffinityType& type, int& level, int& with) {
	string path_ = "database/affinity/" + to_string(uid) + "_.json";
	if (_access_s(path_.c_str(), 0) == 0) {
		try {
			ifstream read(path_.c_str(), ifstream::binary);
			if (read.is_open())
			{
				json j;
				read >> j;
				type = (AffinityType)j["affinity_type"].get<uint8_t>();
				with = j["affinity_with"].get<int>();
				level = j["affinity_level"].get<int>();
				read.close();
			}
		}
		catch (exception& e) {
			cout << e.what() << endl;
			return;
		}
	}
}

void save_affinity(Player* p_) {
	string path_ = "database/affinity/" + to_string(p_->uid) + "_.json";
	if (p_->affinity_level >= 1 && p_->affinity_type != 0 && p_->affinity_with != 0) {
		try {
			ofstream write(path_.c_str(), ifstream::binary);
			json j;
			j["affinity_type"] = p_->affinity_type;
			j["affinity_with"] = p_->affinity_with;
			j["affinity_level"] = p_->affinity_level;
			write << j << endl;
			write.close();
		}
		catch (exception& e) {
			cout << e.what() << endl;
			return;
		}
	}
}

int aaa = 0;
void join_world(ENetPeer* peer, string& name_, int spawnas_x = 0, int spawnas_y = 0, int delay = 0, bool locked = false, bool door = false) {
	if (pInfo(peer)->tankIDName.empty()) return;
	if (not door) {
		if (pInfo(peer)->world_time + 2000 > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			gamepacket_t p;
			p.Insert("OnFailedToEnterWorld"), p.CreatePacket(peer);
			return;
		}
		pInfo(peer)->world_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
	}
	if (not pInfo(peer)->quest_active and not pInfo(peer)->admin and name_ == "LEGENDARYMOUNTAIN") return cant_enter(peer, "You're not legendary enough for this mountain.", door, delay);
	if (!pInfo(peer)->wolf_world) {
		if (not check_name(name_)) return cant_enter(peer, name_, door, delay);
	}
	if (door == false) {
		pInfo(peer)->adventure_begins = false;
	}
	if (pInfo(peer)->n == 0) name_ = "START";
	if (has_playmod(pInfo(peer), "Go To HELL")) name_ = "HELL";
	World world_ = get_world(name_);
	//int owner_id = 0;
	/////get_uid_by_name(world_.owner_name, owner_id);
	//if (not process_uid(world_.owner_name, owner_id)) 
		//write_uid_data(owner_id, world_.owner_name);

	//world_.owner_name = get_name_by_uid(owner_id);
	if (world_.owner_id == 0) {
		world_.world_id = GlobalStats.totalWorldGenerated;
		GlobalStats.totalWorldGenerated++;
		ifstream in("database/server_statistic.json");
		json infile = json::parse(in);
		infile["totalWorldGenerated"] = GlobalStats.totalWorldGenerated;
		ofstream out("database/server_statistic.json");
		out << setw(4) << infile << endl;
		in.close();
		out.close();
	}
	if (world_.owner_id != 0) world_.owner_name = GetNameByUid(world_.owner_id);
	string owner_name = world_.owner_name, user_name = (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName);
	if (world_.nuked == true && pInfo(peer)->mod + pInfo(peer)->admin < 1) return cant_enter(peer, "That world is inaccessible.", door, delay);
	for (auto p : world_.bannedPlayers) {
		if (p.first == pInfo(peer)->uid) {
			long long int time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			if (p.second + WORLDBAN_TIME > time) return cant_enter(peer, "`4Oh no!`` You've been banned from that world by its owner! Try again later after the world ban wears off.", door, delay);
		}
	}
	for (int i = 0; i < pInfo(peer)->temptransmute.size(); i++) {
		auto temp = explode("|", pInfo(peer)->temptransmute[i]);
		if (name_ != temp[1]) {
			pInfo(peer)->temptransmute.erase(remove(pInfo(peer)->temptransmute.begin(), pInfo(peer)->temptransmute.end(), temp[0] + "|" + temp[1]), pInfo(peer)->temptransmute.end());
		}
	}
	int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
	get_players(world_.name, w_c, s_c, net_, r_c);
	if (w_c >= 66 and not pInfo(peer)->mod) return cant_enter(peer, "Oops, `5" + world_.name + "`` already has `466`` people in it. Try again later.", door, delay);
	if (pInfo(peer)->level < world_.entry_level and world_.owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and not pInfo(peer)->mod) {
		if (!guild_access(peer, world_.guild_id) and find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) == world_.admins.end()) return cant_enter(peer, "Players lower than level " + to_string(world_.entry_level) + " can't enter " + world_.name + ".", door, delay);
	}
	uint32_t ySize = world_.height, xSize = world_.width, square = world_.blocks.size();
	if (ySize <= 0 || xSize <= 0 || square <= 0) {
		gamepacket_t p(delay, pInfo(peer)->netID);
		p.Insert("OnSetFreezeState");
		p.Insert(1);
		p.CreatePacket(peer);
		return;
	}
	if (world_.name == pInfo(peer)->world) {
		gamepacket_t p(delay, pInfo(peer)->netID), p2(delay), p3(delay, pInfo(peer)->netID);
		p.Insert("OnSetFreezeState"), p.Insert(1), p.CreatePacket(peer);
		if (spawnas_x != 0) {
		}
		else if (not locked) {
			for (int i_ = 0; i_ < world_.blocks.size(); i_++) {
				if (items.at(world_.blocks.at(i_).fg).blockType == BlockTypes::MAIN_DOOR) {
					spawnas_x = i_ % xSize, spawnas_y = i_ / xSize;
					pInfo(peer)->c_x = spawnas_x, pInfo(peer)->c_y = spawnas_y;
					gamepacket_t p(delay, pInfo(peer)->netID);
					p.Insert("SetRespawnPos"), p.Insert(i_), p.CreatePacket(peer);
					break;
				}
			}
		}
		else {
			gamepacket_t p(delay);
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("The door is locked."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
		}
		if (not locked) {
			pInfo(peer)->x = spawnas_x * 32, pInfo(peer)->y = spawnas_y * 32;
			gamepacket_t p(delay, pInfo(peer)->netID);
			p.Insert("OnSetPos"), p.Insert(float(spawnas_x) * 32, float(spawnas_y) * 32), p.CreatePacket(peer);
			if (not pInfo(peer)->invis) {
				gamepacket_t p(delay, pInfo(peer)->netID);
				p.Insert("OnPlayPositioned"), p.Insert("audio/door_open.wav"), p.CreatePacket(peer);
			}
		}
		p2.Insert("OnZoomCamera"), p2.Insert((float)10000.000000), p2.Insert(1000), p2.CreatePacket(peer);
		p3.Insert("OnSetFreezeState"), p3.Insert(0), p3.CreatePacket(peer);
		return;
	}
	else if (not pInfo(peer)->world.empty()) exit_(peer, true);
	Algorithm::set_bux(peer);
	if (world_.verified == true) {
		gamepacket_t p; p.Insert("OnAddNotification"), p.Insert("interface/large/playerportal_button.rttex"), p.Insert("This world has a `^Verified`` License"), p.Insert("audio/harp.wav"), p.Insert(0), p.CreatePacket(peer);
	}
	pInfo(peer)->lock = 0;
	pInfo(peer)->world = world_.name;
	int total = 78 + world_.name.length() + world_.blocks.size() + 24 + ((8 * world_.blocks.size()) + (world_.drop.size() * 16));
	int spawn_x = 0, spawn_y = 0;
	//	BYTE* data = (BYTE*)malloc((world_.blocks.size()*2) * sizeof(WorldBlock) + sizeof(World));
	BYTE* data = (BYTE*)malloc(world_.blocks.size() * sizeof(WorldBlock) + (sizeof(World) * 2));
	memset(data, 0, total);
	*(__int8*)(data) = 4;
	*(__int8*)(data + 4) = 4;
	*(__int8*)(data + 16) = 8;
	*(__int8*)(data + 66) = world_.name.length();
	memcpy(data + 68, world_.name.c_str(), world_.name.length());
	*(__int8*)(data + 68 + world_.name.length()) = world_.width;
	*(__int8*)(data + 72 + world_.name.length()) = world_.height;
	*(__int16*)(data + 76 + world_.name.length()) = world_.blocks.size();
	BYTE* blc = data + 80 + world_.name.length();
	if (pInfo(peer)->game_temp >= 4.31) blc += 5;
	world_.active_jammers.clear();
	vector<string> world_mods;
	vector<vector<unsigned int>> world_locks, world_seeds, world_crystals;
	for (int i_ = 0; i_ < world_.height * world_.width; i_++) {
		/*
		if (find(blocks.begin(), blocks.end(), world_.blocks[i_].fg) == blocks.end()) {
			blocks.push_back(world_.blocks[i_].fg);
				cout << world_.blocks[i_].fg << endl;
		}*/
		//	if (world_.blocks[i_].fg == 6950 || world_.blocks[i_].fg == 6952 || world_.blocks[i_].fg == 6954)  world_.blocks[i_].fg = 2;
		*(__int16*)(blc) = world_.blocks[i_].fg;
		*(__int16*)(blc + 2) = world_.blocks[i_].bg;
		*(__int32*)(blc + 4) = world_.blocks[i_].flags;
		if (world_.blocks.at(i_).fg == 12358 && world_.blocks.at(i_).flags & 0x00400000) {
			WorldBlock* sfx_pos = &world_.blocks[i_ - 1];
			if ((items[sfx_pos->fg].actionType == 12 or items[world_.blocks.at(i_).fg].actionType == 122) && sfx_pos->flags & 0x00400000) {
				packet_(peer, format("action|play_music\nfile|{}\ndelayMS|0", items[sfx_pos->fg].extraFile));
				packet_(peer, format("action|play_sfx\nfile|{}\ndelayMS|0", items[sfx_pos->fg].extraFile));
			}
		}
		if (world_.verified)
			if (find(world_mods.begin(), world_mods.end(), "`cVERIFIED``") == world_mods.end()) 
				world_mods.push_back("`cVERIFIED``");
		if (!world_.allow_noclip and world_.blocks.at(i_).fg == 8470 || (world_.blocks.at(i_).flags & 0x00400000 &&
			(world_.blocks.at(i_).fg == 226 || world_.blocks.at(i_).fg == 1276 || world_.blocks.at(i_).fg == 1278 ||
				world_.blocks.at(i_).fg == 3616 || world_.blocks.at(i_).fg == 4758 || world_.blocks.at(i_).fg == 4884 ||
				world_.blocks.at(i_).fg == 4992))) world_mods.push_back("`" + a +
					(world_.blocks.at(i_).fg == 226 ? "4JAMMED" : (world_.blocks.at(i_).fg == 1276 ? "2NOPUNCH" : 
						(world_.blocks.at(i_).fg == 1278 ? "2IMMUNE" : (world_.blocks.at(i_).fg == 4884 ? "2NOWAR" : 
							(world_.blocks.at(i_).fg == 3616 ? "2NOCONSUME" :
								(world_.blocks.at(i_).fg == 4992 ? "2ANTIGRAVITY" : 
									!world_.allow_noclip and world_.blocks.at(i_).fg == 8470 ? "2NOGHOST" : "2NODROP")))))) + "``"),
			world_.active_jammers.push_back(world_.blocks.at(i_).fg);
		if (world_.blocks[i_].fg == 5638 || world_.blocks[i_].fg == 6948 || world_.blocks[i_].fg == 6946) {
			*(__int8*)(blc + 8) = 62;
			*(__int16*)(blc + 9) = world_.blocks[i_].id;
			*(__int16*)(blc + 13) = world_.blocks[i_].pr;
			*(__int8*)(blc + 17) = world_.blocks[i_].enabled;
			if (world_.blocks[i_].fg == 5638)*(__int16*)(blc + 18) = world_.blocks[i_].magnetron;
			*(__int16*)(blc + 20) = (world_.blocks[i_].fg == 5638 ? (get_mag_size(world_.blocks.at(i_).fg)) : (get_mag_size(world_.blocks.at(i_).fg)));
			blc += 15;
			total += 15;
		}
		else if (items[world_.blocks[i_].fg].actionType == -115 || world_.blocks[i_].fg == 3760) {
			*(__int8*)(blc + 8) = 6;
			blc += 8;
			total += 8;
		}
		else if (world_.blocks[i_].fg == 6950 || world_.blocks[i_].fg == 6952 || world_.blocks[i_].fg == 6954) {
			*(__int8*)(blc + 8) = world_.blocks[i_].fg == 6950 ? 70 : 69;
			*(__int8*)(blc + 9) = world_.blocks[i_].pr > 0 ? 1 : 0;
			*(__int16*)(blc + 13) = world_.blocks[i_].pr;
			*(__int16*)(blc + 17) = world_.blocks[i_].id;
			*(__int8*)(blc + 21) = world_.blocks[i_].enabled;
			blc += 13;
			total += 13;
		}
		else if (items[world_.blocks[i_].fg].easel) {
			*(__int8*)(blc + 8) = 35;
			*(__int16*)(blc + 9) = world_.blocks[i_].id;
			*(__int16*)(blc + 13) = world_.blocks[i_].txt.size();
			memcpy(blc + 15, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
			blc += 7 + world_.blocks[i_].txt.size();
			total += 7 + world_.blocks[i_].txt.size();
		}
		else if (items[world_.blocks[i_].fg].audio_rack) {
			*(__int8*)(blc + 8) = 56; // tileextra_type_audio_rack
			*(__int16*)(blc + 9) = world_.blocks[i_].audio_notes.size();
			memcpy(blc + 11, world_.blocks[i_].audio_notes.c_str(), world_.blocks[i_].audio_notes.size());
			*(__int16*)(blc + 11 + world_.blocks[i_].audio_notes.size()) = world_.blocks[i_].audio_volume;
			blc += 7 + world_.blocks[i_].audio_notes.size();
			total += 7 + world_.blocks[i_].audio_notes.size(); // end marker i believe
		}
		else if (world_.blocks[i_].fg == 1660) {
			*(__int8*)(blc + 8) = TILEEXTRA_TYPE_GAME_GENERATOR;
			/*
			*(__int16*)(blc + 9) = world_.blocks[i_].game_label.size();
			memcpy(blc + 11, world_.blocks[i_].game_label.c_str(), world_.blocks[i_].game_label.size());
			*(__int8*)(blc + 11 + world_.blocks[i_].game_label.size()) = world_.blocks[i_].teams.size();
			*(__int32*)(blc + 12 + world_.blocks[i_].game_label.size()) = world_.blocks[i_].game_time;

			blc += 7 + world_.blocks[i_].game_label.size();
			total += 7 + world_.blocks[i_].game_label.size();
			*/
			blc += 17;
			total += 17;
		}
		else if (items[world_.blocks[i_].fg].bunny_egg) {
			*(__int8*)(blc + 8) = 15;
			*(__int16*)(blc + 9) = world_.blocks[i_].bunny_egg_progress;
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].kranken) {
			int model_ = world_.blocks[i_].kranken_pattern;
			int rgb = (world_.blocks[i_].b << 24) | (world_.blocks[i_].g << 16) | (world_.blocks[i_].r << 8);
			int w_ = rgb + 255;
			BYTE btype = 0x50;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &model_, 4);
			memcpy(blc + 13, &w_, 4);
			blc += 9;
			total += 9;
		}
		else if (items[world_.blocks[i_].fg].dshelf) {
			*(__int8*)(blc + 8) = 43;
			*(__int16*)(blc + 9) = world_.blocks[i_].shelf_1;
			*(__int16*)(blc + 13) = world_.blocks[i_].shelf_2;
			*(__int16*)(blc + 17) = world_.blocks[i_].shelf_3;
			*(__int16*)(blc + 21) = world_.blocks[i_].shelf_4;
			blc += 17;
			total += 17;
		}
		else if (items[world_.blocks[i_].fg].fish_port) {
			*(__int8*)(blc + 8) = 63;
			blc += 1 + 4 + 8;
			total += 1 + 4 + 8;
		}
		else if (items[world_.blocks[i_].fg].timer) {
			*(__int8*)(blc + 8) = 45;
			blc += 1;
			total += 1;
		}
		else if (items[world_.blocks[i_].fg].heart_monitor) {
			*(__int8*)(blc + 8) = 11;
			{
				bool ijungtas = false;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (fixchar(pInfo(currentPeer)->tankIDName) == fixchar(world_.blocks[i_].heart_monitor)) {
						ijungtas = 1;
						break;
					}
				}
				/*
				GlobalMonitors new_monitor;
				new_monitor.active = ijungtas;
				new_monitor.world_name = world_.name;
				new_monitor.x = i_ % 100;
				new_monitor.y = i_ / 100;
				monitors.push_back(new_monitor);*/
				if (ijungtas)*(int*)(blc + 4) = world_.blocks[i_].flags | 0x00400000;
				*(int*)(blc + 9) = ijungtas;
			}
			*(int*)(blc + 13) = world_.blocks[i_].heart_monitor.size();
			memcpy(blc + 15, world_.blocks[i_].heart_monitor.c_str(), world_.blocks[i_].heart_monitor.size());
			blc += 7 + world_.blocks[i_].heart_monitor.size();
			total += 7 + world_.blocks[i_].heart_monitor.size();
		}
		else if (items[world_.blocks[i_].fg].xeno) {
			*(__int8*)(blc + 8) = 53;
			blc += 9;
			total += 9;
		}
		else if (items[world_.blocks[i_].fg].trickster) {
			*(__int8*)(blc + 8) = 52;
			blc += 1;
			total += 1;
		}
		else if (items[world_.blocks[i_].fg].charger) {
			*(int*)(blc + 4) = (world_.blocks[i_].id != 0 ? 0x00400000 : world_.blocks[i_].flags);
			*(__int8*)(blc + 8) = 57;
			*(__int16*)(blc + 9) = (world_.blocks[i_].planted - time(nullptr) <= 0 ? 3600 : 3600 - (world_.blocks[i_].planted - time(nullptr)));
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].fossil_prep) {
			*(int*)(blc + 4) = (world_.blocks[i_].id != 0 ? 0x00400000 : world_.blocks[i_].flags);
			*(__int8*)(blc + 8) = 50;
			//*(__int16*)(blc + 9) = (world_.blocks[i_].planted - time(nullptr) <= 0 ? 5400 : 5400 - (world_.blocks[i_].planted - time(nullptr)));
			*(__int16*)(blc + 9) = (world_.blocks[i_].planted - time(nullptr) <= 0 ? 3600 : 3600 - (world_.blocks[i_].planted - time(nullptr)));
			blc += 5; // continue later
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].spirit) {
			*(__int8*)(blc + 8) = 41;
			*(__int16*)(blc + 9) = world_.blocks[i_].c_;
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].trans) {
			*(__int8*)(blc + 8) = 19;
			blc += 19;
			total += 19;
		}
		else if (items[world_.blocks[i_].fg].dnaproc) {
			*(__int8*)(blc + 8) = 19;
			blc += 19;
			total += 19;
		}
		else if (items[world_.blocks[i_].fg].mannequin) {
			*(__int8*)(blc + 8) = 14;
			*(__int16*)(blc + 9) = world_.blocks[i_].txt.size();
			memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
			*(__int16*)(blc + 16 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_hair;
			*(__int16*)(blc + 18 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_shirt;
			*(__int16*)(blc + 20 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_pants;
			*(__int16*)(blc + 22 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_feet;
			*(__int16*)(blc + 24 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_head;
			*(__int16*)(blc + 26 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_hand;
			*(__int16*)(blc + 28 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_back;
			*(__int16*)(blc + 30 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_mask;
			*(__int16*)(blc + 32 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_neck;
			blc += 26 + world_.blocks[i_].txt.size();
			total += 26 + world_.blocks[i_].txt.size();
		}
		else if (items[world_.blocks[i_].fg].vipentrance) {
			*(__int8*)(blc + 8) = 44;
			vector<int> vip_members;
			if (world_.blocks[i_].limit_admins or find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), pInfo(peer)->uid) != world_.blocks[i_].admins.end() or pInfo(peer)->tankIDName == world_.owner_name or world_.owner_name.empty()) vip_members.push_back(pInfo(peer)->id);
			*(__int16*)(blc + 14) = vip_members.size();
			for (int i = 0; i < vip_members.size(); i++) *(__int32*)(blc + 18 + (i * 4)) = vip_members[i];
			blc += 10 + (vip_members.size() * 4);
			total += 10 + (vip_members.size() * 4);
		}
		else if (items[world_.blocks[i_].fg].infinitymachine) {
			*(__int8*)(blc + 8) = 19;
			blc += 19;
			total += 19;
		}
		else if (items[world_.blocks[i_].fg].portrait) {
			*(__int8*)(blc + 8) = 48;
			*(__int16*)(blc + 9) = world_.blocks[i_].txt.size();
			memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
			if (world_.blocks[i_].portrait.c_skin == 0 and world_.blocks[i_].portrait.c_face == 0 and world_.blocks[i_].portrait.c_head == 0 and world_.blocks[i_].portrait.c_hair == 0) {
			}
			else {
				*(int*)(blc + 11 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_expression;
				*(int*)(blc + 19 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_hair_colour;
				*(int*)(blc + 23 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_skin;
				*(int*)(blc + 27 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_face;
				*(int*)(blc + 29 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_head;
				*(int*)(blc + 31 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_hair;
			}
			blc += 7 + 15 + 3 + world_.blocks[i_].txt.size();
			total += 7 + 15 + 3 + world_.blocks[i_].txt.size();
		}
		else if (items[world_.blocks[i_].fg].vall_mount/*|| world_.blocks[i_].fg == 6950 || world_.blocks[i_].fg == 6952 || world_.blocks[i_].fg == 6954*/) {
			*(__int8*)(blc + 8) = 47;
			*(__int8*)(blc + 9) = 0;
			blc += 8;
			total += 8;
		}
		else if (items[world_.blocks[i_].fg].bulletin_board or items[world_.blocks[i_].fg].storage_box or items[world_.blocks[i_].fg].growscan or items[world_.blocks[i_].fg].security_camera or items[world_.blocks[i_].fg].spotlight or world_.blocks[i_].fg == 4722) {
			*(__int8*)(blc + 8) = 6;
			blc += 8;
			total += 8;
		}
		else if (world_.blocks[i_].fossil) {
			*(__int32*)(blc + 4) = world_.blocks[i_].flags;
			*(__int8*)(blc + 8) = 12;
			//blc += 0;
			//total += 0;
		}
		else {
			switch (items[world_.blocks[i_].fg].blockType) {
			case BlockTypes::WEATHER:
			{
				switch (world_.blocks[i_].fg) {
				case 3694: case 5000:
				{
					*(__int8*)(blc + 8) = 40;
					*(__int32*)(blc + 9) = (world_.blocks[i_].fg == 3694 ? (world_.blocks[i_].b << 24) | (world_.blocks[i_].g << 16) | (world_.blocks[i_].r << 8) : world_.blocks[i_].id != 0 ? world_.blocks[i_].id : 14);
					blc += 5;
					total += 5;
					break;
				}
				case 3832: case 5958:
				{
					*(__int8*)(blc + 8) = 49;
					*(__int16*)(blc + 9) = (world_.blocks[i_].id != 0 ? world_.blocks[i_].id : 2);
					*(__int16*)(blc + 13) = (world_.blocks[i_].fg == 5958 ? world_.blocks[i_].epoch_minute : world_.blocks[i_].gravity);
					*(__int16*)(blc + 17) = (int)world_.blocks[i_].spin | ((int)world_.blocks[i_].invert << 1);
					blc += 10;
					total += 10;
					break;
				}
				default:
				{
					if (items[world_.blocks[i_].fg].ext_weather) {
						*(__int8*)(blc + 8) = 5;
						blc += 1;
						total += 1;
					}
					break;
				}
				}
				break;
			}
			case BlockTypes::CRYSTAL:
			{
				*(__int8*)(blc + 8) = 6;
				blc += 8;
				total += 8;
				break;
			}
			case BlockTypes::VENDING:
			{
				*(int*)(blc + 9) = (world_.blocks[i_].pr < 0 and world_.blocks[i_].id != 0 && world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1) ? 0 : world_.blocks[i_].id);
				*(__int8*)(blc + 8) = 24;
				*(int*)(blc + 4) = (world_.blocks[i_].pr < 0 and world_.blocks[i_].id != 0 && world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1) ? world_.blocks[i_].flags | ((world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1)) ? (world_.blocks[i_].wl != 0 ? 0x02410000 : 0x00410000) : (world_.blocks[i_].wl != 0 ? 0x02410000 : 0x00410000)) : world_.blocks[i_].flags | (world_.blocks[i_].id == 0 ? (world_.blocks[i_].wl != 0 ? 0x02000000 : 0x00000000) : (world_.blocks[i_].wl != 0 ? 0x02410000 : 0x00410000)));
				*(int*)(blc + 13) = (world_.blocks[i_].pr < 0 and world_.blocks[i_].id != 0 && world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1) ? 0 : world_.blocks[i_].pr);
				blc += 9;
				total += 9;
				break;
			}
			case BlockTypes::DISPLAY:
			{
				*(__int8*)(blc + 8) = 23;
				*(__int16*)(blc + 9) = world_.blocks[i_].id;
				blc += 5;
				total += 5;
				break;
			}
			case BlockTypes::PROVIDER:
			{
				*(__int8*)(blc + 8) = 9;
				*(__int32*)(blc + 9) = (time(nullptr) - world_.blocks[i_].planted <= items[world_.blocks[i_].fg].growTime ? time(nullptr) - world_.blocks[i_].planted : items[world_.blocks[i_].fg].growTime);
				blc += 5;
				total += 5;
				break;
			}
			case BlockTypes::RANDOM_BLOCK:
			{
				*(__int8*)(blc + 8) = 8;
				*(__int32*)(blc + 9) = world_.blocks[i_].roll;
				blc += 2;
				total += 2;
				break;
			}
			case BlockTypes::LOCK:
			{
				if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994) world_locks.push_back({ i_ % xSize, i_ / xSize });
				else pInfo(peer)->lock = world_.blocks[i_].fg;
				if (world_.blocks[i_].open_to_public) {
					*(int*)(blc + 4) = 0x00800000;
				}
				*(__int8*)(blc + 8) = 3;
				bool bl_ab = false;
				if (world_.blocks[i_].fg == 4994 and world_.blocks[i_].build_only) {
					bl_ab = true;
				}
				uint8_t world_settings = world_.disable_music_blocks ? (world_.make_music_blocks_invisible ? 12345 : 1234) : (world_.make_music_blocks_invisible ? 100 : 0);
				if (world_.rainbows and world_.blocks[i_].fg == 4802) world_settings += 128;
				if (bl_ab) *(__int16*)(blc + 9) = 100 + world_settings;
				else *(__int16*)(blc + 9) = world_settings;
				*(int*)(blc + 10) = (world_.blocks[i_].owner_id == pInfo(peer)->uid || world_.owner_name == pInfo(peer)->tankIDName ? pInfo(peer)->id : -1);
				*(__int16*)(blc + 18) = world_.music_bpm * -1;
				bool access = false;
				uint16_t count_of_admins = 1;
				{
					if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994) if (find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), pInfo(peer)->uid) != world_.blocks[i_].admins.end()) access = true;
					if (world_.blocks[i_].fg == 5814) if (guild_access(peer, world_.guild_id)) access = true;
					if (world_.owner_name != "") if (find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) != world_.admins.end()) access = true;
					if (access) *(int*)(blc + 22) = pInfo(peer)->id, count_of_admins++;
				}
				*(__int8*)(blc + 14) = count_of_admins;
				if (world_.blocks[i_].fg == 5814 and world_.guild_id != 0) {
					uint32_t guild_id = world_.guild_id;
					vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
					if (p != guilds.end()) {
						Guild* guild_information = &guilds[p - guilds.begin()];
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 4, &guild_information->guild_mascot[0], 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 6, &guild_information->guild_mascot[1], 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 8, &guild_information->guild_level, 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 12, &guild_information->unlocked_mascot, 1);
						blc += 26 + (count_of_admins * 4);
						total += 26 + (count_of_admins * 4);
					}
				}
				else {
					blc += 10 + (count_of_admins * 4);
					total += 10 + (count_of_admins * 4);
				}
				break;
			}
			case BlockTypes::MAIN_DOOR:
			{
				spawn_x = (i_ % xSize) * 32, spawn_y = (i_ / xSize) * 32;
				pInfo(peer)->c_x = spawn_x / 32;
				pInfo(peer)->c_y = spawn_y / 32;
				*(__int8*)(blc + 8) = 1;
				*(__int16*)(blc + 9) = 4;
				memcpy(blc + 11, "EXIT", 4);
				blc += 8;
				total += 8;
				break;
			}
			case BlockTypes::SEED:
			{
				*(int*)(blc + 4) = 0 | 0x100000;
				*(__int8*)(blc + 8) = 4;
				*(int*)(blc + 9) = (time(nullptr) - world_.blocks[i_].planted <= items.at(world_.blocks[i_].fg).growTime ? time(nullptr) - world_.blocks[i_].planted : items.at(world_.blocks[i_].fg).growTime);
				*(__int16*)(blc + 13) = world_.blocks[i_].fruit;

				blc += 6;
				total += 6;
				break;
			}
			case BlockTypes::DONATION:case BlockTypes::MAILBOX:
			{
				*(__int32*)(blc + 4) = world_.blocks[i_].flags;
				*(__int8*)(blc + 8) = 12;
				blc += 8;
				total += 8;
				break;
			}
			case BlockTypes::DOOR: case BlockTypes::PORTAL:
			{
				string duru_tekstas = (world_.blocks[i_].txt.empty() ? (world_.blocks[i_].door_destination.empty() ? "" : (world_.blocks[i_].door_destination.find(":") != string::npos ? explode(":", world_.blocks[i_].door_destination)[0] + "..." : world_.blocks[i_].door_destination)) : world_.blocks[i_].txt);
				*(__int8*)(blc + 8) = 1;
				*(__int16*)(blc + 9) = duru_tekstas.size();
				memcpy(blc + 11, duru_tekstas.c_str(), duru_tekstas.size());
				*(__int8*)(blc + 11 + duru_tekstas.size()) = (world_.blocks[i_].open ? 0 : 0x08);
				blc += 4 + duru_tekstas.size();
				total += 4 + duru_tekstas.size();
				break;
			}
			case BlockTypes::SIGN:
			{
				*(__int8*)(blc + 8) = 2;
				*(int*)(blc + 9) = world_.blocks[i_].txt.size();
				memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
				*(__int16*)(blc + 11 + world_.blocks[i_].txt.size()) = 0;
				blc += 7 + world_.blocks[i_].txt.size();
				total += 7 + world_.blocks[i_].txt.size();
				break;
			}
			}
		}
		blc += 8;
	}
	if (pInfo(peer)->game_temp >= 4.31) blc += 12;
	*(int*)(blc) = world_.drop.size();
	*(int*)(blc + 4) = world_.drop.size();
	blc += 8;
	for (int i_ = 0; i_ < world_.drop.size(); i_++) {
		if (world_.drop[i_].id <= 1) continue;
		*(__int16*)(blc) = world_.drop[i_].id;
		if (world_.drop[i_].x == -1 or world_.drop[i_].y == -1) continue;
		*(float*)(blc + 2) = world_.drop[i_].x;
		*(float*)(blc + 6) = world_.drop[i_].y;
		*(__int16*)(blc + 10) = world_.drop[i_].count;
		*(int*)(blc + 12) = world_.drop[i_].uid;
		blc += 16;
	}
	enet_peer_send(peer, 0, enet_packet_create(data, total, ENET_PACKET_FLAG_RELIABLE));
	free(data);
	pInfo(peer)->netID = net_;
	if (spawnas_x != 0 or spawnas_y != 0) spawn_x = spawnas_x * 32, spawn_y = spawnas_y * 32;
	pInfo(peer)->name_color = (pInfo(peer)->dev == 1 ? "`6@" : pInfo(peer)->admin == 1 ? "`8@" : pInfo(peer)->supermod == 1 ? "`b@" : (pInfo(peer)->tmod == 1) ? "`#@" : pInfo(peer)->glory ? "`c[GLORY] " : pInfo(peer)->vvip ? "`9[VVIP] " :
		pInfo(peer)->vip ? "`1[VIP] " : (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name :
			pInfo(peer)->tankIDName) == world_.owner_name ? "`2" : 
		(guild_access(peer, world_.guild_id) or 
			find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) != world_.admins.end()) ? "`^" :
		        pInfo(peer)->is_legend and !(guild_access(peer, world_.guild_id) or
					find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) != world_.admins.end() or pInfo(peer)->tankIDName == world_.owner_name) ? "`9" : "`0");
	{
		gamepacket_t p;
		p.Insert("OnMagicCompassTrackingItemIDChanged");
		p.Insert(pInfo(peer)->Magnet_Item);
		p.CreatePacket(peer);
		{
			//gamepacket_t p;
			//p.Insert("OnProgressUISet"), p.Insert(1), p.Insert(3402), p.Insert(pInfo(peer)->booty_broken), p.Insert(100), p.Insert(""), p.Insert(1);
			//p.CreatePacket(peer);
			//gamepacket_t p;
			//p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->pinata_claimed ? 1 : 0), p.Insert(pInfo(peer)->pinata_prize ? 1 : 0), p.CreatePacket(peer);
			//gamepacket_t p;
			//p.Insert("OnProgressUISet"), p.Insert(1), p.Insert(10328), p.Insert(pInfo(peer)->Darking_Sacrifice), p.Insert(15), p.Insert(""), p.Insert(1), p.CreatePacket(peer);
			//{
				//gamepacket_t p;
				//p.Insert("OnProgressUIUpdateValue"); p.Insert(pInfo(peer)->Darking_Sacrifice); p.Insert(0); p.CreatePacket(peer);
			//}
		}
	}
	
	gamepacket_t p;
	p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
	if (pInfo(peer)->supp >= 2) {
		p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
	}
	p.CreatePacket(peer);
	{
		for (int i = 0; i < top_honors.size(); i++) if (top_honors[i].second == world_.name) world_.honors = top_honors[i].first;
		string nuked = "";
		if (world_.nuked == true) nuked = "`0[NUKED: " + world_.n_b + "," + world_.n_t + "]`` ";
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("" + (pInfo(peer)->mod + pInfo(peer)->admin > 0 ? nuked : "") + "World `w" + world_.name + "`` " + (world_mods.size() != 0 ? "`0[``" + join(world_mods, ", ") + "`0]`` " : "") + "" + (world_.honors == "" and world_.yesterday == 0 ? "" : "(`3Honors:`` " + world_.honors + (world_.yesterday == 0 ? "" : (world_.honors.empty() ? "`5#" + to_string(world_.yesterday) + " yesterday``" : "`0,`` `5#" + to_string(world_.yesterday) + " yesterday``")) + "" + (world_.overall == 0 ? "" : world_.honors.empty() && world_.yesterday == 0 ? "`0#" + to_string(world_.overall) + " overall``" : "`0,`` `0#" + to_string(world_.overall) + " overall``") + ") ") + "entered.  There are `w" + to_string(w_c) + "`` other people here, `w" + setGems(s_c) + "`` online.");
		p.CreatePacket(peer);
	}
	{
		gamepacket_t p;
		p.Insert("OnSetCurrentWeather");
		if (world_.weather == 0 || world_.weather == 80 && world_.d_weather != 0) p.Insert(world_.d_weather);
		else p.Insert(world_.weather == 0 ? 80 : world_.weather);
		p.CreatePacket(peer);
	}
	{
		string s_ = "spawn|avatar\nnetID|" + to_string(net_) + "\nuserID|" + to_string(pInfo(peer)->id) + "\ncolrect|0|0|20|30\nposXY|" + to_string(spawn_x) + "|" + to_string(spawn_y) + "\nname|" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + (pInfo(peer)->tankIDName.empty() ? pInfo(peer)->requestedName : pInfo(peer)->tankIDName)) + (is_reseller(peer) and not pInfo(peer)->hide_reseller ? " `b[Atomic ĭ]``" : "") + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "``\ncountry|" + pInfo(peer)->country + "\ninvis|" + (pInfo(peer)->invis ? "1" : "0") + "\nmstate|" + (pInfo(peer)->mod or pInfo(peer)->admin ? "1" : "0") + "\nsmstate|" + (pInfo(peer)->admin ? "1" : "0") + "\nonlineID|";
		gamepacket_t p;
		p.Insert("OnSpawn"), p.Insert(s_);
		{
			gamepacket_t p;
			p.Insert("OnSpawn"), p.Insert(s_ + "\ntype|local"), p.CreatePacket(peer);
		}
		gamepacket_t p57, p58;
		p57.Insert("OnTalkBubble"), p57.Insert(pInfo(peer)->netID), p57.Insert("`5<" + (not pInfo(peer)->d_name.empty() ? "`w" + pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + " ``entered, `w" + to_string(w_c) + "`` others here>``"), p57.Insert(1);
		p58.Insert("OnConsoleMessage"), p58.Insert("`5<" + (not pInfo(peer)->d_name.empty() ? "`w" + pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + " ``entered, `w" + to_string(w_c) + "`` others here>``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_ or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName) continue;
			p.CreatePacket(currentPeer);
			if (not pInfo(currentPeer)->Cheat_HideOther and pInfo(currentPeer)->netID != pInfo(peer)->netID) {
				user_name = (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->tankIDName);
				gamepacket_t p;
				p.Insert("OnSpawn"), p.Insert("spawn|avatar\nnetID|" + to_string(pInfo(currentPeer)->netID) + "\nuserID|" + to_string(pInfo(currentPeer)->id) + "\ncolrect|0|0|20|30\nposXY|" + to_string(pInfo(currentPeer)->x) + "|" + to_string(pInfo(currentPeer)->y) + "\nname|" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + (pInfo(currentPeer)->tankIDName.empty() ? pInfo(currentPeer)->requestedName : pInfo(currentPeer)->tankIDName)) + (pInfo(currentPeer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``\ncountry|" + pInfo(currentPeer)->country + "\ninvis|" + (pInfo(currentPeer)->invis ? "1" : "0") + "\nmstate|" + (pInfo(currentPeer)->mod or pInfo(currentPeer)->admin ? "1" : "0") + "\nsmstate|" + (pInfo(currentPeer)->admin ? "1" : "0") + "\nonlineID|"), p.CreatePacket(peer);
				if (w_c <= 14 && w_c >= 1 && pInfo(peer)->invis == false) p57.CreatePacket(currentPeer), p58.CreatePacket(currentPeer);
			}
		}
	}
	/*send world info if any*/
	if (not world_.owner_name.empty()) {
		if (world_.owner_named == "" && pInfo(peer)->tankIDName == world_.owner_name && world_.owner_named != pInfo(peer)->tankIDName) {
			world_.owner_named = "`o" + pInfo(peer)->tankIDName;
			if (HasRole(pInfo(peer))) world_.owner_named = (pInfo(peer)->dev == 1 ? "`6@" : pInfo(peer)->admin == 1 ? "`8@" : pInfo(peer)->supermod == 1 ? "`b@" : (pInfo(peer)->tmod == 1) ? "`#@" :
				pInfo(peer)->glory == 1 ? "`c[GLORY] " : pInfo(peer)->vvip == 1 ? "`9[VVIP] " : pInfo(peer)->vip == 1 ? "`1[VIP] " : "`0") + pInfo(peer)->tankIDName;
			if (is_reseller(peer) and not pInfo(peer)->hide_reseller) world_.owner_named += " `c[RESELLER]``";
		}
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`5[```w" + world_.name + "`` `$World Locked`` by " + (world_.owner_named == "" ? world_.owner_name : world_.owner_named) + "``" + (world_.owner_name == (pInfo(peer)->tankIDName) or (guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), ( pInfo(peer)->uid)) != world_.admins.end()) ? " (`2ACCESS GRANTED``)" : (world_.open_to_public ? " (`$PUBLIC``)" : "")) + "`5]``");
		p.CreatePacket(peer);
	}
	if (world_.special_event) {
		gamepacket_t p2;
		p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_.special_event_item].event_name + ":`` " + (items[world_.special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_.special_event_item].name + "```o.``" : "`#" + to_string(items[world_.special_event_item].event_total) + " " + items[world_.special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + ""), p2.CreatePacket(peer);
	}
	{
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_pointer_ = &worlds[p - worlds.begin()];
			world_pointer_->owner_named = world_.owner_named;
			world_pointer_->active_jammers = world_.active_jammers;
		}
	}
	if (pInfo(peer)->tankIDName != world_.owner_name and !(find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) != world_.admins.end())) {
		world_.Honor += (float)0.1; world_.Yesterday += (float)0.025;
		world_.Overall += world_.Honor + world_.Yesterday;
	}
	if (!world_.allow_noclip and pInfo(peer)->lock != 8470)
		world_.allow_noclip = true;
	if (pInfo(peer)->tankIDName != world_.owner_name and not pInfo(peer)->dev and world_.allow_noclip and (find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) == world_.admins.end())) {
		pInfo(peer)->ghost = false;
		packet_(peer, "action|log\nmsg|The world owner disabled you to do noclip.");
	}
	for (int i_ = 0; i_ < pInfo(peer)->last_visited_worlds.size(); i_++) {
		if (pInfo(peer)->last_visited_worlds[i_] == world_.name) {
			pInfo(peer)->last_visited_worlds.erase(pInfo(peer)->last_visited_worlds.begin() + i_);
			pInfo(peer)->last_visited_worlds.push_back(world_.name);
		}
		else if (i_ + 1 == pInfo(peer)->last_visited_worlds.size()) {
			if (pInfo(peer)->last_visited_worlds.size() + 1 > 11) {
				pInfo(peer)->last_visited_worlds.erase(pInfo(peer)->last_visited_worlds.begin());
			}
			pInfo(peer)->last_visited_worlds.push_back(world_.name);
		}
	}
	if (pInfo(peer)->last_visited_worlds.size() == 0)
		pInfo(peer)->last_visited_worlds.push_back(world_.name);
	int c_ = 0;
	modify_inventory(peer, 1424, c_);
	if (c_ != 0) {
		c_ *= -1;
		modify_inventory(peer, 1424, c_, false);
	}
	{
		int c_ = 0;
		modify_inventory(peer, 5816, c_);
		if (c_ != 0) {
			c_ *= -1;
			modify_inventory(peer, 5816, c_, false);
		}
	}
	{
		int c_ = 0;
		modify_inventory(peer, 5640, c_);
		if (c_ != 0) {
			c_ *= -1;
			modify_inventory(peer, 5640, c_, false);
			pInfo(peer)->magnetron_id = 0;
			pInfo(peer)->magnetron_x = 0;
			pInfo(peer)->magnetron_y = 0;
		}
	}
	send_inventory(peer);
	if (not pInfo(peer)->invis) packet_(peer, "action|play_sfx\nfile|audio/door_open.wav\ndelayMS|0");
	if (name_ == "START" && pInfo(peer)->n == 0) {
		pInfo(peer)->n = 1;
		gamepacket_t p3(282);
		p3.Insert("OnAddNotification");
		p3.Insert("interface/large/anni_plu.rttex");
		p3.Insert("`wWelcome to `1TayoPs `wstart your journey here!!");
		p3.Insert("");
		p3.CreatePacket(peer);
		packet_(peer, "action|play_sfx\nfile|audio/fight_loop.wav\ndelayMS|2288");
	}
	for (int i_ = 0; i_ < world_.bulletin.size(); i_++) {
		WorldBulletin bulletin = world_.bulletin[i_];
		WorldBlock block_ = world_.blocks[bulletin.x + (bulletin.y * world_.width)];
		if (items[block_.fg].mailbox) {
			PlayerMoving data_{};
			data_.packetType = 5, data_.punchX = bulletin.x, data_.punchY = bulletin.y, data_.characterState = 0x8;
			BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(&world_, &block_));
			BYTE* blc = raw + 56;
			memcpy(blc, &block_.fg, 2);
			memcpy(blc + 2, &block_.bg, 2);
			memcpy(blc + 4, &block_.flags, 4);
			int test_ = (block_.flags | 0x00400000);
			memcpy(blc + 4, &test_, 4);
			BYTE btype = 12;
			memcpy(blc + 8, &btype, 1);
			send_raw(peer, 4, raw, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
			delete[] raw, blc;
		}
	}
	for (int i_ = 0; i_ < world_.machines.size(); i_++) {
		WorldMachines machine_ = world_.machines[i_];
		WorldBlock block_ = world_.blocks[machine_.x + (machine_.y * world_.width)];
		PlayerMoving data_{};
		data_.packetType = 5, data_.punchX = machine_.x, data_.punchY = machine_.y, data_.characterState = 0x8;
		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(&world_, &block_));
		BYTE* blc = raw + 56;
		form_visual(blc, block_, world_, peer, false);
		send_raw(peer, 4, raw, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
		delete[] raw, blc;
	}
	if (world_crystals.size() > 0) {
		for (vector<unsigned int> sk_ : world_crystals) {
			int l_x = sk_[0];
			int l_y = sk_[1];
			WorldBlock* block_s = &world_.blocks[l_x + (l_y * world_.width)];
			punch_tile(peer, l_x, l_y, 0x3, block_s->fg, 0, 0, 1, 1, false);
		}
	}
	if (world_locks.size() > 0) {
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_pointer_ = &worlds[p - worlds.begin()];
			vector<WorldBlock> shadow_copy_2 = world_.blocks;
			for (vector<unsigned int> sk_ : world_locks) {
				int l_x = sk_[0];
				int l_y = sk_[1];
				WorldBlock block_ = world_.blocks[l_x + (l_y * world_.width)];
				//int owner_id = 0;
				//get_uid_by_name(block_.owner_name, owner_id);
				//if (not process_uid(block_.owner_name, owner_id))
					//write_uid_data(owner_id, block_.owner_name);

				//block_.owner_name = get_name_by_uid(owner_id);
				block_.owner_name = GetNameByUid(block_.owner_id);
				block_.owner_named = block_.owner_name;
				world_pointer_->blocks[l_x + (l_y * world_.width)].owner_named = block_.owner_named;
				world_.blocks[l_x + (l_y * world_.width)].owner_named = block_.owner_name;
				vector<vector<int>> locked_tiles_around_lock{};
				vector<int> new_tiles{};
				new_tiles.push_back(l_x + (l_y * world_.width));
				for (int i2 = 0; i2 < new_tiles.size(); i2++) {
					int s_x_ = new_tiles[i2] % world_.width, s_y_ = new_tiles[i2] / world_.width;
					if (s_x_ < (world_.width - 1) and shadow_copy_2[s_x_ + 1 + (s_y_ * world_.width)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * world_.width)].lock_origin == (l_x + (l_y * world_.width))) {
						if (not shadow_copy_2[s_x_ + 1 + (s_y_ * world_.width)].scanned) {
							shadow_copy_2[s_x_ + 1 + (s_y_ * world_.width)].scanned = true;
							new_tiles.push_back(s_x_ + 1 + (s_y_ * world_.width));
							locked_tiles_around_lock.push_back({ s_x_ + 1, s_y_ });
						}
					} if (s_x_ > 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * world_.width)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * world_.width)].lock_origin == (l_x + (l_y * world_.width))) {
						if (not shadow_copy_2[s_x_ - 1 + (s_y_ * world_.width)].scanned) {
							shadow_copy_2[s_x_ - 1 + (s_y_ * world_.width)].scanned = true;
							new_tiles.push_back(s_x_ - 1 + (s_y_ * world_.width));
							locked_tiles_around_lock.push_back({ s_x_ - 1, s_y_ });
						}
					} if (s_y_ < (world_.height - 1) and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_.width)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_.width)].lock_origin == (l_x + (l_y * world_.width))) {
						if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * world_.width)].scanned) {
							shadow_copy_2[s_x_ + ((s_y_ + 1) * world_.width)].scanned = true;
							new_tiles.push_back(s_x_ + ((s_y_ + 1) * world_.width));
							locked_tiles_around_lock.push_back({ s_x_, s_y_ + 1 });
						}
					} if (s_y_ > 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_.width)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_.width)].lock_origin == (l_x + (l_y * world_.width))) {
						if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * world_.width)].scanned) {
							shadow_copy_2[s_x_ + ((s_y_ - 1) * world_.width)].scanned = true;
							new_tiles.push_back(s_x_ + ((s_y_ - 1) * world_.width));
							locked_tiles_around_lock.push_back({ s_x_, s_y_ - 1 });
						}
					}
				}
				if (locked_tiles_around_lock.size() != 0) {
					PlayerMoving data_{};
					data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
					data_.netID = block_.owner_id == pInfo(peer)->uid ? pInfo(peer)->id : -1;
					data_.plantingTree = block_.fg;
					BYTE* raw;
					int alloc = alloc_(&world_, &block_);
					raw = packPlayerMoving(&data_, 112 + (locked_tiles_around_lock.size() * 2) + alloc);
					*(int*)(raw + 8) = locked_tiles_around_lock.size();
					*(__int8*)(raw + 12) = 8;
					BYTE* blc = raw + 56;
					for (int i_ = 0; i_ < locked_tiles_around_lock.size(); i_++) {
						vector<int> update_tiles = locked_tiles_around_lock[i_];
						int x = update_tiles[0];
						int y = update_tiles[1];
						int sq_ = x + (y * world_.width);
						*(int*)(blc + (i_ * 2)) = sq_;
						shadow_copy_2[x + (y * world_.width)].scanned = false;
					}
					send_raw(peer, 4, raw, 112 + (locked_tiles_around_lock.size() * 2) + alloc, ENET_PACKET_FLAG_RELIABLE);
					PlayerMoving data_2{};
					data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
					BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc);
					BYTE* blc2 = raw2 + 56;
					form_visual(blc2, block_, world_, peer, false);
					send_raw(peer, 4, raw2, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw, blc, raw2, blc2;
				}
			}
		}
	}
	Send_Xenonite_Update(peer);
	if (pInfo(peer)->world == "GROWGANOTH" && Halloween) packet_(peer, "action|play_music\nfile|audio/mp3/unspeakable.mp3\ndelayMS|0");
	if (pInfo(peer)->world == "GROWCH" && Winterfest) packet_(peer, "action|play_music\nfile|audio/mp3/tsirhc.mp3\ndelayMS|0");
	if (pInfo(peer)->world == "CARNIVAL" && carnival_open) packet_(peer, "action|play_music\nfile|audio/mp3/funtime.mp3\ndelayMS|0");
	if (pInfo(peer)->invis == false) {
		add_cctv(peer, "entered", "");
	}
	// BLARNEY COUNTDOWN
	if (world_.World_Time != 0) {
		pInfo(peer)->World_Timed = time(nullptr) + (world_.World_Time * 60);
		pInfo(peer)->WorldTimed = true;
	}
	if (world_.Category != "None" and world_.Category != "") {
		gamepacket_t rate(5000);
		rate.Insert("OnConsoleMessage");
		rate.Insert("`9Type /rate to give your opinion of this world!`` `4/rate 1`` if you hate it, `2/rate 5`` if you love it, or anywhere in between. Share your thoughts!");
		rate.CreatePacket(peer);
	}
	if (pInfo(peer)->hair == 7102 && door == false) {
		gamepacket_t p(0, pInfo(peer)->netID);
		p.Insert("OnAction"), p.Insert("/omg"), p.CreatePacket(peer);
	}
}

void warp_to_home_world(ENetPeer* peer) {
	if (pInfo(peer)->home_world.empty()) {
		packet_(peer, "action|log\nmsg|You haven't set a home world yet!");
		gamepacket_t p;
		p.Insert("OnFailedToEnterWorld"), p.CreatePacket(peer);
		return;
	}
	for (pair<string, long long int> p : home_timed) {
		if (p.first == pInfo(peer)->tankIDName) {
			if (p.second + HOME_TIME > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				packet_(peer, "action|log\nmsg|`4Cooldown active`` - You can use `5/home`` in `5" + to_string(((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) - ((((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) / 60) * 60)) + " ``seconds.");
				gamepacket_t p;
				p.Insert("OnFailedToEnterWorld"), p.CreatePacket(peer);
				return;
			}
		}
	}
	home_timed.push_back(make_pair(pInfo(peer)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
	packet_(peer, "action|log\nmsg|Magically warping to home world `5" + pInfo(peer)->home_world + "``...");
	join_world(peer, pInfo(peer)->home_world);
}

void add_curse(ENetPeer* peer, int seconds, string reason, string cursedby, bool wand = false) {
	if (not has_playmod(pInfo(peer), "Curse")) {
		PlayMods give_playmod{};
		give_playmod.id = 78;
		give_playmod.time = time(nullptr) + seconds;
		pInfo(peer)->playmods.push_back(give_playmod);
		pInfo(peer)->m_r = reason;
		update_clothes(peer);
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oYou're on the HIGHWAY TO HELL!! (`$Curse`` mod added, " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " left)");
			p.CreatePacket(peer);
		}
		if (not wand) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`#**`` `$The Ancient Ones`` have `4sent`` " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + "``to `4HELL `#**`` (`4/rules`` to see the rules!)");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				p.CreatePacket(currentPeer);
			}
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oWarning from `4Admin``: You've been `bcursed`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
			p.CreatePacket(peer);
			{
				gamepacket_t p;
				p.Insert("OnAddNotification");
				p.Insert("interface/atomic_button.rttex");
				p.Insert("`wWarning from `4Admin``: You've been `bcursed`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
				p.Insert("audio/hub_open.wav");
				p.Insert(0);
				p.CreatePacket(peer);
			}
		}
		string namewrld = "HELL";
		join_world(peer, namewrld);
	}
}
void summon_to_world(ENetPeer* peer, string& name_, int spawnas_x = 0, int spawnas_y = 0, int delay = 0, bool locked = false, bool door = false) {
	if (pInfo(peer)->tankIDName.empty()) return;
	if (door == false) {
		pInfo(peer)->adventure_begins = false;
	}
	World world_ = get_world(name_);
	string owner_name = world_.owner_name, user_name = (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName);
	int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
	get_players(world_.name, w_c, s_c, net_, r_c);
	uint32_t ySize = world_.height, xSize = world_.width, square = world_.blocks.size();
	if (ySize <= 0 || xSize <= 0 || square <= 0) {
		gamepacket_t p(delay, pInfo(peer)->netID);
		p.Insert("OnSetFreezeState");
		p.Insert(1);
		p.CreatePacket(peer);
		return;
	}
	if (world_.name == pInfo(peer)->world) {
		gamepacket_t p(delay, pInfo(peer)->netID), p2(delay), p3(delay, pInfo(peer)->netID);
		p.Insert("OnSetFreezeState"), p.Insert(1), p.CreatePacket(peer);
		if (spawnas_x != 0) {
		}
		else if (not locked) {
			for (int i_ = 0; i_ < world_.blocks.size(); i_++) {
				if (items.at(world_.blocks.at(i_).fg).blockType == BlockTypes::MAIN_DOOR) {
					spawnas_x = i_ % xSize, spawnas_y = i_ / xSize;
					pInfo(peer)->c_x = spawnas_x, pInfo(peer)->c_y = spawnas_y;
					gamepacket_t p(delay, pInfo(peer)->netID);
					p.Insert("SetRespawnPos"), p.Insert(i_), p.CreatePacket(peer);
					break;
				}
			}
		}
		else {
			gamepacket_t p(delay);
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("The door is locked."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
		}
		if (not locked) {
			pInfo(peer)->x = spawnas_x * 32, pInfo(peer)->y = spawnas_y * 32;
			gamepacket_t p(delay, pInfo(peer)->netID);
			p.Insert("OnSetPos"), p.Insert(float(spawnas_x) * 32, float(spawnas_y) * 32), p.CreatePacket(peer);
			if (not pInfo(peer)->invis) {
				gamepacket_t p(delay, pInfo(peer)->netID);
				p.Insert("OnPlayPositioned"), p.Insert("audio/door_open.wav"), p.CreatePacket(peer);
			}
		}
		p2.Insert("OnZoomCamera"), p2.Insert((float)10000.000000), p2.Insert(1000), p2.CreatePacket(peer);
		p3.Insert("OnSetFreezeState"), p3.Insert(0), p3.CreatePacket(peer);
		return;
	}
	else if (not pInfo(peer)->world.empty()) exit_(peer, true);
	pInfo(peer)->lock = 0;
	pInfo(peer)->world = world_.name;
	int total = 78 + world_.name.length() + world_.blocks.size() + 24 + ((8 * world_.blocks.size()) + (world_.drop.size() * 16));
	int spawn_x = 0, spawn_y = 0;
	//	BYTE* data = (BYTE*)malloc((world_.blocks.size()*2) * sizeof(WorldBlock) + sizeof(World));
	BYTE* data = (BYTE*)malloc(world_.blocks.size() * sizeof(WorldBlock) + (sizeof(World) * 2));
	memset(data, 0, total);
	*(__int8*)(data) = 4;
	*(__int8*)(data + 4) = 4;
	*(__int8*)(data + 16) = 8;
	*(__int8*)(data + 66) = world_.name.length();
	memcpy(data + 68, world_.name.c_str(), world_.name.length());
	*(__int8*)(data + 68 + world_.name.length()) = world_.width;
	*(__int8*)(data + 72 + world_.name.length()) = world_.height;
	*(__int16*)(data + 76 + world_.name.length()) = world_.blocks.size();
	BYTE* blc = data + 80 + world_.name.length();
	world_.active_jammers.clear();
	vector<string> world_mods;
	vector<vector<unsigned int>> world_locks, world_seeds, world_crystals;
	for (int i_ = 0; i_ < world_.height * world_.width; i_++) {
		/*
		if (find(blocks.begin(), blocks.end(), world_.blocks[i_].fg) == blocks.end()) {
			blocks.push_back(world_.blocks[i_].fg);
				cout << world_.blocks[i_].fg << endl;
		}*/
		//	if (world_.blocks[i_].fg == 6950 || world_.blocks[i_].fg == 6952 || world_.blocks[i_].fg == 6954)  world_.blocks[i_].fg = 2;
		*(__int16*)(blc) = world_.blocks[i_].fg;
		*(__int16*)(blc + 2) = world_.blocks[i_].bg;
		*(__int32*)(blc + 4) = world_.blocks[i_].flags;
		//if (world_.blocks.at(i_).flags & 0x00400000 && (world_.blocks.at(i_).fg == 226 || world_.blocks.at(i_).fg == 1276 || world_.blocks.at(i_).fg == 1278 || world_.blocks.at(i_).fg == 3616 || world_.blocks.at(i_).fg == 4758 || world_.blocks.at(i_).fg == 4884 || world_.blocks.at(i_).fg == 4992)) world_mods.push_back("`" + a + (world_.blocks.at(i_).fg == 226 ? "4JAMMED" : (world_.blocks.at(i_).fg == 1276 ? "2NOPUNCH" : (world_.blocks.at(i_).fg == 1278 ? "2IMMUNE" : (world_.blocks.at(i_).fg == 4884 ? "2NOWAR" : (world_.blocks.at(i_).fg == 3616 ? "2NOCONSUME" : (world_.blocks.at(i_).fg == 4992 ? "2ANTIGRAVITY" : "2NODROP")))))) + "``"), world_.active_jammers.push_back(world_.blocks.at(i_).fg);
		if (!world_.allow_noclip and world_.blocks.at(i_).fg == 8470 || (world_.blocks.at(i_).flags & 0x00400000 &&
			(world_.blocks.at(i_).fg == 226 || world_.blocks.at(i_).fg == 1276 || world_.blocks.at(i_).fg == 1278 ||
				world_.blocks.at(i_).fg == 3616 || world_.blocks.at(i_).fg == 4758 || world_.blocks.at(i_).fg == 4884 ||
				world_.blocks.at(i_).fg == 4992))) world_mods.push_back("`" + a +
					(world_.blocks.at(i_).fg == 226 ? "4JAMMED" : (world_.blocks.at(i_).fg == 1276 ? "2NOPUNCH" :
						(world_.blocks.at(i_).fg == 1278 ? "2IMMUNE" : (world_.blocks.at(i_).fg == 4884 ? "2NOWAR" :
							(world_.blocks.at(i_).fg == 3616 ? "2NOCONSUME" :
								(world_.blocks.at(i_).fg == 4992 ? "2ANTIGRAVITY" :
									!world_.allow_noclip and world_.blocks.at(i_).fg == 8470 ? "2NOGHOST" : "2NODROP")))))) + "``"),
			world_.active_jammers.push_back(world_.blocks.at(i_).fg);
		if (world_.blocks[i_].fg == 5638 || world_.blocks[i_].fg == 6948 || world_.blocks[i_].fg == 6946) {
			*(__int8*)(blc + 8) = 62;
			*(__int16*)(blc + 9) = world_.blocks[i_].id;
			*(__int16*)(blc + 13) = world_.blocks[i_].pr;
			*(__int8*)(blc + 17) = world_.blocks[i_].enabled;
			if (world_.blocks[i_].fg == 5638)*(__int16*)(blc + 18) = world_.blocks[i_].magnetron;
			*(__int16*)(blc + 20) = (world_.blocks[i_].fg == 5638 ? (get_mag_size(world_.blocks.at(i_).fg)) : (get_mag_size(world_.blocks.at(i_).fg)));
			blc += 15;
			total += 15;
		}
		else if (items[world_.blocks[i_].fg].actionType == -115 || world_.blocks[i_].fg == 3760) {
			*(__int8*)(blc + 8) = 6;
			blc += 8;
			total += 8;
		}
		else if (world_.blocks[i_].fg == 6950 || world_.blocks[i_].fg == 6952 || world_.blocks[i_].fg == 6954) {
			*(__int8*)(blc + 8) = world_.blocks[i_].fg == 6950 ? 70 : 69;
			*(__int8*)(blc + 9) = world_.blocks[i_].pr > 0 ? 1 : 0;
			*(__int16*)(blc + 13) = world_.blocks[i_].pr;
			*(__int16*)(blc + 17) = world_.blocks[i_].id;
			*(__int8*)(blc + 21) = world_.blocks[i_].enabled;
			blc += 13;
			total += 13;
		}
		else if (items[world_.blocks[i_].fg].easel) {
			*(__int8*)(blc + 8) = 35;
			*(__int16*)(blc + 9) = world_.blocks[i_].id;
			*(__int16*)(blc + 13) = world_.blocks[i_].txt.size();
			memcpy(blc + 15, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
			blc += 7 + world_.blocks[i_].txt.size();
			total += 7 + world_.blocks[i_].txt.size();
		}
		else if (items[world_.blocks[i_].fg].audio_rack) {
			*(__int8*)(blc + 8) = 56; // tileextra_type_audio_rack
			*(__int16*)(blc + 9) = world_.blocks[i_].audio_notes.size();
			memcpy(blc + 11, world_.blocks[i_].audio_notes.c_str(), world_.blocks[i_].audio_notes.size());
			*(__int16*)(blc + 11 + world_.blocks[i_].audio_notes.size()) = world_.blocks[i_].audio_volume;
			blc += 7 + world_.blocks[i_].audio_notes.size();
			total += 7 + world_.blocks[i_].audio_notes.size(); // end marker i believe
		}
		else if (world_.blocks[i_].fg == 1660) {
			*(__int8*)(blc + 8) = TILEEXTRA_TYPE_GAME_GENERATOR;
			/*
			*(__int16*)(blc + 9) = world_.blocks[i_].game_label.size();
			memcpy(blc + 11, world_.blocks[i_].game_label.c_str(), world_.blocks[i_].game_label.size());
			*(__int8*)(blc + 11 + world_.blocks[i_].game_label.size()) = world_.blocks[i_].teams.size();
			*(__int32*)(blc + 12 + world_.blocks[i_].game_label.size()) = world_.blocks[i_].game_time;

			blc += 7 + world_.blocks[i_].game_label.size();
			total += 7 + world_.blocks[i_].game_label.size();
			*/
			blc += 17;
			total += 17;
		}
		else if (items[world_.blocks[i_].fg].bunny_egg) {
			*(__int8*)(blc + 8) = 15;
			*(__int16*)(blc + 9) = world_.blocks[i_].bunny_egg_progress;
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].kranken) {
			int model_ = world_.blocks[i_].kranken_pattern;
			int rgb = (world_.blocks[i_].b << 24) | (world_.blocks[i_].g << 16) | (world_.blocks[i_].r << 8);
			int w_ = rgb + 255;
			BYTE btype = 0x50;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &model_, 4);
			memcpy(blc + 13, &w_, 4);
			blc += 9;
			total += 9;
		}
		else if (items[world_.blocks[i_].fg].dshelf) {
			*(__int8*)(blc + 8) = 43;
			*(__int16*)(blc + 9) = world_.blocks[i_].shelf_1;
			*(__int16*)(blc + 13) = world_.blocks[i_].shelf_2;
			*(__int16*)(blc + 17) = world_.blocks[i_].shelf_3;
			*(__int16*)(blc + 21) = world_.blocks[i_].shelf_4;
			blc += 17;
			total += 17;
		}
		else if (items[world_.blocks[i_].fg].fish_port) {
			*(__int8*)(blc + 8) = 63;
			blc += 1 + 4 + 8;
			total += 1 + 4 + 8;
		}
		else if (items[world_.blocks[i_].fg].timer) {
			*(__int8*)(blc + 8) = 45;
			blc += 1;
			total += 1;
		}
		else if (items[world_.blocks[i_].fg].heart_monitor) {
			*(__int8*)(blc + 8) = 11;
			{
				bool ijungtas = false;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (fixchar(pInfo(currentPeer)->tankIDName) == fixchar(world_.blocks[i_].heart_monitor)) {
						ijungtas = 1;
						break;
					}
				}
				/*
				GlobalMonitors new_monitor;
				new_monitor.active = ijungtas;
				new_monitor.world_name = world_.name;
				new_monitor.x = i_ % 100;
				new_monitor.y = i_ / 100;
				monitors.push_back(new_monitor);*/
				if (ijungtas)*(int*)(blc + 4) = world_.blocks[i_].flags | 0x00400000;
				*(int*)(blc + 9) = ijungtas;
			}
			*(int*)(blc + 13) = world_.blocks[i_].heart_monitor.size();
			memcpy(blc + 15, world_.blocks[i_].heart_monitor.c_str(), world_.blocks[i_].heart_monitor.size());
			blc += 7 + world_.blocks[i_].heart_monitor.size();
			total += 7 + world_.blocks[i_].heart_monitor.size();
		}
		else if (items[world_.blocks[i_].fg].xeno) {
			*(__int8*)(blc + 8) = 53;
			blc += 9;
			total += 9;
		}
		else if (items[world_.blocks[i_].fg].trickster) {
			*(__int8*)(blc + 8) = 52;
			blc += 1;
			total += 1;
		}
		else if (items[world_.blocks[i_].fg].charger) {
			*(int*)(blc + 4) = (world_.blocks[i_].id != 0 ? 0x00400000 : world_.blocks[i_].flags);
			*(__int8*)(blc + 8) = 57;
			*(__int16*)(blc + 9) = (world_.blocks[i_].planted - time(nullptr) <= 0 ? 3600 : 3600 - (world_.blocks[i_].planted - time(nullptr)));
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].fossil_prep) {
			*(int*)(blc + 4) = (world_.blocks[i_].id != 0 ? 0x00400000 : world_.blocks[i_].flags);
			*(__int8*)(blc + 8) = 50;
			*(__int16*)(blc + 9) = (world_.blocks[i_].planted - time(nullptr) <= 0 ? 5400 : 5400 - (world_.blocks[i_].planted - time(nullptr)));
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].spirit) {
			*(__int8*)(blc + 8) = 41;
			*(__int16*)(blc + 9) = world_.blocks[i_].c_;
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].trans) {
			*(__int8*)(blc + 8) = 19;
			blc += 19;
			total += 19;
		}
		else if (items[world_.blocks[i_].fg].dnaproc) {
			*(__int8*)(blc + 8) = 19;
			blc += 19;
			total += 19;
		}
		else if (items[world_.blocks[i_].fg].mannequin) {
			*(__int8*)(blc + 8) = 14;
			*(__int16*)(blc + 9) = world_.blocks[i_].txt.size();
			memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
			*(__int16*)(blc + 16 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_hair;
			*(__int16*)(blc + 18 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_shirt;
			*(__int16*)(blc + 20 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_pants;
			*(__int16*)(blc + 22 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_feet;
			*(__int16*)(blc + 24 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_head;
			*(__int16*)(blc + 26 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_hand;
			*(__int16*)(blc + 28 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_back;
			*(__int16*)(blc + 30 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_mask;
			*(__int16*)(blc + 32 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_neck;
			blc += 26 + world_.blocks[i_].txt.size();
			total += 26 + world_.blocks[i_].txt.size();
		}
		else if (items[world_.blocks[i_].fg].vipentrance) {
			*(__int8*)(blc + 8) = 44;
			vector<int> vip_members;
			if (world_.blocks[i_].limit_admins or find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), pInfo(peer)->uid) != world_.blocks[i_].admins.end() or pInfo(peer)->tankIDName == world_.owner_name or world_.owner_name.empty()) vip_members.push_back(pInfo(peer)->id);
			*(__int16*)(blc + 14) = vip_members.size();
			for (int i = 0; i < vip_members.size(); i++) *(__int32*)(blc + 18 + (i * 4)) = vip_members[i];
			blc += 10 + (vip_members.size() * 4);
			total += 10 + (vip_members.size() * 4);
		}
		else if (items[world_.blocks[i_].fg].infinitymachine) {
			*(__int8*)(blc + 8) = 19;
			blc += 19;
			total += 19;
		}
		else if (items[world_.blocks[i_].fg].portrait) {
			*(__int8*)(blc + 8) = 48;
			*(__int16*)(blc + 9) = world_.blocks[i_].txt.size();
			memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
			if (world_.blocks[i_].portrait.c_skin == 0 and world_.blocks[i_].portrait.c_face == 0 and world_.blocks[i_].portrait.c_head == 0 and world_.blocks[i_].portrait.c_hair == 0) {
			}
			else {
				*(int*)(blc + 11 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_expression;
				*(int*)(blc + 19 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_hair_colour;
				*(int*)(blc + 23 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_skin;
				*(int*)(blc + 27 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_face;
				*(int*)(blc + 29 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_head;
				*(int*)(blc + 31 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_hair;
			}
			blc += 7 + 15 + 3 + world_.blocks[i_].txt.size();
			total += 7 + 15 + 3 + world_.blocks[i_].txt.size();
		}
		else if (items[world_.blocks[i_].fg].vall_mount/*|| world_.blocks[i_].fg == 6950 || world_.blocks[i_].fg == 6952 || world_.blocks[i_].fg == 6954*/) {
			*(__int8*)(blc + 8) = 47;
			*(__int8*)(blc + 9) = 0;
			blc += 8;
			total += 8;
		}
		else if (items[world_.blocks[i_].fg].bulletin_board or items[world_.blocks[i_].fg].storage_box or items[world_.blocks[i_].fg].growscan or items[world_.blocks[i_].fg].security_camera or items[world_.blocks[i_].fg].spotlight or world_.blocks[i_].fg == 4722) {
			*(__int8*)(blc + 8) = 6;
			blc += 8;
			total += 8;
		}
		else if (world_.blocks[i_].fossil) {
			*(__int32*)(blc + 4) = world_.blocks[i_].flags;
			*(__int8*)(blc + 8) = 12;
			//blc += 0;
			//total += 0;
		}
		else {
			switch (items[world_.blocks[i_].fg].blockType) {
			case BlockTypes::WEATHER:
			{
				switch (world_.blocks[i_].fg) {
				case 3694: case 5000:
				{
					*(__int8*)(blc + 8) = 40;
					*(__int32*)(blc + 9) = (world_.blocks[i_].fg == 3694 ? (world_.blocks[i_].b << 24) | (world_.blocks[i_].g << 16) | (world_.blocks[i_].r << 8) : world_.blocks[i_].id != 0 ? world_.blocks[i_].id : 14);
					blc += 5;
					total += 5;
					break;
				}
				case 3832: case 5958:
				{
					*(__int8*)(blc + 8) = 49;
					*(__int16*)(blc + 9) = (world_.blocks[i_].id != 0 ? world_.blocks[i_].id : 2);
					*(__int16*)(blc + 13) = (world_.blocks[i_].fg == 5958 ? world_.blocks[i_].epoch_minute : world_.blocks[i_].gravity);
					*(__int16*)(blc + 17) = (int)world_.blocks[i_].spin | ((int)world_.blocks[i_].invert << 1);
					blc += 10;
					total += 10;
					break;
				}
				default:
				{
					if (items[world_.blocks[i_].fg].ext_weather) {
						*(__int8*)(blc + 8) = 5;
						blc += 1;
						total += 1;
					}
					break;
				}
				}
				break;
			}
			case BlockTypes::CRYSTAL:
			{
				*(__int8*)(blc + 8) = 6;
				blc += 8;
				total += 8;
				break;
			}
			case BlockTypes::VENDING:
			{
				*(int*)(blc + 9) = (world_.blocks[i_].pr < 0 and world_.blocks[i_].id != 0 && world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1) ? 0 : world_.blocks[i_].id);
				*(__int8*)(blc + 8) = 24;
				*(int*)(blc + 4) = (world_.blocks[i_].pr < 0 and world_.blocks[i_].id != 0 && world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1) ? world_.blocks[i_].flags | ((world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1)) ? (world_.blocks[i_].wl != 0 ? 0x02410000 : 0x00410000) : (world_.blocks[i_].wl != 0 ? 0x02410000 : 0x00410000)) : world_.blocks[i_].flags | (world_.blocks[i_].id == 0 ? (world_.blocks[i_].wl != 0 ? 0x02000000 : 0x00000000) : (world_.blocks[i_].wl != 0 ? 0x02410000 : 0x00410000)));
				*(int*)(blc + 13) = (world_.blocks[i_].pr < 0 and world_.blocks[i_].id != 0 && world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1) ? 0 : world_.blocks[i_].pr);
				blc += 9;
				total += 9;
				break;
			}
			case BlockTypes::DISPLAY:
			{
				*(__int8*)(blc + 8) = 23;
				*(__int16*)(blc + 9) = world_.blocks[i_].id;
				blc += 5;
				total += 5;
				break;
			}
			case BlockTypes::PROVIDER:
			{
				*(__int8*)(blc + 8) = 9;
				*(__int32*)(blc + 9) = (time(nullptr) - world_.blocks[i_].planted <= items[world_.blocks[i_].fg].growTime ? time(nullptr) - world_.blocks[i_].planted : items[world_.blocks[i_].fg].growTime);
				blc += 5;
				total += 5;
				break;
			}
			case BlockTypes::RANDOM_BLOCK:
			{
				*(__int8*)(blc + 8) = 8;
				*(__int32*)(blc + 9) = world_.blocks[i_].roll;
				blc += 2;
				total += 2;
				break;
			}
			case BlockTypes::LOCK:
			{
				if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994) {
					world_locks.push_back({ i_ % xSize, i_ / xSize });
				}
				else pInfo(peer)->lock = world_.blocks[i_].fg, world_.lockid = world_.blocks[i_].fg;

				if (world_.blocks[i_].open_to_public) {
					int new_ = 0x00800000;
					memcpy(blc + 4, &new_, 4);
				}
				BYTE btype = 3;
				memcpy(blc + 8, &btype, 1);
				uint32_t world_owner_id = -1;
				{
					uint8_t world_settings = 0;
					if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994) {
						if (world_.blocks[i_].fg == 4994 and world_.blocks[i_].build_only) world_settings |= 64;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (world_.blocks[i_].owner_name == pInfo(currentPeer)->tankIDName) {
								world_owner_id = pInfo(currentPeer)->id;
							}
						}
						uint32_t bpm_ = world_.music_bpm * -1; //world_.music_bpm * -1
						memcpy(blc + 9, &world_settings, 1);
						memcpy(blc + 10, &world_owner_id, 4);
						memcpy(blc + 18, &bpm_, 4);
						//cout << to_string(world_settings) << endl;
					}
					else {
						uint8_t world_settings = 0;
						if (world_.disable_music_blocks) world_settings |= 16;
						if (world_.make_music_blocks_invisible) world_settings |= 32;
						if (world_.rainbows and world_.blocks[i_].fg == 4802) world_settings |= 128;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (world_.owner_name == pInfo(currentPeer)->tankIDName) {
								world_owner_id = pInfo(currentPeer)->id;
							}
						}
						uint32_t bpm_ = world_.music_bpm * -1; //world_.music_bpm * -1
						memcpy(blc + 9, &world_settings, 1);
						memcpy(blc + 10, &world_owner_id, 4);
						memcpy(blc + 18, &bpm_, 4);
						//cout << to_string(world_settings) << endl;
					}
				}
				uint32_t admin_id = 0;
				uint32_t count_of_admins = 1;
				{
					if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994) {
						if (peer != NULL and find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), pInfo(peer)->uid) != world_.blocks[i_].admins.end()) {
							memcpy(blc + 22, &pInfo(peer)->id, 4);
							count_of_admins++;
						} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_.name) {
								if (find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), pInfo(currentPeer)->uid) != world_.blocks[i_].admins.end()) {
									if (count_of_admins == 1) {
										memcpy(blc + 22, &pInfo(currentPeer)->id, 4);
									}
									else {
										memcpy(blc + 22 + (count_of_admins * 4), &pInfo(currentPeer)->id, 4);
									}
									count_of_admins++;
									//if (count_of_admins > 7) break;
								}
							}
						}
					}
					else {
						if (peer != NULL and guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) != world_.admins.end()) {
							memcpy(blc + 22, &pInfo(peer)->id, 4);
							count_of_admins++;
						} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_.name) {
								if (guild_access(currentPeer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(currentPeer)->uid) != world_.admins.end()) {
									if (count_of_admins == 1) {
										memcpy(blc + 22, &pInfo(currentPeer)->id, 4);
									}
									else {
										memcpy(blc + 22 + (count_of_admins * 4), &pInfo(currentPeer)->id, 4);
									}
									count_of_admins++;
								}
							}
						}
					}
					memcpy(blc + 14, &count_of_admins, 1);
				}
				
				break;
			}
			case BlockTypes::MAIN_DOOR:
			{
				spawn_x = (i_ % xSize) * 32, spawn_y = (i_ / xSize) * 32;
				pInfo(peer)->c_x = spawn_x / 32;
				pInfo(peer)->c_y = spawn_y / 32;
				*(__int8*)(blc + 8) = 1;
				*(__int16*)(blc + 9) = 4;
				memcpy(blc + 11, "EXIT", 4);
				blc += 8;
				total += 8;
				break;
			}
			case BlockTypes::SEED:
			{
				*(int*)(blc + 4) = 0 | 0x100000;
				*(__int8*)(blc + 8) = 4;
				*(int*)(blc + 9) = (time(nullptr) - world_.blocks[i_].planted <= items.at(world_.blocks[i_].fg).growTime ? time(nullptr) - world_.blocks[i_].planted : items.at(world_.blocks[i_].fg).growTime);
				*(__int16*)(blc + 13) = world_.blocks[i_].fruit;

				blc += 6;
				total += 6;
				break;
			}
			case BlockTypes::DONATION:case BlockTypes::MAILBOX:
			{
				*(__int32*)(blc + 4) = world_.blocks[i_].flags;
				*(__int8*)(blc + 8) = 12;
				blc += 8;
				total += 8;
				break;
			}
			case BlockTypes::DOOR: case BlockTypes::PORTAL:
			{
				string duru_tekstas = (world_.blocks[i_].txt.empty() ? (world_.blocks[i_].door_destination.empty() ? "" : (world_.blocks[i_].door_destination.find(":") != string::npos ? explode(":", world_.blocks[i_].door_destination)[0] + "..." : world_.blocks[i_].door_destination)) : world_.blocks[i_].txt);
				*(__int8*)(blc + 8) = 1;
				*(__int16*)(blc + 9) = duru_tekstas.size();
				memcpy(blc + 11, duru_tekstas.c_str(), duru_tekstas.size());
				*(__int8*)(blc + 11 + duru_tekstas.size()) = (world_.blocks[i_].open ? 0 : 0x08);
				blc += 4 + duru_tekstas.size();
				total += 4 + duru_tekstas.size();
				break;
			}
			case BlockTypes::SIGN:
			{
				*(__int8*)(blc + 8) = 2;
				*(int*)(blc + 9) = world_.blocks[i_].txt.size();
				memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
				*(__int16*)(blc + 11 + world_.blocks[i_].txt.size()) = 0;
				blc += 7 + world_.blocks[i_].txt.size();
				total += 7 + world_.blocks[i_].txt.size();
				break;
			}
			}
		}
		blc += 8;
	}
	*(int*)(blc) = world_.drop.size();
	*(int*)(blc + 4) = world_.drop.size();
	blc += 8;
	for (int i_ = 0; i_ < world_.drop.size(); i_++) {
		*(__int16*)(blc) = world_.drop[i_].id;
		*(float*)(blc + 2) = world_.drop[i_].x;
		*(float*)(blc + 6) = world_.drop[i_].y;
		*(__int8*)(blc + 10) = world_.drop[i_].count;
		*(int*)(blc + 12) = world_.drop[i_].uid;
		blc += 16;
	}
	enet_peer_send(peer, 0, enet_packet_create(data, total, ENET_PACKET_FLAG_RELIABLE));
	//delete[] data;
	free(data);
	pInfo(peer)->netID = net_;
	if (spawnas_x != 0 or spawnas_y != 0) spawn_x = spawnas_x * 32, spawn_y = spawnas_y * 32;
	pInfo(peer)->name_color = ((pInfo(peer)->dev == 1) ? "`6@" : (pInfo(peer)->admin == 1) ? "`6@" : (pInfo(peer)->tmod == 1) ? "`#@" : (pInfo(peer)->tankIDName == world_.owner_name) ? "`2" : (guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) != world_.admins.end()) ? "`^" : pInfo(peer)->is_legend and not(pInfo(peer)->tankIDName == world_.owner_name or (guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->uid) != world_.admins.end())) ? "`9" : "`0");
	{
		gamepacket_t p;
		p.Insert("OnMagicCompassTrackingItemIDChanged");
		p.Insert(pInfo(peer)->Magnet_Item);
		p.CreatePacket(peer);
		{
			//gamepacket_t p;
			//p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->pinata_claimed ? 1 : 0), p.Insert(pInfo(peer)->pinata_prize ? 1 : 0), p.CreatePacket(peer);
			//gamepacket_t p;
			//p.Insert("OnProgressUISet"), p.Insert(1), p.Insert(3402), p.Insert(pInfo(peer)->booty_broken), p.Insert(100), p.Insert(""), p.Insert(1);
			//p.CreatePacket(peer);
			//gamepacket_t p;
			//p.Insert("OnProgressUISet"), p.Insert(1), p.Insert(10328), p.Insert(pInfo(peer)->Darking_Sacrifice), p.Insert(15), p.Insert(""), p.Insert(1), p.CreatePacket(peer);
			{
				//gamepacket_t p;
				//p.Insert("OnProgressUIUpdateValue"); p.Insert(pInfo(peer)->Darking_Sacrifice); p.Insert(0); p.CreatePacket(peer);
			}
		}
	}
	gamepacket_t p;
	p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
	if (pInfo(peer)->supp >= 2) {
		p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
	}
	p.CreatePacket(peer);
	{
		for (int i = 0; i < top_honors.size(); i++) if (top_honors[i].second == world_.name) world_.honors = top_honors[i].first;
		string nuked = "";
		if (world_.nuked == true) nuked = "`0[NUKED: " + world_.n_b + "," + world_.n_t + "]`` ";
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("" + (pInfo(peer)->mod + pInfo(peer)->admin > 0 ? nuked : "") + "World `w" + world_.name + "`` " + (world_mods.size() != 0 ? "`0[``" + join(world_mods, ", ") + "`0]`` " : "") + "" + (world_.honors == "" and world_.yesterday == 0 ? "" : "(`3Honors:`` " + world_.honors + (world_.yesterday == 0 ? "" : (world_.honors.empty() ? "`5#" + to_string(world_.yesterday) + " yesterday``" : "`0,`` `5#" + to_string(world_.yesterday) + " yesterday``")) + "" + (world_.overall == 0 ? "" : world_.honors.empty() && world_.yesterday == 0 ? "`0#" + to_string(world_.overall) + " overall``" : "`0,`` `0#" + to_string(world_.overall) + " overall``") + ") ") + "entered.  There are `w" + to_string(w_c) + "`` other people here, `w" + setGems(s_c) + "`` online.");
		p.CreatePacket(peer);
	}
	{
		gamepacket_t p;
		p.Insert("OnSetCurrentWeather");
		if (world_.weather == 0 || world_.weather == 80 && world_.d_weather != 0) p.Insert(world_.d_weather);
		else p.Insert(world_.weather == 0 ? 80 : world_.weather);
		p.CreatePacket(peer);
	}
	{
		string s_ = "spawn|avatar\nnetID|" + to_string(net_) + "\nuserID|" + to_string(pInfo(peer)->id) + "\ncolrect|0|0|20|30\nposXY|" + to_string(spawn_x) + "|" + to_string(spawn_y) + "\nname|" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + (pInfo(peer)->tankIDName.empty() ? pInfo(peer)->requestedName : pInfo(peer)->tankIDName)) + (is_reseller(peer) ? " `b[Atomic]``" : "") + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "``\ncountry|" + pInfo(peer)->country + "\ninvis|" + (pInfo(peer)->invis ? "1" : "0") + "\nmstate|" + (pInfo(peer)->mod or pInfo(peer)->admin ? "1" : "0") + "\nsmstate|" + (pInfo(peer)->admin ? "1" : "0") + "\nonlineID|";
		gamepacket_t p;
		p.Insert("OnSpawn"), p.Insert(s_);
		{
			gamepacket_t p;
			p.Insert("OnSpawn"), p.Insert(s_ + "\ntype|local"), p.CreatePacket(peer);
		}
		gamepacket_t p57, p58;
		p57.Insert("OnTalkBubble"), p57.Insert(pInfo(peer)->netID), p57.Insert("`5<" + (not pInfo(peer)->d_name.empty() ? "`w" + pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (is_reseller(peer) and not pInfo(peer)->hide_reseller  ? "`b[Atomic ĭ]" : "") + " ``entered, `w" + to_string(w_c) + "`` others here>``"), p57.Insert(1);
		p58.Insert("OnConsoleMessage"), p58.Insert("`5<" + (not pInfo(peer)->d_name.empty() ? "`w" + pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + " ``entered, `w" + to_string(w_c) + "`` others here>``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_ or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName) continue;
			p.CreatePacket(currentPeer);
			if (not pInfo(currentPeer)->Cheat_HideOther and pInfo(currentPeer)->netID != pInfo(peer)->netID) {
				user_name = (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->tankIDName);
				gamepacket_t p;
				p.Insert("OnSpawn"), p.Insert("spawn|avatar\nnetID|" + to_string(pInfo(currentPeer)->netID) + "\nuserID|" + to_string(pInfo(currentPeer)->id) + "\ncolrect|0|0|20|30\nposXY|" + to_string(pInfo(currentPeer)->x) + "|" + to_string(pInfo(currentPeer)->y) + "\nname|" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + (pInfo(currentPeer)->tankIDName.empty() ? pInfo(currentPeer)->requestedName : pInfo(currentPeer)->tankIDName)) + (is_reseller(currentPeer) and not pInfo(currentPeer)->hide_reseller ? " `b[Atomic]``" : "") + (pInfo(currentPeer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``\ncountry|" + pInfo(currentPeer)->country + "\ninvis|" + (pInfo(currentPeer)->invis ? "1" : "0") + "\nmstate|" + (pInfo(currentPeer)->mod or pInfo(currentPeer)->admin ? "1" : "0") + "\nsmstate|" + (pInfo(currentPeer)->admin ? "1" : "0") + "\nonlineID|"), p.CreatePacket(peer);
				if (w_c <= 14 && w_c >= 1 && pInfo(peer)->invis == false) p57.CreatePacket(currentPeer), p58.CreatePacket(currentPeer);
			}
		}
	}
	/*send world info if any*/
	if (not world_.owner_name.empty()) {
		if (world_.owner_named == "" && pInfo(peer)->tankIDName == world_.owner_name && world_.owner_named != pInfo(peer)->tankIDName) {
			world_.owner_named = "`o" + pInfo(peer)->tankIDName;
			if (HasRole(pInfo(peer))) world_.owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
		}
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`5[```w" + world_.name + "`` `$World Locked`` by " + (world_.owner_named == "" ? world_.owner_name : world_.owner_named) + "``" + (world_.owner_name == (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) or (guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), (pInfo(peer)->uid)) != world_.admins.end()) ? " (`2ACCESS GRANTED``)" : (world_.open_to_public ? " (`$PUBLIC``)" : "")) + "`5]``");
		p.CreatePacket(peer);
	}
	if (world_.special_event) {
		gamepacket_t p2;
		p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_.special_event_item].event_name + ":`` " + (items[world_.special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_.special_event_item].name + "```o.``" : "`#" + to_string(items[world_.special_event_item].event_total) + " " + items[world_.special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + ""), p2.CreatePacket(peer);
	}
	{
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_pointer_ = &worlds[p - worlds.begin()];
			world_pointer_->owner_named = world_.owner_named;
			world_pointer_->active_jammers = world_.active_jammers;
		}
	}
	if (pInfo(peer)->uid != world_.owner_id or !(find(world_.admins.begin(), world_.admins.end(), (pInfo(peer)->uid)) != world_.admins.end())) {
		world_.Honor += (float)0.1; world_.Yesterday += (float)0.025;
		world_.Overall += world_.Honor + world_.Yesterday;
	}
	for (int i_ = 0; i_ < pInfo(peer)->last_visited_worlds.size(); i_++) {
		if (pInfo(peer)->last_visited_worlds[i_] == world_.name) {
			pInfo(peer)->last_visited_worlds.erase(pInfo(peer)->last_visited_worlds.begin() + i_);
			pInfo(peer)->last_visited_worlds.push_back(world_.name);
		}
		else if (i_ + 1 == pInfo(peer)->last_visited_worlds.size()) {
			if (pInfo(peer)->last_visited_worlds.size() + 1 > 11) {
				pInfo(peer)->last_visited_worlds.erase(pInfo(peer)->last_visited_worlds.begin());
			}
			pInfo(peer)->last_visited_worlds.push_back(world_.name);
		}
	}
	if (pInfo(peer)->last_visited_worlds.size() == 0)
		pInfo(peer)->last_visited_worlds.push_back(world_.name);
	int c_ = 0;
	modify_inventory(peer, 1424, c_);
	if (c_ != 0) {
		c_ *= -1;
		modify_inventory(peer, 1424, c_, false);
	}
	{
		int c_ = 0;
		modify_inventory(peer, 5816, c_);
		if (c_ != 0) {
			c_ *= -1;
			modify_inventory(peer, 5816, c_, false);
		}
	}
	{
		int c_ = 0;
		modify_inventory(peer, 5640, c_);
		if (c_ != 0) {
			c_ *= -1;
			modify_inventory(peer, 5640, c_, false);
			pInfo(peer)->magnetron_id = 0;
			pInfo(peer)->magnetron_x = 0;
			pInfo(peer)->magnetron_y = 0;
		}
	}
	send_inventory(peer);
	if (not pInfo(peer)->invis) packet_(peer, "action|play_sfx\nfile|audio/door_open.wav\ndelayMS|0");
	if (name_ == "START" && pInfo(peer)->n == 0) {
		pInfo(peer)->n = 1;
		gamepacket_t p3(2288);
		p3.Insert("OnAddNotification");
		p3.Insert("interface/large/anni_plu.rttex");
		p3.Insert("`wWelcome to `1TayoPs `wstart your journey here!!");
		p3.Insert("");
		p3.CreatePacket(peer);
		packet_(peer, "action|play_sfx\nfile|audio/fight_loop.wav\ndelayMS|2288");
	}
	for (int i_ = 0; i_ < world_.bulletin.size(); i_++) {
		WorldBulletin bulletin = world_.bulletin[i_];
		WorldBlock block_ = world_.blocks[bulletin.x + (bulletin.y * world_.width)];
		if (items[block_.fg].mailbox) {
			PlayerMoving data_{};
			data_.packetType = 5, data_.punchX = bulletin.x, data_.punchY = bulletin.y, data_.characterState = 0x8;
			BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(&world_, &block_));
			BYTE* blc = raw + 56;
			memcpy(blc, &block_.fg, 2);
			memcpy(blc + 2, &block_.bg, 2);
			memcpy(blc + 4, &block_.flags, 4);
			int test_ = (block_.flags | 0x00400000);
			memcpy(blc + 4, &test_, 4);
			BYTE btype = 12;
			memcpy(blc + 8, &btype, 1);
			send_raw(peer, 4, raw, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
			delete[] raw, blc;
		}
	}
	for (int i_ = 0; i_ < world_.machines.size(); i_++) {
		WorldMachines machine_ = world_.machines[i_];
		WorldBlock block_ = world_.blocks[machine_.x + (machine_.y * world_.width)];
		PlayerMoving data_{};
		data_.packetType = 5, data_.punchX = machine_.x, data_.punchY = machine_.y, data_.characterState = 0x8;
		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(&world_, &block_));
		BYTE* blc = raw + 56;
		form_visual(blc, block_, world_, peer, false);
		send_raw(peer, 4, raw, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
		delete[] raw, blc;
	}
	if (world_crystals.size() > 0) {
		for (vector<unsigned int> sk_ : world_crystals) {
			int l_x = sk_[0];
			int l_y = sk_[1];
			WorldBlock* block_s = &world_.blocks[l_x + (l_y * world_.width)];
			punch_tile(peer, l_x, l_y, 0x3, block_s->fg, 0, 0, 1, 1, false);
		}
	}
	if (world_locks.size() > 0) {
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_pointer_ = &worlds[p - worlds.begin()];
			vector<WorldBlock> shadow_copy_2 = world_.blocks;
			for (vector<unsigned int> sk_ : world_locks) {
				int l_x = sk_[0];
				int l_y = sk_[1];
				WorldBlock block_ = world_.blocks[l_x + (l_y * world_.width)];
				block_.owner_named = block_.owner_name;
				world_pointer_->blocks[l_x + (l_y * world_.width)].owner_named = block_.owner_named;
				world_.blocks[l_x + (l_y * world_.width)].owner_named = block_.owner_name;
				vector<vector<int>> locked_tiles_around_lock{};
				vector<int> new_tiles{};
				new_tiles.push_back(l_x + (l_y * world_.width));
				for (int i2 = 0; i2 < new_tiles.size(); i2++) {
					int s_x_ = new_tiles[i2] % world_.width, s_y_ = new_tiles[i2] / world_.width;
					if (s_x_ < (world_.width - 1) and shadow_copy_2[s_x_ + 1 + (s_y_ * world_.width)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * world_.width)].lock_origin == (l_x + (l_y * world_.width))) {
						if (not shadow_copy_2[s_x_ + 1 + (s_y_ * world_.width)].scanned) {
							shadow_copy_2[s_x_ + 1 + (s_y_ * world_.width)].scanned = true;
							new_tiles.push_back(s_x_ + 1 + (s_y_ * world_.width));
							locked_tiles_around_lock.push_back({ s_x_ + 1, s_y_ });
						}
					} if (s_x_ > 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * world_.width)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * world_.width)].lock_origin == (l_x + (l_y * world_.width))) {
						if (not shadow_copy_2[s_x_ - 1 + (s_y_ * world_.width)].scanned) {
							shadow_copy_2[s_x_ - 1 + (s_y_ * world_.width)].scanned = true;
							new_tiles.push_back(s_x_ - 1 + (s_y_ * world_.width));
							locked_tiles_around_lock.push_back({ s_x_ - 1, s_y_ });
						}
					} if (s_y_ < (world_.height - 1) and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_.width)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_.width)].lock_origin == (l_x + (l_y * world_.width))) {
						if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * world_.width)].scanned) {
							shadow_copy_2[s_x_ + ((s_y_ + 1) * world_.width)].scanned = true;
							new_tiles.push_back(s_x_ + ((s_y_ + 1) * world_.width));
							locked_tiles_around_lock.push_back({ s_x_, s_y_ + 1 });
						}
					} if (s_y_ > 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_.width)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_.width)].lock_origin == (l_x + (l_y * world_.width))) {
						if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * world_.width)].scanned) {
							shadow_copy_2[s_x_ + ((s_y_ - 1) * world_.width)].scanned = true;
							new_tiles.push_back(s_x_ + ((s_y_ - 1) * world_.width));
							locked_tiles_around_lock.push_back({ s_x_, s_y_ - 1 });
						}
					}
				}
				if (locked_tiles_around_lock.size() != 0) {
					PlayerMoving data_{};
					data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
					data_.netID = block_.owner_id == pInfo(peer)->uid ? pInfo(peer)->id : -1;
					data_.plantingTree = block_.fg;
					BYTE* raw;
					int alloc = alloc_(&world_, &block_);
					raw = packPlayerMoving(&data_, 112 + (locked_tiles_around_lock.size() * 2) + alloc);
					*(int*)(raw + 8) = locked_tiles_around_lock.size();
					*(__int8*)(raw + 12) = 8;
					BYTE* blc = raw + 56;
					for (int i_ = 0; i_ < locked_tiles_around_lock.size(); i_++) {
						vector<int> update_tiles = locked_tiles_around_lock[i_];
						int x = update_tiles[0];
						int y = update_tiles[1];
						int sq_ = x + (y * world_.width);
						*(int*)(blc + (i_ * 2)) = sq_;
						shadow_copy_2[x + (y * world_.width)].scanned = false;
					}
					send_raw(peer, 4, raw, 112 + (locked_tiles_around_lock.size() * 2) + alloc, ENET_PACKET_FLAG_RELIABLE);
					PlayerMoving data_2{};
					data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
					BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc);
					BYTE* blc2 = raw2 + 56;
					form_visual(blc2, block_, world_, peer, false);
					send_raw(peer, 4, raw2, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw, blc, raw2, blc2;
				}
			}
		}
	}
	Send_Xenonite_Update(peer);
	if (pInfo(peer)->world == "GROWGANOTH" && Halloween) packet_(peer, "action|play_music\nfile|audio/mp3/unspeakable.mp3\ndelayMS|0");
	if (pInfo(peer)->world == "GROWCH" && Winterfest) packet_(peer, "action|play_music\nfile|audio/mp3/tsirhc.mp3\ndelayMS|0");
	if (pInfo(peer)->world == "CARNIVAL") packet_(peer, "action|play_music\nfile|audio/mp3/funtime.mp3\ndelayMS|0");
	if (pInfo(peer)->invis == false) {
		add_cctv(peer, "entered", "");
	}
	if (pInfo(peer)->wolf_world) {
		long long time_ = time(nullptr);
		int a9sd = pInfo(peer)->Time_Remaining - time_;
		gamepacket_t cd(1000, pInfo(peer)->netID);
		cd.Insert("OnCountdownStart"), cd.Insert(a9sd - 3), cd.Insert(-1), cd.CreatePacket(peer);
	}
	if (world_.World_Time != 0) {
		pInfo(peer)->World_Timed = time(nullptr) + (world_.World_Time * 60);
		pInfo(peer)->WorldTimed = true;
	}
	if (world_.Category != "None" and world_.Category != "") {
		gamepacket_t rate(5000);
		rate.Insert("OnConsoleMessage");
		rate.Insert("`9Type /rate to give your opinion of this world!`` `4/rate 1`` if you hate it, `2/rate 5`` if you love it, or anywhere in between. Share your thoughts!");
		rate.CreatePacket(peer);
	}
	if (pInfo(peer)->hair == 7102 && door == false) {
		gamepacket_t p(0, pInfo(peer)->netID);
		p.Insert("OnAction"), p.Insert("/omg"), p.CreatePacket(peer);
	}
}
ENetPeer* get_clicked_on(World* world_, int x_, int y_, ENetPeer* peer = NULL) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name and not pInfo(currentPeer)->ghost) {
			if (y_ == pInfo(currentPeer)->y / 32) {
				if (pInfo(currentPeer)->state == 0 and x_ * 32 < pInfo(currentPeer)->x and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state == 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state != 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 20) {
					return currentPeer;
				}
			}
		}
	}
	return NULL;
}
bool tst = true;
void save_server_events() {
	if (tst) {
		struct tm newtime;
		time_t now = time(0);
		localtime_s(&newtime, &now);
		today_day = newtime.tm_mday;
		ofstream o("database/server_events.json");
		if (!o.is_open()) tayo_warn("server_events " + GetLastError());
		json j;
		if (top_points.size() != 0) j["h" + to_string(today_day)] = top_points;
		if (top_yesterday.size() != 0) j["h" + to_string(today_day - 1)] = top_yesterday;
		if (top_overall.size() != 0) j["m" + to_string(today_month)] = top_overall;
		o << j << endl;
	}
}
void honors_reset() {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	if (today_day != newtime.tm_mday) {
		today_day = newtime.tm_mday;
		top_yesterday = top_points;
		top_points.clear();
	}
	if (today_month != newtime.tm_mon + 1) {
		today_month = newtime.tm_mon + 1;
		top_overall.clear();
	}
	vector<pair<int, string>> top_tier = top_points;
	top_list = "", top_list_world_menu = "", top_yesterday_list = "";
	sort(top_tier.begin(), top_tier.end());
	reverse(top_tier.begin(), top_tier.end());
	top_tier.resize((top_tier.size() >= 28 ? 28 : top_tier.size()));
	for (uint8_t i = 0; i < top_tier.size(); i++) {
		string owner_name = "", world_name = top_tier[i].second;
		//get_world(world_name);
		vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [world_name](const World& a) { return a.name == world_name; });
		if (paa != worlds.end()) {
			World* worlded_ = &worlds[paa - worlds.begin()];
			worlded_->honors = "`8#" + to_string(i + 1) + " today``";
			owner_name = worlded_->owner_name;
			if (worlded_->owner_named != "") {
				if (worlded_->owner_named.substr(0, 2) == "`o" || worlded_->owner_named.substr(0, 2) == "`2") owner_name = worlded_->owner_name;
				else owner_name = worlded_->owner_named;
			}
		}
		if (i < 32) top_list_world_menu += "\nadd_floater|" + top_tier[i].second + "|" + to_string((i + 1) * -1) + "|0.38|3417414143";
		top_list += "\nadd_button|warp_to_" + top_tier[i].second + "|`w#" + to_string(i + 1) + "`` " + top_tier[i].second + " by `#" + owner_name + "`|noflags|0|0|";
	}
	if (top_list == "") top_list = "\nadd_smalltext|The list should update in few minutes.|\nadd_spacer|small|";
	top_tier = top_overall;
	top_overall_list = "";
	sort(top_tier.begin(), top_tier.end());
	reverse(top_tier.begin(), top_tier.end());
	top_tier.resize((top_tier.size() >= 10 ? 10 : top_tier.size()));
	for (uint8_t i = 0; i < top_tier.size(); i++) {
		string owner_name = "", world_name = top_tier[i].second;
		//get_world(world_name);
		vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [world_name](const World& a) { return a.name == world_name; });
		if (paa != worlds.end()) {
			World* worlded_ = &worlds[paa - worlds.begin()];
			worlded_->overall = i + 1;
			owner_name = worlded_->owner_name;
			if (worlded_->owner_named != "") {
				if (worlded_->owner_named.substr(0, 2) == "`o" || worlded_->owner_named.substr(0, 2) == "`2") owner_name = worlded_->owner_name;
				else owner_name = worlded_->owner_named;
			}
		}
		top_overall_list += "\nadd_button|warp_to_" + top_tier[i].second + "|`w#" + to_string(i + 1) + "`` " + top_tier[i].second + " by `#" + owner_name + "`|noflags|0|0|";
	}
	if (top_overall_list == "") top_overall_list = "\nadd_smalltext|The list should update in few minutes.|\nadd_spacer|small|";

	sort(top_yesterday.begin(), top_yesterday.end());
	reverse(top_yesterday.begin(), top_yesterday.end());
	top_yesterday.resize((top_yesterday.size() >= 28 ? 28 : top_yesterday.size()));
	for (uint8_t i = 0; i < top_yesterday.size(); i++) {
		string owner_name = "", world_name = top_yesterday[i].second;
		//get_world(world_name);
		vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [world_name](const World& a) { return a.name == world_name; });
		if (paa != worlds.end()) {
			World* worlded_ = &worlds[paa - worlds.begin()];
			worlded_->yesterday = i + 1;
			owner_name = worlded_->owner_name;
			if (worlded_->owner_named != "") {
				if (worlded_->owner_named.substr(0, 2) == "`o" || worlded_->owner_named.substr(0, 2) == "`2") owner_name = worlded_->owner_name;
				else owner_name = worlded_->owner_named;
			}
		}
		top_yesterday_list += "\nadd_button|warp_to_" + top_yesterday[i].second + "|`w#" + to_string(i + 1) + "`` " + top_yesterday[i].second + " by `#" + owner_name + "`|noflags|0|0|";
	}
	if (top_yesterday_list.empty()) top_yesterday_list = "\nadd_smalltext|There was zero worlds with honors yesterday.|\nadd_spacer|small|";
	save_server_events();
}

inline void RandomlyDailyRiddles(int ID, string Dialog) {
	ofstream IDRiddle("database/Ancestral/IDDailyRiddles.txt");
	IDRiddle << ID;
	IDRiddle.close();
	ofstream Riddle("database/Ancestral/DailyRiddles.txt");
	Riddle << Dialog;
	Riddle.close();
}
void daily_ancient_riddle() {
	srand(time(NULL));
	ifstream ifs("database/Ancestral/DailyR.json");
	if (!ifs.is_open()) cout << "riddle reset error " << GetLastError() << endl;
	if (ifs.is_open()) {
		json j;
		ifs >> j;
		day_ = j["day"].get<uint8_t>();
	}
	day_;
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	today_day = newtime.tm_mday;
	if (day_ != today_day) {
		int Random = rand() % 43 + 1;
		day_ = today_day;
		ofstream o("database/Ancestral/DailyR.json");
		if (!o.is_open()) cout << "riddle reset error " << GetLastError() << endl;
		json j;
		j["day"] = day_;
		o << j << endl;
		o.close();
		if (Random == 1) {
			RandomlyDailyRiddles(982, "I see you wish to acquire greatness. I'd never block your efforts.");
		}
		else if (Random == 2) {
			RandomlyDailyRiddles(598, "This is a part of a fantasy, but I wouldn't want to be around it when it comes to a close.");
		}
		else if (Random == 3) {
			RandomlyDailyRiddles(320, "1812 is over, sure, but there's a way to bring it back. I can go on, but you should know how by now.");
		}
		else if (Random == 4) {
			RandomlyDailyRiddles(756, "Bring me a bandit. I don't even need all of him.");
		}
		else if (Random == 5) {
			RandomlyDailyRiddles(824, "I could never tell you what I want, because I'm not a fan of spoilers, and I'd prefer to keep things cool.");
		}
		else if (Random == 6) {
			RandomlyDailyRiddles(456, "My paradise is lost, but perhaps you can bring me halfway there.");
		}
		else if (Random == 7) {
			RandomlyDailyRiddles(480, "If you're a record breaker, stay away from this.");
		}
		else if (Random == 8) {
			RandomlyDailyRiddles(784, "I'd like a huckleberry. Know where I can find one?");
		}
		else if (Random == 9) {
			RandomlyDailyRiddles(658, "If you shoot this, would it be redundant? At the very least, I'll know you're bored.");
		}
		else if (Random == 10) {
			RandomlyDailyRiddles(1430, "Everyone asks the gods for these. Just once, I'd like to get one.");
		}
		else if (Random == 11) {
			RandomlyDailyRiddles(114, "You can silence this, but it will never die.");
		}
		else if (Random == 12) {
			RandomlyDailyRiddles(596, "A store full of wonders, none of which are for sale, is exactly the mark I'd like to spot.");
		}
		else if (Random == 13) {
			RandomlyDailyRiddles(286, "I'd like to remove some underlings from my employ. Give me a place to put them.");
		}
		else if (Random == 14) {
			RandomlyDailyRiddles(1048, "Spark my memories of the open range.");
		}
		else if (Random == 15) {
			RandomlyDailyRiddles(992, "I'd like a bright idea, but remember that I'm a city girl at heart.");
		}
		else if (Random == 16) {
			RandomlyDailyRiddles(1046, "I'm undecided, but I think the cowboy life calls to me on this one.");
		}
		else if (Random == 17) {
			RandomlyDailyRiddles(220, "Block out a little time to tune this the right way and that's what you'll have.");
		}
		else if (Random == 18) {
			RandomlyDailyRiddles(64, "If you ever had to use the bathroom in a dungeon, theres a chance you will put this together.");
		}
		else if (Random == 19) {
			RandomlyDailyRiddles(666, "Don't make an assumption, presume, or suppose - just take this for what it is and igneore the distractions.");
		}
		else if (Random == 20) {
			RandomlyDailyRiddles(684, "There aren't any drinks to be found here, but if they were, they'd be good for your blood.");
		}
		else if (Random == 21) {
			RandomlyDailyRiddles(872, "A creature of roads and rubber. It is dangerous to go alone, but even moreso, where beasts such as this are concerned.");
		}
		else if (Random == 22) {
			RandomlyDailyRiddles(866, "Time to get low. Perhaps this choice will cheese you off, but I suggest you move along.");
		}
		else if (Random == 23) {
			RandomlyDailyRiddles(1044, "It's worth more than a nickel, has nothing to do with chickens, and up to eight of them are correct, which I find baffling.");
		}
		else if (Random == 24) {
			RandomlyDailyRiddles(786, "Sorry, I can't quite racal what I wanted for this one. Call it a sign of the times.");
		}
		else if (Random == 25) {
			RandomlyDailyRiddles(1420, "Don't blink.");
		}
		else if (Random == 26) {
			RandomlyDailyRiddles(970, "Ag! You woke me up. I dreamt of when I was a smaller, simpler goddess. Perhaps you could remind me of that time?");
		}
		else if (Random == 27) {
			RandomlyDailyRiddles(260, "Find me a shimmering thing of wonder - I don't care what, so long as it's ausome!");
		}
		else if (Random == 28) {
			RandomlyDailyRiddles(186, "Bessie's a good name for a cow. Put it together with the sea France, and you have the first step in getting me what I want...");
		}
		else if (Random == 29) {
			RandomlyDailyRiddles(780, "2623, you'll know what to do. But there are alternates.");
		}
		else if (Random == 30) {
			RandomlyDailyRiddles(298, "Actually, I can't think of anything. Therefore, the opposite must do.");
		}
		else if (Random == 31) {
			RandomlyDailyRiddles(926, "Steel yourself, for I grow weary (or is it hungry?) and must set this discussion aside.");
		}
		else if (Random == 32) {
			RandomlyDailyRiddles(688, "These are spooky. I know everybody has one, but getting it to me is the key.");
		}
		else if (Random == 33) {
			RandomlyDailyRiddles(1002, "Hercules never defeated one of these, though, flames are still involved.");
		}
		else if (Random == 34) {
			RandomlyDailyRiddles(1530, "Whenever I sea these, I remember to keep quiet.");
		}
		else if (Random == 35) {
			RandomlyDailyRiddles(194, "Get me my favorite topping, and remember - I'm a fun girl.");
		}
		else if (Random == 36) {
			RandomlyDailyRiddles(334, "What's your favorite color? I can't decide between pink and yellow, so you'll have to bring me both.");
		}
		else if (Random == 37) {
			RandomlyDailyRiddles(1896, "I have trouble remembering things, so get me something that never forgets.");
		}
		else if (Random == 38) {
			RandomlyDailyRiddles(436, "Get me something to paint-and don't bangle it up.");
		}
		else if (Random == 39) {
			RandomlyDailyRiddles(454, "I want something strange, deadly, and otherworldly - but nothing from Mercury, please.");
		}
		else if (Random == 40) {
			RandomlyDailyRiddles(988, "Take one down from its perch and bring it here - just make sure you don't sluice it!");
		}
		else if (Random == 41) {
			RandomlyDailyRiddles(1312, "What do Vikings, Lumberjacks and Shrubbery have in common?");
		}
		else if (Random == 42) {
			RandomlyDailyRiddles(382, "I hate to break it to you, but it's time to give me some space.");
		}
		else if (Random == 43) {
			RandomlyDailyRiddles(922, "Most of the things I want are a mystery, but this one is especially so.");
		}
		else if (Random == 44) {
			RandomlyDailyRiddles(664, "I had a plan to get something tasty, but it's full of holes..");
		}
	}
}
void daily_quest() {
	srand(time(NULL));
	string dqitems = "", eventday = "";
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	today_day = newtime.tm_mday;
	int todayday = newtime.tm_wday;
	ifstream ifs("daily_quest.json");
	if (ifs.is_open()) {
		json j;
		ifs >> j;
		gems_c = j["gem_count"].get<int>();
		day_ = j["day"].get<int>();
	}
	if (day_ != today_day) {
		//vector<int> random_xy{ -1, 0 };
		//vector<int> list{ 231,487,483,2019,427,1757,2009,281,781,329,459,1041,421,2787,2789,1043,2797,181,613,65,4983,283,553,425,4635,987,627,2017,989,61,4639,973,3523,331,265,859,433,253,339,1105,439,4567,333,677,5673,1427,5603,183,10533,5731,7223,10833,6035,6813,1113,1047,653,2811,4703,1429,847,665,485,1613,833,2025,1775,3931,429,3831,423,437,1773,4767,1299,361,667,2815,3473,301,4637,5683,2709,415,955,461,861,9389,5467,2791,2815,1803,419,2027,685,555,741,10531,5729,7221,10831,6033,6811,621,6401,1107,359,3471,855,309,1685,1449,1309,441,1111,221,1431,3065,9307,1257,1501,1109,4641,3587,1103,417,743,431,3823,2949,1131,3825,727,5379,729,187,787,5459,4785,3261,3521,2293,2309,2321,2333,5461,3721,327,247,63,3479,445,4783,299,863,8935,1451,261,1871,1499,455,9391,683,1159,551,1745,411,3005,557,687,4799,559,4643,3899,1605,9309,567,565,1154,3827,1327,1767,993,1157,563,4721,115,1423,10515,1329,6545,287,669,777,5463,1655,1599,561,4585,3413,4745,1771,2011,1161,1729,3757,3753,321,3265,3263,623,775,6397,129,4667,759,3767,1529,6543,4707,3835,1435,651,8929,569,527,3287,1595,6063,2795,1003,1731,4943,4963,597,4669,1531,1523,625,4297,599,657,571,873,3755,2969,1725,4603,1447,3267,5375,1683 };
		//vector<int> list2{ 3567, 13, 57, 17, 381, 1139, 21, 101, 379, 117, 27, 23, 581, 195, 105, 191, 377, 1307, 697, 881, 167, 185, 1323, 165, 3783, 369, 25, 171, 53, 103, 179, 29, 249, 177, 1325, 337, 189, 169, 55, 223, 175, 885, 119, 3573, 199, 549, 681, 655, 107, 163, 31, 671, 889, 887, 193, 127, 1433, 173, 7631, 413, 3571, 3569, 2809, 9393, 225, 111, 109, 201, 59, 607, 285, 2029, 2013, 2015, 1611, 995, 997, 963, 1481, 219, 197, 2023, 2021, 9331, 1305, 823, 1039, 231, 487, 483, 2019, 427, 1757, 2009, 281, 781, 329, 459, 1041, 421, 2787, 2789, 1043, 2797, 181, 613, 65, 4983, 283, 553, 425, 4635, 987, 627, 2017, 989, 61, 4639, 973, 3523, 331, 265, 859, 433, 253, 339, 1105, 439, 4567, 333, 677, 5673, 1427, 5603, 183, 10533, 5731, 7223, 10833, 6035, 6813, 1113, 1047, 653, 2811, 4703, 1429, 847, 665 };
		//item1 = list[rand() % list.size()] + random_xy[rand() % random_xy.size()];
		//item2 = list2[rand() % list2.size()] + random_xy[rand() % random_xy.size()];
		//item1c = rand() % 150 + 1;
		//item2c = rand() % 150 + 1;
		gems_c = Algorithm::rand(10000, 200000);
		day_ = today_day;
		//dqitems += "" + to_string(item1c) + " " + items[item1].name + "\n" + to_string(item2c) + " " + items[item2].name + "";
		ofstream o("daily_quest.json");
		if (!o.is_open()) cout << "daily quest error " << GetLastError() << endl;
		json j;
		j["gem_count"] = gems_c;
		j["day"] = day_;
		o << j << endl;
		if (todayday == 1) eventday += ("Farming Day");
		else if (todayday == 2) eventday += ("Breaking Day");
		else if (todayday == 3) eventday += ("Geiger Day");
		else if (todayday == 4) eventday += ("Leveling Day");
		else if (todayday == 5) eventday += ("Extra Gems Day");
		else if (todayday == 6) eventday += ("Surgery Day");
		else if (todayday == 0) eventday += ("Fishing Day");
		string ancientriddle;
		ifstream newfile("database/Ancestral/DailyRiddles.txt", ios::in);
		if (newfile.is_open()) {
			getline(newfile, ancientriddle);
		}
		newfile.close();
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("`2*** The Daily Quest Update``: requires `$" + setGems(gems_c) + " gems``. Go tell the `5Crazy Jim``!");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
			p.CreatePacket(currentPeer);
			pInfo(currentPeer)->AlreadyDailyQ = false;
		}
	}
}

void loop_save(ENetPeer* peer) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (world_->save_time + 900000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			if (world_->save_time != 0) save_world(pInfo(peer)->world, false);
			world_->save_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (world_->World_Rating != 0) add_honors(pInfo(currentPeer)->world);
			}
			honors_reset();
		}
		if (world_->special_event == false && server_event_spawn + 30000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			int event_item = 0;
			if (rand() % 200 < 1 && world_->last_special_event + 90000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				vector<int> list = { 263,942,942,1396,4774,4522, 4774, 5002, 121, 1636, 2798, 2704, 3786, 1056, 528 };
				world_->special_event_item = list[rand() % list.size()];
				event_item = world_->special_event_item;
				world_->special_event = true;
				gamepacket_t p, p2;
				p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2" + items[world_->special_event_item].event_name + ":`` " + (items[world_->special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_->special_event_item].name + "```o.``" : "`#" + to_string(items[world_->special_event_item].event_total) + " " + items[world_->special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + ""), p.Insert("audio/cumbia_horns.wav"), p.Insert(0);
				p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_->special_event_item].event_name + ":`` " + (items[world_->special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_->special_event_item].name + "```o.``" : "`#" + to_string(items[world_->special_event_item].event_total) + " " + items[world_->special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + "");
				for (ENetPeer* currentPeer_event = server->peers; currentPeer_event < &server->peers[server->peerCount]; ++currentPeer_event) {
					if (currentPeer_event->state != ENET_PEER_STATE_CONNECTED or currentPeer_event->data == NULL or pInfo(currentPeer_event)->world != name_) continue;
					p.CreatePacket(currentPeer_event), p2.CreatePacket(currentPeer_event);
				}
				world_->last_special_event = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			/*
			else if (Zombie_Apocalypse && rand() % 3 < 1 && world_->last_special_event + 180000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				gamepacket_t p, p2, p3(0);
				p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2Zombie Apocalypse:`` `oIt's the Return of the Growing Dead!``"), p.Insert("audio/owooooo.wav"), p.Insert(0);
				p2.Insert("OnConsoleMessage"), p2.Insert("`2Zombie Apocalypse:`` `oIt's the Return of the Growing Dead!``");
				p3.Insert("OnSetCurrentWeather"), p3.Insert(31);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
					p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer), p3.CreatePacket(currentPeer);
					if (not has_playmod(pInfo(currentPeer), "Infected!")) {
						if (rand() % 2 < 1) {
							PlayMods give_playmod{};
							give_playmod.id = 28, give_playmod.time = time(nullptr) + 60;
							pInfo(currentPeer)->playmods.push_back(give_playmod);
							update_clothes(currentPeer, true);
						}
					}
				}
				world_->last_special_event = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}*/
			/*
			else if (Comet_Dust && rand() % 3 < 1 && world_->last_comet_spawn + 180000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				event_item = 2034;
				world_->last_comet_spawn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			else if (rand() % 2 < 1 && world_->last_comet_spawn + 420000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() && server_event_spawn + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (world_->last_comet_spawn != 0) event_item = 611;
				world_->last_comet_spawn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			*/
			if (event_item != 0) {
				tayo_info("Special event spawned in world: " + name_);
				server_event_spawn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				WorldDrop dropeerblock_{};
				dropeerblock_.count = 1, dropeerblock_.special = event_item == 2034 || event_item == 611 ? false : true;
				for (int i_ = 0; i_ < items[event_item].event_total; i_++) {
					dropeerblock_.id = event_item == 2034 ? (rand() % 100 < 25 ? 2036 : 2034) : world_->special_event_item, dropeerblock_.uid = uint16_t(world_->drop.size()) + 1, dropeerblock_.x = rand() % 99 * 32, dropeerblock_.y = rand() % 54 * 32;
					dropas_(world_, dropeerblock_);
				}
			}
		}
	}
	pInfo(peer)->save_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
}
auto load_tournament() -> void
{
	std::ifstream read("database/tournament_data.json"); 
	if (read.is_open()) 
	{
		json j;
		read >> j;
		tournament_players = j["tournament_players"].get<vector<int>>();
		tournament_board = j["tournament_board"].get<vector<pair<int, int>>>();
		fish_id = j["fish_id"].get<int>();
	}
}

auto save_tournament() -> void
{
	std::sort(tournament_board.begin(), tournament_board.end(), [](pair<int, int> a, pair<int, int> b) {
		return a.second > b.second;
	});
	
	if (tournament_board.size() >= 10) {
		tournament_board.resize(10);
		tournament_board.erase(tournament_board.begin() + 10, tournament_board.end());
	}

	std::ofstream write("database/tournament_data.json");
	//if (write.is_open())
	{
		json j;
		j["tournament_players"] = tournament_players;
		j["tournament_board"] = tournament_board;
		j["fish_id"] = fish_id;
		write << j << endl;
	}
}

auto start_tournament(ENetPeer* peer) -> void
{
	tournament_players.push_back((pInfo(peer)->uid));
	bool found = false;
	for (int i = 0; i < tournament_board.size(); i++) {
		if ((tournament_board[i].first) == (pInfo(peer)->uid)) {
			found = true;
			break;
		}
	}

	if (not found) {
		tournament_board.push_back(make_pair(pInfo(peer)->uid, pInfo(peer)->fishing_score));
	}
    
	pInfo(peer)->fishing_until = time(nullptr) + (60 * 5 * 1000);

	gamepacket_t p(0, pInfo(peer)->netID);
	p.Insert("OnCountdownStart"), p.Insert(300), p.Insert(pInfo(peer)->fishing_score);
	p.CreatePacket(peer);

	save_tournament();
}

auto end_player_tournament(ENetPeer* peer) -> void
{
	for (int i = 0; i < tournament_players.size(); i++) {
		if ((tournament_players[i]) == (pInfo(peer)->uid)) {
			{
				gamepacket_t p;
				p.Insert("OnCountdownEnd"), p.CreatePacket(peer);
				if (pInfo(peer)->fishing_score <= 0)
				{
					Algorithm::send_console(peer, "You don't get any score so your data won't be saved.");
					for (int i_ = 0; i_ < tournament_board.size(); i_++) {
						if ((tournament_board[i_].first) == (pInfo(peer)->uid))
							tournament_board.erase(tournament_board.begin() + i_);
					}
					return;
				}
				Algorithm::send_console(peer, format("Good achievement! You've reached {} scores until this time.", pInfo(peer)->fishing_score));
				for (int i_ = 0; i_ < tournament_board.size(); i_++) {
					if ((tournament_board[i_].first) == (pInfo(peer)->uid))
						tournament_board[i_] = make_pair(pInfo(peer)->uid, pInfo(peer)->fishing_score);
				}
				for (int i = 0; i < pInfo(peer)->playmods.size(); i++)
					if (pInfo(peer)->playmods[i].id == 126) 
						pInfo(peer)->playmods[i].time = 0;

				clear_tournament(peer, true);
				save_tournament();

				packet_(peer, "action|play_sfx\nfile|audio/race_end.wav\ndelayMS|0");
			}
		}
	}
}

auto clear_tournament(ENetPeer* peer, bool on_exit = false) -> void
{
	//pInfo(peer)->fishing_begin = 0;
	pInfo(peer)->fishing_until = 0;

	for (int i = 0; i < tournament_players.size(); i++) {
		if ((tournament_players[i]) == (pInfo(peer)->uid))
			tournament_players.erase(tournament_players.begin() + i);
	}

	//hemat uang
	if (on_exit) {
		/*
		for (int i = 0; i < tournament_board.size(); i++) {
			if (to_lower(tournament_board[i].first) == to_lower(pInfo(peer)->tankIDName))
				tournament_board.erase(tournament_board.begin() + i);
		}
		*/
		gamepacket_t p;
		p.Insert("OnCountdownEnd"), p.CreatePacket(peer);
	}
	save_tournament();
}

auto reset_tournament() -> void
{
	try {
		srand(time(nullptr));
		bool is_true = false;
		vector<int> lists = {3000, 3030, 3026, 3458, 5450, 5542, 5548, 3038, 3032, 8606, 3034, 5552, 3222, 
		3224, 3036, 3814, 5538, 3226, 5580, 5574, 4958,
		3024, 7744, 3094, 3092, 3096, 3220, 5448};
		struct tm newtime;
		time_t now = time(0);
		localtime_s(&newtime, &now);
		today_day = newtime.tm_mday;
		load_tournament();

		fish_id = lists[rand() % lists.size()];

		auto prize = [](int x) -> int {
			switch (x) {
			case 0: return 200000;
			case 1: return 100000;
			case 2: return 50000;
			default: return 0;
			}
		};

		string winners = "";
		vector<pair<string, int>> top_;
		if (not tournament_board.empty()) {
			std::sort(tournament_board.begin(), tournament_board.end(), [](pair<int, int> a, pair<int, int> b) {
				return a.second > b.second;
			});
			if (tournament_board.size() > 3) {
				tournament_board.resize(3);
				tournament_board.erase(tournament_board.begin() + 3, tournament_board.end());
			}
			for (int i = 0; i < tournament_board.size(); i++) {
				winners += format("{}. {} with {} points. (Won: {} gems)\n", i + 1, GetNameByUid(tournament_board[i].first), setGems(tournament_board[i].second), setGems(prize(i)));
				top_.push_back(make_pair(GetNameByUid(tournament_board[i].first), tournament_board[i].second));
				cout << "Pushed new data: " << top_[i].first << '|' << top_[i].second << ", index: " << i << '\n';
			}
		}

		vector<pair<string, int>> offline;
		if (not top_.empty()) {
			for (int i = 0; i < top_.size(); i++) {
				offline.push_back(make_pair(top_[i].first, prize(i)));
				cout << "Pushed new data: " << offline[i].first << '|' << offline[i].second << ", index: " << i << '\n';
				//top_.erase(top_.begin() + i);
			}
		}

		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("`2*** The Fishing Tournament Update``: requires `$" + items[fish_id].name + "``. Go to register in the `5Fishing Tournament``!");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->fishing_until != 0) is_true = true;
			packet_(currentPeer, "action|play_sfx\nfile|audio/cumbia_horns.wav\ndelayMS|0");
			p.CreatePacket(currentPeer);
			clear_tournament(currentPeer, is_true);
			if (not winners.empty())
				Algorithm::send_console(currentPeer, "The winners are: "), Algorithm::send_console(currentPeer, winners);
		}

		// bukan sumber masalah

		if (not offline.empty()) 
		{
			for (int i = 0; i < offline.size(); i++) 
			{
				cout << "Top Global " << i + 1 << ": " << offline[i].first << endl;
				ifstream ifs("database/players/" + offline[i].first + "_.json");
				int gems = 0;
				if (ifs.is_open()) {
					json j;
					ifs >> j;
					gems = j["gems"].get<int>();
				}
				{
					ifstream in("database/players/" + offline[i].first + "_.json");
					json infile = json::parse(in);
					infile["gems"] = gems + offline[i].second;
					ofstream out("database/players/" + offline[i].first + "_.json");
					out << setw(4) << infile << endl;
					in.close();
					out.close();
				}
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(offline[i].first)) {
						ifstream ifz("database/players/" + pInfo(currentPeer)->tankIDName + "_.json");
						int gems_ = 0;
						if (ifz.is_open()) {
							json j_;
							ifz >> j_;
							gems_ = j_["gems"].get<int>();
							pInfo(currentPeer)->gems = gems_;
							Algorithm::set_bux(currentPeer);
						}
					}
				}
			}
		}

		if (not tournament_players.empty()) tournament_players.clear();
		if (not tournament_board.empty()) tournament_board.clear();
		save_tournament();
	}
	catch (bad_alloc& e) {
		tayo_warn(e.what());
	}
}

auto show_tournament(ENetPeer* peer) -> void {
	std::sort(tournament_board.begin(), tournament_board.end(), [](pair<int, int> a, pair<int, int> b) {
		return a.second > b.second;
	});

	if (tournament_board.size() >= 10) {
		tournament_board.resize(10);
		tournament_board.erase(tournament_board.begin() + 10, tournament_board.end());
	}

	DialogBuilder db{ "`o" };
	db.add_label_icon(true, 9498, "`wTayoPs Fishing Tournament")
		.add_textbox("Rules of this tournament: ")
		.add_textbox("1. Once you clicked start, there'll be 5 minutes for you to fish.")
		.add_textbox("2. In this case, your scores will only be recorded if you caught the specified fish.")
		.add_textbox("3. After 5 minutes, your recorded score will be stored (unless if you have 0 score).")
		.add_textbox("4. Your name will be displayed in the board below. (Only if you have the enough score)")
		.add_textbox("5. The winners will be only top 1 - 3.").add_spacer(false);

	db.add_label_icon(false, 3732, "WARNING: This tournament will be reset in every 24 hours.")
		.add_label_icon(false, fish_id, format("Current fish to catch: {}", items[fish_id].name))
		.add_label_icon(false, 9498, "Current Top 10 Global Players: ");

	if (tournament_board.empty())
		db.add_textbox("Currently, there are no top players.");
	else
	    for (int i = 0; i < tournament_board.size(); i++) 
			db.add_textbox(format("{}. {} with {} points.", i + 1, GetNameByUid(tournament_board[i].first), setGems(tournament_board[i].second)));

	db.add_spacer(false).add_textbox("Prizes: ").add_smalltext("Top 1: 200,000 gems").add_smalltext("Top 2: 100,000 gems")
		.add_smalltext("Top 3: 50,000 gems");
	if (find(tournament_players.begin(), tournament_players.end(),
		(pInfo(peer)->uid)) == tournament_players.end()) {
		db.add_button("register_tour", "`wRegister");
	}
	db.end_dialog("fish_tour", "`wClose``", "").add_quick_exit();

	gamepacket_t p;
	p.Insert("OnDialogRequest"), p.Insert(db.to_string()), p.CreatePacket(peer);
}
uint16_t get_epoch_weather(WorldBlock block) {
	if (block.fg == 5958) {
		if (block.epoch_state.first[0] == true) return 38;
		if (block.epoch_state.first[1] == true) return 39;
		if (block.epoch_state.first[2] == true) return 40;
	}
	return 38;
}
inline void epoch_cycle() {
	for (int i = 0; i < worlds.size(); i++) {
		World* world_ = &worlds[i];
		int ySize = world_->blocks.size() / world_->width, xSize = world_->blocks.size() / ySize;
		for (int f = 0; f < world_->blocks.size(); f++) {
			int x = f % xSize, y = f / xSize;
			WorldBlock* block_ = &world_->blocks[f];
			if (block_->fg == 5958 && block_->flags & 0x00400000) {
				long long current_time = time(nullptr);
				if (block_->epoch_cycle - current_time <= 1) {
					if (world_->weather == 38) {
						world_->weather = (block_->epoch_state.first[1] == true ? 39 : block_->epoch_state.first[2] == true ? 40 : 38);
					}
					else if (world_->weather == 39) {
						world_->weather = (block_->epoch_state.first[2] == true ? 40 : block_->epoch_state.first[0] == true ? 38 : 39);
					}
					else if (world_->weather == 40) {
						world_->weather = (block_->epoch_state.first[0] == true ? 38 : block_->epoch_state.first[1] == true ? 38 : 40);
					}
					block_->epoch_cycle = current_time + (block_->epoch_state.second * 60);
					gamepacket_t p;
					p.Insert("OnSetCurrentWeather");
					p.Insert(world_->weather == 0 ? 4 : world_->weather);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							p.CreatePacket(currentPeer);
						}
					}
				}
			}
		}
	}
}
void save_affinity(Player* p_);
void save_player(Player* p_, bool on_exit = true) {
	if (p_->tankIDName.empty() or p_->email.empty()) return;
	if (saving_ and p_->saved_on_close) {
		gnettoken_db_logs("Player data already saved");
		return;
	}
	//saveall
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	p_->lo = "" + to_string(newtime.tm_mon + 1) + "/" + to_string(today_day) + "/2023 " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec) + "";
	json save_, achievements_ = json::array(), tradehis = json::array(), friends_ = json::array(), inv_ = json::array(), visited_worlds_ = json::array(), worlds_owned_ = json::array(), playmods_ = json::array(), trade_history_ = json::array();
	save_["transmute"] = p_->transmute;
	save_["userID"] = p_->uid;
	save_["name"] = p_->tankIDName;
	save_["guardian"] = p_->guardian;

	save_["modname"] = p_->modName;
	save_["reqname"] = p_->lastReqName;
	save_["totalplaytime"] = p_->roundedPlaytime;
	save_["n"] = p_->n;
	save_["vip"] = p_->vip;
	save_["vvip"] = p_->vvip;
	save_["glory"] = p_->glory;
	save_["mod"] = p_->mod;
	save_["admin"] = p_->admin;
	save_["dev"] = p_->dev;
	save_["crole"] = p_->crole;

	save_["owner"] = p_->owner;
	save_["staff"] = p_->staff;
	save_["umod"] = p_->umod;
	save_["mvp"] = p_->mvp;
	save_["founder"] = p_->founder;


	save_["musik"] = p_->musik;
	save_["udah_dft"] = p_->udah_daftar;
	save_["gotted"] = p_->udahan;
	save_["ray_level"] = p_->raylvl;
	save_["ray_exp"] = p_->expray;
	save_["supermod"] = p_->supermod;
	save_["m_h"] = p_->m_h;
	save_["cc"] = p_->cc;
	save_["opc"] = p_->opc;

	save_["choco"] = p_->valentine.chocolates;
	save_["slevel"] = p_->snackLevel;
	save_["glevel"] = p_->ghosts.level;
	save_["ttBadge"] = p_->ttBadge;
	save_["ccBadge"] = p_->ccBadge;
	save_["bans"] = p_->bans;
	save_["promo"] = p_->promo;
	save_["w_w"] = p_->w_w;
	save_["w_d"] = p_->w_d;
	save_["mer"] = p_->mercy;
	save_["datem"] = p_->dateMasterB_title;
	save_["drtt"] = p_->drtitle;
	save_["_drt"] = p_->drt;
	save_["dnr"] = p_->donor;
	save_["have_donor"] = p_->have_donor;
	save_["mst"] = p_->master;
	save_["have_master"] = p_->have_master;
	save_["p_7"] = p_->pure_shadow;
	save_["staged"] = p_->staged;
	save_["s4tb"] = p_->s4tb;
	save_["g_a_b"] = p_->grow_air_ballon;
	save_["eq_a"] = p_->eq_a;
	save_["mk_w"] = p_->MKW;
	save_["mk_p"] = p_->MKP;
	save_["warn_count"] = p_->Warning;
	save_["warnings"] = p_->Warning_Message;
	save_["notes"] = p_->Account_Notes;
	save_["alts"] = p_->Alt_Accounts;
	save_["spr"] = p_->sprite;
	save_["spr2"] = p_->wild;
	save_["spr3"] = p_->golem;
	save_["grm"] = p_->growmoji;
	save_["p_d1"] = p_->pinata_day;
	save_["p_d2"] = p_->pinata_prize;
	save_["p_d3"] = p_->pinata_claimed;
	// Kits
	save_["Kit"] = p_->startedKit;
	save_["kit_level"] = p_->lvlKit;
	save_["kit_xp"] = p_->xpKit;
	save_["kit_1"] = p_->kit1;
	save_["kit_2"] = p_->kit2;
	save_["kit_3"] = p_->kit3;
	save_["kit_4"] = p_->kit4;
	save_["kit_5"] = p_->kit5;
	save_["kit_6"] = p_->kit6;
	save_["kit_7"] = p_->kit7;
	save_["kit_8"] = p_->kit8;
	save_["kit_9"] = p_->kit9;
	save_["kit_10"] = p_->kit10;
	// Role Title & Skin
	save_["rSkin"] = p_->unlockRoleSkin;
	save_["rDrt"] = p_->titleDoctor;
	save_["rFst"] = p_->titleFisher;
	save_["rChf"] = p_->titleChef;
	save_["rStr"] = p_->titleStartopia;
	// Rift Wings
	save_["fixrw"] = p_->fixrw;
	save_["Wing_Time_Change"] = p_->Wing_Time_Change;
	save_["Wing_Cycle_Time"] = p_->Wing_Cycle_Time;
	save_["Wing_R_0"] = p_->Wing_R_0;
	save_["Wing_G_0"] = p_->Wing_G_0;
	save_["Wing_B_0"] = p_->Wing_B_0;
	save_["Wing_Metal_R_0"] = p_->Wing_Metal_R_0;
	save_["Wing_Metal_G_0"] = p_->Wing_Metal_G_0;
	save_["Wing_Metal_B_0"] = p_->Wing_Metal_B_0;
	save_["Wing_R_1"] = p_->Wing_R_1;
	save_["Wing_G_1"] = p_->Wing_G_1;
	save_["Wing_B_1"] = p_->Wing_B_1;
	save_["Wing_Metal_R_1"] = p_->Wing_Metal_R_1;
	save_["Wing_Metal_G_1"] = p_->Wing_Metal_G_1;
	save_["Wing_Metal_B_1"] = p_->Wing_Metal_B_1;
	save_["Closed_Wing_0"] = p_->Closed_Wing_0;
	save_["Open_Wing_0"] = p_->Open_Wing_0;
	save_["Stamp_Particle_0"] = p_->Stamp_Particle_0;
	save_["Trail_On_0"] = p_->Trail_On_0;
	save_["Trail_1st_0"] = p_->Trail_1st_0;
	save_["Trail_2nd_0"] = p_->Trail_2nd_0;
	save_["Trail_3rd_0"] = p_->Trail_3rd_0;
	save_["Material_1st_0"] = p_->Material_1st_0;
	save_["Material_2nd_0"] = p_->Material_2nd_0;
	save_["Material_3rd_0"] = p_->Material_3rd_0;
	save_["Closed_Wing_1"] = p_->Closed_Wing_1;
	save_["Open_Wing_1"] = p_->Open_Wing_1;
	save_["Stamp_Particle_1"] = p_->Stamp_Particle_1;
	save_["Trail_On_1"] = p_->Trail_On_1;
	save_["Trail_1st_1"] = p_->Trail_1st_1;
	save_["Trail_2nd_1"] = p_->Trail_2nd_1;
	save_["Trail_3rd_1"] = p_->Trail_3rd_1;
	save_["Material_1st_1"] = p_->Material_1st_1;
	save_["Material_2nd_1"] = p_->Material_2nd_1;
	save_["Material_3rd_1"] = p_->Material_3rd_1;
	save_["Wing_Value"] = p_->Wing_Value;
	save_["Wing_Color_0_Value"] = p_->Wing_Color_0_Value;
	save_["Wing_Metal_0_Value"] = p_->Wing_Metal_0_Value;
	save_["Wing_Color_1_Value"] = p_->Wing_Color_1_Value;
	save_["Wing_Metal_1_Value"] = p_->Wing_Metal_1_Value;
	// Rift Cape
	save_["Time_Change"] = p_->Time_Change;
	save_["Cycle_Time"] = p_->Cycle_Time;
	save_["Cape_R_0"] = p_->Cape_R_0;
	save_["Cape_G_0"] = p_->Cape_G_0;
	save_["Cape_B_0"] = p_->Cape_B_0;
	save_["Collar_R_0"] = p_->Collar_R_0;
	save_["Collar_G_0"] = p_->Collar_G_0;
	save_["Collar_B_0"] = p_->Collar_B_0;
	save_["Cape_R_1"] = p_->Cape_R_1;
	save_["Cape_G_1"] = p_->Cape_G_1;
	save_["Cape_B_1"] = p_->Cape_B_1;
	save_["Collar_R_1"] = p_->Collar_R_1;
	save_["Collar_G_1"] = p_->Collar_G_1;
	save_["Collar_B_1"] = p_->Collar_B_1;
	save_["Closed_Cape_0"] = p_->Closed_Cape_0;
	save_["Open_On_Move_0"] = p_->Open_On_Move_0;
	save_["Aura_0"] = p_->Aura_0;
	save_["Aura_1st_0"] = p_->Aura_1st_0;
	save_["Aura_2nd_0"] = p_->Aura_2nd_0;
	save_["Aura_3rd_0"] = p_->Aura_3rd_0;
	save_["Closed_Cape_1"] = p_->Closed_Cape_1;
	save_["Open_On_Move_1"] = p_->Open_On_Move_1;
	save_["Aura_1"] = p_->Aura_1;
	save_["Aura_1st_1"] = p_->Aura_1st_1;
	save_["Aura_2nd_1"] = p_->Aura_2nd_1;
	save_["Aura_3rd_1"] = p_->Aura_3rd_1;
	save_["Cape_Value"] = p_->Cape_Value;
	save_["Cape_Collor_0_Value"] = p_->Cape_Collor_0_Value;
	save_["Cape_Collar_0_Value"] = p_->Cape_Collar_0_Value;
	save_["Cape_Collor_1_Value"] = p_->Cape_Collor_1_Value;
	save_["Cape_Collar_1_Value"] = p_->Cape_Collar_1_Value;
	// Infinity Crown
	save_["Crown_Time_Change"] = p_->Crown_Time_Change;
	save_["Crown_Cycle_Time"] = p_->Crown_Cycle_Time;
	save_["Base_R_0"] = p_->Base_R_0;
	save_["Base_G_0"] = p_->Base_G_0;
	save_["Base_B_0"] = p_->Base_B_0;
	save_["Gem_R_0"] = p_->Gem_R_0;
	save_["Gem_G_0"] = p_->Gem_G_0;
	save_["Gem_B_0"] = p_->Gem_B_0;
	save_["Crystal_R_0"] = p_->Crystal_R_0;
	save_["Crystal_G_0"] = p_->Crystal_G_0;
	save_["Crystal_B_0"] = p_->Crystal_B_0;
	save_["Crown_Floating_Effect_0"] = p_->Crown_Floating_Effect_0;
	save_["Crown_Laser_Beam_0"] = p_->Crown_Laser_Beam_0;
	save_["Crown_Crystals_0"] = p_->Crown_Crystals_0;
	save_["Crown_Rays_0"] = p_->Crown_Rays_0;
	save_["Base_R_1"] = p_->Base_R_1;
	save_["Base_G_1"] = p_->Base_G_1;
	save_["Base_B_1"] = p_->Base_B_1;
	save_["Gem_R_1"] = p_->Gem_R_1;
	save_["Gem_G_1"] = p_->Gem_G_1;
	save_["Gem_B_1"] = p_->Gem_B_1;
	save_["Crystal_R_1"] = p_->Crystal_R_1;
	save_["Crystal_G_1"] = p_->Crystal_G_1;
	save_["Crystal_B_1"] = p_->Crystal_B_1;
	save_["Crown_Floating_Effect_1"] = p_->Crown_Floating_Effect_1;
	save_["Crown_Laser_Beam_1"] = p_->Crown_Laser_Beam_1;
	save_["Crown_Crystals_1"] = p_->Crown_Crystals_1;
	save_["Crown_Rays_1"] = p_->Crown_Rays_1;
	save_["Crown_Value"] = p_->Crown_Value;
	save_["Crown_Value_0_0"] = p_->Crown_Value_0_0;
	save_["Crown_Value_0_1"] = p_->Crown_Value_0_1;
	save_["Crown_Value_0_2"] = p_->Crown_Value_0_2;
	save_["Crown_Value_1_0"] = p_->Crown_Value_1_0;
	save_["Crown_Value_1_1"] = p_->Crown_Value_1_1;
	save_["Crown_Value_1_2"] = p_->Crown_Value_1_2;
	// Crown of Season
	save_["Aura_Season"] = p_->Aura_Season;
	save_["Trail_Season"] = p_->Trail_Season;
	// Banner Bandolier
	save_["Banner_Item"] = p_->Banner_Item;
	save_["Banner_Flag"] = p_->Banner_Flag;
	// Magic Magnet
	save_["Magnet_Item"] = p_->Magnet_Item;
	// Halloween
	save_["Darking_Sacrifice"] = p_->Darking_Sacrifice;
	save_["Task_Darking"] = p_->Task_Darking;
	save_["Task_Dark_Ticket"] = p_->Task_Dark_Ticket;
	save_["Task_Gift_Growganoth"] = p_->Task_Gift_Growganoth;
	save_["Task_Mountain"] = p_->Task_Mountain;
	// Legendary Quest
	save_["Last_lQuest"] = p_->lastquest;
	save_["lQuest_Active"] = p_->quest_active;
	save_["lQuest_Step"] = p_->quest_step;
	save_["lQuest_Prog"] = p_->quest_progress;
	// Carnival Quest
	save_["CQuest"] = p_->C_QuestActive;
	save_["CQItem"] = p_->C_DeliverID;
	save_["CQProg"] = p_->C_QuestProgress;
	save_["CQKind"] = p_->C_QuestKind;
	save_["CQNeed"] = p_->C_ProgressNeeded;
	save_["CQStep"] = p_->C_QuestStep;
	// Cheat
	save_["AFTime"] = p_->Cheat_AF_Time;
	save_["Antibounce"] = p_->Cheat_AB;
	save_["HideOther"] = p_->Cheat_HideOther;
	save_["HideChat"] = p_->Cheat_HideChat;
	save_["Autoclt"] = p_->Cheat_AutoCollect;
	save_["Fastpull"] = p_->Cheat_FastPull;
	save_["Fastdrp"] = p_->Cheat_FastDrop;
	save_["Fasttsh"] = p_->Cheat_FastTrash;
	save_["Spam_Text"] = p_->Cheat_Spam_Text;
	save_["Spam_Delay"] = p_->Cheat_Spam_Delay;
	save_["cspeed"] = p_->Cheat_Speed;
	save_["cjump"] = p_->Cheat_Jump;
	//
	save_["e_1"] = p_->hair_color;
	save_["e_2"] = p_->eye_drop;
	save_["e_3"] = p_->eye_lenses;

	save_["status"] = p_->p_status;
	save_["s_ach"] = p_->Show_Achievements;
	save_["s_uid"] = p_->show_uid;
	save_["s_wrl"] = p_->Show_OwnedWorlds;
	save_["s_age"] = p_->Show_AccountCreated;
	save_["s_hom"] = p_->Show_HomeWorld;
	/*
	save_["g4g_1"] = p_->grow4good_day;
	save_["g4g_2"] = p_->grow4good_rarity;
	save_["g4g_3"] = p_->grow4good_total_rarity;
	save_["g4g_4"] = p_->grow4good_wl;
	save_["g4g_5"] = p_->grow4good_total_wl;
	save_["g4g_6"] = p_->grow4good_donate_gems;
	save_["g4g_7"] = p_->grow4good_gems;
	save_["g4g_8"] = p_->grow4good_purchase_waving;
	save_["g4g_9"] = p_->grow4good_surgery;
	save_["g4g_10"] = p_->grow4good_fish;
	save_["g4g_11"] = p_->grow4good_points;
	save_["g4g_12"] = p_->grow4good_claim_prize;
	save_["g4g_13"] = p_->grow4good_claimed_prize;
	save_["g4g_14"] = p_->grow4good_break;
	save_["g4g_15"] = p_->grow4good_place;
	save_["g4g_16"] = p_->grow4good_trade;
	save_["g4g_17"] = p_->grow4good_sb;*/
	save_["fire"] = p_->fires;
	save_["Total_TopUp"] = p_->totaltopup;
	save_["Total_Wls"] = p_->totalWls;
	save_["Total_Worth"] = p_->totalNetWorth;
	save_["lvl125"] = p_->lvl125;
	save_["radio"] = p_->radio;
	save_["flagset"] = p_->flagset;
	save_["skl"] = p_->surgery_skill;
	save_["sgt"] = p_->surgery_type;
	save_["sd"] = p_->surgery_done;
	save_["su1"] = p_->su_8552_1;
	save_["su2"] = p_->su_8552_2;
	save_["egg"] = p_->egg;
	save_["glo"] = p_->glo;
	//save_["logs"] = p_->logs;
	save_["b_t"] = p_->b_t;
	save_["b_b"] = p_->b_b;
	save_["dd"] = p_->dd;
	save_["AlreadyDailyQ"] = p_->AlreadyDailyQ;
	save_["lo"] = p_->lo;
	save_["ip"] = p_->ip;
	save_["lastIP"] = p_->last_ip;
	save_["b_s"] = p_->b_s;
	save_["b_r"] = p_->b_r;
	save_["b_ra"] = p_->b_ra;
	save_["i_11818_1"] = p_->i_11818_1;
	save_["i_11818_2"] = p_->i_11818_2;
	save_["b_lvl"] = p_->b_lvl;
	save_["b_i"] = p_->b_i;
	save_["b_a"] = p_->b_a;
	save_["b_w"] = p_->b_w;
	save_["b_p"] = p_->b_p;
	save_["m_r"] = p_->m_r;
	save_["m_b"] = p_->m_b;
	save_["s_t"] = p_->s_t;
	save_["s_r"] = p_->s_r;
	save_["note"] = p_->note;
	save_["supp"] = p_->supp;
	save_["hs"] = p_->hs;
	save_["dds"] = p_->dds;
	save_["tk"] = p_->tk;
	save_["bb"] = p_->bb;
	save_["gtwl"] = p_->gtwl;
	save_["vip"] = p_->vip;
	save_["rb"] = p_->rb;
	save_["mds"] = p_->mds;
	save_["gr"] = p_->gr;
	save_["gp"] = p_->gp;
	save_["trdr"] = p_->trader;
	save_["gd"] = p_->gd;
	save_["glo_p"] = p_->glo_p;
	save_["lvl_p"] = p_->lvl_p;
	save_["surg_p"] = p_->surg_p;
	save_["t_p"] = p_->t_p;
	save_["bb_p"] = p_->bb_p;
	save_["ff_p"] = p_->ff_p;
	save_["p_p"] = p_->p_p;
	save_["g_p"] = p_->g_p;
	save_["t_xp"] = p_->t_xp;
	save_["bb_xp"] = p_->bb_xp;
	save_["ff_xp"] = p_->ff_xp;
	save_["s_xp"] = p_->s_xp;
	save_["g_xp"] = p_->g_xp;
	save_["p_xp"] = p_->p_xp;
	save_["t_lvl"] = p_->t_lvl;
	save_["bb_lvl"] = p_->bb_lvl;
	save_["ff_lvl"] = p_->ff_lvl;
	save_["g_lvl"] = p_->g_lvl;
	save_["p_lvl"] = p_->p_lvl;
	save_["s_lvl"] = p_->s_lvl;
	save_["b_l"] = p_->b_l;
	save_["bp"] = p_->bp;
	save_["flagmay"] = p_->flagmay;
	save_["pass"] = p_->tankIDPass, save_["email"] = p_->email, save_["last_online"] = p_->last_online;
	save_["gems"] = p_->gems;
	save_["punch"] = p_->punch_count;
	save_["home_world"] = p_->home_world;
	save_["show_location"] = p_->show_location_;
	save_["show_notifications"] = p_->show_friend_notifications_;
	save_["xp"] = p_->xp;
	save_["d_name"] = p_->d_name;
	save_["level"] = p_->level;
	save_["skin"] = p_->skin;
	save_["geiger"] = p_->geiger_;
	save_["ghost"] = p_->ghost;
	save_["invis"] = p_->invis;
	save_["date"] = p_->account_created;
	save_["booty_broken"] = p_->booty_broken;
	save_["playtime"] = p_->seconds + (time(NULL) - p_->playtime);
	save_["guild_id"] = p_->guild_id;
	save_["is_legend"] = p_->is_legend;
	save_["legend"] = p_->legend;
	save_["roleSkin"] = p_->roleSkin;
	save_["roleIcon"] = p_->roleIcon;
	save_["mac"] = p_->mac;
	save_["rid"] = p_->rid;
	save_["vid"] = p_->vid;
	save_["pid"] = p_->platformid;
	save_["lock_bank"] = p_->lockInBank; 
	save_["wk"] = p_->wk;
	for (int i_ = 0; i_ < p_->inv.size(); i_++) {
		json item_;
		item_["i"] = p_->inv[i_].id;
		item_["c"] = p_->inv[i_].count;
		item_["t"] = p_->inv[i_].transmuted;
		inv_.push_back(item_);
	}
	map<string, int>::iterator it;
	for (it = p_->achievements.begin(); it != p_->achievements.end(); it++) {
		json achievement_;
		achievement_["title"] = it->first;
		achievement_["progress"] = it->second;
		achievements_.push_back(achievement_);
	} for (int i_ = 0; i_ < p_->friends.size(); i_++) {
		json friend_;
		friend_["name"] = p_->friends[i_].name;
		friend_["uid"] = p_->friends[i_].uid;
		friend_["mute"] = p_->friends[i_].mute;
		friend_["block_trade"] = p_->friends[i_].block_trade;
		friend_["last_seen"] = p_->friends[i_].last_seen;
		friends_.push_back(friend_);
	} for (int i_ = 0; i_ < p_->last_visited_worlds.size(); i_++) {
		json world_;
		world_["name"] = p_->last_visited_worlds[i_];
		visited_worlds_.push_back(world_);
	}
	for (int i_ = 0; i_ < p_->worlds_owned.size(); i_++) {
		json world_;
		world_["name"] = p_->worlds_owned[i_];
		worlds_owned_.push_back(world_);
	} for (int i_ = 0; i_ < p_->playmods.size(); i_++) {
		json playmod_;
		playmod_["id"] = p_->playmods[i_].id;
		playmod_["time"] = p_->playmods[i_].time;
		playmod_["user"] = p_->playmods[i_].user;
		playmods_.push_back(playmod_);
	} for (int i_ = 0; i_ < p_->trade_history.size(); i_++) {
		json trd_history_;
		trd_history_["t_h"] = p_->trade_history[i_];
		trade_history_.push_back(trd_history_);
	}
	json blarneys_ = json::array();
	for (int i_ = 0; i_ < p_->completed_blarneys.size(); i_++) {
		json blarney_;
		blarney_["world"] = p_->completed_blarneys[i_][0];
		blarney_["time"] = p_->completed_blarneys[i_][1];
		blarneys_.push_back(blarney_);
	}
	save_["blarney"] = blarneys_;
	save_["playmods"] = playmods_;
	save_["worlds_owned"] = worlds_owned_;
	save_["last_worlds"] = visited_worlds_;
	save_["t_h"] = trade_history_;
	save_["inv"] = inv_;
	save_["achievements"] = achievements_;
	save_["friends"] = friends_;
	save_["hair"] = p_->hair, save_["shirt"] = p_->shirt, save_["pants"] = p_->pants, save_["feet"] = p_->feet, save_["face"] = p_->face, save_["hand"] = p_->hand, save_["back"] = p_->back, save_["mask"] = p_->mask, save_["necklace"] = p_->necklace, save_["ances"] = p_->ances;
	save_["cheat_fs"] = p_->Cheat_FastSpin;
	save_["u_fs"] = p_->unlocked_fs;
	save_["u_fp"] = p_->unlocked_fp;
	save_["u_as"] = p_->unlocked_as;
	save_["u_af"] = p_->unlocked_af;
	save_["u_ft"] = p_->unlocked_ft;
	save_["u_fd"] = p_->unlocked_fd;
	save_["u_at"] = p_->unlocked_at;
	save_["u_ab"] = p_->unlocked_ab;
	save_["u_ss"] = p_->unlocked_ss;
	save_["u_sj"] = p_->unlocked_sj;
	save_["u_hp"] = p_->unlocked_hp;
	save_["u_hc"] = p_->unlocked_hc;
	save_["hide_logs"] = p_->hide_logs;
	save_["void_1hit"] = p_->void_ray_1hit;
	save_["old_name"] = p_->old_name;
	save_["punch_sword"] = p_->punch_sword_time;
	save_["hide_reseller"] = p_->hide_reseller; 
	save_["superInvis"]["face"] = p_->superInvisFace;
	save_["superInvis"]["isSuperInvis"] = p_->isSuperInvis;
	save_["superInvis"]["name"] = p_->superInvisName;
	//Save_["uuid"] = p_->uuid;
	ofstream w_("database/players/" + p_->tankIDName + "_.json");
	if (w_.fail()) {
		tayo_warn("Error while writing database");
		gnettoken_db_logs("Failed to save " + p_->tankIDName + "_.json");
		return;
	}
	w_ << save_ << endl;
	save_affinity(p_);
	//write_uid_data(p_);
	w_.close();
	{
		if (on_exit) {
			uint32_t guild_id = p_->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
					GuildMember* edit_member = &guild_information->guild_members[i_];
					if (edit_member->member_name == p_->tankIDName) {
						edit_member->last_online = time(NULL);
						break;
					}
				}
			}
			vector<int> friends_;
			long long time_t = time(NULL);
			for (int c_ = 0; c_ < p_->friends.size(); c_++) {
				friends_.push_back(p_->friends[c_].uid);
			} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->m_h == 1) continue;
				if (pInfo(currentPeer)->invis == true) continue;
				pInfo(currentPeer)->last_online = time(NULL);
				if (find(friends_.begin(), friends_.end(), pInfo(currentPeer)->uid) != friends_.end()) {
					for (int d_ = 0; d_ < pInfo(currentPeer)->friends.size(); d_++) {
						if (pInfo(currentPeer)->friends[d_].uid == p_->uid) {
							pInfo(currentPeer)->friends[d_].last_seen = time_t;
							break;
						}
					}
					if (not p_->invis and not p_->m_h) {
						if (pInfo(currentPeer)->show_friend_notifications_) {
							packet_(currentPeer, "action|play_sfx\nfile|audio/friend_logoff.wav\ndelayMS|0");
							string color = "`o";
							if (p_->name_color == "`6@" or p_->name_color == "`b@" or p_->name_color == "`8@" or p_->name_color == "`#@"
								or p_->name_color == "") color = p_->name_color;
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`3FRIEND ALERT:`` " + color + p_->tankIDName + (is_reseller(p_->uid) and not p_->hide_reseller ? " `c[RESELLER]" : "") + "`` has `4logged off``.");
							p.CreatePacket(currentPeer);
						}
					}
					friends_.erase(remove(friends_.begin(), friends_.end(), pInfo(currentPeer)->uid), friends_.end());
				}
			}
			try {
				for (int c_ = 0; c_ < friends_.size(); c_++) {
					string path_ = "database/players/" + GetNameByUid(friends_.at(c_)) + "_.json";
					//if (exists(path_)) {
					if (_access_s(path_.c_str(), 0) == 0) {
						json r_;
						ifstream f_(path_, ifstream::binary);
						if (f_.fail()) {
							cout << "failed reading data for " << friends_.at(c_) << endl;
							return;
						}
						f_ >> r_;
						f_.close();
						json f_g = r_.at("friends").get<json>();
						for (int i_ = 0; i_ < f_g.size(); i_++) {
							if (f_g.at(i_).at("name") == p_->tankIDName) {
								f_g.at(i_).at("last_seen") = time_t;
								break;
							}
						}
						r_.at("friends") = f_g;
						{
							ofstream f_(path_, ifstream::binary);
							f_ << r_;
							f_.close();
						}
					}
				}
			}
			catch (exception)
			{
				return;
				//cout << "3 err " << e.what() << endl;
			}
		}
	}
}
void write_maintenance(bool maint) {
	string file_path = "database/maint.txt";
	ofstream file(file_path);
	if (file.is_open()) {
		file << (maint ? 1 : 0) << endl;
		file.close();
	}
	else cerr << "Error opening the file." << std::endl;
}
void read_maintenance(bool& maint) {
	string file_path = "database/maint.txt";
	ifstream file(file_path);

	if (file.is_open()) {
		int value;
		if (file >> value) maint = (value == 1 ? true : false);
		else cerr << "Error reading the file." << endl;
		file.close();
	}
	else cerr << "Error opening the file." << endl;
}
void down_save() {
	gnettoken_db_logs("Saving Players & Worlds");
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		save_player(pInfo(currentPeer), false);
	}
	for (int i = 0; i < static_cast<int>(worlds.size()); i++) {
		string world_name = worlds[i].name;
		save_world(world_name, false);
	}
	tayo_info("Successfully Saved all Worlds and Players");
	gnettoken_db_logs(to_string(worlds.size()) + " Worlds Saved");
	save_guilds();
	save_valentine();
	enet_host_flush(server);
	exit(0);
}
void trigger_save_() {
	if (not saving_) {
		cout << "Saving: [server/database/guilds]" << endl;
		//send_discord_webhook("<:gt_clock:1038657897166540890> Server Down, Read <#1036259914160541806>", "1048284827671085076/f96OM76LsIG50CpNT7NXIQ9FS8mfK5PkqBDRYEZTjumB-z6ofuG3qbL-QwPYdm966ydP");
		f_saving_ = true;
		saving_ = true;
		enet_host_flush(server);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			save_player(pInfo(currentPeer), false);
		}
		cout << "Saving WORLDS [" << worlds.size() << "]" << endl;
		for (int i = 0; i < worlds.size(); i++) {
			string world_name = worlds[i].name;
			save_world(world_name, false);
			Sleep(50);
		}
		cout << "Saving GUILDS" << endl;
		save_guilds();
		save_valentine();
		cout << "Saved: [server/database/guilds]" << endl;
		system("PAUSE");
		exit(0);
	}
}
void trigger_save_2() {
	if (not saving_) {
		cout << "Saving: [server/database/guilds]" << endl;
		//send_discord_webhook("<:gt_clock:1038657897166540890> Server Down, Read <#1036259914160541806>", "1048284827671085076/f96OM76LsIG50CpNT7NXIQ9FS8mfK5PkqBDRYEZTjumB-z6ofuG3qbL-QwPYdm966ydP");
		f_saving_ = true;
		saving_ = true;
		enet_host_flush(server);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			save_player(pInfo(currentPeer), false);
		}
		Sleep(2000);
		cout << "Saving WORLDS [" << worlds.size() << "]" << endl;
		for (int i = 0; i < worlds.size(); i++) {
			string world_name = worlds[i].name;
			save_world(world_name, false);
			Sleep(50);
		}
		cout << "Saving GUILDS" << endl;
		save_guilds();
		save_valentine();
		cout << "Saved: [server/database/guilds]" << endl;
	}
}
void save_all() {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		save_player(pInfo(currentPeer), false);
	}
	for (int i = 0; i < static_cast<int>(worlds.size()); i++) {
		string world_name = worlds[i].name;
		save_world(world_name, false);
	}
	save_guilds();
}

int auth_(ENetPeer* peer) {
	Player* p_ = pInfo(peer);
	string path_ = "database/players/" + p_->tankIDName + "_.json";
	if (_access_s(path_.c_str(), 0) == 0) {
		//cout << "login " << p_->tankIDName << endl;
		try {
			//saveall
			json r_;
			ifstream f_(path_, ifstream::binary);
			if (f_.fail()) {
				cout << "failed reading data for " << p_->tankIDName << endl;
				return -1;
			}
			f_ >> r_;
			f_.close();
			if (p_->tankIDPass != r_["pass"])
				return -1;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(p_->tankIDName) and to_lower(pInfo(currentPeer)->tankIDPass) == to_lower(p_->tankIDPass) and
					p_->onlineID != pInfo(currentPeer)->onlineID) {
					save_player(pInfo(currentPeer));
					if (p_->tankIDPass != r_["pass"])
						return -1;
					pInfo(currentPeer)->invalid_data = true;
					exit_(currentPeer, true);

					ifstream f_(path_, ifstream::binary);
					f_ >> r_;
					f_.close();
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`4ALREADY ON?! `o: This account was already online, kicking it off so you can log on. (if you were just playing before, this is nothing to worry about)");
					p.CreatePacket(peer);
					enet_peer_disconnect_later(currentPeer, 0);
					break;
				}
			}
			pInfo(peer)->onlineID = rand() % 83746384;
			json a_ = r_["inv"].get<json>(), b_ = r_["achievements"].get<json>(), c_ = r_["friends"].get<json>(), d_ = r_["last_worlds"].get<json>(), e_ = r_["worlds_owned"].get<json>(), th_ = r_["t_h"].get<json>();
			for (int i_ = 0; i_ < a_.size(); i_++) {
				Items item_{};
				item_.id = a_[i_]["i"].get<int>();
				item_.count = a_[i_]["c"].get<int>();
				item_.transmuted = (!(a_[i_].find("t") != a_[i_].end()) ? false : a_[i_]["t"].get<bool>());
				p_->inv.push_back(item_);
			} for (int i_ = 0; i_ < b_.size(); i_++) {
				p_->achievements.insert({ b_[i_]["title"].get<string>(), b_[i_]["progress"].get<int>() });
			} for (int i_ = 0; i_ < c_.size(); i_++) {
				Friends new_friend_;
				new_friend_.name = c_[i_]["name"].get<string>();
				new_friend_.uid = c_[i_]["uid"].get<int>();
				new_friend_.mute = c_[i_]["mute"].get<bool>();
				new_friend_.block_trade = c_[i_]["block_trade"].get<bool>();
				new_friend_.last_seen = c_[i_]["last_seen"].get<long long>();
				p_->friends.push_back(new_friend_);
			} for (int i_ = 0; i_ < d_.size(); i_++) {
				p_->last_visited_worlds.push_back(d_[i_]["name"].get<string>());
			} for (int i_ = 0; i_ < e_.size(); i_++) {
				p_->worlds_owned.push_back(e_[i_]["name"].get<string>());
			} for (int i_ = 0; i_ < th_.size(); i_++) {
				p_->trade_history.push_back(th_[i_]["t_h"].get<string>());
			}
			p_->last_online = (!(r_.find("last_online") != r_.end()) ? 0 : r_["last_online"].get<long long>());
			p_->legend = (!(r_.find("legend") != r_.end()) ? false : r_["legend"].get<int>());
			p_->is_legend = (!(r_.find("is_legend") != r_.end()) ? false : r_["is_legend"].get<int>());
			p_->bb = (!(r_.find("bb") != r_.end()) ? false : r_["bb"].get<bool>());
			p_->AlreadyDailyQ = (!(r_.find("AlreadyDailyQ") != r_.end()) ? false : r_["AlreadyDailyQ"].get<bool>());
			p_->dd = (!(r_.find("dd") != r_.end()) ? 0 : r_["dd"].get<int>());
			p_->supp = (!(r_.find("supp") != r_.end()) ? 0 : r_["supp"].get<int>());
			p_->hs = (!(r_.find("hs") != r_.end()) ? 0 : r_["hs"].get<int>());
			p_->dds = (!(r_.find("dds") != r_.end()) ? 0 : r_["dds"].get<int>());
			p_->tk = (!(r_.find("tk") != r_.end()) ? 0 : r_["tk"].get<int>());
			p_->note = (!(r_.find("note") != r_.end()) ? "" : r_["note"].get<string>());
			p_->d_name = (!(r_.find("d_name") != r_.end()) ? "" : r_["d_name"].get<string>());
			p_->gtwl = (!(r_.find("gtwl") != r_.end()) ? 0 : r_["gtwl"].get<int>());
			p_->vip = (!(r_.find("vip") != r_.end()) ? 0 : r_["vip"].get<int>());
			p_->rb = (!(r_.find("rb") != r_.end()) ? 0 : r_["rb"].get<int>());
			p_->mds = (!(r_.find("mds") != r_.end()) ? 0 : r_["mds"].get<int>());
			p_->gr = (!(r_.find("gr") != r_.end()) ? p_->gr : r_["gr"].get<vector<string>>());
			p_->gp = (!(r_.find("gp") != r_.end()) ? 0 : r_["gp"].get<int>());
			p_->trader = (!(r_.find("trdr") != r_.end()) ? 0 : r_["trdr"].get<int>());
			p_->gd = (!(r_.find("gd") != r_.end()) ? 0 : r_["gd"].get<int>());
			p_->glo = (!(r_.find("glo") != r_.end()) ? 0 : r_["glo"].get<int>());
			p_->glo_p = (!(r_.find("glo_p") != r_.end()) ? p_->glo_p : r_["glo_p"].get<vector<int>>());
			p_->lvl_p = (!(r_.find("lvl_p") != r_.end()) ? p_->lvl_p : r_["lvl_p"].get<vector<int>>());
			p_->surg_p = (!(r_.find("surg_p") != r_.end()) ? p_->surg_p : r_["surg_p"].get<vector<int>>());
			p_->t_p = (!(r_.find("t_p") != r_.end()) ? p_->t_p : r_["t_p"].get<vector<int>>());
			p_->bb_p = (!(r_.find("bb_p") != r_.end()) ? p_->bb_p : r_["bb_p"].get<vector<int>>());
			p_->ff_p = (!(r_.find("ff_p") != r_.end()) ? p_->ff_p : r_["ff_p"].get<vector<int>>());
			p_->p_p = (!(r_.find("p_p") != r_.end()) ? p_->p_p : r_["p_p"].get<vector<int>>());
			p_->ttBadge = (!(r_.find("ttBadge") != r_.end()) ? false : r_["ttBadge"].get<bool>());
			p_->ccBadge = (!(r_.find("ccBadge") != r_.end()) ? false : r_["ccBadge"].get<bool>());
			p_->g_p = (!(r_.find("g_p") != r_.end()) ? p_->g_p : r_["g_p"].get<vector<int>>());
			p_->t_xp = (!(r_.find("t_xp") != r_.end()) ? 0 : r_["t_xp"].get<int>());
			p_->bb_xp = (!(r_.find("bb_xp") != r_.end()) ? 0 : r_["bb_xp"].get<int>());
			p_->ff_xp = (!(r_.find("ff_xp") != r_.end()) ? 0 : r_["ff_xp"].get<int>());
			p_->s_xp = (!(r_.find("s_xp") != r_.end()) ? 0 : r_["s_xp"].get<int>());
			p_->g_xp = (!(r_.find("g_xp") != r_.end()) ? 0 : r_["g_xp"].get<int>());
			p_->p_xp = (!(r_.find("p_xp") != r_.end()) ? 0 : r_["p_xp"].get<int>());
			p_->t_lvl = (!(r_.find("t_lvl") != r_.end()) ? 0 : r_["t_lvl"].get<int>());
			p_->bb_lvl = (!(r_.find("bb_lvl") != r_.end()) ? 0 : r_["bb_lvl"].get<int>());
			p_->ff_lvl = (!(r_.find("ff_lvl") != r_.end()) ? 0 : r_["ff_lvl"].get<int>());
			p_->s_lvl = (!(r_.find("s_lvl") != r_.end()) ? 0 : r_["s_lvl"].get<int>());
			p_->g_lvl = (!(r_.find("g_lvl") != r_.end()) ? 0 : r_["g_lvl"].get<int>());
			p_->p_lvl = (!(r_.find("p_lvl") != r_.end()) ? 0 : r_["p_lvl"].get<int>());
			p_->b_l = (!(r_.find("b_l") != r_.end()) ? 1 : r_["b_l"].get<int>());
			p_->bp = (!(r_.find("bp") != r_.end()) ? p_->bp : r_["bp"].get<vector<pair<int, int>>>());
			p_->flagmay = (!(r_.find("flagmay") != r_.end()) ? p_->flagmay : r_["flagmay"].get<int>());
			p_->cc = (!(r_.find("cc") != r_.end()) ? p_->cc : r_["cc"].get<int>());
			p_->opc = (!(r_.find("opc") != r_.end()) ? p_->opc : r_["opc"].get<int>());
			p_->valentine.chocolates = (!(r_.find("choco") != r_.end()) ? p_->valentine.chocolates : r_["choco"].get<uint64_t>());
			p_->snackLevel = (!(r_.find("slevel") != r_.end()) ? p_->snackLevel : r_["slevel"].get<int>());
			p_->ghosts.level = (!(r_.find("glevel") != r_.end()) ? p_->ghosts.level : r_["glevel"].get<int>());
			p_->dev = (!(r_.find("dev") != r_.end()) ? p_->dev : r_["dev"].get<int>());
			p_->crole = (!(r_.find("crole") != r_.end()) ? p_->crole : r_["crole"].get<int>());

			p_->supermod = (!(r_.find("supermod") != r_.end()) ? p_->supermod : r_["supermod"].get<int>());
			p_->owner = (!(r_.find("owner") != r_.end()) ? p_->owner : r_["owner"].get<int>());
			p_->staff = (!(r_.find("staff") != r_.end()) ? p_->staff : r_["staff"].get<int>());
			p_->founder = (!(r_.find("founder") != r_.end()) ? p_->founder : r_["founder"].get<int>());



			p_->umod = (!(r_.find("umod") != r_.end()) ? p_->umod : r_["umod"].get<int>());
			p_->mvp = (!(r_.find("mvp") != r_.end()) ? p_->mvp : r_["mvp"].get<int>());
			p_->musik = (!(r_.find("musik") != r_.end()) ? p_->musik : r_["musik"].get<int>());
			p_->udah_daftar = (!(r_.find("udah_dft") != r_.end()) ? p_->udah_daftar : r_["udah_dft"].get<bool>());
			p_->udahan = (!(r_.find("gotted") != r_.end()) ? p_->udahan : r_["gotted"].get<int>());
			p_->raylvl = (!(r_.find("ray_level") != r_.end()) ? p_->raylvl : r_["ray_level"].get<int>());
			p_->expray = (!(r_.find("ray_exp") != r_.end()) ? p_->expray : r_["ray_exp"].get<int>());
			p_->b_i = (!(r_.find("b_i") != r_.end()) ? p_->b_i : r_["b_i"].get<int>());
			p_->b_a = (!(r_.find("b_a") != r_.end()) ? p_->b_a : r_["b_a"].get<int>());
			p_->b_w = (!(r_.find("b_w") != r_.end()) ? p_->b_w : r_["b_w"].get<int>());
			p_->b_p = (!(r_.find("b_p") != r_.end()) ? p_->b_p : r_["b_p"].get<int>());
			p_->surgery_skill = (!(r_.find("skl") != r_.end()) ? p_->surgery_skill : r_["skl"].get<int>());
			p_->surgery_type = (!(r_.find("sgt") != r_.end()) ? p_->surgery_type : r_["sgt"].get<int>());
			p_->surgery_done = (!(r_.find("sd") != r_.end()) ? p_->surgery_done : r_["sd"].get<int>());
			p_->su_8552_1 = (!(r_.find("su1") != r_.end()) ? p_->su_8552_1 : r_["su1"].get<int>());
			p_->su_8552_2 = (!(r_.find("su2") != r_.end()) ? p_->su_8552_2 : r_["su2"].get<int>());
			p_->b_ra = (!(r_.find("b_ra") != r_.end()) ? p_->b_ra : r_["b_ra"].get<int>());
			p_->b_lvl = (!(r_.find("b_lvl") != r_.end()) ? p_->b_lvl : r_["b_lvl"].get<int>());
			p_->i_11818_1 = (!(r_.find("i_11818_1") != r_.end()) ? p_->i_11818_1 : r_["i_11818_1"].get<signed char>());
			p_->i_11818_2 = (!(r_.find("i_11818_2") != r_.end()) ? p_->i_11818_2 : r_["i_11818_2"].get<signed char>());
			p_->roleSkin = (!(r_.find("roleSkin") != r_.end()) ? 6 : r_["roleSkin"].get<int>());
			p_->roleIcon = (!(r_.find("roleIcon") != r_.end()) ? 6 : r_["roleIcon"].get<int>());
			p_->promo = (!(r_.find("promo") != r_.end()) ? p_->promo : r_["promo"].get<int>());
			p_->flagset = (!(r_.find("flagset") != r_.end()) ? p_->flagset : r_["flagset"].get<int>());
			p_->radio = (!(r_.find("radio") != r_.end()) ? p_->radio : r_["radio"].get<int>());
			p_->w_w = (!(r_.find("w_w") != r_.end()) ? p_->w_w : r_["w_w"].get<int>());
			p_->w_d = (!(r_.find("w_d") != r_.end()) ? p_->w_d : r_["w_d"].get<int>());
			p_->egg = (!(r_.find("egg") != r_.end()) ? p_->egg : r_["egg"].get<int>());
			p_->mercy = (!(r_.find("mer") != r_.end()) ? p_->mercy : r_["mer"].get<bool>());
			p_->drtitle = (!(r_.find("drtt") != r_.end()) ? p_->drtitle : r_["drtt"].get<bool>());
			p_->dateMasterB_title = (!(r_.find("datem") != r_.end()) ? p_->dateMasterB_title : r_["datem"].get<bool>());

			p_->drt = (!(r_.find("_drt") != r_.end()) ? p_->drt : r_["_drt"].get<bool>());
			p_->lvl125 = (!(r_.find("lvl125") != r_.end()) ? p_->lvl125 : r_["lvl125"].get<bool>());
			p_->donor = (!(r_.find("dnr") != r_.end()) ? p_->donor : r_["dnr"].get<int>());
			p_->master = (!(r_.find("mst") != r_.end()) ? p_->master : r_["mst"].get<int>());
			p_->have_master = p_->master ? true : (!(r_.find("have_master") != r_.end()) ? p_->have_master : r_["have_master"].get<int>());
			p_->have_donor = p_->donor ? true : (!(r_.find("have_donor") != r_.end()) ? p_->have_donor : r_["have_donor"].get<int>());
			if (!(r_.find("p_7") == r_.end())) {
				p_->pure_shadow = r_["p_7"].get<uint8_t>();
			}
			if (!(r_.find("e_1") == r_.end())) {
				p_->hair_color = r_["e_1"].get<uint32_t>();
				p_->eye_drop = r_["e_2"].get<uint32_t>();
				p_->eye_lenses = r_["e_3"].get<uint32_t>();
			}
			if (!r_["superInvis"].is_null()) {
				p_->isSuperInvis = r_["superInvis"]["isSuperInvis"].get<bool>();
				p_->superInvisFace = r_["superInvis"]["face"].get<int>();
				p_->superInvisName = r_["superInvis"]["name"].get<std::string>();
			}
			p_->eq_a = (!(r_.find("eq_a") != r_.end()) ? p_->eq_a : r_["eq_a"].get<int>());
			p_->MKW = (!(r_.find("mk_w") != r_.end()) ? p_->MKW : r_["mk_w"].get<bool>());
			p_->MKP = (!(r_.find("mk_p") != r_.end()) ? p_->MKP : r_["mk_p"].get<bool>());
			p_->grow_air_ballon = (!(r_.find("g_a_b") != r_.end()) ? p_->grow_air_ballon : r_["g_a_b"].get<uint8_t>());
			p_->sprite = (!(r_.find("spr") != r_.end()) ? p_->sprite : r_["spr"].get<uint8_t>());
			p_->wild = (!(r_.find("spr2") != r_.end()) ? p_->wild : r_["spr2"].get<uint8_t>());
			p_->golem = (!(r_.find("spr3") != r_.end()) ? p_->golem : r_["spr3"].get<uint8_t>());
			p_->Warning = (!(r_.find("warn_count") != r_.end()) ? p_->Warning : r_["warn_count"].get<int>());
			p_->Warning_Message = (!(r_.find("warnings") != r_.end()) ? p_->Warning_Message : r_["warnings"].get<vector<string>>());
			p_->Account_Notes = (!(r_.find("notes") != r_.end()) ? p_->Account_Notes : r_["notes"].get<vector<string>>());
			p_->Alt_Accounts = (!(r_.find("alts") != r_.end()) ? p_->Alt_Accounts : r_["alts"].get<vector<string>>());
			p_->pinata_day = (!(r_.find("p_d1") != r_.end()) ? p_->pinata_day : r_["p_d1"].get<int>());
			p_->pinata_prize = (!(r_.find("p_d2") != r_.end()) ? p_->pinata_prize : r_["p_d2"].get<bool>());
			p_->pinata_claimed = (!(r_.find("p_d3") != r_.end()) ? p_->pinata_claimed : r_["p_d3"].get<bool>());
			p_->lockInBank = r_.find("lock_bank") == r_.end() ? p_->lockInBank : r_["lock_bank"].get<uint64_t>();
			p_->Darking_Sacrifice = (!(r_.find("Darking_Sacrifice") != r_.end()) ? p_->Darking_Sacrifice : r_["Darking_Sacrifice"].get<int>());
			p_->Task_Darking = (!(r_.find("Task_Darking") != r_.end()) ? p_->Task_Darking : r_["Task_Darking"].get<int>());
			p_->Task_Dark_Ticket = (!(r_.find("Task_Dark_Ticket") != r_.end()) ? p_->Task_Dark_Ticket : r_["Task_Dark_Ticket"].get<int>());
			p_->Task_Gift_Growganoth = (!(r_.find("Task_Gift_Growganoth") != r_.end()) ? p_->Task_Gift_Growganoth : r_["Task_Gift_Growganoth"].get<int>());
			p_->Task_Mountain = (!(r_.find("Task_Mountain") != r_.end()) ? p_->Task_Mountain : r_["Task_Mountain"].get<int>());
			p_->quest_active = (!(r_.find("lQuest_Active") != r_.end()) ? false : r_["lQuest_Active"].get<bool>());
			p_->lastquest = (!(r_.find("Last_lQuest") != r_.end()) ? "" : r_["Last_lQuest"].get<string>());
			p_->quest_step = (!(r_.find("lQuest_Step") != r_.end()) ? 0 : r_["lQuest_Step"].get<int>());
			p_->quest_progress = (!(r_.find("lQuest_Prog") != r_.end()) ? 0 : r_["lQuest_Prog"].get<int>());
			p_->C_QuestActive = (!(r_.find("CQuest") != r_.end()) ? p_->C_QuestActive : r_["CQuest"].get<bool>());
			p_->C_DeliverID = (!(r_.find("CQItem") != r_.end()) ? p_->C_DeliverID : r_["CQItem"].get<int>());
			p_->C_QuestProgress = (!(r_.find("CQProg") != r_.end()) ? p_->C_QuestProgress : r_["CQProg"].get<int>());
			p_->C_QuestKind = (!(r_.find("CQKind") != r_.end()) ? p_->C_QuestKind : r_["CQKind"].get<int>());
			p_->C_ProgressNeeded = (!(r_.find("CQNeed") != r_.end()) ? p_->C_ProgressNeeded : r_["CQNeed"].get<int>());
			p_->C_QuestStep = (!(r_.find("CQStep") != r_.end()) ? p_->C_QuestStep : r_["CQStep"].get<int>());
			p_->Cheat_AF_Time = (!(r_.find("AFTime") != r_.end()) ? p_->Cheat_AF_Time : r_["AFTime"].get<long long int>());
			p_->Cheat_HideOther = (!(r_.find("HideOther") != r_.end()) ? p_->Cheat_HideOther : r_["HideOther"].get<bool>());
			p_->Cheat_HideChat = (!(r_.find("HideChat") != r_.end()) ? p_->Cheat_HideChat : r_["HideChat"].get<bool>());
			p_->Cheat_AB = (!(r_.find("Antibounce") != r_.end()) ? p_->Cheat_AB : r_["Antibounce"].get<bool>());
			p_->Cheat_AutoCollect = (!(r_.find("Autoclt") != r_.end()) ? p_->Cheat_AutoCollect : r_["Autoclt"].get<bool>());
			p_->Cheat_FastPull = (!(r_.find("Fastpull") != r_.end()) ? p_->Cheat_FastPull : r_["Fastpull"].get<bool>());
			p_->Cheat_FastDrop = (!(r_.find("Fastdrp") != r_.end()) ? p_->Cheat_FastDrop : r_["Fastdrp"].get<bool>());
			p_->Cheat_FastTrash = (!(r_.find("Fasttsh") != r_.end()) ? p_->Cheat_FastTrash : r_["Fasttsh"].get<bool>());
			p_->Cheat_Jump = (!(r_.find("cjump") != r_.end()) ? p_->Cheat_Jump : r_["cjump"].get<bool>());
			p_->Cheat_Speed = (!(r_.find("cspeed") != r_.end()) ? p_->Cheat_Speed : r_["cspeed"].get<bool>());
			p_->Cheat_Spam_Text = (!(r_.find("Spam_Text") != r_.end()) ? p_->Cheat_Spam_Text : r_["Spam_Text"].get<string>());
			p_->Cheat_Spam_Delay = (!(r_.find("Spam_Delay") != r_.end()) ? p_->Cheat_Spam_Delay : r_["Spam_Delay"].get<int>());
			p_->staged = (!(r_.find("staged") != r_.end()) ? p_->staged : r_["staged"].get<int>());
			p_->s4tb = (!(r_.find("s4tb") != r_.end()) ? p_->s4tb : r_["s4tb"].get<int>());
			p_->p_status = (!(r_.find("status") != r_.end()) ? p_->p_status : r_["status"].get<int>());
			p_->Show_Achievements = (!(r_.find("s_ach") != r_.end()) ? p_->Show_Achievements : r_["s_ach"].get<bool>());
			p_->show_uid = (!(r_.find("s_uid") != r_.end()) ? p_->show_uid : r_["s_uid"].get<bool>());
			p_->Show_OwnedWorlds = (!(r_.find("s_wrl") != r_.end()) ? p_->Show_OwnedWorlds : r_["s_wrl"].get<bool>());
			p_->Show_AccountCreated = (!(r_.find("s_age") != r_.end()) ? p_->Show_AccountCreated : r_["s_age"].get<bool>());
			p_->Show_HomeWorld = (!(r_.find("s_hom") != r_.end()) ? p_->Show_HomeWorld : r_["s_hom"].get<bool>());
			// Kits
			p_->startedKit = (!(r_.find("Kit") != r_.end()) ? p_->startedKit : r_["Kit"].get<bool>());
			p_->lvlKit = (!(r_.find("kit_level") != r_.end()) ? p_->lvlKit : r_["kit_level"].get<int>());
			p_->xpKit = (!(r_.find("kit_xp") != r_.end()) ? p_->xpKit : r_["kit_xp"].get<int>());
			p_->kit1 = (!(r_.find("kit_1") != r_.end()) ? p_->kit1 : r_["kit_1"].get<bool>());
			p_->kit2 = (!(r_.find("kit_2") != r_.end()) ? p_->kit2 : r_["kit_2"].get<bool>());
			p_->kit3 = (!(r_.find("kit_3") != r_.end()) ? p_->kit3 : r_["kit_3"].get<bool>());
			p_->kit4 = (!(r_.find("kit_4") != r_.end()) ? p_->kit4 : r_["kit_4"].get<bool>());
			p_->kit5 = (!(r_.find("kit_5") != r_.end()) ? p_->kit5 : r_["kit_5"].get<bool>());
			p_->kit6 = (!(r_.find("kit_6") != r_.end()) ? p_->kit6 : r_["kit_6"].get<bool>());
			p_->kit7 = (!(r_.find("kit_7") != r_.end()) ? p_->kit7 : r_["kit_7"].get<bool>());
			p_->kit8 = (!(r_.find("kit_8") != r_.end()) ? p_->kit8 : r_["kit_8"].get<bool>());
			p_->kit9 = (!(r_.find("kit_9") != r_.end()) ? p_->kit9 : r_["kit_9"].get<bool>());
			p_->kit10 = (!(r_.find("kit_10") != r_.end()) ? p_->kit10 : r_["kit_10"].get<bool>());
			// Role Title & Skin
			p_->unlockRoleSkin = (!(r_.find("rSkin") != r_.end()) ? p_->unlockRoleSkin : r_["rSkin"].get<bool>());
			p_->titleDoctor = (!(r_.find("rDrt") != r_.end()) ? p_->titleDoctor : r_["rDrt"].get<bool>());
			p_->titleFisher = (!(r_.find("rFst") != r_.end()) ? p_->titleFisher : r_["rFst"].get<bool>());
			p_->titleChef = (!(r_.find("rChf") != r_.end()) ? p_->titleChef : r_["rChf"].get<bool>());
			p_->titleStartopia = (!(r_.find("rStr") != r_.end()) ? p_->titleStartopia : r_["rStr"].get<bool>());
			// Rift Wings
			p_->fixrw = (!(r_.find("fixrw") != r_.end()) ? p_->fixrw : r_["fixrw"].get<bool>());
			p_->Wing_Time_Change = (!(r_.find("Wing_Time_Change") != r_.end()) ? p_->Wing_Time_Change : r_["Wing_Time_Change"].get<bool>());
			p_->Wing_Cycle_Time = (!(r_.find("Wing_Cycle_Time") != r_.end()) ? p_->Wing_Cycle_Time : r_["Wing_Cycle_Time"].get<int>());
			p_->Wing_R_0 = (!(r_.find("Wing_R_0") != r_.end()) ? p_->Wing_R_0 : r_["Wing_R_0"].get<int>());
			p_->Wing_G_0 = (!(r_.find("Wing_G_0") != r_.end()) ? p_->Wing_G_0 : r_["Wing_G_0"].get<int>());
			p_->Wing_B_0 = (!(r_.find("Wing_B_0") != r_.end()) ? p_->Wing_B_0 : r_["Wing_B_0"].get<int>());
			p_->Wing_Metal_R_0 = (!(r_.find("Wing_Metal_R_0") != r_.end()) ? p_->Wing_Metal_R_0 : r_["Wing_Metal_R_0"].get<int>());
			p_->Wing_Metal_G_0 = (!(r_.find("Wing_Metal_G_0") != r_.end()) ? p_->Wing_Metal_G_0 : r_["Wing_Metal_G_0"].get<int>());
			p_->Wing_Metal_B_0 = (!(r_.find("Wing_Metal_B_0") != r_.end()) ? p_->Wing_Metal_B_0 : r_["Wing_Metal_B_0"].get<int>());
			p_->Wing_R_1 = (!(r_.find("Wing_R_1") != r_.end()) ? p_->Wing_R_1 : r_["Wing_R_1"].get<int>());
			p_->Wing_G_1 = (!(r_.find("Wing_G_1") != r_.end()) ? p_->Wing_G_1 : r_["Wing_G_1"].get<int>());
			p_->Wing_B_1 = (!(r_.find("Wing_B_1") != r_.end()) ? p_->Wing_B_1 : r_["Wing_B_1"].get<int>());
			p_->Wing_Metal_R_1 = (!(r_.find("Wing_Metal_R_1") != r_.end()) ? p_->Wing_Metal_R_1 : r_["Wing_Metal_R_1"].get<int>());
			p_->Wing_Metal_G_1 = (!(r_.find("Wing_Metal_G_1") != r_.end()) ? p_->Wing_Metal_G_1 : r_["Wing_Metal_G_1"].get<int>());
			p_->Wing_Metal_B_1 = (!(r_.find("Wing_Metal_B_1") != r_.end()) ? p_->Wing_Metal_B_1 : r_["Wing_Metal_B_1"].get<int>());
			p_->Closed_Wing_0 = (!(r_.find("Closed_Wing_0") != r_.end()) ? p_->Closed_Wing_0 : r_["Closed_Wing_0"].get<bool>());
			p_->Open_Wing_0 = (!(r_.find("Open_Wing_0") != r_.end()) ? p_->Open_Wing_0 : r_["Open_Wing_0"].get<bool>());
			p_->Stamp_Particle_0 = (!(r_.find("Stamp_Particle_0") != r_.end()) ? p_->Stamp_Particle_0 : r_["Stamp_Particle_0"].get<bool>());
			p_->Trail_On_0 = (!(r_.find("Trail_On_0") != r_.end()) ? p_->Trail_On_0 : r_["Trail_On_0"].get<bool>());
			p_->Trail_1st_0 = (!(r_.find("Trail_1st_0") != r_.end()) ? p_->Trail_1st_0 : r_["Trail_1st_0"].get<bool>());
			p_->Trail_2nd_0 = (!(r_.find("Trail_2nd_0") != r_.end()) ? p_->Trail_2nd_0 : r_["Trail_2nd_0"].get<bool>());
			p_->Trail_3rd_0 = (!(r_.find("Trail_3rd_0") != r_.end()) ? p_->Trail_3rd_0 : r_["Trail_3rd_0"].get<bool>());
			p_->Material_1st_0 = (!(r_.find("Material_1st_0") != r_.end()) ? p_->Material_1st_0 : r_["Material_1st_0"].get<bool>());
			p_->Material_2nd_0 = (!(r_.find("Material_2nd_0") != r_.end()) ? p_->Material_2nd_0 : r_["Material_2nd_0"].get<bool>());
			p_->Material_3rd_0 = (!(r_.find("Material_3rd_0") != r_.end()) ? p_->Material_3rd_0 : r_["Material_3rd_0"].get<bool>());
			p_->Closed_Wing_1 = (!(r_.find("Closed_Wing_1") != r_.end()) ? p_->Closed_Wing_1 : r_["Closed_Wing_1"].get<bool>());
			p_->Open_Wing_1 = (!(r_.find("Open_Wing_1") != r_.end()) ? p_->Open_Wing_1 : r_["Open_Wing_1"].get<bool>());
			p_->Stamp_Particle_1 = (!(r_.find("Stamp_Particle_1") != r_.end()) ? p_->Stamp_Particle_1 : r_["Stamp_Particle_1"].get<bool>());
			p_->Trail_On_1 = (!(r_.find("Trail_On_1") != r_.end()) ? p_->Trail_On_1 : r_["Trail_On_1"].get<bool>());
			p_->Trail_1st_1 = (!(r_.find("Trail_1st_1") != r_.end()) ? p_->Trail_1st_1 : r_["Trail_1st_1"].get<bool>());
			p_->Trail_2nd_1 = (!(r_.find("Trail_2nd_1") != r_.end()) ? p_->Trail_2nd_1 : r_["Trail_2nd_1"].get<bool>());
			p_->Trail_3rd_1 = (!(r_.find("Trail_3rd_1") != r_.end()) ? p_->Trail_3rd_1 : r_["Trail_3rd_1"].get<bool>());
			p_->Material_1st_1 = (!(r_.find("Material_1st_1") != r_.end()) ? p_->Material_1st_1 : r_["Material_1st_1"].get<bool>());
			p_->Material_2nd_1 = (!(r_.find("Material_2nd_1") != r_.end()) ? p_->Material_2nd_1 : r_["Material_2nd_1"].get<bool>());
			p_->Material_3rd_1 = (!(r_.find("Material_3rd_1") != r_.end()) ? p_->Material_3rd_1 : r_["Material_3rd_1"].get<bool>());
			p_->Wing_Value = (!(r_.find("Wing_Value") != r_.end()) ? p_->Wing_Value : r_["Wing_Value"].get<int>());
			p_->Wing_Color_0_Value = (!(r_.find("Wing_Color_0_Value") != r_.end()) ? p_->Wing_Color_0_Value : r_["Wing_Color_0_Value"].get<int>());
			p_->Wing_Metal_0_Value = (!(r_.find("Wing_Metal_0_Value") != r_.end()) ? p_->Wing_Metal_0_Value : r_["Wing_Metal_0_Value"].get<int>());
			p_->Wing_Color_1_Value = (!(r_.find("Wing_Color_1_Value") != r_.end()) ? p_->Wing_Color_1_Value : r_["Wing_Color_1_Value"].get<int>());
			p_->Wing_Metal_1_Value = (!(r_.find("Wing_Metal_1_Value") != r_.end()) ? p_->Wing_Metal_1_Value : r_["Wing_Metal_1_Value"].get<int>());
			// Rift Cape
			p_->Time_Change = (!(r_.find("Time_Change") != r_.end()) ? p_->Time_Change : r_["Time_Change"].get<bool>());
			p_->Cycle_Time = (!(r_.find("Cycle_Time") != r_.end()) ? p_->Cycle_Time : r_["Cycle_Time"].get<int>());
			p_->Cape_R_0 = (!(r_.find("Cape_R_0") != r_.end()) ? p_->Cape_R_0 : r_["Cape_R_0"].get<int>());
			p_->Cape_G_0 = (!(r_.find("Cape_G_0") != r_.end()) ? p_->Cape_G_0 : r_["Cape_G_0"].get<int>());
			p_->Cape_B_0 = (!(r_.find("Cape_B_0") != r_.end()) ? p_->Cape_B_0 : r_["Cape_B_0"].get<int>());
			p_->Collar_R_0 = (!(r_.find("Collar_R_0") != r_.end()) ? p_->Collar_R_0 : r_["Collar_R_0"].get<int>());
			p_->Collar_G_0 = (!(r_.find("Collar_G_0") != r_.end()) ? p_->Collar_G_0 : r_["Collar_G_0"].get<int>());
			p_->Collar_B_0 = (!(r_.find("Collar_B_0") != r_.end()) ? p_->Collar_B_0 : r_["Collar_B_0"].get<int>());
			p_->Cape_R_1 = (!(r_.find("Cape_R_1") != r_.end()) ? p_->Cape_R_1 : r_["Cape_R_1"].get<int>());
			p_->Cape_G_1 = (!(r_.find("Cape_G_1") != r_.end()) ? p_->Cape_G_1 : r_["Cape_G_1"].get<int>());
			p_->Cape_B_1 = (!(r_.find("Cape_B_1") != r_.end()) ? p_->Cape_B_1 : r_["Cape_B_1"].get<int>());
			p_->Collar_R_1 = (!(r_.find("Collar_R_1") != r_.end()) ? p_->Collar_R_1 : r_["Collar_R_1"].get<int>());
			p_->Collar_G_1 = (!(r_.find("Collar_G_1") != r_.end()) ? p_->Collar_G_1 : r_["Collar_G_1"].get<int>());
			p_->Collar_B_1 = (!(r_.find("Collar_B_1") != r_.end()) ? p_->Collar_B_1 : r_["Collar_B_1"].get<int>());
			p_->Cape_Collar_0 = (!(r_.find("Cape_Collar_0") != r_.end()) ? p_->Cape_Collar_0 : r_["Cape_Collar_0"].get<bool>());
			p_->Closed_Cape_0 = (!(r_.find("Closed_Cape_0") != r_.end()) ? p_->Closed_Cape_0 : r_["Closed_Cape_0"].get<bool>());
			p_->Open_On_Move_0 = (!(r_.find("Open_On_Move_0") != r_.end()) ? p_->Open_On_Move_0 : r_["Open_On_Move_0"].get<bool>());
			p_->Aura_0 = (!(r_.find("Aura_0") != r_.end()) ? p_->Aura_0 : r_["Aura_0"].get<bool>());
			p_->Aura_1st_0 = (!(r_.find("Aura_1st_0") != r_.end()) ? p_->Aura_1st_0 : r_["Aura_1st_0"].get<bool>());
			p_->Aura_2nd_0 = (!(r_.find("Aura_2nd_0") != r_.end()) ? p_->Aura_2nd_0 : r_["Aura_2nd_0"].get<bool>());
			p_->Aura_3rd_0 = (!(r_.find("Aura_3rd_0") != r_.end()) ? p_->Aura_3rd_0 : r_["Aura_1st_0"].get<bool>());
			p_->Cape_Collar_1 = (!(r_.find("Cape_Collar_1") != r_.end()) ? p_->Cape_Collar_1 : r_["Cape_Collar_1"].get<bool>());
			p_->Closed_Cape_1 = (!(r_.find("Closed_Cape_1") != r_.end()) ? p_->Closed_Cape_1 : r_["Closed_Cape_1"].get<bool>());
			p_->Open_On_Move_1 = (!(r_.find("Open_On_Move_1") != r_.end()) ? p_->Open_On_Move_1 : r_["Open_On_Move_1"].get<bool>());
			p_->Aura_1 = (!(r_.find("Aura_1") != r_.end()) ? p_->Aura_1 : r_["Aura_1"].get<bool>());
			p_->Aura_1st_1 = (!(r_.find("Aura_1st_1") != r_.end()) ? p_->Aura_1st_1 : r_["Aura_1st_1"].get<bool>());
			p_->Aura_2nd_1 = (!(r_.find("Aura_2nd_1") != r_.end()) ? p_->Aura_2nd_1 : r_["Aura_2nd_1"].get<bool>());
			p_->Aura_3rd_1 = (!(r_.find("Aura_3rd_1") != r_.end()) ? p_->Aura_3rd_1 : r_["Aura_1st_1"].get<bool>());
			p_->Cape_Value = (!(r_.find("Cape_Value") != r_.end()) ? p_->Cape_Value : r_["Cape_Value"].get<int>());
			p_->Cape_Collor_0_Value = (!(r_.find("Cape_Collor_0_Value") != r_.end()) ? p_->Cape_Collor_0_Value : r_["Cape_Collor_0_Value"].get<int>());
			p_->Cape_Collar_0_Value = (!(r_.find("Cape_Collar_0_Value") != r_.end()) ? p_->Cape_Collar_0_Value : r_["Cape_Collar_0_Value"].get<int>());
			p_->Cape_Collor_1_Value = (!(r_.find("Cape_Collor_1_Value") != r_.end()) ? p_->Cape_Collor_1_Value : r_["Cape_Collor_1_Value"].get<int>());
			p_->Cape_Collar_1_Value = (!(r_.find("Cape_Collar_1_Value") != r_.end()) ? p_->Cape_Collar_1_Value : r_["Cape_Collar_1_Value"].get<int>());
			// Infinity Crownvod
			p_->Crown_Time_Change = (!(r_.find("Crown_Time_Change") != r_.end()) ? p_->Crown_Time_Change : r_["Crown_Time_Change"].get<bool>());
			p_->Crown_Cycle_Time = (!(r_.find("Crown_Cycle_Time") != r_.end()) ? p_->Crown_Cycle_Time : r_["Crown_Cycle_Time"].get<int>());
			p_->Base_R_0 = (!(r_.find("Base_R_0") != r_.end()) ? p_->Base_R_0 : r_["Base_R_0"].get<int>());
			p_->Base_G_0 = (!(r_.find("Base_G_0") != r_.end()) ? p_->Base_G_0 : r_["Base_G_0"].get<int>());
			p_->Base_B_0 = (!(r_.find("Base_B_0") != r_.end()) ? p_->Base_B_0 : r_["Base_B_0"].get<int>());
			p_->Gem_R_0 = (!(r_.find("Gem_R_0") != r_.end()) ? p_->Gem_R_0 : r_["Gem_R_0"].get<int>());
			p_->Gem_G_0 = (!(r_.find("Gem_G_0") != r_.end()) ? p_->Gem_G_0 : r_["Gem_G_0"].get<int>());
			p_->Gem_B_0 = (!(r_.find("Gem_B_0") != r_.end()) ? p_->Gem_B_0 : r_["Gem_B_0"].get<int>());
			p_->Crystal_R_0 = (!(r_.find("Crystal_R_0") != r_.end()) ? p_->Crystal_R_0 : r_["Crystal_R_0"].get<int>());
			p_->Crystal_G_0 = (!(r_.find("Crystal_G_0") != r_.end()) ? p_->Crystal_G_0 : r_["Crystal_G_0"].get<int>());
			p_->Crystal_B_0 = (!(r_.find("Crystal_B_0") != r_.end()) ? p_->Crystal_B_0 : r_["Crystal_B_0"].get<int>());
			p_->Crown_Floating_Effect_0 = (!(r_.find("Crown_Floating_Effect_0") != r_.end()) ? p_->Crown_Floating_Effect_0 : r_["Crown_Floating_Effect_0"].get<bool>());
			p_->Crown_Laser_Beam_0 = (!(r_.find("Crown_Laser_Beam_0") != r_.end()) ? p_->Crown_Laser_Beam_0 : r_["Crown_Laser_Beam_0"].get<bool>());
			p_->Crown_Crystals_0 = (!(r_.find("Crown_Crystals_0") != r_.end()) ? p_->Crown_Crystals_0 : r_["Crown_Crystals_0"].get<bool>());
			p_->Crown_Rays_0 = (!(r_.find("Crown_Rays_0") != r_.end()) ? p_->Crown_Rays_0 : r_["Crown_Rays_0"].get<bool>());
			p_->Base_R_1 = (!(r_.find("Base_R_1") != r_.end()) ? p_->Base_R_1 : r_["Base_R_1"].get<int>());
			p_->Base_G_1 = (!(r_.find("Base_G_1") != r_.end()) ? p_->Base_G_1 : r_["Base_G_1"].get<int>());
			p_->Base_B_1 = (!(r_.find("Base_B_1") != r_.end()) ? p_->Base_B_1 : r_["Base_B_1"].get<int>());
			p_->Gem_R_1 = (!(r_.find("Gem_R_1") != r_.end()) ? p_->Gem_R_1 : r_["Gem_R_1"].get<int>());
			p_->Gem_G_1 = (!(r_.find("Gem_G_1") != r_.end()) ? p_->Gem_G_1 : r_["Gem_G_1"].get<int>());
			p_->Gem_B_1 = (!(r_.find("Gem_B_1") != r_.end()) ? p_->Gem_B_1 : r_["Gem_B_1"].get<int>());
			p_->Crystal_R_1 = (!(r_.find("Crystal_R_1") != r_.end()) ? p_->Crystal_R_1 : r_["Crystal_R_1"].get<int>());
			p_->Crystal_G_1 = (!(r_.find("Crystal_G_1") != r_.end()) ? p_->Crystal_G_1 : r_["Crystal_G_1"].get<int>());
			p_->Crystal_B_1 = (!(r_.find("Crystal_B_1") != r_.end()) ? p_->Crystal_B_1 : r_["Crystal_B_1"].get<int>());
			p_->Crown_Floating_Effect_1 = (!(r_.find("Crown_Floating_Effect_1") != r_.end()) ? p_->Crown_Floating_Effect_1 : r_["Crown_Floating_Effect_1"].get<bool>());
			p_->Crown_Laser_Beam_1 = (!(r_.find("Crown_Laser_Beam_1") != r_.end()) ? p_->Crown_Laser_Beam_1 : r_["Crown_Laser_Beam_1"].get<bool>());
			p_->Crown_Crystals_1 = (!(r_.find("Crown_Crystals_1") != r_.end()) ? p_->Crown_Crystals_1 : r_["Crown_Crystals_1"].get<bool>());
			p_->Crown_Rays_1 = (!(r_.find("Crown_Rays_1") != r_.end()) ? p_->Crown_Rays_1 : r_["Crown_Rays_1"].get<bool>());
			p_->Crown_Value = (!(r_.find("Crown_Value") != r_.end()) ? p_->Crown_Value : r_["Crown_Value"].get<int>());
			p_->Crown_Value_0_0 = (!(r_.find("Crown_Value_0_0") != r_.end()) ? p_->Crown_Value_0_0 : r_["Crown_Value_0_0"].get<long long int>());
			p_->Crown_Value_0_1 = (!(r_.find("Crown_Value_0_1") != r_.end()) ? p_->Crown_Value_0_1 : r_["Crown_Value_0_1"].get<long long int>());
			p_->Crown_Value_0_2 = (!(r_.find("Crown_Value_0_2") != r_.end()) ? p_->Crown_Value_0_2 : r_["Crown_Value_0_2"].get<long long int>());
			p_->Crown_Value_1_0 = (!(r_.find("Crown_Value_1_0") != r_.end()) ? p_->Crown_Value_1_0 : r_["Crown_Value_1_0"].get<long long int>());
			p_->Crown_Value_1_1 = (!(r_.find("Crown_Value_1_1") != r_.end()) ? p_->Crown_Value_1_1 : r_["Crown_Value_1_1"].get<long long int>());
			p_->Crown_Value_1_2 = (!(r_.find("Crown_Value_1_2") != r_.end()) ? p_->Crown_Value_1_2 : r_["Crown_Value_1_2"].get<long long int>());
			// Crown of Season
			p_->Aura_Season = (!(r_.find("Aura_Season") != r_.end()) ? p_->Aura_Season : r_["Aura_Season"].get<int>());
			p_->Trail_Season = (!(r_.find("Trail_Season") != r_.end()) ? p_->Trail_Season : r_["Trail_Season"].get<int>());
			// Banner Bandolier
			p_->Banner_Item = (!(r_.find("Banner_Item") != r_.end()) ? p_->Banner_Item : r_["Banner_Item"].get<int>());
			p_->Banner_Flag = (!(r_.find("Banner_Flag") != r_.end()) ? p_->Banner_Flag : r_["Banner_Flag"].get<int>());
			// Magic Magnet
			p_->Magnet_Item = (!(r_.find("Magnet_Item") != r_.end()) ? p_->Magnet_Item : r_["Magnet_Item"].get<int>());
			/*
			p_->grow4good_day = (!(r_.find("g4g_1") != r_.end()) ? p_->grow4good_day : r_["g4g_1"].get<int>());
			p_->grow4good_rarity = (!(r_.find("g4g_2") != r_.end()) ? p_->grow4good_rarity : r_["g4g_2"].get<int>());
			p_->grow4good_total_rarity = (!(r_.find("g4g_3") != r_.end()) ? p_->grow4good_total_rarity : r_["g4g_3"].get<int>());
			p_->grow4good_wl = (!(r_.find("g4g_4") != r_.end()) ? p_->grow4good_wl : r_["g4g_4"].get<int>());
			p_->grow4good_total_wl = (!(r_.find("g4g_5") != r_.end()) ? p_->grow4good_total_wl : r_["g4g_5"].get<int>());
			p_->grow4good_donate_gems = (!(r_.find("g4g_6") != r_.end()) ? p_->grow4good_donate_gems : r_["g4g_6"].get<bool>());
			p_->grow4good_gems = (!(r_.find("g4g_7") != r_.end()) ? p_->grow4good_gems : r_["g4g_7"].get<int>());
			p_->grow4good_purchase_waving = (!(r_.find("g4g_8") != r_.end()) ? p_->grow4good_purchase_waving : r_["g4g_8"].get<bool>());
			p_->grow4good_surgery = (!(r_.find("g4g_9") != r_.end()) ? p_->grow4good_surgery : r_["g4g_9"].get<int>());
			p_->grow4good_fish = (!(r_.find("g4g_10") != r_.end()) ? p_->grow4good_fish : r_["g4g_10"].get<int>());
			p_->grow4good_points = (!(r_.find("g4g_11") != r_.end()) ? p_->grow4good_points : r_["g4g_11"].get<int>());
			p_->grow4good_claim_prize = (!(r_.find("g4g_12") != r_.end()) ? p_->grow4good_claim_prize : r_["g4g_12"].get<int>());
			p_->grow4good_claimed_prize = (!(r_.find("g4g_13") != r_.end()) ? p_->grow4good_claimed_prize : r_["g4g_13"].get<int>());
			p_->grow4good_break = (!(r_.find("g4g_14") != r_.end()) ? p_->grow4good_break : r_["g4g_14"].get<int>());
			p_->grow4good_place = (!(r_.find("g4g_15") != r_.end()) ? p_->grow4good_place : r_["g4g_15"].get<int>());
			p_->grow4good_trade = (!(r_.find("g4g_16") != r_.end()) ? p_->grow4good_trade : r_["g4g_16"].get<int>());
			p_->grow4good_sb = (!(r_.find("g4g_17") != r_.end()) ? p_->grow4good_sb : r_["g4g_17"].get<int>());*/
			p_->uid = (!(r_.find("userID") != r_.end()) ? p_->id : r_["userID"].get<int>());
			p_->transmute = (!(r_.find("transmute") != r_.end()) ? p_->transmute : r_["transmute"].get<vector<string>>());
			p_->tankIDName = (!(r_.find("name") != r_.end()) ? p_->tankIDName : r_["name"].get<string>());
			p_->lastReqName = (!(r_.find("reqname") != r_.end()) ? p_->lastReqName : r_["reqname"].get<string>());
			p_->roundedPlaytime = (!(r_.find("totalplaytime") != r_.end()) ? p_->roundedPlaytime : r_["totalplaytime"].get<string>());
			p_->modName = (!(r_.find("modname") != r_.end()) ? p_->modName : r_["modname"].get<string>());
			p_->email = (!(r_.find("email") != r_.end()) ? "The email has've been corrupted!" : r_["email"].get<string>());
			p_->b_r = (!(r_.find("b_r") != r_.end()) ? p_->b_r : r_["b_r"].get<string>());
			p_->b_b = (!(r_.find("b_b") != r_.end()) ? p_->b_b : r_["b_b"].get<string>());
			p_->b_s = (!(r_.find("b_s") != r_.end()) ? p_->b_t : r_["b_s"].get<long long int>());
			p_->b_t = (!(r_.find("b_t") != r_.end()) ? p_->b_t : r_["b_t"].get<long long int>());
			p_->m_r = (!(r_.find("m_r") != r_.end()) ? p_->m_r : r_["m_r"].get<string>());
			p_->m_b = (!(r_.find("m_b") != r_.end()) ? p_->m_b : r_["m_b"].get<string>());
			p_->s_t = (!(r_.find("s_t") != r_.end()) ? p_->s_t : r_["s_t"].get<long long int>());
			p_->s_r = (!(r_.find("s_r") != r_.end()) ? p_->s_r : r_["s_r"].get<string>());
			p_->punch_count = (!(r_.find("punch") != r_.end()) ? p_->punch_count : r_["punch"].get<long long int>());
			p_->n = (!(r_.find("n") != r_.end()) ? p_->n : r_["n"].get<int>());
			p_->lo = (!(r_.find("lo") != r_.end()) ? p_->lo : r_["lo"].get<string>());
			p_->ghost = (!(r_.find("ghost") != r_.end()) ? p_->ghost : r_["ghost"].get<bool>());
			p_->invis = (!(r_.find("invis") != r_.end()) ? p_->invis : r_["invis"].get<bool>());
			p_->bans = (!(r_.find("bans") != r_.end()) ? p_->bans : r_["bans"].get<vector<string>>());
			//p_->logs = r_["logs"].get<vector<string>>();
			p_->vip = (!(r_.find("vip") != r_.end()) ? p_->vip : r_["vip"].get<int>());
			p_->vvip = (!(r_.find("vvip") != r_.end()) ? p_->vvip : r_["vvip"].get<int>());
			p_->glory = (!(r_.find("glory") != r_.end()) ? p_->glory : r_["glory"].get<int>());
			p_->mod = (!(r_.find("mod") != r_.end()) ? p_->mod : r_["mod"].get<int>());
			p_->guardian = (!(r_.find("guardian") != r_.end()) ? p_->guardian : r_["guardian"].get<int>());

			p_->supermod = (!(r_.find("supermod") != r_.end()) ? p_->supermod : r_["supermod"].get<int>());
			p_->admin = (!(r_.find("admin") != r_.end()) ? p_->admin : r_["admin"].get<int>());

			p_->m_h = (!(r_.find("m_h") != r_.end()) ? p_->m_h : r_["m_h"].get<int>());
			p_->totaltopup = (!(r_.find("Total_TopUp") != r_.end()) ? 0 : r_["Total_TopUp"].get<int>());
			p_->totalWls = (!(r_.find("Total_Wls") != r_.end()) ? 0 : r_["Total_Wls"].get<int>());
			p_->totalNetWorth = (!(r_.find("Total_Worth") != r_.end()) ? 0 : r_["Total_Worth"].get<int>());
			p_->gems = (!(r_.find("gems") != r_.end()) ? p_->gems : r_["gems"].get<int>());
			p_->xp = (!(r_.find("xp") != r_.end()) ? p_->xp : r_["xp"].get<unsigned long long int>());
			p_->level = (!(r_.find("level") != r_.end()) ? p_->level : r_["level"].get<int>());
			p_->skin = (!(r_.find("skin") != r_.end()) ? p_->skin : r_["skin"].get<int>());
			p_->show_location_ = (!(r_.find("show_location") != r_.end()) ? p_->show_location_ : r_["show_location"].get<bool>());
			p_->show_friend_notifications_ = (!(r_.find("show_friend_notifications") != r_.end()) ? p_->show_friend_notifications_ : r_["show_friend_notifications"].get<bool>());
			p_->playtime = time(NULL), p_->seconds = (!(r_.find("playtime") != r_.end()) ? p_->playtime : r_["playtime"].get<long long int>());
			p_->account_created = (!(r_.find("date") != r_.end()) ? p_->account_created : r_["date"].get<long long int>());
			if (p_->account_created == 0) p_->account_created = time(NULL) / 86400;
			p_->home_world = (!(r_.find("home_world") != r_.end()) ? p_->home_world : r_["home_world"].get<string>());
			p_->hair = (!(r_.find("hair") != r_.end()) ? p_->hair : r_["hair"].get<int>());
			p_->shirt = (!(r_.find("shirt") != r_.end()) ? p_->shirt : r_["shirt"].get<int>());
			p_->pants = (!(r_.find("pants") != r_.end()) ? p_->pants : r_["pants"].get<int>());
			p_->feet = (!(r_.find("feet") != r_.end()) ? p_->feet : r_["feet"].get<int>());
			p_->face = (!(r_.find("face") != r_.end()) ? p_->face : r_["face"].get<int>());
			p_->ip = (!(r_.find("ip") != r_.end()) ? p_->ip : r_["ip"].get<string>());
			p_->last_ip = (!(r_.find("lastIP") != r_.end()) ? p_->last_ip : r_["lastIP"].get<string>());
			p_->hand = (!(r_.find("hand") != r_.end()) ? p_->hand : r_["hand"].get<int>());
			p_->back = (!(r_.find("back") != r_.end()) ? p_->back : r_["back"].get<int>());
			p_->mask = (!(r_.find("mask") != r_.end()) ? p_->mask : r_["mask"].get<int>());
			p_->necklace = (!(r_.find("necklace") != r_.end()) ? p_->necklace : r_["necklace"].get<int>());
			p_->ances = (!(r_.find("ances") != r_.end()) ? p_->ances : r_["ances"].get<int>());
			if (r_.find("guild_id") != r_.end()) {
				p_->guild_id = r_["guild_id"].get<int>();
			}
			if (r_.find("geiger") != r_.end()) {
				p_->geiger_ = r_["geiger"].get<int>();
			}
			if (r_.find("booty_broken") != r_.end()) {
				p_->booty_broken = r_["booty_broken"].get<int>();
			}
			if (!(r_.find("grm") == r_.end())) {
				p_->growmoji = r_["grm"].get<string>();
			}
			if (r_.find("playmods") != r_.end()) {
				json list_playmod = r_["playmods"].get<json>();
				for (int i_ = 0; i_ < list_playmod.size(); i_++) {
					PlayMods give_playmod{};
					give_playmod.id = list_playmod[i_]["id"].get<int>();
					give_playmod.time = list_playmod[i_]["time"].get<long long>();
					if (list_playmod[i_].find("user") != list_playmod[i_].end()) {
						give_playmod.user = list_playmod[i_]["user"].get<string>();
					}
					p_->playmods.push_back(give_playmod);
				}
			}
			if (r_.find("blarney") != r_.end()) {
				json list_blarney = r_["blarney"].get<json>();
				for (int i_ = 0; i_ < list_blarney.size(); i_++) {
					int w_ = list_blarney[i_]["world"].get<int>();
					long long tim_ = list_blarney[i_]["time"].get<long long>();
					for (int c_ = 0; c_ < p_->completed_blarneys.size(); c_++) {
						if ((int)p_->completed_blarneys[c_][0] == w_) {
							p_->completed_blarneys[c_][1] = tim_;
							break;
						}
					}
				}
			}
			p_->Cheat_FastSpin = (!(r_.find("cheat_fs") != r_.end()) ? p_->unlocked_fs : r_["cheat_fs"].get<bool>());
			p_->unlocked_fs = (!(r_.find("u_fs") != r_.end()) ? p_->unlocked_fs : r_["u_fs"].get<bool>());
			p_->unlocked_fp = (!(r_.find("u_fp") != r_.end()) ? p_->unlocked_fp : r_["u_fp"].get<bool>());
			p_->unlocked_as = (!(r_.find("u_as") != r_.end()) ? p_->unlocked_as : r_["u_as"].get<bool>());
			p_->unlocked_af = (!(r_.find("u_af") != r_.end()) ? p_->unlocked_af : r_["u_af"].get<bool>());
			p_->unlocked_ft = (!(r_.find("u_ft") != r_.end()) ? p_->unlocked_ft : r_["u_ft"].get<bool>());
			p_->unlocked_fd = (!(r_.find("u_fd") != r_.end()) ? p_->unlocked_fd : r_["u_fd"].get<bool>());
			p_->unlocked_at = (!(r_.find("u_at") != r_.end()) ? p_->unlocked_at : r_["u_at"].get<bool>());
			p_->unlocked_ab = (!(r_.find("u_ab") != r_.end()) ? p_->unlocked_ab : r_["u_ab"].get<bool>());
			p_->unlocked_ss = (!(r_.find("u_ss") != r_.end()) ? p_->unlocked_ss : r_["u_ss"].get<bool>());
			p_->unlocked_sj = (!(r_.find("u_sj") != r_.end()) ? p_->unlocked_sj : r_["u_sj"].get<bool>());
			p_->unlocked_hp = (!(r_.find("u_hp") != r_.end()) ? p_->unlocked_hp : r_["u_hp"].get<bool>());
			p_->unlocked_hc = (!(r_.find("u_hc") != r_.end()) ? p_->unlocked_hc : r_["u_hc"].get<bool>());
			p_->hide_logs = (!(r_.find("hide_logs") != r_.end()) ? p_->hide_logs : r_["hide_logs"].get<bool>());
			p_->void_ray_1hit = (!(r_.find("void_1hit") != r_.end()) ? p_->void_ray_1hit : r_["void_1hit"].get<bool>());
			p_->old_name = (!(r_.find("old_name") != r_.end()) ? p_->old_name : r_["old_name"].get<string>());
			p_->punch_sword_time = (r_.find("punch_sword") == r_.end() ? p_->punch_sword_time : r_["punch_sword"].get<int>());
			p_->hide_reseller = (r_.find("hide_reseller") == r_.end() ? p_->hide_reseller : r_["hide_reseller"].get<bool>()); 
			//p_->uuid = (r_.find("uuid") == r_.end() ? p_->uuid : r_["uuid"].get<string>());
			//if (not process_uid(p_)) 
				//write_uid_data(p_);

			if (p_->ghost or p_->invis) {
				if (not p_->mod and not p_->admin) {
					p_->invis = false;
				}
				if (not p_->admin) {
					p_->ghost = false;
					if (p_->skin == -2450) p_->skin = 0x8295C3FF;
				}
			}
			if (pInfo(peer)->b_s == 0) {
				if (pInfo(peer)->supp == 2) {
					/*gamepacket_t p;
					p.Insert("OnOverrideGDPRFromServer");
					p.Insert(39);
					p.Insert(1);
					p.Insert(0);
					p.Insert(1);
					p.CreatePacket(peer);*/
					{
						gamepacket_t p;
						string skinVal1 = (pInfo(peer)->t_lvl >= 50 ? "1" : "0");
						string skinVal2 = (pInfo(peer)->bb_lvl >= 50 ? "1" : "0");
						string skinVal3 = (pInfo(peer)->unlockRoleSkin ? "1111" : "0000");
						string roleSkin = skinVal1 + skinVal2 + skinVal3;
						string titleVal1 = (pInfo(peer)->t_lvl >= 50 ? "2" : "0");
						string titleVal2 = (pInfo(peer)->bb_lvl >= 50 ? "2" : "0");
						string titleVal3 = (pInfo(peer)->titleDoctor ? "2" : "0");
						string titleVal4 = (pInfo(peer)->titleFisher ? "2" : "0");
						string titleVal5 = (pInfo(peer)->titleChef ? "2" : "0");
						string titleVal6 = (pInfo(peer)->titleStartopia ? "2" : "0");
						string roleTitle = titleVal1 + titleVal2 + titleVal3 + titleVal4 + titleVal5 + titleVal6;
						p.Insert("OnSetRoleSkinsAndTitles");
						p.Insert(roleSkin);
						p.Insert(roleTitle);
						p.CreatePacket(peer);
					}
				}
				if (pInfo(peer)->gp == 1) {
					gamepacket_t p;
					p.Insert("OnPaw2018SkinColor1Changed");
					p.Insert(1);
					p.CreatePacket(peer);
					{
						gamepacket_t p;
						p.Insert("OnPaw2018SkinColor2Changed");
						p.Insert(1);
						p.CreatePacket(peer);
					}
				}
				{
					gamepacket_t p, px;
					p.Insert("OnSetBux");
					p.Insert(pInfo(peer)->gems);
					p.Insert(1);
					p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
					if (pInfo(peer)->supp >= 2) {
						p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
					}
					p.CreatePacket(peer);
					px.Insert("OnSetVouchers"), px.Insert(pInfo(peer)->gtwl), px.CreatePacket(peer);
					
				}
				{
					gamepacket_t p2;
					p2.Insert("SetHasAccountSecured"), p2.Insert(1), p2.CreatePacket(peer);
				}
				gamepacket_t p;
				p.Insert("SetHasGrowID"), p.Insert(1), p.Insert(p_->tankIDName), p.Insert(p_->tankIDPass), p.CreatePacket(peer);
			}

			load_affinity(p_);
		}
		catch (exception& e) {
			tayo_warn(p_->tankIDName + " Failed authenticate");
			tayo_warn(e.what());
			return -1;
			save_player(pInfo(peer));
		}
		return 0;
	}
	return -1;
	save_player(pInfo(peer));
}

string form_mods(Player* p_, int text) {
	vector<string> player_playmods;
	long long time_ = time(nullptr);
	vector<string> added_{};
	if (not p_->playmods.empty())
	{
		for (PlayMods peer_playmod : p_->playmods) {
			Playmod playmod = info_about_playmods[peer_playmod.id];
			string playmod_name = playmod.name;
			//cout << "playmod info of form_mods: \n";
			//print_info_pmod(playmod);
			if (find(added_.begin(), added_.end(), playmod_name) == added_.end()) {
				added_.push_back(playmod_name);
				player_playmods.push_back(playmod_name + "`` (`w" + Algorithm::to_playmod_time(peer_playmod.time - time_) + "``left)");
				player_playmods.push_back(to_string(playmod.displayId));
			}
		}
	}
	player_playmods.push_back(items[p_->hair].playmod), player_playmods.push_back(to_string(p_->hair));
	player_playmods.push_back(items[p_->shirt].playmod), player_playmods.push_back(to_string(p_->shirt));
	player_playmods.push_back(items[p_->pants].playmod), player_playmods.push_back(to_string(p_->pants));
	player_playmods.push_back(items[p_->feet].playmod), player_playmods.push_back(to_string(p_->feet));
	player_playmods.push_back(items[p_->face].playmod), player_playmods.push_back(to_string(p_->face));
	player_playmods.push_back(items[p_->hand].playmod), player_playmods.push_back(to_string(p_->hand));
	player_playmods.push_back(items[p_->back].playmod), player_playmods.push_back(to_string(p_->back));
	player_playmods.push_back(items[p_->mask].playmod), player_playmods.push_back(to_string(p_->mask));
	player_playmods.push_back(items[p_->necklace].playmod), player_playmods.push_back(to_string(p_->necklace));
	player_playmods.push_back(items[p_->ances].playmod), player_playmods.push_back(to_string(p_->ances));
	if (p_->ghost) player_playmods.push_back("Ghost in the Shell"), player_playmods.push_back("290");
	if (p_->Cheat_AB) player_playmods.push_back("Cheat Active: Antibounce"), player_playmods.push_back("7068");
	if (p_->Cheat_AF) player_playmods.push_back("Cheat Active: Auto Farm"), player_playmods.push_back("7064");
	if (p_->Cheat_AutoCollect) player_playmods.push_back("Cheat Active: Auto Collect"), player_playmods.push_back("112");
	if (p_->Cheat_Speed) player_playmods.push_back("Cheat Active: Super Speed"), player_playmods.push_back("18");
	if (p_->Cheat_Jump) player_playmods.push_back("Cheat Active: Super Jump"), player_playmods.push_back("18");
	if (p_->Cheat_FastPull) player_playmods.push_back("Cheat Active: Fast Pull"), player_playmods.push_back("32");
	if (p_->Cheat_FastDrop) player_playmods.push_back("Cheat Active: Fast Drop"), player_playmods.push_back("32");
	if (p_->Cheat_FastTrash) player_playmods.push_back("Cheat Active: Fast Trash"), player_playmods.push_back("32");
	//if (p_->Cheat_Spam) player_playmods.push_back("Cheat Active: Spam"), player_playmods.push_back("1400");
	if (p_->b_s != 0) player_playmods.push_back("Duct Tape"), player_playmods.push_back("408");
	if (p_->hand == 2286) player_playmods.push_back("Charging Geiger Counter`` (" + to_string(p_->geiger_) + "%)"), player_playmods.push_back("2204");
	if (p_->spotlight) player_playmods.push_back("In the Spotlight"), player_playmods.push_back("2646");
	if (p_->affinity_type != NO_AFFINITY && !aff_lvl_mod(p_).empty()) player_playmods.push_back(aff_lvl_mod(p_)), player_playmods.push_back(p_->affinity_type == LOVER ? "190" : "1366");
	string t_ = "";
	int active = 0;
	if (p_->s_t - time(nullptr) > 0) t_ += "\nadd_label_with_icon|small|`wSilenced `o(" + Algorithm::to_playmod_time(p_->s_t - time(nullptr)) + "left)|left|408|";
	if (p_->At_Clashparkour) t_ += "\nadd_label_with_icon|small|`wCompetitor: Finale Ticket! `o(" + Algorithm::to_playmod_time(p_->Time_Remaining - time_) + "left)|left|8774|";
	if (p_->wolf_world) t_ += "\nadd_label_with_icon|small|`wHowlin' Mad `o(" + Algorithm::to_playmod_time(p_->Time_Remaining - time_) + "left)|left|2992|";
	try {
		for (int i_ = 0; i_ < player_playmods.size(); i_++) {
			if (player_playmods.at(i_).empty() or isdigit(player_playmods.at(i_).at(0))) continue;
			t_ += (text == 0 ? "\nadd_label_with_icon|small|`w" + player_playmods.at(i_) + "``|left|" + player_playmods.at(i_ + 1) + "|" : "\n`w" + player_playmods.at(i_) + "``");
			active++;
		}
		string name_ = p_->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (world_->X_1 or world_->X_2) {
				t_ += "\nadd_label_with_icon|small|`wXenonite!``|left|2072|";
			}
		}
	}
	catch (out_of_range) {
		return t_;
	}
	if (t_.empty())
		t_ = "";
	else
		if (text == 0) t_ = "\nadd_textbox|`wActive effects:``|left|\nadd_label_with_icon|small|" + t_;
		else t_ = "\n" + to_string(active) + " mods active:" + t_;
	return t_;
}

void gems_(ENetPeer* peer, World* world_, int c_, int x_, int y_, int from) {
	if (thedaytoday == 5 and rand() % 50 < 1) c_++;
	if (from == 5136 || from == 9386 || from == 9400 || from == 9384) return;
	if (from != 1008 and from != 3604) {
		if (peer != NULL and has_playmod(pInfo(peer), "Extra Wealth...")) {
			if (pInfo(peer)->ances == 5084 and rand() % 100 < 1) {
				c_ += 10;
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
			}
			if (pInfo(peer)->ances == 5180 and rand() % 90 < 1) {
				c_ += 20;
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
			}
			if (pInfo(peer)->ances == 5182 and rand() % 80 < 1) {
				c_ += 30;
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
			}
			if (pInfo(peer)->ances == 5184 and rand() % 70 < 1) {
				c_ += 40;
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
			}
			if (pInfo(peer)->ances == 5186 and rand() % 60 < 1) {
				c_ += 50;
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
			}
			if (pInfo(peer)->ances == 5188 and rand() % 50 < 1) {
				c_ += 60;
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
			}
		}
		if (peer != NULL and has_playmod(pInfo(peer), "Lucky More Gems")) c_++;
		bool doubled = false;
		/*
		if (peer != NULL and rand() % 282 < 1 and pInfo(peer)->gp or peer != NULL and rand() % 282 < 1 and pInfo(peer)->lock == 2408) {
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 125, data_.YSpeed = 125, data_.x = x_ + 16, data_.y = y_ + 16;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == world_->name) send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
			// give more gems drop from item
			if (pInfo(peer)->gp) c_ *= 2, doubled = true;
		}
		*/
		/*
		if (pInfo(peer)->affinity_level >= 1) {
			c_ *= pInfo(peer)->affinity_level < 2 && pInfo(peer)->affinity_level != 0 ? 1.5 :
				(pInfo(peer)->affinity_level);
		}
		*/
		{
			std::ifstream fileitem("./database/config/items.json");
			if (!fileitem.is_open()) {
				std::cerr << "Error opening file." << std::endl;
			}
			//int g_m = items[pInfo(peer)->hand].multigems;
			json jsonitem;
			fileitem >> jsonitem;
			fileitem.close();
			if (jsonitem.is_array()) {
				for (const auto& obj : jsonitem) {
					if (obj.is_object()) {
						if (obj.contains("ItemId") && obj.contains("Gems")) {
							int itemsid = obj["ItemId"];
							int farsg = obj["Gems"];
							if (pInfo(peer)->hand == itemsid) {
								c_ *= farsg, doubled = true;
							}
						}
					}
				}
			}
		}
		/*if (pInfo(peer)->hand == 9520) c_ *= 3, doubled = true;
		if (pInfo(peer)->hand == 9160) c_ *= 3, doubled = true;
		if (pInfo(peer)->hand == 8532) c_ *= 5;//void rayman fist
		if (pInfo(peer)->hand == 13828) c_ *= 10;//Frozen rayman
		if (pInfo(peer)->hand == 9508) c_ *= 50;//Kamish Dagger
		if (pInfo(peer)->hand == 9512) c_ *= 30;//Cloud Ruler
		if (pInfo(peer)->hand == 9510) c_ *= 45;//Kamish Blade
		if (pInfo(peer)->hand == 13864) c_ *= 45;//FP SWORD
		if (pInfo(peer)->hand == 13612) c_ *= 5;//Sage Eye
        if (pInfo(peer)->hand == 10384) c_ *= 5;//the serpent
		if (pInfo(peer)->hand == 9150) c_ *= 5;//predator
		if (pInfo(peer)->hand == 9500) c_ *= 5;//eldricth sword
		if (pInfo(peer)->hand == 8530) c_ *= 2;//magma rayman
		if (pInfo(peer)->hand == 11050) c_ *= 5;//Ultra
		*/
		if (pInfo(peer)->dateMasterB_title) c_ *= 10;
		//if (pInfo(peer)->hand == 6312) c_ *= 2;
		if (pInfo(peer)->affinity_level == 5) {
			c_ += Algorithm::rand(1, 4);
		}
		if (not doubled) {
			c_ *= 1;
		}
		//if (c_ > 5000) c_ = 5000;
		//if (c_ > 10000) c_ = 10000;
	}
	c_ *= (gem_event + has_playmod(pInfo(peer), "Boosted")); // default 1
	// extra gem event (*) x amount
	if (pInfo(peer)->Cheat_AutoCollect) {
		int gemText = c_;
		pInfo(peer)->gems += c_;
		if (pInfo(peer)->lastquest == "Ruler Sword" && pInfo(peer)->quest_step == 3 && pInfo(peer)->quest_active) {
			pInfo(peer)->quest_progress += c_;
			if (pInfo(peer)->quest_progress >= 2000000000 && pInfo(peer)->blmNotip) pInfo(peer)->blmNotip = false, Algorithm::send_console_message(peer, "`9Legendary Wizz Quest: Your kamish (3/5) earn 2B gems complete!");
		}

		Algorithm::send_bubble(peer, pInfo(peer)->netID, "Collected " + fixint(gemText) + " ė");
		gamepacket_t p;
		p.Insert("OnSetBux");
		p.Insert(pInfo(peer)->gems);
		p.Insert(1);
		p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
		if (pInfo(peer)->supp >= 2) {
			p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
		}
		p.CreatePacket(peer);
	}
	else {
		int a_ = c_;
		int hgem_ = c_ >= 1000 ? c_ / 1000 : 0, purple_ = c_ - (hgem_ * 1000) >= 100 ? (c_ - (hgem_ * 1000)) / 100 : 0, green_ = c_ - (hgem_ * 1000) - (purple_ * 100) >= 50 ? (c_ - (hgem_ * 1000) - (purple_ * 100)) / 50 : 0, red_ = c_ - (purple_ * 100) - (hgem_ * 1000) - (green_ * 50) >= 10 ? (c_ - (purple_ * 100) - (hgem_ * 1000) - (green_ * 50)) / 10 : 0, blue_ = c_ - (green_ * 50) - (purple_ * 100) - (hgem_ * 1000) - (red_ * 10) >= 5 ? (c_ - (green_ * 50) - (purple_ * 100) - (hgem_ * 1000) - (red_ * 10)) / 5 : 0, yellow_ = c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (hgem_ * 1000) - (blue_ * 5) > 0 ? (c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (hgem_ * 1000) - (blue_ * 5)) / 1 : 0;
		//int ggem_ = get_drop_count(5136, drop_, world_) >= 100 ? get_drop_count(5136, drop_, world_) / 100 : 0;
		//int ggem_ = hgem_ >= 100 ? hgem_ / 100 : 0;
		WorldDrop item_{};
		/*
		* item_.id = 9148;
		item_.count = 1;
	for (int i_ = 0; i_ < ggem_; i_++) { 
			item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
			item_.uid = uint16_t(world_->drop.size()) + 1;
			dropas_(world_, item_);
		}
	*/
		item_.id = 5136;
		item_.count = 1;
		for (int i_ = 0; i_ < hgem_; i_++) {
			item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
			item_.uid = uint16_t(world_->drop.size()) + 1;
			dropas_(world_, item_);
		}
		item_.id = 112;
		item_.count = 100;
		for (int i_ = 0; i_ < purple_; i_++) {
			item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
			item_.uid = uint16_t(world_->drop.size()) + 1;
			dropas_(world_, item_);
		}
		item_.count = 50;
		for (int i_ = 0; i_ < green_; i_++) {
			item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
			item_.uid = uint16_t(world_->drop.size()) + 1;
			dropas_(world_, item_);
		}
		item_.count = 10;
		for (int i_ = 0; i_ < red_; i_++) {
			item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
			item_.uid = uint16_t(world_->drop.size()) + 1;
			dropas_(world_, item_);
		}
		item_.count = 5;
		for (int i_ = 0; i_ < blue_; i_++) {
			item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
			item_.uid = uint16_t(world_->drop.size()) + 1;
			dropas_(world_, item_);
		}
		item_.count = 1;
		for (int i_ = 0; i_ < yellow_; i_++) {
			item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
			item_.uid = uint16_t(world_->drop.size()) + 1;
			dropas_(world_, item_);
		}
	}
}
bool static_(BlockTypes& c_, ItemDB item_) {
	// figure out how to decide whether a block is solid or background
	c_ = item_.blockType;
	if (item_.id == 0) return false;
	if (c_ == LOCK or c_ == BEDROCK or c_ == MAIN_DOOR or c_ == FOREGROUND or c_ == DEADLY or c_ == PAIN_BLOCK or item_.name.find(" Block") != string::npos and item_.name.find(" Seed") == string::npos or item_.name.find(" Bricks") != string::npos and item_.name.find(" Seed") == string::npos)
		return true;
	return false;
}
void send_friends(ENetPeer* p_, bool all = false) {
	int on_ = 0;
	string info_ = "";
	vector<int> friends_, online_friends_;
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		friends_.push_back(pInfo(p_)->friends[c_].uid);
	} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (find(friends_.begin(), friends_.end(), pInfo(currentPeer)->uid) != friends_.end()) {
			online_friends_.push_back(pInfo(currentPeer)->uid);
			on_++;
		}
	} if (all and pInfo(p_)->friends.size() != 0) {
		long long time_t = time(NULL);
		for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
			if (find(online_friends_.begin(), online_friends_.end(), pInfo(p_)->friends[c_].uid) == online_friends_.end()) {
				long long friend_last_online_ = time_t - pInfo(p_)->friends[c_].last_seen;
				info_ += "\nadd_friend_image_label_button|" + to_string(pInfo(p_)->friends[c_].uid) + "|`4(" + (friend_last_online_ < 60 ? to_string(friend_last_online_) + "s" : (friend_last_online_ < 3600 ? to_string(friend_last_online_ / 60) + "m" : (friend_last_online_ < 86400 ? to_string(friend_last_online_ / 3600) + "h" : to_string(friend_last_online_ / 86400) + "d"))) + ") ``" + GetNameByUid(pInfo(p_)->friends[c_].uid) + "|game/tiles_page14.rttex|1.6|31|23|32|" + (pInfo(p_)->friends[c_].mute ? "true" : "false") + "|" + (pInfo(p_)->friends[c_].block_trade ? "true" : "false") + "|";
			}
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + to_string(on_) + " of " + to_string(pInfo(p_)->friends.size()) + " `wFriends Online``|left|1366|\nadd_spacer|small|" + info_ + "\nadd_spacer|small|\nadd_textbox|`oYou aren't currently ignoring anyone.``|left|\nadd_spacer|small|\nadd_button|all_friends|Edit Friends|noflags|0|0|\nadd_button|friends_options|Friend Options|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nend_dialog|friends|||\nadd_quick_exit|");
		p.CreatePacket(p_);
	}
	else {
		for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
			if (find(online_friends_.begin(), online_friends_.end(), pInfo(p_)->friends[c_].uid) != online_friends_.end()) {
				info_ += "\nadd_friend_image_label_button|" + to_string(pInfo(p_)->friends[c_].uid) + "|" + GetNameByUid(pInfo(p_)->friends[c_].uid) + "|game/tiles_page14.rttex|1.6|28|23|32|" + (pInfo(p_)->friends[c_].mute ? "true" : "false") + "|" + (pInfo(p_)->friends[c_].block_trade ? "true" : "false") + "|";
			}
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + to_string(on_) + " of " + to_string(pInfo(p_)->friends.size()) + " `wFriends Online``|left|1366|\nadd_spacer|small|" + (on_ == 0 and pInfo(p_)->friends.size() != 0 ? "\nadd_textbox|`oNone of your friends are currently online.``|left|\nadd_spacer|small|" : (pInfo(p_)->friends.size() == 0 ? "\nadd_textbox|`oYou currently have no friends.  That's just sad.  To make some, press a person's wrench icon, then choose `5Add as friend``.``|left|\nadd_spacer|small|" : (on_ != 0 ? info_ : "\nadd_textbox|`oNone of your friends are currently online.``|left|\nadd_spacer|small|"))) + "\nadd_spacer|small|" + (pInfo(p_)->friends.size() == 0 ? "" : (on_ == pInfo(p_)->friends.size() ? "\nadd_spacer|small|\nadd_button|all_friends|Edit Friends|noflags|0|0|" : "\nadd_button|friend_all|Show offline and ignored too|noflags|0|0|\nadd_button|all_friends|Edit Friends|noflags|0|0|")) + "\nadd_button|friends_options|Friend Options|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nend_dialog|friends|||\nadd_quick_exit|");
		p.CreatePacket(p_);
	}
}
/*
void mines_(ENetPeer* p_) {
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\n"
		"\nadd_label_with_icon|big|`wGrowLand Mines``|left|6994|"
		"\nadd_textbox|Are you sure you want to play " + server_name + " Bet?|left|"
		"\nadd_text_input|gems|Gems Amount:|100000|15|"
		"\nadd_smalltext|(100,000-5,000,000)|left|\nadd_text_input|minesamount|Mines Amount:|4|2|\nadd_smalltext|(1-10)|left|"
		"\nadd_spacer|small|\nadd_textbox|Confirm to play " + server_name + " Mines by clicking `2Bet!`` below to start playing.|left|\nadd_textbox|`8Remember``: Every mine will add 1 in 9 of your bet amount of gems!|left|\nadd_spacer|small|\nadd_textbox|`4Warning!`` You will lose all your progress/gems if you disconnect or leave!|left|"
		"\nadd_spacer|small|\nadd_button|accelts|Bet!|noflags|0|0|\nadd_button|backs|`oBack|noflags|0|0|\nend_dialog|mines|Close||\n");
	p.CreatePacket(p_);
}
*/
void send_social(ENetPeer* p_) {
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	string guildInfo = pInfo(p_)->guild_id != 0 ? "Show Guild Members" : "Create Guild";
	p.Insert("set_default_color|`o\nadd_label_with_icon|big| `wSocial Portal`` |left|7074|\n"
		"add_spacer|small|\nadd_button|showfriend|`3Friends``|left|1366|\n"
		"add_button|showguild|`w" + guildInfo + "``|noflags|0|0|\n"
		//"add_button|spotifymain|`2Spotify``|noflags|0|0|\n"

		"add_button|verifiedw|`9Verify Worlds|noflags|0|0|\n"
		"add_button|onlinepointhub|`bOnline Point (Credits)``|noflags|0|0|\n"
		"add_button|trade_history|`8Trading History``|noflags|0|0|\n"
		"add_button|classic_bank|`cBank Lock``|noflags|0|0|\n"
		//"add_button|casino_gachas|`bLIMITED GACHA``|noflags|0|0|\n"
		//"add_button|redeem_open|`wRedeem Code``|noflags|0|0|\n"
		"add_button|rayman_up|`cRayman upgrade``|noflags|0|0|\n"
		//"add_button|gamble_game|`bMiner Game``|noflags|0|0|\n"
	//	"add_button|slot_game|`4Slot Game``|noflags|0|0|\n"
		"add_button|punch_e|`2Punch Count Quest|noflags|0|0|\n"
		//"add_button|lmboS|`wLimbo Game|noflags|0|0|\n"
		//"add_button|mining|`2Mining``|noflags|0|0|\n"
		"add_quick_exit|\nend_dialog|socialportal||Back|\n");
	p.CreatePacket(p_);
}
void edit_friend(ENetPeer* p_, string name_, bool back_ = false) {
	int uid = GetUidByName(name_);
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		if (pInfo(p_)->friends[c_].uid == uid) {
			if (back_) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->uid == pInfo(p_)->friends[c_].uid) {
						send_friends(p_, true);
						return;
					}
				}
				send_friends(p_);
				break;
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Remove Friend``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4remove`` " + GetNameByUid(pInfo(p_)->friends[c_].uid) + " as a friend?|left|\nadd_spacer|small|\nadd_button|remove|`4Remove Friend``|noflags|0|0|\nembed_data|friendID|" + to_string(pInfo(p_)->friends[c_].uid) + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_remove|||\nadd_quick_exit|");
			p.CreatePacket(p_);
			break;
		}
	}
}
void send_info_friend(ENetPeer* p_, string name_) {
	int uid = GetUidByName(name_);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->tankIDName == name_) {
			if (pInfo(currentPeer)->invis or pInfo(currentPeer)->m_h) continue;
			for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
				if (pInfo(p_)->friends[c_].uid == pInfo(currentPeer)->uid) {
					pInfo(p_)->last_edit = pInfo(currentPeer)->tankIDName;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (not pInfo(currentPeer)->show_location_) {
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + GetNameByUid(pInfo(currentPeer)->uid) + "``|left|1366|\nadd_spacer|small|\nembed_data|friendID|" + to_string(pInfo(currentPeer)->uid) + "\nadd_textbox|`o" + GetNameByUid(pInfo(currentPeer)->uid) + " is `2online`` now, but has not made their location public to friends.|left|\nadd_spacer|small|\nadd_button|remove|Remove as friend|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_edit|||\nadd_quick_exit|");
					}
					else {
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + GetNameByUid(pInfo(currentPeer)->uid) + "``|left|1366|\nadd_spacer|small|\nembed_data|friendID|" + to_string(pInfo(currentPeer)->uid) + "\nadd_textbox|`o" + GetNameByUid(pInfo(currentPeer)->uid) + " is `2online`` now in the world `5" + (pInfo(currentPeer)->world.empty() ? "EXIT" : pInfo(currentPeer)->world) + "``.|left|\nadd_spacer|small|\nadd_button|goto|Warp to `5" + (pInfo(currentPeer)->world.empty() ? "EXIT" : pInfo(currentPeer)->world) + "``|noflags|0|0|" + (pInfo(p_)->friends[c_].mute ? "\nadd_button||`4Can't Send message``|disabled|0|0|\nadd_button|mute|Un Mute Friend|noflags|0|0|" : "\nadd_button|msg|`5Send message``|noflags|0|0|\nadd_button|mute|Mute Friend|noflags|0|0|") + (pInfo(p_)->friends[c_].block_trade ? "\nadd_button|trade_block|Enable Trade|noflags|0|0|" : "\nadd_button|trade_block|Disable Trade|noflags|0|0|") + "\nadd_spacer|small|\nadd_button|remove|Remove as friend|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_edit|||\nadd_quick_exit|");
					}
					p.CreatePacket(p_);
					return;
				}
			}
			return;
		}
	}
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		if (pInfo(p_)->friends[c_].uid == uid) {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + GetNameByUid(uid) + "``|left|1366|\nadd_spacer|small|\nembed_data|friendID|" + to_string(uid) + "\nadd_textbox|`o" + GetNameByUid(uid) + " is `4offline``.|left|\nadd_spacer|small|\nadd_button|remove|Remove as friend|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_edit|||\nadd_quick_exit|");
			p.CreatePacket(p_);
			break;
		}
	}
}
void update_guild_name(ENetPeer* peer, string guild_world, World* world_) {
	update_clothes(peer);
}
void update_world(ENetPeer* peer, World* world_, string newName, string worldName) {
	if (world_->owner_name.empty() or world_->owner_name == pInfo(peer)->tankIDName) return;
	int lock_id = 0, lock_x = -1, lock_y = -1;
	int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
	for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
		if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
			if (world_->blocks[i_].fg == 202 || world_->blocks[i_].fg == 204 || world_->blocks[i_].fg == 206 || world_->blocks[i_].fg == 4994) {
				world_->blocks[i_].owner_name = newName;
				world_->blocks[i_].owner_id = pInfo(peer)->uid;
			}
		}
	}
	world_->owner_id = pInfo(peer)->uid;
	world_->owner_name = newName;
	world_->owner_named = (pInfo(peer)->dev == 1 ? "`6@" : pInfo(peer)->admin == 1 ? "`8@" : pInfo(peer)->supermod == 1 ? "`b@" : (pInfo(peer)->tmod == 1) ? "`#@" :
		pInfo(peer)->glory == 1 ? "`c[GLORY] " : pInfo(peer)->vvip == 1 ? "`9[VVIP] " : pInfo(peer)->vip == 1 ? "`1[VIP] " : "`o") + newName + (is_reseller(peer) and not pInfo(peer)->hide_reseller ? " `4[LICENSE]``" : "");
	save_world(worldName, false);
}
/*

void update_access(ENetPeer* peer, World* world_) {
	//if (world_->owner_name.empty())
	{
		for (int i = 0; i < world_->blocks.size(); i++) {
			if (world_->blocks[i].fg == 202 || world_->blocks[i].fg == 204 || world_->blocks[i].fg == 206 || world_->blocks[i].fg == 4994)
			{
				if (world_->blocks[i].owner_name == pInfo(peer)->old_name)
					world_->blocks[i].owner_name = pInfo(peer)->tankIDName;
			}
			if (find(world_->blocks[i].admins.begin(), world_->blocks[i].admins.end(), pInfo(peer)->uid) != world_->blocks[i].admins.end())
			{
				for (int i = 0; i < world_->blocks[i].admins.size(); i++) {
					if (to_lower(world_->blocks[i].admins[i]) == to_lower(pInfo(peer)->old_name))
						world_->blocks[i].admins[i] = pInfo(peer)->tankIDName;
				}
			}
		}
	}
	//else
	{
		if (find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->old_name) != world_->admins.end())
		{
			for (int i = 0; i < world_->admins.size(); i++)
			{
				if (world_->admins[i] == pInfo(peer)->old_name)
					world_->admins[i] = pInfo(peer)->tankIDName;
			}
		}
	}
}
void update_friends(ENetPeer* peer) {
	for (int i = 0; i < pInfo(peer)->friends.size(); i++) {
		ENetPeer* f_ = pData::Algorithm::get_player(pInfo(peer)->friends[i].name);
		if (f_ != nullptr) {
			for (int j = 0; j < pInfo(f_)->friends.size(); j++) {
				if (pInfo(f_)->friends[j].name == pInfo(peer)->old_name)
					pInfo(f_)->friends[j].name = pInfo(peer)->tankIDName;
			}
			save_player(pInfo(f_), false);
		}
		else {
			string path_ = "database/players/" + pInfo(peer)->friends[i].name + "_.json";
			if (_access_s(path_.c_str(), 0) == 0) {
				json r_;
				ifstream f_s(path_, ifstream::binary);
				if (f_s.fail()) {
					tayo_warn("Error while reading database");
					gnettoken_db_logs("Failed reading data for " + pInfo(peer)->friends[i].name);
					return;
				}
				f_s >> r_;
				f_s.close();
				try {
					json f_ = r_["friends"].get<json>();
					for (int i_ = 0; i_ < f_.size(); i_++) {
						if (f_[i_]["name"] == pInfo(peer)->old_name) {
							f_[i_]["name"] = pInfo(peer)->tankIDName;
							break;
						}
					}
					r_["friends"] = f_;
				}
				catch (exception) {
					return;
				}
				ofstream f_l(path_, ifstream::binary);
				f_l << r_;
				f_l.close();
			}
		}
	}
}
*/


void transfer_world(World* world_, ENetPeer* from_, ENetPeer* to_) {
	if (world_->owner_name.empty()) return;
	int lock_id = 0, lock_x = -1, lock_y = -1;
	int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
	for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
		if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
			if (world_->blocks[i_].fg == 202 || world_->blocks[i_].fg == 204 || world_->blocks[i_].fg == 206 || world_->blocks[i_].fg == 4994) continue;
			uint32_t id_ = world_->blocks[i_].fg;
			lock_id = id_, lock_x = i_ % xSize, lock_y = i_ / xSize;
			break;
		}
	}
	if (lock_id == 0) return;
	if (world_->guild_id != 0) {
		uint32_t guild_id = world_->guild_id;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			uint32_t my_rank = 0;
			for (GuildMember member_search : guild_information->guild_members) {
				if (member_search.member_name == pInfo(from_)->tankIDName) {
					my_rank = member_search.role_id;
					break;
				}
			}
			if (my_rank < 3 || pInfo(from_)->guild_id != world_->guild_id || pInfo(from_)->guild_id != 0 || pInfo(to_)->guild_id != 0 || pInfo(to_)->guild_id != world_->guild_id) {
				cancel_trade(from_, false);
				gamepacket_t p, p1;
				p.Insert("OnTalkBubble"); p1.Insert("OnTalkBubble");
				p.Insert(pInfo(from_)->netID), p1.Insert(pInfo(from_)->netID);
				p.Insert("That's doesn't seems valid! You doesn't have the Guild/You're trying to abusing exploit bugs!\nThis a warning!");
				p1.Insert("That's doesn't seems valid! You doesn't have the Guild/You're trying to abusing exploit bugs!\nThis a warning!");
				p.Insert(0), p.Insert(0); p1.Insert(0), p1.Insert(0);
				p.CreatePacket(from_); p1.CreatePacket(to_);
				pInfo(from_)->Warning++; pInfo(to_)->Warning++;
				pInfo(from_)->Warning_Message.push_back("Trying to exploit bugs (Guild Key)");
				pInfo(to_)->Warning_Message.push_back("Trying to exploit bugs (Guild Key)");
				gamepacket_t a, b;
				a.Insert("OnAddNotification"), b.Insert("OnConsoleMessage"); a.Insert("interface/atomic_button.rttex");
				a.Insert("Warning from `4System``: You've been warned for trying to exploit"); a.Insert("audio/hub_open.wav"); a.Insert(0);
				b.Insert("Warning from `4System``: You've been warned for trying to exploit");
				a.CreatePacket(from_), b.CreatePacket(from_);
				Send_Mod_Logs2("(```4System```^) in [```4HIDDEN!```^] > `^Warn : " + pInfo(from_)->tankIDName + "\n`4Warning Message : Trying a exploit? Nice try kiddo``");
				string Logs = "<:warn:1038681185284542464> `4System`` has've been warn: " + pInfo(from_)->tankIDName + " | <:hacker:1038632206400233522> Warn Message: Warned for trying to exploit";
				//send_discord_webhook(Logs, "1038680512748867644/W2voEitQEH3moqXSeIIwfI3DLonOXQnah03XRvvKE3YOVCj1fLSQUbBOLbgbFnya2I9u");
				if (pInfo(from_)->Warning >= 5) {
					int Time = 604800;
					add_ban(from_, Time, "You has 3 warnings records!", pInfo(from_)->name_color + pInfo(from_)->tankIDName + "``");
					Send_Mod_Logs2("(```4System```^) in [```4HIDEEN!```^] > `^BANNED (has've been reach 5 warnings!): " + pInfo(from_)->name_color + pInfo(from_)->tankIDName + "``\n`4Time`` : `#" + ((Time / 86400 > 0) ? to_string(Time / 86400) + " days" : (Time / 3600 > 0) ? to_string(Time / 3600) + " hours" : (Time / 60 > 0) ? to_string(Time / 60) + " minutes" : to_string(Time) + " seconds"));
				}
				{
					gamepacket_t a, b;
					a.Insert("OnAddNotification"), b.Insert("OnConsoleMessage"); a.Insert("interface/atomic_button.rttex");
					a.Insert("Warning from `4System``: You've been warned for trying to exploit"); a.Insert("audio/hub_open.wav"); a.Insert(0);
					b.Insert("Warning from `4System``: You've been warned for trying to exploit");
					a.CreatePacket(to_), b.CreatePacket(to_);
					Send_Mod_Logs2("(```4System```^) in [```4HIDDEN!```^] > `^Warn : " + pInfo(to_)->tankIDName + "\n`4Warning Message : Trying a exploit? Nice try kiddo``");
					string Logs = "<:warn:1038681185284542464> `4System`` has've been warn: " + pInfo(to_)->tankIDName + " | <:hacker:1038632206400233522> Warn Message: Warned for trying to exploit";
					//send_discord_webhook(Logs, "1038680512748867644/W2voEitQEH3moqXSeIIwfI3DLonOXQnah03XRvvKE3YOVCj1fLSQUbBOLbgbFnya2I9u");
					if (pInfo(to_)->Warning >= 5) {
						int Time = 604800;
						add_ban(to_, Time, "You has 3 warnings records!", pInfo(to_)->name_color + pInfo(to_)->tankIDName + "``");
						Send_Mod_Logs2("(```4System```^) in [```4HIDEEN!```^] > `^BANNED (has've been reach 3 warnings!): " + pInfo(to_)->name_color + pInfo(to_)->tankIDName + "``\n`4Time`` : `#" + ((Time / 86400 > 0) ? to_string(Time / 86400) + " days" : (Time / 3600 > 0) ? to_string(Time / 3600) + " hours" : (Time / 60 > 0) ? to_string(Time / 60) + " minutes" : to_string(Time) + " seconds"));
					}
				}
				return;
			}
			if (pInfo(from_)->tankIDName == world_->owner_name) {
				pInfo(from_)->worlds_owned.erase(remove(pInfo(from_)->worlds_owned.begin(), pInfo(from_)->worlds_owned.end(), world_->name), pInfo(from_)->worlds_owned.end());
			}
			else {
				bool on_ = false;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->tankIDName == world_->owner_name) {
						pInfo(currentPeer)->worlds_owned.erase(remove(pInfo(currentPeer)->worlds_owned.begin(), pInfo(currentPeer)->worlds_owned.end(), world_->name), pInfo(currentPeer)->worlds_owned.end());
						on_ = true;
						break;
					}
				} if (not on_) {
					try {
						string path_ = "database/players/" + world_->owner_name + "_.json";
						if (_access_s(path_.c_str(), 0) == 0) {
							json r_;
							ifstream f_(path_, ifstream::binary);
							if (f_.fail()) {
								tayo_warn("Error while reading database");
								gnettoken_db_logs("Failed reading data for " + world_->owner_name);
								return;
							}
							f_ >> r_;
							f_.close();
							try {
								json f_ = r_["worlds_owned"].get<json>();
								for (int i_ = 0; i_ < f_.size(); i_++) {
									if (f_[i_]["name"] == world_->name) {
										f_.erase(f_.begin() + i_);
										break;
									}
								}
								r_["worlds_owned"] = f_;
							}
							catch (exception) {
								return;
							}
							{
								ofstream f_(path_, ifstream::binary);
								f_ << r_;
								f_.close();
							}
						}
					}
					catch (exception) {
						tayo_warn("Error while reading database");
						gnettoken_db_logs("Something went wrong players/json");
					}
				}
			}
			string before_name = world_->owner_name;
			world_->owner_name = pInfo(to_)->tankIDName;
			world_->owner_id = pInfo(to_)->uid;
			if (pInfo(to_)->name_color == "`0") world_->owner_named = "`o" + pInfo(to_)->tankIDName;
			if (HasRole(pInfo(to_)))  world_->owner_named = pInfo(to_)->name_color + pInfo(to_)->tankIDName;
			pInfo(to_)->worlds_owned.push_back(world_->name);
			PlayerMoving data_{};
			data_.packetType = 15, data_.punchX = lock_x, data_.punchY = lock_y, data_.characterState = 0x8;
			data_.netID = pInfo(to_)->id;
			data_.plantingTree = lock_id;
			BYTE* raw = packPlayerMoving(&data_, 56);
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(to_)->netID);
			p.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + pInfo(to_)->name_color + world_->owner_name + "```5]``");
			p.Insert(0);
			gamepacket_t p2;
			{
				p2.Insert("OnConsoleMessage");
				p2.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + pInfo(to_)->name_color + world_->owner_name + "```5]``");
			}
			update_clothes(to_);
			update_clothes(from_);
			gamepacket_t p1;
			p1.Insert("OnAddNotification");
			p1.Insert("interface/large/gd_prom.rttex");
			p1.Insert("You have been promoted to Leader");
			p1.Insert("audio/levelup2.wav"); p1.Insert(0);
			p1.CreatePacket(to_);
			gamepacket_t p22;
			p22.Insert("OnConsoleMessage");
			p22.Insert("`5[GUILD ALERT]`` `2" + pInfo(from_)->tankIDName + "`` has been `4demoted`` to Co-Leader!");
			gamepacket_t p3;
			p3.Insert("OnConsoleMessage");
			p3.Insert("`5[GUILD ALERT]`` `2" + pInfo(to_)->tankIDName + "`` has been `2promoted`` to Leader!");
			for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
				GuildMember* edit_member = &guild_information->guild_members[i_];
				if (edit_member->member_name == before_name) edit_member->role_id = 2;
				if (edit_member->member_name == pInfo(to_)->tankIDName) edit_member->role_id = 3;
			}
			int x_ = 0, y_ = 0;
			int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
			for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
				if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
					uint32_t id_ = world_->blocks[i_].fg;
					if (id_ == 5814) {
						x_ = i_ % xSize;
						y_ = i_ / xSize;
						break;
					}
				}
			}
			WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
			PlayerMoving dataa_{};
			dataa_.packetType = 5, dataa_.punchX = x_, dataa_.punchY = y_, dataa_.characterState = 0x8;
			BYTE* raww = packPlayerMoving(&dataa_, 112 + alloc_(world_, block_));
			BYTE* blc = raww + 56;
			form_visual(blc, *block_, *world_, to_, false);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == world_->name) {
					packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
					send_raw(currentPeer, 4, raww, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
				}
				if (pInfo(currentPeer)->guild_id == guild_id) {
					p22.CreatePacket(currentPeer); p3.CreatePacket(currentPeer);
				}
			}
			update_guild_name(from_, world_->name, world_);
			update_guild_name(to_, world_->name, world_);
			delete[] raw, raww, blc;
		}
		save_world(pInfo(to_)->world, false);
	}
	else {
		for (int i_ = 0; i_ < pInfo(from_)->trade_items.size(); i_++) {
			map<string, int>::iterator it;
			for (auto it = pInfo(from_)->trade_items[i_].begin(); it != pInfo(from_)->trade_items[i_].end(); it++) {
				if (it->first == 5816) {
					cancel_trade(from_, false);
					gamepacket_t p, p1;
					p.Insert("OnTalkBubble"); p1.Insert("OnTalkBubble");
					p.Insert(pInfo(from_)->netID), p1.Insert(pInfo(from_)->netID);
					p.Insert("That doesn't seems valid! You doesn't have the Guild/You're trying to abuse bugs!\nThis a warning!");
					p1.Insert("That doesn't seems valid! You doesn't have the Guild/You're trying to abuse bugs!\nThis a warning!");
					p.Insert(0), p.Insert(0); p1.Insert(0), p1.Insert(0);
					p.CreatePacket(from_); p1.CreatePacket(to_);
					pInfo(from_)->Warning++; pInfo(to_)->Warning++;
					pInfo(from_)->Warning_Message.push_back("Trying exploit bugs (Guild Key)");
					pInfo(to_)->Warning_Message.push_back("Trying exploit bugs (Guild Key)");
					gamepacket_t a, b;
					a.Insert("OnAddNotification"), b.Insert("OnConsoleMessage"); a.Insert("interface/atomic_button.rttex");
					a.Insert("Warning from `4System``: Trying to exploit? Nice try but it won't work here"); a.Insert("audio/hub_open.wav"); a.Insert(0);
					b.Insert("Warning from `4System``: Trying to exploit? Nice try but it won't work here");
					a.CreatePacket(from_), b.CreatePacket(from_);

					//WEBHOOK HERE
					if (pInfo(from_)->Warning >= 3) {
						int Time = 604800;
						add_ban(from_, Time, "Reached 3 Warnings!", "System");
						Send_Mod_Logs2("(```4System```^) in [```4HIDEEN!```^] > `^AUTO-BANNED (reached 3 warnings!): " + pInfo(from_)->name_color + pInfo(from_)->tankIDName + "``\n`4Time`` : `#" + ((Time / 86400 > 0) ? to_string(Time / 86400) + " days" : (Time / 3600 > 0) ? to_string(Time / 3600) + " hours" : (Time / 60 > 0) ? to_string(Time / 60) + " minutes" : to_string(Time) + " seconds"));
					}
					{
						gamepacket_t a, b;
						a.Insert("OnAddNotification"), b.Insert("OnConsoleMessage"); a.Insert("interface/atomic_button.rttex");
						a.Insert("Warning from `4System``: Trying to exploit? Nice try but it won't work here"); a.Insert("audio/hub_open.wav"); a.Insert(0);
						b.Insert("Warning from `4System``: Trying to exploit? Nice try but it won't work here");
						a.CreatePacket(to_), b.CreatePacket(to_);
						Send_Mod_Logs2("(```4System```^) in [```4HIDDEN!```^] > `^Warn : " + pInfo(to_)->tankIDName + "\n`4Warning Message : Trying to exploit``");
						//WEBHOOK HERE
						if (pInfo(to_)->Warning >= 3) {
							int Time = 604800;
							add_ban(to_, Time, "Reached 3 Warnings!", "System");
							Send_Mod_Logs2("(```4System```^) in [```4HIDEEN!```^] > `^AUTO-BANNED (reached 3 warnings!): " + pInfo(to_)->name_color + pInfo(to_)->tankIDName + "``\n`4Time`` : `#" + ((Time / 86400 > 0) ? to_string(Time / 86400) + " days" : (Time / 3600 > 0) ? to_string(Time / 3600) + " hours" : (Time / 60 > 0) ? to_string(Time / 60) + " minutes" : to_string(Time) + " seconds"));
						}
					}
					return;
				}
			}
		}
		if (pInfo(from_)->tankIDName == world_->owner_name) {
			pInfo(from_)->worlds_owned.erase(remove(pInfo(from_)->worlds_owned.begin(), pInfo(from_)->worlds_owned.end(), world_->name), pInfo(from_)->worlds_owned.end());
		}
		else {
			bool on_ = false;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->tankIDName == world_->owner_name) {
					pInfo(currentPeer)->worlds_owned.erase(remove(pInfo(currentPeer)->worlds_owned.begin(), pInfo(currentPeer)->worlds_owned.end(), world_->name), pInfo(currentPeer)->worlds_owned.end());
					on_ = true;
					break;
				}
			} if (not on_) {
				try {
					string path_ = "database/players/" + world_->owner_name + "_.json";
					if (_access_s(path_.c_str(), 0) == 0) {
						json r_;
						ifstream f_(path_, ifstream::binary);
						if (f_.fail()) {
							tayo_warn("Error while reading database");
							gnettoken_db_logs("Failed reading data for " + world_->owner_name);
							return;
						}
						f_ >> r_;
						f_.close();
						try {
							json f_ = r_["worlds_owned"].get<json>();
							for (int i_ = 0; i_ < f_.size(); i_++) {
								if (f_[i_]["name"] == world_->name) {
									f_.erase(f_.begin() + i_);
									break;
								}
							}
							r_["worlds_owned"] = f_;
						}
						catch (exception) {
							return;
						}
						{
							ofstream f_(path_, ifstream::binary);
							f_ << r_;
							f_.close();
						}
					}
				}
				catch (exception) {
					tayo_warn("Error while reading database");
					gnettoken_db_logs("Something went wrong players/json");
				}
			}
		}
		string before_name = world_->owner_name;
		world_->owner_name = pInfo(to_)->tankIDName;
		if (pInfo(to_)->name_color == "`0") world_->owner_named = "`o" + pInfo(to_)->tankIDName;
		if (pInfo(to_)->mod || pInfo(to_)->admin || pInfo(to_)->dev)  world_->owner_named = pInfo(to_)->name_color + pInfo(to_)->tankIDName;
		pInfo(to_)->worlds_owned.push_back(world_->name);
		PlayerMoving data_{};
		data_.packetType = 15, data_.punchX = lock_x, data_.punchY = lock_y, data_.characterState = 0x8;
		data_.netID = pInfo(to_)->id;
		data_.plantingTree = lock_id;
		BYTE* raw = packPlayerMoving(&data_, 56);
		gamepacket_t p;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(to_)->netID);
		p.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + pInfo(to_)->name_color + world_->owner_name + "```5]``");
		p.Insert(0);
		gamepacket_t p2;
		{
			p2.Insert("OnConsoleMessage");
			p2.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + pInfo(to_)->name_color + world_->owner_name + "```5]``");
		}
		update_clothes(to_);
		update_clothes(from_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name) {
				packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
			}
		}
		delete[] raw;
		save_world(pInfo(to_)->world, false);
	}
}
void add_items_newjson(ENetPeer* peer, const json& newItem, json& jsonData) {
	auto itemId = newItem["ItemId"];
	auto existingItem = std::find_if(jsonData.begin(), jsonData.end(),
		[itemId](const json& item) { return item["ItemId"] == itemId; });

	if (existingItem == jsonData.end()) {
		jsonData.push_back(newItem);
		std::ofstream fileOutput("./database/config/items.json");
		fileOutput << std::setw(4) << jsonData << std::endl;
		fileOutput.close();
		int fars = newItem["Fars"];
		int maxgem = newItem["Gems"];
		int brekhit = newItem["BreakHit"];
		Algorithm::send_overlay(peer, "`2[ `0Succesfully edit " + items[itemId].ori_name + "! `2]");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			packet_(currentPeer, "action|play_sfx\nfile|audio/levelup.wav\ndelayMS|0");
			Algorithm::send_console(currentPeer, "`2>> `cServer Update :");
			Algorithm::send_console(currentPeer, "");
			Algorithm::send_console(currentPeer, "`2>> `9The Item " + items[itemId].ori_name + "!!");
			Algorithm::send_console(currentPeer, "`2>> `cHas Been Added");
			Algorithm::send_console(currentPeer, "`2>> `cItem Name : `9" + items[itemId].ori_name);
			Algorithm::send_console(currentPeer, "`2>> `cFar Place & Punch : `9" + setGems(fars));
			Algorithm::send_console(currentPeer, "`2>> `cGems Multiplied : `9" + setGems(maxgem));
			Algorithm::send_console(currentPeer, "`2>> `cBreak Hit : `9" + setGems(brekhit));
			Algorithm::send_console(currentPeer, "`2>> `4Global System Message: `5Enjoy Playing :D");
		}
	}
	else {
		Algorithm::send_overlay(peer, "Item with ItemId " + to_string(itemId) + " already exists.");
	}
}
void remove_friend(ENetPeer* p_, World* world_, string name_, bool show_Dialog = true) {
	int uid = GetUidByName(name_);
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		if (pInfo(p_)->friends[c_].uid == uid) {
			if (show_Dialog) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Friend removed``|left|1366|\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with " + GetNameByUid(pInfo(p_)->friends[c_].uid) + ".|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|friends_remove_finish|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			bool on_ = false;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->uid == uid) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`3FRIEND ALERT:`` " + pInfo(p_)->modName + "`` has removed you as a friend.");
					p.CreatePacket(currentPeer);
					for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
						if (pInfo(currentPeer)->friends[c_].uid == pInfo(p_)->uid) {
							pInfo(currentPeer)->friends.erase(pInfo(currentPeer)->friends.begin() + c_);
							break;
						}
					}
					on_ = true;
					break;
				}
			} if (not on_) {
				try {
					string path_ = "database/players/" + GetNameByUid(uid) + "_.json";
					if (_access_s(path_.c_str(), 0) == 0) {
						json r_;
						ifstream f_(path_, ifstream::binary);
						if (f_.fail()) {
							tayo_warn("Error while reading database");
							gnettoken_db_logs("Failed reading data for " + GetNameByUid(uid));
							return;
						}
						f_ >> r_;
						f_.close();
						try {
							json f_ = r_["friends"].get<json>();
							for (int i_ = 0; i_ < f_.size(); i_++) {
								if (f_[i_]["uid"] == pInfo(p_)->uid) {
									f_.erase(f_.begin() + i_);
									break;
								}
							}
							r_["friends"] = f_;
						}
						catch (exception) {
							return;
						}
						{
							ofstream f_(path_, ifstream::binary);
							f_ << r_;
							f_.close();
						}
					}
				}
				catch (exception) {
					tayo_warn("Error while reading database");
					gnettoken_db_logs("Something went wrong on players.json");
				}
			}
			pInfo(p_)->friends.erase(pInfo(p_)->friends.begin() + c_);
		}
	}
}

void send_all_edit_friends(ENetPeer* p_) {
	string info_ = "";
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		info_ += "\nadd_checkbox|cf_" + to_string(c_) + "|" + GetNameByUid(pInfo(p_)->friends[c_].uid) + (pInfo(p_)->friends[c_].mute ? " <Muted>" : "") + (pInfo(p_)->friends[c_].block_trade ? " <Trade Block>" : "") + "|0";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wAll Friends``|left|1366|\nadd_spacer|small|\nadd_button|remove_multi_friends|Remove|noflags|0|0|\nadd_button|block_multi_friends|Block / Unblock Trade|noflags|0|0|\nadd_button|mute_multi_friends|Mute / Unmute|noflags|0|0|\nadd_spacer|small|" + info_ + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|all_friends|||\nadd_quick_exit|");
	p.CreatePacket(p_);
}
string make_trade_offer(Player* p_, bool special_ = false) {
	if (p_->trade_items.size() == 0 and not special_)
		return "\nadd_textbox|`4Nothing!``|left|";
	string list_ = "";
	for (int i_ = 0; i_ < p_->trade_items.size(); i_++) {
		map<string, int>::iterator it;
		for (auto it = p_->trade_items[i_].begin(); it != p_->trade_items[i_].end(); it++) {
			if (special_)
				list_ += "add_slot|" + to_string(it->first) + "|" + to_string(it->second) + "\n";
			else
				list_ += "\nadd_label_with_icon|small|(`w" + to_string(it->second) + "``) " + items[it->first].ori_name + "|left|" + to_string(it->first) + "|";
		}
	}
	return list_;
}
void send_offline_info(ENetPeer* peer, string name) {
	try {
		pInfo(peer)->last_wrenched = name;
		int tesdt = 0, tesst = 0, totalWarn = 0;
		ifstream ifs("database/players/" + name + "_.json");
		if (ifs.is_open()) {
			string bans = "", warn = "", actualName = "";
			json j;
			ifs >> j;
			tesdt = j["b_t"].get<long long int>();
			tesst = j["b_s"].get<long long int>();
			actualName = j["modname"].get<string>();
			string bannedMessage = tesdt + tesst != 0 ? " `o(`4BANNED`o)" : "";
			for (string a : j["bans"]) bans += "\nadd_smalltext|" + a + ",|left|";
			if (bans == "") bans = "This player has clear logs.";
			for (string b : j["warnings"]) warn += "`4" + b + "``\n", totalWarn++;
			if (warn == "") warn = "This player seems doesn't have any warning received!";
			string level_display;
			if (j["level"].get<int>() == 125) {
				level_display = "125 (`4MAX!``)";
			}
			else if (j["level"].get<int>() > 125) {
				level_display = to_string(j["level"].get<int>()) + " (`4EXTRA!``)";
			}
			else {
				level_display = to_string(j["level"].get<int>());
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`1Editing -`` `0" + actualName + bannedMessage + "``|left|732|\nadd_spacer|small\nadd_textbox|`4Player Logs``|left|" + bans + "\nadd_spacer|small|\nadd_textbox|`4Warnings``|left|\nadd_smalltext|Current warnings got : `4" + to_string(totalWarn) + "``|left|\nadd_smalltext|Warnings : " + warn + "|left|\nadd_spacer|small|\nadd_textbox|`6Network Info``|left|\nadd_smalltext|Status: `4OFFLINE``|left|\nadd_smalltext|IP: `5" + j["ip"].get<string>() + "``|left|\nadd_smalltext|Last RID: `5" + j["rid"].get<string>() + "``|left|\nadd_smalltext|Last MAC Address: `5" + j["mac"].get<string>() + "``|left|\nadd_smalltext|Country Code: `5Not found.``|left|\nadd_spacer|small\nadd_textbox|`6Assets Info``|left|\nadd_smalltext|Level: `5" + to_string(j["level"].get<int>()) + "``|left|\nadd_smalltext|Gems: `5" + fixint(j["gems"].get<int>()) + "``|left|\nadd_smalltext|Credit Point: `5" + fixint(j["opc"].get<int>()) + "``|left|\nadd_smalltext|gnettoken: `5" + fixint(j["gtwl"].get<int>()) + "``|left|\nadd_smalltext|XP: `5" + fixint(j["xp"].get<int>()) + "``|left|\nadd_spacer|small|\nadd_textbox|`7Punish Player``|left|\nadd_text_input|reason|Reason: ||180|\nadd_spacer|small|\nadd_label_with_icon_button|small|`o<- 24 Hours Ban|left|278|oan_86400|\nadd_spacer|small|\nadd_label_with_icon_button|small|`o<- 3 Days Ban|left|278|oan_259200|\nadd_spacer|small|\nadd_label_with_icon_button|small|`o<- 7 Days Ban|left|278|oan_604800|\nadd_spacer|small|\nadd_label_with_icon_button|small|`o<- 14 Days Ban|left|278|oan_1209600|\nadd_spacer|small|\nadd_label_with_icon_button|small|`o<- 30 Days Ban|left|278|oan_2592000|\nadd_spacer|small|\nadd_label_with_icon_button|small|`o<- 60 Days Ban|left|278|oan_5184000|\nadd_spacer|small|\nadd_label_with_icon_button|small|`o<- Permanently Ban|left|278|oan_64720000|" + (pInfo(peer)->owner ? "\nadd_spacer|small|"
				"\nadd_label_with_icon_button|small|`o<- Permanently IP Ban|left|732|ipban|"
				"\nadd_label_with_icon_button|small|`o<- Hard-Ban for Device|left|732|hardban|" : "") + "\nadd_spacer|small|\nend_dialog|punish_view|Cancel||\nadd_quick_exit|\n");
			p.CreatePacket(peer);
		}
	}
	catch (exception& e) {
		tayo_warn(e.what());
	}
}
void send_wrench_self(ENetPeer* peer, string tab = "info") {
	switch (Algorithm::quick_hash(tab)) {
	case "info"_qh: {
		time_t s__;
		s__ = time(NULL);
		int with = 0, name = pInfo(peer)->uid;
		AffinityType my_type = NO_AFFINITY;
		int my_aff_lvl = 0;
		load_affinity(name, my_type, my_aff_lvl, with);
		pInfo(peer)->affinity_type = my_type;
		pInfo(peer)->affinity_level = my_aff_lvl;
		pInfo(peer)->affinity_with = with;
		int days_ = int(s__) / (60 * 60 * 24);
		double hours_ = (double)((s__ - pInfo(peer)->playtime) + pInfo(peer)->seconds) / 3600;
		string num_text = to_string(hours_), status = "";
		string rounded = num_text.substr(0, num_text.find(".") + 3);
		int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
		get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
		if (pInfo(peer)->p_status == 0) status = "image:interface/large/gui_wrench_online_status_1green.rttex;image_size:400,260;width:0.19;";
		if (pInfo(peer)->p_status == 1) status = "image:interface/large/gui_wrench_online_status_2yellow.rttex;image_size:400,260;width:0.19;";
		if (pInfo(peer)->p_status == 2) status = "image:interface/large/gui_wrench_online_status_3red.rttex;image_size:400,260;width:0.19;";
		DialogBuilder player("`o");
		player.raw("start_custom_tabs|\n")
			.raw("add_custom_button|info|image:interface/large/gtps_wrench_tabs.rttex;image_size:228,92;frame:1,6;width:0.14;min_width:60;|\n")
			.raw("end_custom_tabs|\n");
		player.add_player_info("`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "``", pInfo(peer)->level, pInfo(peer)->xp, 50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2))
			.add_spacer(false);
		if (pInfo(peer)->guild_id != 0) {
			uint32_t guild_id = pInfo(peer)->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				uint32_t my_rank = 0;
				for (GuildMember member_search : guild_information->guild_members) {
					if (member_search.member_name == pInfo(peer)->tankIDName) {
						my_rank = member_search.role_id;
						break;
					}
				}
				if (guild_information->guild_mascot[1] == 0 and guild_information->guild_mascot[0] == 0) {
					player.add_label_icon(false, 5814, "`9Guild: `2" + guild_information->guild_name + "``");
					if (my_rank == 0) player.add_textbox("`9Rank: `2Member``");
					if (my_rank == 1) player.add_textbox("`9Rank: `2Elder``");
					if (my_rank == 2) player.add_textbox("`9Rank: `2Co-Leader``");
					if (my_rank == 3) player.add_textbox("`9Rank: `2Leader``");
				}
				else {
					player.add_dual_layer(false, 1, guild_information->guild_mascot[1], guild_information->guild_mascot[0], 1.0, "`9Guild: `2" + guild_information->guild_name + "``");
					if (my_rank == 0) player.add_textbox("`9Rank: `2Member``");
					if (my_rank == 1) player.add_textbox("`9Rank: `2Elder``");
					if (my_rank == 2) player.add_textbox("`9Rank: `2Co-Leader``");
					if (my_rank == 3) player.add_textbox("`9Rank: `2Leader``");
				}
			}
		}
		if (pInfo(peer)->ac_.size() != 0) {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					if (pInfo(peer)->ac_.find(pInfo(currentPeer)->netID) != pInfo(peer)->ac_.end()) {
						string name_ = pInfo(peer)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							string owner_name = world_->owner_name, user_name = pInfo(currentPeer)->tankIDName;
							WorldBlock block_ = world_->blocks[pInfo(peer)->ac_[pInfo(currentPeer)->netID]];
							if (block_.fg == 202 or block_.fg == 204 or block_.fg == 206 or block_.fg == 4994) {
								if (block_.owner_name != user_name and not pInfo(currentPeer)->dev) break;
							}
							else {
								if (owner_name != user_name and not pInfo(currentPeer)->dev) break;
							}
							player.add_button("acceptlock", "`2Accept Access on " + items[block_.fg].name + "``");
						}
						break;
					}
				}
			}
			//if (extra.empty()) pInfo(peer)->ac_.clear();
		}
		if (pInfo(peer)->pending_guild != 0 and pInfo(peer)->guild_id == 0) {
			uint32_t guild_id = pInfo(peer)->pending_guild;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				if (guild_information->guild_members.size() < guild_information->guild_level * 5) {
					player.add_button("acceptguild", "`2Join " + guild_information->guild_name + " Guild``");
				}
			}
		}
		player.add_small_font_button("account_security", "Account Management");
		if (pInfo(peer)->glo == 1) player.add_small_font_button("glory", "Road To Glory");
		if (pInfo(peer)->affinity_level <= 0 || pInfo(peer)->affinity_with <= 0 || pInfo(peer)->affinity_level > 5) pInfo(peer)->affinity_type = NO_AFFINITY;
		if (pInfo(peer)->affinity_type != NO_AFFINITY) player.add_small_font_button("aff_upgrade", "Manage affinity");
		player.add_spacer(false)
			.set_custom_spacing(5, 10);
		if (pInfo(peer)->back == 10424) player.add_custom_button("rift_cape_edit", "image:interface/large/gui_wrench_rift_cape.rttex;image_size_x:400;image_size_y:260;width:0.19;");
		if (pInfo(peer)->back == 10182) player.add_custom_button("pianowings_edit", "image:interface/large/gui_wrench_musical_wings.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->back == 11478) player.add_custom_button("rift_wings_edit", "image:interface/large/gui_wrench_rift_wings.rttex;image_size_x:400;image_size_y:260;width:0.19;");
		if (pInfo(peer)->face == 11506 or pInfo(peer)->face == 11508) player.add_custom_button("dragon_mask_transform", "image:interface/large/gui_wrench_mask_dragon_transform.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->necklace == 11748) player.add_custom_button("bannerbandolier", "image:interface/large/gui_wrench_banner_bandolier.rttex;image_size_x:400;image_size_y:260;width:0.19;");
		if (pInfo(peer)->hand == 12018 or pInfo(peer)->hand == 12020 or pInfo(peer)->hand == 12014 or pInfo(peer)->hand == 12016) player.add_custom_button("Startek", "image:interface/large/gui_wrench_st_transform.rttex;image_size_x:400;image_size_y:260;width:0.19;");
		if (pInfo(peer)->hand == 12866 or pInfo(peer)->hand == 12868) player.add_custom_button("street_transform", "image:interface/large/gui_wrench_st_ani.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->hand == 10952 or pInfo(peer)->hand == 10954 or pInfo(peer)->hand == 10956 or pInfo(peer)->hand == 10958 or pInfo(peer)->hand == 10960) player.add_custom_button("tmnt_transform", "image:interface/large/gui_wrench_space_animals_transform.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->necklace == 11560 or pInfo(peer)->necklace == 11554 or pInfo(peer)->necklace == 11556 or pInfo(peer)->necklace == 11558) player.add_custom_button("u_transform", "image:interface/large/gui_wrench_u_transform.rttex;image_size_x:400;image_size_y:260;width:0.19;");
		if (pInfo(peer)->necklace == 11818) player.add_custom_button("scarf_of_seasons_edit", "image:interface/large/gui_wrench_banner_seasons_item2.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->necklace == 12646 or pInfo(peer)->necklace == 12648 or pInfo(peer)->necklace == 12650) player.add_custom_button("ac15_transform", "image:interface/large/gui_wrench_a15.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->necklace == 13220 or pInfo(peer)->necklace == 13196) player.add_custom_button("u_transform", "image:interface/large/gui_wrench_u2_transform.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->hair == 12872 or pInfo(peer)->hair == 12874) player.add_custom_button("red_panda_transform", "image:interface/large/gui_wrench_rpan.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->hair == 10674) player.add_custom_button("cernuous_mask_edit", "image:interface/large/gui_wrench_crown_seasons.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->ances == 12634) player.add_custom_button("eq_aura_edit", "image:interface/large/gui_wrench_eq_a.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->back == 12640) player.add_custom_button("minokawa_wings_edit", "image:interface/large/gui_wrench_mkw.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->hair == 12958) player.add_custom_button("infinity_crown_edit", "image:interface/large/gui_wrench_icr.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->feet == 10618) player.add_custom_button("pps_transform", "image:interface/large/gui_wrench_pps_transform.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->feet == 9136 or pInfo(peer)->feet == 9138) player.add_custom_button("dsf_transform", "image:interface/large/gui_wrench_dsf_transform.rttex;image_size:400,260;width:0.19;");
		player.add_custom_button("open_personlize_profile", "image:interface/large/gui_wrench_personalize_profile.rttex;image_size:400,260;width:0.19;")
			.add_custom_button("set_online_status", status)
			.add_custom_button("notebook_edit", "image:interface/large/gui_wrench_notebook.rttex;image_size:400,260;width:0.19;")
			.add_custom_button("goals", "image:interface/large/gui_wrench_goals_quests.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->supp != 0) player.add_custom_button("billboard_edit", "image:interface/large/gui_wrench_edit_billboard.rttex;image_size:400,260;width:0.19;");
		if (pInfo(peer)->gp) player.add_custom_button("bonus", "image:interface/large/gui_wrench_daily_bonus_active.rttex;image_size:400,260;width:0.19;");
		player.add_custom_button("my_worlds", "image:interface/large/gui_wrench_my_worlds.rttex;image_size:400,260;width:0.19;")
			.add_custom_button("alist", "image:interface/large/gui_wrench_achievements.rttex;image_size:400,260;width:0.19;")
			.add_custom_label("(" + to_string(pInfo(peer)->aAchieved) + "/171)", "target:alist;top:0.72;left:0.5;size:small")
			.add_custom_button("emojis", "image:interface/large/gui_wrench_growmojis.rttex;image_size:400,260;width:0.19;")
			.add_custom_button("title_edit", "image:interface/large/gui_wrench_title.rttex;image_size:400,260;width:0.19;")
			//.add_custom_button("show_backpack", "image:interface/large/gui_wrench_backpack.rttex;image_size:400,260;width:0.19;")
			//.add_custom_label("(" + to_string(pInfo(peer)->bp.size()) + "/" + to_string(pInfo(peer)->b_l * 10) + ")", "target:show_backpack;top:0.72;left:0.5;size:small")
			.add_break()
			.add_spacer(false)
			.set_custom_spacing(0, 0);
		if (pInfo(peer)->hand == 8532) player.add_small_font_button("void_ray", "Void Dragon Fist's Settings");
		if (pInfo(peer)->face == 13554) player.add_small_font_button("sharingan", "Ability Sukuna's Settings");
		if (pInfo(peer)->face == 13896) player.add_small_font_button("ruler_sword", "Ability Gojo's Settings");
		if (pInfo(peer)->hand == 9508) player.add_small_font_button("kamish_sword", "Ability Mornach's Settings");
		player.add_small_font_button("cheat_menu", "Cheat Menu");
		player.add_small_font_button("spotify_list", "Spotify");
		player.raw(form_mods(pInfo(peer), 0))
			.add_spacer(false).add_smalltext("`oFires Put Out: " + to_string(pInfo(peer)->fires)).add_smalltext("`oCarnival games won: " + to_string(pInfo(peer)->carnivalgameswon)).add_textbox("`oYou have `w" + to_string(pInfo(peer)->inv.size() - 1) + "`` backpack slots.``")
			.add_textbox("`oCurrent world: `w" + pInfo(peer)->world + "`` (`w" + to_string(pInfo(peer)->x / 32) + "``, `w" + to_string(pInfo(peer)->y / 32) + "``) (`w" + to_string(w_c) + "`` person)````");
		if (pInfo(peer)->home_world != "") player.add_smalltext("`oHome World: " + pInfo(peer)->home_world);
		if (pInfo(peer)->affinity_type != NO_AFFINITY) {
			player.add_smalltext("Affinity: " + GetNameByUid(pInfo(peer)->affinity_with) + "'s " + affinity_to_string(pInfo(peer)->affinity_type));
			player.add_smalltext("Level: " + to_string(pInfo(peer)->affinity_level));
		}
		if (pInfo(peer)->hand == 9882) {
			player.add_smalltext(format("{}'s break limit: {}/200", items[9882].name, pInfo(peer)->punch_sword_time));
		}
		player.add_textbox(pInfo(peer)->supp == 0 ? "`oYou are not yet a `2Supporter or `5Super Supporter`o." : pInfo(peer)->supp == 1 ? "`oYou are a `2Supporter and have the `wRecycler``.``" : pInfo(peer)->supp == 2 ? "`oYou are a `5Super Supporter`` and have the `wRecycler and `w/warp.``" : "");
		if (pInfo(peer)->level >= 125) player.add_textbox("`1Blue Title `ounlocked");
		if (pInfo(peer)->trader) player.add_textbox("`eGlobal Trade License `ounlocked");
		if (pInfo(peer)->vip) player.add_textbox("`1VIP Commands `ounlocked");
		if (pInfo(peer)->vvip) player.add_textbox("`9VVIP Commands `ounlocked");
		if (pInfo(peer)->glory) player.add_textbox("`cGLORY Commands `ounlocked");
		if (pInfo(peer)->mod) player.add_textbox("`#Moderator Commands `ounlocked");
		if (pInfo(peer)->supermod) player.add_textbox("`bSuper Moderator Commands `ounlocked");
		if (is_reseller(peer)) player.add_textbox("`cReseller Commands `ounlocked");
		if (pInfo(peer)->admin) player.add_textbox("`8Admin Commands `ounlocked");
		if (pInfo(peer)->dev) player.add_textbox("`6Developer Commands `ounlocked");
		player.add_textbox("`oYou are standing on the note \"A\".``")
			.add_spacer(false)
			.add_textbox("`oTotal time played is `w" + rounded + "`` hours.  This account was created `w" + to_string(days_ - pInfo(peer)->account_created) + "`` days ago.``")
			.add_spacer(false)
			.end_dialog("popup", "", "Continue")
			.add_quick_exit();
		enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(player.to_string()).pack());
	} break;
	}
	
}

void send_trade_confirm_dialog(ENetPeer* peer, ENetPeer* currentPeer, bool self_only = false) {
	pInfo(peer)->block_trade = true;
	pInfo(currentPeer)->block_trade = true;
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		bool world_key_p = false, world_key_cp = false;
		bool guild_key_p = false, guild_key_cp = false;
		string lock = "";
		for (int i_ = 0; i_ < pInfo(peer)->trade_items.size(); i_++) {
			if (world_key_p or guild_key_p) break;
			map<string, int>::iterator it;
			for (auto it = pInfo(peer)->trade_items[i_].begin(); it != pInfo(peer)->trade_items[i_].end(); it++) {
				if (it->first == 1424 or it->first == 5816) {
					if (it->first == 5816) guild_key_p = true;
					else world_key_p = true;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
							uint16_t id_ = world_->blocks[i_].fg;
							if (id_ != 202 and id_ != 204 and id_ != 206 and id_ != 4994) {
								lock = items[id_].name;
								break;
							}
						}
					}
					break;
				}
			}
		} for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
			if (world_key_cp or guild_key_cp) break;
			map<string, int>::iterator it;
			for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
				if (it->first == 1424 or it->first == 5816) {
					if (it->first == 5816) guild_key_cp = true;
					else world_key_cp = true;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
							if (world_->blocks[i_].fg != 202 and world_->blocks[i_].fg != 204 and world_->blocks[i_].fg != 206 and world_->blocks[i_].fg != 4994) {
								lock = items[world_->blocks[i_].fg].name;
								break;
							}
						}
					}
					break;
				}
			}
		}
		string g_name = "";
		if (guild_key_p or guild_key_cp) {
			uint32_t guild_id = world_->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				g_name = guild_information->guild_name;
			}
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(peer)) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(currentPeer)) + "\nadd_spacer|small|" + (pInfo(currentPeer)->trade_items.size() == 0 ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|" : "") + (guild_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are taking leadership of the guild: `#" + g_name + " and the guild world: " + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a guild world for its name, guild mascot and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (world_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (guild_key_p ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to transfer guild leadership and your guild world `#" + world_->name + "`` - the guild lock ownership will be transferred over to " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``.|left|\nadd_spacer|small|" : (world_key_p ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world_->name + "`` - the world lock ownership will be transferred over to " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``.|left|\nadd_spacer|small|" : "")))) + "\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|trade_confirm|||");
		p.CreatePacket(peer);
		if (not self_only) {
			{
				gamepacket_t p;
				p.Insert("OnForceTradeEnd");
				p.CreatePacket(currentPeer);
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(currentPeer)) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(peer)) + "\nadd_spacer|small|" + (pInfo(peer)->trade_items.size() == 0 ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|" : "") + (guild_key_p ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are taking leadership of the guild: `#" + g_name + " and the guild world: " + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a guild world for its name, guild mascot and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (world_key_p ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (guild_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to transfer guild leadership and your guild world `#" + world_->name + "`` - the guild lock ownership will be transferred over to " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``.|left|\nadd_spacer|small|" : (world_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world_->name + "`` - the world lock ownership will be transferred over to " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``.|left|\nadd_spacer|small|" : "")))) + "\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|trade_confirm|||");
			p.CreatePacket(currentPeer);
		}
	}
}
void mod_trade(ENetPeer* p_, int item_id, int count, bool remove = false) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == pInfo(p_)->world) {
			if (pInfo(currentPeer)->netID == pInfo(p_)->trading_with and pInfo(p_)->netID == pInfo(currentPeer)->trading_with) {
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (pInfo(p_)->block_trade or pInfo(currentPeer)->block_trade) {
						cancel_trade(pInfo(p_)->block_trade ? p_ : currentPeer, false);
						return;
					}
					if (item_id == 5816 and pInfo(p_)->tankIDName != world_->owner_name and not pInfo(p_)->admin or item_id == 1424 and pInfo(p_)->tankIDName != world_->owner_name and not pInfo(p_)->admin) {
						packet_(p_, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("You can only trade World Keys in a world you own!");
						p.CreatePacket(p_);
						break;
					}
					if (item_id == 5816 and pInfo(p_)->guild_id == 0 or item_id == 5816 and pInfo(p_)->guild_id != pInfo(currentPeer)->guild_id) {
						packet_(p_, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("The person must join your guild first!");
						p.CreatePacket(p_);
						break;
					}
					if (remove) {
						int count_ = 0;
						for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
							auto i = pInfo(p_)->trade_items[i_].find(item_id);
							if (i != pInfo(p_)->trade_items[i_].end()) {
								map<string, int>::iterator it;
								for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
									if (it->first == item_id)
										count_ = it->second;
								}
								pInfo(p_)->trade_items.erase(pInfo(p_)->trade_items.begin() + i_);
								break;
							}
						}
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`1TRADE CHANGE: `` " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` removed `w" + to_string(count_) + "`` " + items[item_id].name);
						p.CreatePacket(currentPeer);
					}
					else {
						if (count == 0)break;
						bool f_ = false;
						for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
							map<string, int>::iterator it;
							for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
								if (it->first == item_id and it->second == count) {
									swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
									f_ = true;
									break;
								}
								else if (it->first == item_id and it->second != count) {
									swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
									f_ = true;
									it->second = count;
									break;
								}
							}
						} if (not f_) {
							if (count == 0)break;
							if (pInfo(p_)->trade_items.size() > 3) return;
							map<int, int> new_;
							new_.insert({ item_id, count });
							pInfo(p_)->trade_items.push_back(new_);
						}
						else {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`1TRADE CHANGE: `` " + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " removed `w" + to_string(count) + "`` " + items[item_id].name);
							p.CreatePacket(currentPeer);
						}
						if (count == 0)break;
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`1TRADE CHANGE: `` " + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " added `w" + to_string(count) + "`` " + items[item_id].name);
						p.CreatePacket(currentPeer);
					}
					if (pInfo(p_)->trade_accept == 1) {
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(p_)->netID);
							p.Insert("");
							p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(p_);
						}
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(p_)->netID);
						p.Insert("");
						p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
						p.Insert("locked|0\naccepted|1");
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(p_)->netID);
							p.Insert("");
							p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(p_);
						}
					}
					gamepacket_t p;
					p.Insert("OnTradeStatus");
					p.Insert(pInfo(p_)->netID);
					p.Insert("");
					p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
					p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\naccepted|0");
					p.CreatePacket(p_);
					{
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(currentPeer)->netID);
						p.Insert("");
						p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
						p.Insert("locked|0\naccepted|1");
						p.CreatePacket(currentPeer);
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
							p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(p_)->netID);
							p.Insert("");
							p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
							p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
							p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(p_);
						}
					}
					{
						packet_(p_, "action|play_sfx\nfile|audio/tile_removed.wav\ndelayMS|0");
						packet_(currentPeer, "action|play_sfx\nfile|audio/tile_removed.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("The deal has changed");
						p.CreatePacket(p_), p.CreatePacket(currentPeer);
					}
					pInfo(p_)->trade_accept = 0, pInfo(currentPeer)->trade_accept = 0;
				}
				return;
			}
		}
	}
	if (remove) {
		for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
			auto i = pInfo(p_)->trade_items[i_].find(item_id);
			if (i != pInfo(p_)->trade_items[i_].end()) {
				pInfo(p_)->trade_items.erase(pInfo(p_)->trade_items.begin() + i_);
				break;
			}
		}
	}
	else {
		if (count == 0)return;
		bool f_ = false;
		for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
			map<string, int>::iterator it;
			for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
				if (it->first == item_id and it->second == count) {
					swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
					f_ = true;
					break;
				}
				else if (it->first == item_id and it->second != count) {
					swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
					f_ = true;
					it->second = count;
					break;
				}
			}
		} if (not f_) {
			if (count == 0)return;
			if (pInfo(p_)->trade_items.size() > 3) return;
			map<int, int> new_;
			new_.insert({ item_id, count });
			pInfo(p_)->trade_items.push_back(new_);
		}
	}
	string name_ = pInfo(p_)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (pInfo(p_)->trade_accept == 1) {
			{
				gamepacket_t p;
				p.Insert("OnTradeStatus");
				p.Insert(pInfo(p_)->netID);
				p.Insert("");
				p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
				p.Insert("locked|0\nreset_locks|1\naccepted|0");
				p.CreatePacket(p_);
			}
			gamepacket_t p;
			p.Insert("OnTradeStatus");
			p.Insert(pInfo(p_)->netID);
			p.Insert("");
			p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
			p.Insert("locked|0\naccepted|1");
			p.CreatePacket(p_);
			{
				gamepacket_t p;
				p.Insert("OnTradeStatus");
				p.Insert(pInfo(p_)->netID);
				p.Insert("");
				p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
				p.Insert("locked|0\nreset_locks|1\naccepted|0");
				p.CreatePacket(p_);
			}
		}
		gamepacket_t p;
		p.Insert("OnTradeStatus");
		p.Insert(pInfo(p_)->netID);
		p.Insert("");
		p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
		p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\naccepted|0");
		p.CreatePacket(p_);
		{
			if (pInfo(p_)->trade_accept == 1) {
				packet_(p_, "action|play_sfx\nfile|audio/tile_removed.wav\ndelayMS|0");
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("The deal has changed");
				p.CreatePacket(p_);
				pInfo(p_)->trade_accept = 0;
			}
		}
	}
}

void GrowlandGacha(ENetPeer* peer) {
	DialogBuilder db{ "`o" };
	db.add_label_icon(true, 9154, "`wGacha here With Your gems: ");

	db.add_smalltext("This Command Only use gems and minimal 100k gems - max");
	db.add_spacer(false);

	db.add_button("buttongrowlandgacha1", "Gacha Level 1 (100k)");
	db.add_spacer(false);

	db.add_button("buttongrowlandgacha2", "Gacha Level 2 (350k)");
	db.add_spacer(false);

	db.add_button("buttongrowlandgacha3", "Gacha Level 3 (850k)");
	db.add_spacer(false);

	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert(db.to_string());
	p.CreatePacket(peer);
}

void SendReceive(ENetPeer* peer) {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	int add_more_time = 0;
	string stringToStore = "0", stringToStore2 = "0";
	int totalTopup = pInfo(peer)->totaltopup, bonus = 1;
	ifstream openFile2("database/top_up/" + to_lower(pInfo(peer)->tankIDName) + ".txt");
	if (openFile2.is_open()) {
		getline(openFile2, stringToStore);
		openFile2.close();
		int deposit = atoi(stringToStore.c_str()), c_ = atoi(stringToStore.c_str());
		if (deposit > 0) {
			if (newtime.tm_wday == 6 || newtime.tm_wday == 0) bonus = 1.5;
			pInfo(peer)->gtwl += (deposit * bonus);
			pInfo(peer)->totaltopup += deposit;
			if (modify_inventory(peer, 10394, c_) == 0) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("Collected `w" + to_string(c_) + " " + items[10394].name + "``." + (items[10394].rarity > 363 ? "" : " Rarity: `w" + to_string(items[10394].rarity) + "``") + ""), p.CreatePacket(peer);
			}
			save_player(pInfo(peer), false);

			ofstream m;
			m.open("database/top_up/" + to_lower(pInfo(peer)->tankIDName) + ".txt"), m << "0", m.close();
			gamepacket_t p, p2;
			p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("`wReceived `1" + setGems((deposit)) + " TayoPoint`w!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
			p2.Insert("OnConsoleMessage"), p2.Insert("You received `1" + setGems((deposit)) + " TayoPoint!"), p2.CreatePacket(peer);
			if (pInfo(peer)->totaltopup < 50 && pInfo(peer)->supp == 0) {
				int total = pInfo(peer)->totaltopup;
				int ssup = 50;
				int needed = ssup - total;
				pInfo(peer)->supp = 1;
				gamepacket_t p(2000), p2(4000), p3(6000);
				p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("You've unlocked `2Supporter`` skin colors``!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
				p2.Insert("OnAddNotification"), p2.Insert("interface/cash_icon_overlay.rttex"), p2.Insert("You've unlocked the `wRecycle Tool``!"), p2.Insert("audio/piano_nice.wav.wav"), p2.Insert(0), p2.CreatePacket(peer);
				p3.Insert("OnConsoleMessage"), p3.Insert("Thank you for supporting `cTayoPs`` you've just unlocked `2Supporter ``and its benefit. to unlock `5Super Supporter`` and its benefit you'll need to buy `1" + to_string(needed) + " ``more `1TayoPoint``."), p3.CreatePacket(peer);
				form_emoji(peer, true, add_more_time += 2000);
			}
			else if (pInfo(peer)->totaltopup < 50 && pInfo(peer)->supp == 1) {
				int total = pInfo(peer)->totaltopup;
				int ssup = 50;
				int needed = ssup - total;
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("Thank you for supporting `cTayoPs``. to unlock `5Super Supporter`` and its benefit you'll need to buy `1" + to_string(needed) + " ``more `1TayoPoint``."), p.CreatePacket(peer);
			}
			else if (pInfo(peer)->totaltopup >= 50 && pInfo(peer)->supp == 1 || pInfo(peer)->supp == 0) {
				pInfo(peer)->supp = 2;
				pInfo(peer)->hs = 1;
				gamepacket_t p(2000), p2(4000), p3(6000);
				p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("You've unlocked `5Super Supporter`` skin colors``!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
				p2.Insert("OnAddNotification"), p2.Insert("interface/cash_icon_overlay.rttex"), p2.Insert("You've unlocked the `5Super Supporter`` only command `w/warp``!"), p2.Insert("audio/piano_nice.wav.wav"), p2.Insert(0), p2.CreatePacket(peer);
				p3.Insert("OnConsoleMessage"), p3.Insert("Thank you for supporting `cTayoPs`` you've just unlocked `5Super Supporter ``and its benefit."), p3.CreatePacket(peer);
				form_emoji(peer, true, add_more_time += 2000);
			}
			int adaBrp = 0;
			if (pInfo(peer)->totaltopup >= 1000 and not pInfo(peer)->trader) {
				modify_inventory(peer, 9504, adaBrp);
				if (adaBrp == 0) {
					modify_inventory(peer, 9504, adaBrp = 1);
					Algorithm::send_console(peer, "Thank you for supporting `cTayoPs`` you've earned `9Global Trade License");
				}
			}
		}
	}
}

CL_Vec2i GetTilePos(const uint16_t& id, World* world) {
	for (int i = 0; i < world->blocks.size(); i++) {
		if (world->blocks[i].fg != id)
			continue;
		return { i % world->width, i / world->width };
	}
	return { 0, 0 };
}
CL_Vec2i GetTilePos(const BlockTypes& type, World* world) {
	for (int i = 0; i < world->blocks.size(); i++) {
		if (items[world->blocks[i].fg].blockType != type)
			continue;
		return { i % world->width, i / world->width };
	}
	return { 0, 0 };
}
WorldBlock* GetTile(int x, int y, World* world) {
	if (x < 0 || y < 0 || x > world->width || y > world->height)
		return nullptr;
	return &world->blocks[x + y * world->width];
}
WorldBlock* GetTile(CL_Vec2i pos, World* world) {
	return GetTile(pos.x, pos.y, world);
}
WorldBlock* GetTile(const uint16_t& id, World* world) {
	auto pos = GetTilePos(id, world);
	if (pos.x < 0 || pos.y < 0 || pos.x > world->width || pos.y > world->height)
		return nullptr;
	return GetTile(pos.x, pos.y, world);
}
WorldBlock* GetTile(int index, World* world) {
	return &world->blocks[index];
}
WorldBlock* GetParentTile(WorldBlock* neighbour, World* world) {
	if (neighbour->lock_origin < 0)
		return nullptr;
	CL_Vec2i parent = {
		(int)(neighbour->lock_origin % world->width), (int)(neighbour->lock_origin / world->width)
	};
	return GetTile(parent.x, parent.y, world);
}
bool HasFlag(WorldBlock* block, int fl) {
	return block->flags & fl;
}

void reset_(WorldBlock* block_, int x_, int y_, World* world_) {
	for (int i_ = 0; i_ < world_->machines.size(); i_++) {
		if (world_->machines[i_].x == x_ and world_->machines[i_].y == y_) {
			world_->machines.erase(world_->machines.begin() + i_);
			break;
		}
	}
	if (items[block_->fg].blockType == BlockTypes::BULLETIN_BOARD || items[block_->fg].blockType == BlockTypes::MAILBOX) {
		for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
			if (world_->bulletin[i_].x == x_ and world_->bulletin[i_].y == y_) {
				world_->bulletin.erase(world_->bulletin.begin() + i_);
				i_--;
			}
		}
		for (int i_ = 0; i_ < world_->bulletins.size(); i_++) {
			if (world_->bulletins[i_].x == x_ and world_->bulletins[i_].y == y_) {
				world_->bulletins.erase(world_->bulletins.begin() + i_);
				i_--;
			}
		}
	}
	if (block_->fg == 6016) {
		for (int i_ = 0; i_ < world_->gscan.size(); i_++) {
			if (world_->gscan[i_].x == x_ and world_->gscan[i_].y == y_) {
				world_->gscan.erase(world_->gscan.begin() + i_);
				i_--;
			}
		}
	}
	if (block_->fg == 8246 || block_->fg == 10258 || block_->fg == 1436) {
		for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) {
			if (world_->cctv_settings[i_].x == x_ and world_->cctv_settings[i_].y == y_) {
				world_->cctv_settings.erase(world_->cctv_settings.begin() + i_);
				i_--;
			}
		}
		for (int i_ = 0; i_ < world_->cctv.size(); i_++) {
			if (world_->cctv[i_].x == x_ and world_->cctv[i_].y == y_) {
				world_->cctv.erase(world_->cctv.begin() + i_);
				i_--;
			}
		}
	}
	if (block_->fg == 2646) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or world_->name != pInfo(currentPeer)->world or block_->spotlight != pInfo(currentPeer)->tankIDName) continue;
			pInfo(currentPeer)->spotlight = false, update_clothes(currentPeer);
			gamepacket_t p, p2;
			p.Insert("OnConsoleMessage"), p.Insert("Back to anonymity. (`$In the Spotlight`` mod removed)"), p.CreatePacket(currentPeer);
			p2.Insert("OnTalkBubble"), p2.Insert(pInfo(currentPeer)->netID), p2.Insert("Lights out!"), p2.CreatePacket(currentPeer);
		}
	}
	if (block_->fg == 0) block_->bg = 0;
	else block_->fg = 0;
	block_->id = 0, block_->hp = -1, block_->planted = 0, block_->fruit = 1, block_->sp = 0, block_->txt = "";
	block_->wl = 0, block_->pr = 0, block_->c_ = 0;
	block_->door_destination = "", block_->door_id = "", block_->open = true;
	block_->flags = 0x00000000;
	block_->last_punch_weather = 0;
	block_->projectile_speed = 100, block_->rate_of_fire = 10;
	block_->enabled = false;
	block_->invert = false, block_->spin = false, block_->gravity = 50;
	block_->magnetron = false;
	block_->open_to_public = false;
	block_->empty_air = false;
	block_->admins.clear();
	block_->owner_name = "";
	block_->build_only = false;
	block_->limit_admins = false;
	block_->crystals.clear();
	block_->r = 255;
	block_->g = 128;
	block_->b = 64;
	block_->portrait.c_expression = 1;
	block_->portrait.c_face = 0;
	block_->portrait.c_hair = 0;
	block_->portrait.c_hair_colour = 0;
	block_->portrait.c_head = 0;
	block_->portrait.c_skin = 0;
	block_->bunny_egg_progress = 0;
	block_->heart_monitor = "";
	block_->spotlight = "";
}

namespace player::algorithm {
	void loop_world(std::string const& world, std::function<void(ENetPeer*)> func) {
		pData::Algorithm::loop_players([&](ENetPeer* currentPeer) {
			if (currentPeer == nullptr || currentPeer->data == nullptr) return;

			if (pInfo(currentPeer)->world == world) func(currentPeer);
			});
	}
}
namespace logs {
	std::string decode_special_char(std::string const& str) {
		std::string result;
		for (char const& c : str) {
			switch (c) {
			case '\n': result += "\\n";
				break;
			case '\t': result += "\\t";
				break;
			case '\\': result += "\\\\";
				break;
			default: result += c;
			}
		}
		return result;
	}

	void log_text(std::string const& path, std::string const& content) {
		std::ofstream ostream(path, std::ios::app);

		ostream << decode_special_char(content) << '\n';
	}
	void log_text(std::string const& file, ENetPeer* peer, std::string const& message) {
		std::string content = std::format("[{}] ({}) >> from {} in [{}] : {}", date_time::get_time(), pInfo(peer)->ip, pInfo(peer)->tankIDName.empty() ? pInfo(peer)->requestedName : pInfo(peer)->tankIDName, pInfo(peer)->world, message);
		log_text(file, content);
	}
}
namespace player::algorithm {
	void OnCountdownStart(ENetPeer* peer, int time) {
		ENetPacket* packet = Variant{ "OnSetMissionTimer" }.push(time).pack();

		enet_peer_send(peer, 0, packet);
	}
	void OnCountdownEnd(ENetPeer* peer) {
		ENetPacket* packet = Variant{ "OnEndMission" }.push().pack();

		enet_peer_send(peer, 0, packet);
	}
	void TestingBlock(ENetPeer* currentPeer, int playerBlock) {
		if (pInfo(currentPeer)->hideseek.Seekers) return;

		pInfo(currentPeer)->face = 3774;
		pInfo(currentPeer)->hideseek.playerBlock = playerBlock;

		ENetPacket* packet = Variant{ "OnNameChanged" }.push("").pack(pInfo(currentPeer)->netID);

		player::algorithm::loop_world(pInfo(currentPeer)->world, [&](ENetPeer* peer) {
			if (peer != nullptr || !pInfo(peer)->tankIDName.empty()) {
				enet_peer_send(peer, 0, packet);
				update_clothes(peer);
			}
			});
	}
	void StartGameSeek() {
		pData::Algorithm::loop_players([&](ENetPeer* peer) {
			if (pInfo(peer)->hideseek.InGame) {
				OnCountdownStart(peer, 300);

				enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`1HIDE-SEEK: `oThe `5Hide and Seek `omatch has been started. The `4Seekers `owill search the `2Hiders`o.").pack());

				pInfo(peer)->ghost = false;
				if (pInfo(peer)->hideseek.Hiders) {
					update_clothes(peer);
				}

				if (pInfo(peer)->hideseek.Seekers) {
					pInfo(peer)->isFrozen = !pInfo(peer)->isFrozen;
					update_clothes(peer);
				}
			}
			});
	}
	void StartHideSeek() {
		pData::Algorithm::loop_players([&](ENetPeer* peer) {
			if (pInfo(peer)->hideseek.InGame) {
				if (!pInfo(peer)->hideseek.Hiders && !pInfo(peer)->hideseek.Seekers) {
					if (global::algorithm::hideseek.Seekers <= 0) {
						global::algorithm::hideseek.Seekers++;

						pInfo(peer)->hideseek.Seekers = true;
					}
					else {
						pInfo(peer)->hideseek.Hiders = true;

						global::algorithm::hideseek.Hiders++;
					}

					if (pInfo(peer)->hideseek.Seekers) {
						enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`1HIDE-SEEK: `oYou're the `4Seekers `oyou have to wait `w15 seconds `obefore the games match started.").pack());

						join_world(peer, pInfo(peer)->world);

						if (pInfo(peer)->hideseek.Seekers) pInfo(peer)->isFrozen = !pInfo(peer)->isFrozen;

						update_clothes(peer);

						player::algorithm::loop_world(pInfo(peer)->world, [&](ENetPeer* currentPeer) {
							enet_peer_send(currentPeer, 0, Variant{ "OnConsoleMessage" }.push("`1HIDE-SEEK: `w" + pInfo(peer)->tankIDName + " `ois now The `4Seekers`o. Avoid to meet the seekers, or you'll be lose!").pack());
							});
					}
					else if (pInfo(peer)->hideseek.Hiders){
						enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`1HIDE-SEEK: `oYou're the `2Hiders `oyou've been given `w15 seconds `oto hide on the right spots!").pack());

						std::vector<int> randomBlock = { 2514, 954, 7882, 1308, 8772, 5034 };
						int blockCertified = randomBlock[rand() % randomBlock.size()];
						pInfo(peer)->hideseek.playerBlock = blockCertified;
						TestingBlock(peer, pInfo(peer)->hideseek.playerBlock);
					}

					pInfo(peer)->ghost = false;
					bool isHiders = pInfo(peer)->hideseek.Hiders ? true : false;

					global::algorithm::hideseek.RestTimers = Algorithm::get_epoch_time<std::chrono::seconds>() + 15;
					OnCountdownStart(peer, 15);
				}
			}
			});
	}
}

void SendCmd(ENetPeer* peer, string cmd, bool c_ = false) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (paa != worlds.end()) {
		World* world_ = &worlds[paa - worlds.begin()];
		if (pInfo(peer)->tankIDName == "") return;
		string actual_command = cmd;
		transform(actual_command.begin(), actual_command.end(), actual_command.begin(), ::tolower);
		if (actual_command.find("player_chat=") != string::npos) return;
		if (actual_command.substr(0, 5) == "/msg " || actual_command.substr(0, 3) == "/r " || actual_command == "/msg" || actual_command == "/r") packet_(peer, "action|log\nmsg|CT:[MSG]_ `6" + cmd + "``", "");
		else if (actual_command.substr(0, 4) == "/sb " || actual_command == "/sb") packet_(peer, "action|log\nmsg|CT:[SB]_ `6" + cmd + "``", "");
		else if (actual_command.substr(0, 4) == "/bc " || actual_command == "/bc") packet_(peer, "action|log\nmsg|CT:[BC]_ `6" + cmd + "``", "");
		else if (actual_command.substr(0, 4) == "/gc " || actual_command == "/gc") packet_(peer, "action|log\nmsg|CT:[GC]_ `6" + cmd + "``", "");
		else if (not c_) packet_(peer, "action|log\nmsg| `6" + cmd + "``", "");
		if (actual_command == "/help" || actual_command == "/?") {
			Algorithm::send_console(peer, ">> Available Commands: /event /spotify /save /w <nameworld> /wl /dl /bgl /discord /group /spotify /wave /dance /love /sleep /facepalm /fp /smh /yes /no /omg /dab /sassy /dance2 /grumpy /shy /idk /furious /rolleyes /position /msg /status /sell /sb /top /time /who /me /mods /uba /r /go /rgo /pull /kick /ban /trade /sethome /home /report /fold /fc /gc ");
			if (pInfo(peer)->supp == 2) {
				Algorithm::send_console(peer, ">> `5Super Supporter ``Commands: /warp /pay <TayoPsID> <amount> /hidestatus /fixworld");
			}
			//if (is_promoter(peer)) Algorithm::send_console(peer, ">> `4PROMOTER ``Commands: /dropwl <amount>");
			if (is_reseller(peer)) Algorithm::send_console(peer, ">> `cRESELLER ``Commands: /buy <item name> /hidereseller");
			if (pInfo(peer)->crole) Algorithm::send_console(peer, ">> `4Cheat Role ``Commands: /reme /qq /qeme /rr");

			if (pInfo(peer)->vip + pInfo(peer)->vvip >= 1) Algorithm::send_console(peer, ">> `1VIP ``Commands: /vsb /radio /unaccess /warp /online");
			if (pInfo(peer)->mvp)  Algorithm::send_console(peer, ">> `7MVP ``Commands: /createworld /2hit /rainbow");


			if (pInfo(peer)->glory)  Algorithm::send_console(peer, ">> `1GLORY ``Commands: /buy /warpto /clear /track");
			if (pInfo(peer)->mod) Algorithm::send_console(peer, ">> `^Moderator ``Commands:  /1hit /togglemods /hidelogs (Remove the annoying logs from your console.) /hide /invis /magic /color <id> /info <TayoPsID> /banworld /warpto <TayoPsID> /summon <TayoPsID> /ghost /nick <new nickname> /msb <text> /unmute /uncurse /online /punch <id>");
			if (pInfo(peer)->guardian)  Algorithm::send_console(peer, ">> `8GUARDIAN ``Commands: /unfreeze /uncurse /unmute /unban");

			if (pInfo(peer)->supermod) Algorithm::send_console(peer, "`bSuper Moderator ``Commands:  /1hit  /generatebedrock  /nuke <duration in second> <reason> (Nuke world and ban all people inside the world including the world owner) /removedrop (Becareful with this feature) /weather <weather-id>");
			if (pInfo(peer)->umod)  Algorithm::send_console(peer, ">> `6UMOD ``Commands: /sdb  /warn <TayoPsID> <reason>  /massfreeze <duration in second> /masstape <duration in second> /1hit /uncurse");
			if (pInfo(peer)->admin) Algorithm::send_console(peer, ">> `8Admin  ``Commands: /removelogs <TayoPsID> /trashall /buy <item name>");
			if (pInfo(peer)->dev) Algorithm::send_console(peer, ">> `6Developer ``Commands: /cp /qp /skip / /send /ft /ef2 /ef /superinvis /serum <TayoPsID> /search <item name>");
			if (pInfo(peer)->staff)  Algorithm::send_console(peer, ">> `bSTAFF ``Commands: /give125 /givedeoc /givevalentine /salesman /carnival  /blacklist <itemid> /reserve <item_id> <price> <per_wl> /editreserve <item_id> <price> <per_wl> /farm /removetime  /unban <TayoPsID> /unbandev <TayoPsID>  /removetile  /removeid <itemid> (remove all blocks by id)");
			
			if (pInfo(peer)->owner) Algorithm::send_console(peer, ">> `7Owner Hidden ``Commands: /vend <amount> (Restock whole vend in the world) /mag <amount> (Restock whole magplant in the world) /magseed <amount> /givegems /gm /spk //transferworld   /give  /drop /givd /give /givegwl <TayoPsID> <amount> /givecrp <TayoPsID> <amount> /demote <TayoPsID>  /carnival /setproviderevent /setexpevent <multiplied xp> /setgemevent <multiplied gems> (This will set the gem event to specified amount, it will return to normal if the amount is 1.) /remd <id> <amount> (Remove all from every peer's inventory)");
			if (pInfo(peer)->founder)  Algorithm::send_console(peer, ">> `bFOUNDER ``Commands: /givefon /givegua /givemod <TayoPsID> /givesmod <TayoPsID> /giveadm <TayoPsID> /givevvip <TayoPsID> /givevip <TayoPsID> /giveglory <TayoPsID>  /givecrole /givestaff /giveown /givemvp /giveumod  /givedev <TayoPsID> /givepro <TayoPsID> /giversl <TayoPsID> /givedrt <TayoPsID> /giveltit <TayoPsID>   ");

		}
		else if (actual_command == "/reme" || actual_command == "/qeme" || actual_command == "/qq" || actual_command == "/re" && pInfo(peer)->crole) {
			if (actual_command == "/reme" || actual_command == "/re" && pInfo(peer)->crole) {
				pInfo(peer)->reme_spin = !pInfo(peer)->reme_spin; // Toggle reme_spin
				if (pInfo(peer)->reme_spin) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`2>> Cheat Reme Diaktifkan");
					p.CreatePacket(peer);
				}
				else {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`2>> Cheat Reme Dimatikan");
					p.CreatePacket(peer);
				}
			}
			if (actual_command == "/qeme" || actual_command == "/qq" && pInfo(peer)->crole) {
				pInfo(peer)->qeme_spin = !pInfo(peer)->qeme_spin;
				if (pInfo(peer)->qeme_spin) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`2>> Cheat Qeme Diaktifkan");
					p.CreatePacket(peer);
				}
				else {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`2>> Cheat Qeme Dimatikan");
					p.CreatePacket(peer);
				}
			}
		}
		//Credit -iNapis /superinvis
		/*else if (actual_command.substr(0, 4) == "/wl " || actual_command.substr(0, 4) == "/dl " || actual_command.substr(0, 5) == "/bgl ") {
			try
		{
			string name_ = pInfo(peer)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
				int acount = atoi(actual_command.substr(5).c_str()), id_;
				if (actual_command.substr(0, 4) == "/wl ") {
						id_ = 242;
				}
			else if (actual_command.substr(0, 4) == "/dl ") {
					id_ = 1796;
				}
			else id_ = 7188;
			World* world_ = &worlds[p - worlds.begin()];
			WorldDrop drop_{};
				drop_.id = id_;
				drop_.uid = uint16_t(world_->drop.size()) + 1;
				int a_ = rand() % 12;
					drop_.x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - (a_ + 20) : (pInfo(peer)->x + 20) + a_);
			drop_.y = pInfo(peer)->y + rand() % 16;
				drop_.count = acount;
				if (drop_.x / 32 < 0 or drop_.x / 32 >= world_->width or drop_.y / 32 < 0 or drop_.y / 32 >= world_->height) {
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("You can't drop that here, face somewhere with open space.");
						p.CreatePacket(peer);
						return;
					}
					int count_ = 0;
					bool dublicated = false;
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16) {
							count_ += 1;
						}
						if (world_->drop[i_].id == id_) if (world_->drop[i_].count + drop_.count < 200) dublicated = true;
					}
					if (!dublicated) {
						if (count_ > 20) {
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("You can't drop that here, find an emptier spot!");
							p.CreatePacket(peer);
							return;
						}
					}
					int c_;
					 bool Growganoth = false;
					if (modify_inventory(peer, id_, c_) != 0) {
						if (c_ < acount || acount > 200) {
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("lack of "+ items[id_].name);
							p.CreatePacket(peer);
							return;
						}
						int dropped = c_;
						Algorithm::log_text("DropLog", pInfo(peer)->tankIDName + " (#" + to_string(pInfo(peer)->id) + ") dropped " + to_string(drop_.count) + " " + items[id_].ori_name + " in world " + pInfo(peer)->world);
						if (pInfo(peer)->level < 125) {
							if (id_ == 7188) send_user_logs(pInfo(peer)->tankIDName, "Suspiciously dropped " + to_string(drop_.count) + " Blue Gem Lock in World: " + pInfo(peer)->world + ".");
							if (id_ == 1796 and drop_.count > 10) send_user_logs(pInfo(peer)->tankIDName, "Suspiciously dropped " + to_string(drop_.count) + " Diamond Lock in World: " + pInfo(peer)->world + ".");
							if (id_ == 242 and drop_.count == 200) send_user_logs(pInfo(peer)->tankIDName, "Suspiciously dropped " + to_string(drop_.count) + " World Lock in World: " + pInfo(peer)->world + ".");
						}

						add_cctv(peer, "dropped", to_string(abs(dropped)) + " " + items[id_].name);
						dropas_(world_, drop_, pInfo(peer)->netID);
}
				}
			}
			catch (const std::exception&)
			{
			} */
		else if (actual_command == "/spotify") {
			spotify(peer);

		}

		
		else if (actual_command == "/event") {
			if (gem_event > 1) {
				packet_(peer, format("action|log\nmsg|`9{}x gems event`` is going on! Make sure to grab your farmables.", gem_event));
			}
			if (provider_event > 1) {
				packet_(peer, format("action|log\nmsg|`9{}x provider event`` is going on! In this event, all providers will grow x{} faster. Make sure to grab your farmables.", provider_event, provider_event));
			}
			if (xp_event > 1) {
				packet_(peer, format("action|log\nmsg|`9{}x xp event`` is going on! Make sure to grab your farmables.", xp_event));
			}
			if (carnival_open) {
				packet_(peer, "action|log\nmsg|`2Carnival has visited the town! Don't forget to pay a visit in `9CARNIVAL`2 because it's limited.``");
			}
			if (salesman_open) {
				packet_(peer, "action|log\nmsg|`2Salesman has visited the town! Don't forget to pay a visit in `9LOCKE`2 because it's limited.``");
			}
			if (Harvest_Festival) {
				packet_(peer, "action|log\nmsg|`2Harvest Festival is here!`` Go collect some mooncakes from harvesting trees.``");
			}
		}
		
		else if (actual_command == "/superinvis" && pInfo(peer)->dev == 1) {
			pInfo(peer)->invis = !pInfo(peer)->invis;
			pInfo(peer)->isSuperInvis = pInfo(peer)->invis;

			if (!pInfo(peer)->invis) {
				if (pInfo(peer)->superInvisFace != -1) {
					pInfo(peer)->face = pInfo(peer)->superInvisFace;
					pInfo(peer)->d_name = pInfo(peer)->superInvisName;
				}

				pInfo(peer)->superInvisName.clear();
				pInfo(peer)->superInvisFace = -1;
			}
			else {
				pInfo(peer)->superInvisFace = pInfo(peer)->face;
				pInfo(peer)->superInvisName = pInfo(peer)->d_name;
				pInfo(peer)->d_name = ".";
				pInfo(peer)->face = 3774;
			}

			update_clothes(peer);

			ENetPacket* packet = Variant{ "OnInvis" }.push(pInfo(peer)->isSuperInvis).pack(pInfo(peer)->netID);
			ENetPacket* packet2 = Variant{ "OnNameChanged" }.push(player::algorithm::get_name(peer)).pack(pInfo(peer)->netID);

			player::algorithm::loop_world(world_->name, [&](ENetPeer* currentPeer) {
				enet_peer_send(currentPeer, 0, packet);
				enet_peer_send(currentPeer, 0, packet2);
				});
		}
	/*	else if (actual_command.substr(0, 11) == "/checkpass " && pInfo(peer)->owner) {
			std::string player = actual_command.substr(11);

			if (!std::filesystem::exists("database/players/" + player + "_.json")) return;

			enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push(std::format("`0{}`o's password is `5{}", player::dataserver::get_json_object<std::string>(player, "name"), player::dataserver::get_json_object<std::string>(player, "pass"))).pack());
		} */
		else if (actual_command == "/rwarp" && pInfo(peer)->mod + pInfo(peer)->dev >= 1) {
			std::vector<ENetPeer*> players;

			pData::Algorithm::loop_players([&](ENetPeer* currentPeer) {
				if (peer == currentPeer) return;
				if (pInfo(currentPeer)->admin == 1 && pInfo(peer)->admin == 0) return;
				if (pInfo(currentPeer)->mod == 1 && pInfo(peer)->mod == 0) return;

				players.push_back(currentPeer);
				});

			if (players.empty()) return;

			SendCmd(peer, "/warpto " + pInfo(players[database::create_random_int(0, players.size() - 1)])->tankIDName, true);
		}

		else if (actual_command == "/group") {
			std::ifstream istream("configwa.txt");
			std::vector<std::string> lines;

			for (std::string line; std::getline(istream, line);) {
				lines.push_back(line);
			}

			Algorithm::send_dialog(peer, Algorithm::join(lines, "\n"));
			return;
		}
		else if (actual_command == "/discord") {
			std::ifstream istream("configdiscord.txt");
			std::vector<std::string> lines;

			for (std::string line; std::getline(istream, line);) {
				lines.push_back(line);
			}

			Algorithm::send_dialog(peer, Algorithm::join(lines, "\n"));
			return;
		}
		else if (actual_command == "/reloadworld" && pInfo(peer)->dev == 1) {
			World* world = world::algorithm::get_world(peer);

			if (!std::filesystem::exists("database/worlds/" + world->name + "_.json")) {
				Algorithm::send_console(peer, "`oUnable to load the world's SystemAttribute.");
				return;
			}

			if (world->lastAutoSave <= date_time::get_epoch_time()) {
				Algorithm::send_console(peer, "`oIn order to load the world, This world must be once auto saved first.");
				return;
			}

			ENetPacket* packet = Variant{ "OnAddNotification" }.push("interface/large/jump_icon.rttex", "`0This world has been reloaded by `5" + player::algorithm::get_name(peer), "audio/gate_close.wav", 0).pack();
			ENetPacket* packet2 = Variant{ "OnConsoleMessage" }.push("`0This world has been reloaded by `5" + player::algorithm::get_name(peer)).pack();

			Send_Mod_Logs2("has reloaded the SystemAttribute of world `0" + world->name);

			player::algorithm::loop_world(world->name, [&](ENetPeer* currentPeer) {
				enet_peer_send(currentPeer, 0, packet);
				enet_peer_send(currentPeer, 0, packet2);

				exit_(currentPeer);
				});

			std::erase_if(worlds, [name = world->name](World const& world) { return world.name == name; });
		}
		else if (actual_command == "/valentine" && pInfo(peer)->owner) {
			DialogBuilder builder;

			builder.add_label_icon(true, 384, "`wValentine's Wishing Times")
				.add_smalltext("`5REMINDER: `oYou can get a rewards by making a wish to the valentine's. Give all your highest rarity items, more good rewards!")
				.add_spacer(false);

			builder.add_small_font_button("leaderboard", "`9Show Leaderboards")
				.add_small_font_button("stores", "`#Show Stores")
				.add_small_font_button("prize", "`wView Wishing Prizes");

			if (pInfo(peer)->owner) {
				builder.add_small_font_button("config", "`wView Configurations");
			}

			builder.add_spacer(false);

			builder.add_smalltext("`oAbout Valentine's Wishing:")
				.add_label_icon(false, 6012, std::format("`oTotal Rarity: `w{} rarity`o.", setGems(global::events::valentineRarity)))
				.add_label_icon(false, 1482, std::format("`oTimes Remaining: `w{}`o", global::events::valentineTimers == 0 ? "No Active Events" : Algorithm::second_to_time(global::events::valentineTimers - date_time::get_epoch_time())))
				.add_label_icon(false, 4422, std::format("`oMy Chocolate's: `w{} items`o.", setGems(pInfo(peer)->valentine.chocolates)))
				.add_spacer(false);

			builder.add_smalltext("`o(If you're lucky, you can get `wCustom Rayman's `owith `w0,5% `oof chances)")
				.add_quick_exit()
				.end_dialog("valentine", "", "");

			Algorithm::send_dialog(peer, builder.to_string());

			return;
		}
		else if (actual_command.substr(0, 10) == "/setuntrd " || actual_command == "/setitem" || actual_command.substr(0, 10) == "/farevent " || actual_command == "/punchid" || actual_command == "/punchidfind" || actual_command.substr(0, 16) == "/setcreateworld " && pInfo(peer)->founder) {
			if (actual_command.substr(0, 10) == "/farevent ") {
				int quantity = atoi(cmd.substr(10, cmd.length() - 10).c_str());
				jawa = quantity;
				Algorithm::send_overlay(peer, "Succesfully set far all cloth to " + to_string(quantity));
				return;
			}
			if (actual_command.substr(0, 10) == "/setuntrd ") {
				int datas = atoi(cmd.substr(10, cmd.length() - 10).c_str());
				std::string filename = "./database/config/untradeableitem.json";
				json jsonData;
				std::ifstream inputFile(filename);
				if (inputFile.is_open()) {
					inputFile >> jsonData;
					inputFile.close();
				}
				json newItem = {
								   {"ItemId", datas}
				};
				editjson::nxr::add_untrade_newjson(peer, newItem, jsonData);
				
			}
			if (actual_command.substr(0, 16) == "/setcreateworld ") {
				if (pInfo(peer)->owner) {
					vector<string> data = explode(" ", actual_command);
					if (data.size() != 4) {
						Algorithm::send_console(peer, "Usage /setcreateworld <label> <worldname> <price>");
						return;
					}
					if (data[1].length() < 2) {
						Algorithm::send_overlay(peer, "Please enter a Label world name (minimum 2 characters)");
						return;
					}
					if (!isdigit(data[3][0])) {
						Algorithm::send_overlay(peer, "Please enter a valid price (numeric value)");
						return;
					}
					if (atoi(data[3].c_str()) <= 0) {
						Algorithm::send_overlay(peer, "Please enter a valid price (positive integer)");
						return;
					}
					std::string input = data[1];
					std::transform(input.begin(), input.end(), input.begin(), ::toupper);

					std::string filename = "./database/config/createworld.json";
					json jsonData;
					std::ifstream inputFile(filename);
					if (inputFile.is_open()) {
						inputFile >> jsonData;
						inputFile.close();
					}

					json newData;
					newData["label"] = input;
					newData["worldname"] = data[2];
					newData["price"] = atoi(data[3].c_str());
					jsonData.push_back(newData);

					std::ofstream outputFile(filename);
					if (outputFile.is_open()) {
						outputFile << std::setw(4) << jsonData << std::endl;
						outputFile.close();
						Algorithm::send_overlay(peer, "`2[`0Successfully added new world to /createworld`2]");
					}
					else {
						Algorithm::send_overlay(peer, "Failed to open file for writing.");
					}
				}
				else {
					Algorithm::send_overlay(peer, "You don't have permission to perform this action.");
				}
				return;
			}
			if (actual_command == "/punchid") {
				DialogBuilder o;
				o.add_label_icon(true, 32, "Set Item Punch")
					.add_spacer(false)
					.add_smalltext("You can Add item Punch effect by enter ItemId and id punch")
					.add_smalltext("This cost only 1 BGL")
					.add_spacer(false);
				if (pInfo(peer)->owner) {
					o.add_smalltext("Want edit a item have a punch effect? click 'Edit Item Punch'")
						.add_button("edit_puncef", "Edit Item Punch")
						.add_spacer(false)
						.add_smalltext("Want Remove punch effect item? Click 'Remove Item Effect'")
						.add_button("rem_puncef", "Remove Item Effect")
						.add_spacer(false);
				}
					o.add_text_input(5, "i_iditem", "ItemId : ", "")
					.add_spacer(false)
					.add_smalltext("Now Enter the punch id!")
					.add_text_input(4, "i_punchid", "Punch Id : ", "")
					.add_spacer(false)
					.add_button("confirm_apply", "Apply");
				o.end_dialog("confirm_addpunch", "Close", ""), o.add_quick_exit();
				Algorithm::send_dialog(peer, o.to_string());
			}
			if (actual_command == "/punchidfind") {
				ifstream fileitem("./database/config/punch.json");
				if (!fileitem.is_open()) {
					cerr << "Error opening file." << endl;
				}
				else {
					json jsonitem;
					fileitem >> jsonitem;
					fileitem.close();

					if (jsonitem.is_array()) {
						DialogBuilder p;
						p.add_label_icon(true, 32, "Punch Id Effect")
							.add_spacer(false)
							.add_textbox(server_name + " punch id effct, in this page you can see item / hand effect punch id!!");
						for (const auto& obj : jsonitem) {
							if (obj.contains("id") && obj.contains("punchid")) {
								int itemsid = obj["id"].get<int>();
								int punched = obj["punchid"].get<int>();
								p.add_label_icon(false, itemsid, "`2" + items[itemsid].name)
									.add_smalltext("ItemID: " + to_string(itemsid))
									.add_smalltext("Punch ID : " + to_string(punched))
									.add_spacer(false);
							}
						}
						p.add_spacer(false)
							.end_dialog("itkybociltololbyjar", "Close", "")
							.add_quick_exit();

						Algorithm::send_dialog(peer, p.to_string());
					}
				}
			}
			
			if (actual_command == "/setitem") {
				DialogBuilder db;
				db.add_label_icon(true, 18, " `5Far-Hand's Setting``")
					.add_spacer(false);
				db.add_textbox("`2\"Search\"`` Name Hand Items!")
					.add_text_input(10, "search_items", "Search ")
					.end_dialog("find_hand", "Close", "`2Search!``");
				enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(db.to_string()).pack());
			}
		}
		else if (actual_command == "/update") { //t
			if (pInfo(peer)->founder) {
				string n_ = pInfo(peer)->world;
				Algorithm::send_overlay(peer, "`2[`0Succesfully read / load json`2]");
				std::ifstream fileitem("./database/config/items.json");
				if (!fileitem.is_open()) {
					std::cerr << "Error opening file." << std::endl;
				}
				json jsonitem;
				fileitem >> jsonitem;
				fileitem.close();
				if (jsonitem.is_array()) {
					for (const auto& obj : jsonitem) {
						if (obj.is_object()) {
							if (obj.contains("ItemId") && obj.contains("Fars")) {
								int itemsid = obj["ItemId"];
								int farsg = obj["Fars"];
								items[itemsid].place_far = farsg, items[itemsid].punch_far = farsg;
							}
						}
					}
				}
				std::ifstream untd("./database/config/untradeableitem.json");
				if (!untd.is_open()) {
					std::cerr << "Error opening file." << std::endl;
				}
				json untrd;
				untd >> untrd;
				untd.close();
				if (untrd.is_array()) {
					for (const auto& obj : untrd) {
						if (obj.is_object()) {
							if (obj.contains("ItemId")) {
								int itemsid = obj["ItemId"];
								items[itemsid].untradeable = 1;
							}
						}
					}
				}
				std::ifstream punj("./database/config/punch.json");
				if (!punj.is_open()) {
					std::cerr << "Error opening file." << std::endl;
				}

				json jkn;
				punj >> jkn;
				punj.close();

				if (jkn.is_array()) {
					for (const auto& obj : jkn) {
						if (obj.is_object()) {
							if (obj.contains("id") && obj.contains("punchid")) {
								int ids = obj["id"].get<int>();
								int punched = obj["punchid"].get<int>();
								items[ids].effect = get_punch_id(ids);
							}
						}
					}
				}
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == n_) {
						exit_(currentPeer, true);
						join_world(currentPeer, n_);
					}
				}
			}
		}
		else if (actual_command == "/valentest" && pInfo(peer)->owner) {
			pInfo(peer)->valentine.chocolates += 500;

			global::events::valentineUpdate = date_time::get_epoch_time() + 1;
			return;
		}
		else if (actual_command == "/dialog") {
			std::ifstream istream("dialogs.txt");
			std::vector<std::string> lines;

			for (std::string line; std::getline(istream, line);) {
				lines.push_back(line);
			}

			Algorithm::send_dialog(peer, Algorithm::join(lines, "\n"));
			return;
		}
		else if (actual_command == "/groupkanjutcok") {
			std::string dialog_group = "";
			DialogBuilder db{ "`o" };
			db.add_label_icon(true, 7188, "`cGrowLand Group Server``");
			dialog_group += "add_textbox|Yo! " + player::algorithm::get_name(peer) + " Welcome to link Group Server TayoPs |left|\n";
			dialog_group += "add_textbox|Here Provides Group Links WhatsApp,Discord, And Any More|left|\n";
			dialog_group += "add_button|https://chat.whatsapp.com/Kd2lZyDlHUL5yNNeQpwtNy|Link Group WhatsApp|noflags|0|0|\n";
			dialog_group += "add_textbox|Many Fiture This Server,More Fiture Chat Owner Server: 083846273773|left|\n";
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert(dialog_group);
			p.CreatePacket(peer);
		}
		else if (actual_command == "/createworld" && pInfo(peer)->mvp) {
			DialogBuilder p;
			p.add_label_icon(true, 9950, "Create World!")
				.add_spacer(false)
				.add_textbox("There command you can buy / create world instanly tax build 75wls")
				.add_spacer(false);
			//.add_button("buyfarm", "`9BUY FARM WORLD FOR `c500ā `0/ `95 `cDLS");
			std::ifstream fileitem("./database/config/createworld.json");
			if (!fileitem.is_open()) {
				std::cerr << "Error opening file." << std::endl;
			}
			json jsonitem;
			fileitem >> jsonitem;
			fileitem.close();
			if (jsonitem.is_array()) {
				for (const auto& obj : jsonitem) {
					if (obj.is_object()) {
						if (obj.contains("worldname") && obj.contains("price") && obj.contains("label")) {
							string button = obj["label"].get<string>();
							string wname = obj["worldname"].get<string>();
							//string bdialog = obj["btndialog"].get<string>();
							int price = obj["price"].get<int>();
							p.add_button(wname + "_1", "`9BUY " + button + " WORLD FOR `c" + to_string(price * 100) + "ā `0/ `9" + to_string(price) + " `cDLS");
						}
					}
				}
			}
			p.add_spacer(false)
				.end_dialog("create_worldmain", "Close", "");
			p.add_quick_exit(), Algorithm::send_dialog(peer, p.to_string());
			}
		else if (actual_command == "/sethome") {
			if (pInfo(peer)->tankIDName == world_->owner_name) {
				if (pInfo(peer)->home_world == world_->name) {
					pInfo(peer)->home_world.clear();
					packet_(peer, "action|log\nmsg|" + world_->name + " is not longer your home world.");
				}
				else {
					pInfo(peer)->home_world = world_->name;
					packet_(peer, "action|log\nmsg|Set " + world_->name + " as your home world.");
				}
				save_player(pInfo(peer), false);
			}
			else packet_(peer, "action|log\nmsg|You need to be owner of world " + world_->name + " to set it as your home world.");
		}
		else if (actual_command.substr(0, 9) == "/restart " && pInfo(peer)->dev == 1) {
			string text = cmd.substr(9, cmd.length() - 9).c_str();
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` `$Restart System Message:`` `4" + text + "``");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				p.CreatePacket(currentPeer);
			}
			trigger_save_();
		}
		else if ((actual_command == "/removetime" || actual_command.starts_with("/farm ")) and pInfo(peer)->staff) {
			if (pInfo(peer)->owner) {
				if (actual_command == "/removetime") {
					for (int i = 0; i < world_->width * world_->height; i++) {
						if (items[world_->blocks[i].fg].blockType == PROVIDER || items[world_->blocks[i].fg].blockType == SEED || items[world_->blocks[i].fg].charger || items[world_->blocks[i].fg].fossil_prep) {
							world_->blocks[i].planted = 0;
						}
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(peer)->world == pInfo(currentPeer)->world) {
							exit_(currentPeer);
						}
					}
				}
				if (actual_command.starts_with("/farm ")) {
					auto data = explode(" ", cmd);
					if (data.size() < 3) {
						Algorithm::send_console(peer, "Usage: /farm <platform_id> <is_wide_world>. Example: /farm 102 1 (This will generate you a wide world with Platform as the base.)");
						return;
					}
					int plat_ = atoi(data[1].c_str());
					bool wide_ = atoi(data[2].c_str());
					int random_ = rand() % 1000;
					if (fs::exists(format("database/worlds/FARM{}_.json", random_)))
						random_ = rand() % 1000;
					string names_ = format("FARM{}", random_);
					create_farm(peer, names_, plat_, wide_);
					join_world(peer, names_);
				}
			}
		}
		else if (actual_command == "/rules") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\nadd_textbox|`w`2World or Accounts`` may be deleted after long periods of inactivity if a world is not visited regularly. `2Item function and prices are subject to change`` at anytime and without warning as we are constantly trying to balance different aspects of the game.``|left|\nadd_spacer|small|\nadd_textbox|`wProtect your worlds and the items by using Doors, Locks, and Blocks wisely, `2never share your login credentials`` with anyone, and be aware of `2fake system messages and phishing websites``.``|left|\nadd_spacer|small|\nadd_textbox|`w`2Inappropriate behavior`` (profanity, racist, sexist or sexual content, abusive behavior, and bullying); any form of scam game such as Drop Game, Dirt Game, etc.; `2buying, selling, or trading TayoPs accounts`` for real money; `2purchase fraud``; and usage of `2third party software``, including, but not limited to, client-side manipulation, speed hacks, clock manipulation, bots, will be sanctioned and may result in a permanent suspension.``|left|\nadd_spacer|small|\nadd_textbox|`wTo report a world, type `2/report`` and exit the world immediately. To report a player, contact us directly. For any issues and questions you may have, please visit our discord server`` `2https://discord.gg/Hz3Kq5xCs8``|left|\nadd_spacer|small|\nadd_textbox|`wAdvertising another `2Private servers or any social medias`` is `4not allowed``.|left|\nadd_spacer|small|\nadd_textbox|`wThere is account creation limit,creating mass account might get you `4banned``.Punishment might applied to you alternative accounts or account that have the same ip address.|left|\nadd_spacer|small|\nadd_textbox|`wAny kind of abusing behaviour is not tolerated such as abusing commands, bugs or glitches will result a `4permanent`` suspension.|left|\nadd_spacer|small|\nadd_textbox|`wPlayers that faking `2System`` messages will be punished.Stolen/Scammed item will never be restored.|left|\nadd_spacer|small|\nadd_textbox|`wBugs and Glitches are bound to happen.if you lost item/rollback it will always happen we will do anything in our power to prevent this sort thing to happen.|left|\nadd_spacer|small|\nadd_button|news|`wI accept these rules!``|noflags|0|0|end_dialog|generic|||");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/hidelogs" and pInfo(peer)->mod) {
			if (pInfo(peer)->hide_logs) {
				pInfo(peer)->hide_logs = false;
				packet_(peer, "action|log\nmsg|You can see all logs now! (Hide Logs mod removed)");
			}
			else {
				pInfo(peer)->hide_logs = true;
				packet_(peer, "action|log\nmsg|The logs are hidden to you now! (Hide Logs mod added)");
			}
			save_player(pInfo(peer), false);
		}
		else if (actual_command == "/online" && HasRole(pInfo(peer))) {
			{
				string text;
				int C = 0;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
					C++;
					text += pInfo(currentPeer)->name_color + (pInfo(currentPeer)->tankIDName.empty() ? pInfo(currentPeer)->requestedName : pInfo(currentPeer)->tankIDName) + (" [" + pInfo(currentPeer)->world) + "], ";
				}
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oPlayers Online [`w" + to_string(C) + "`o]:" + text);
				p.CreatePacket(peer);
			}
		}
		else if (actual_command.substr(0, 8) == "/demote " and pInfo(peer)->founder) {
				pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						pInfo(currentPeer)->founder = 0, pInfo(currentPeer)->guardian = 0, pInfo(currentPeer)->owner = 0, pInfo(currentPeer)->staff = 0, pInfo(currentPeer)->umod = 0, pInfo(currentPeer)->mvp = 0, pInfo(currentPeer)->dev = 0, pInfo(currentPeer)->supermod = 0, pInfo(currentPeer)->mod = 0, pInfo(currentPeer)->admin = 0, pInfo(currentPeer)->glory = 0, pInfo(currentPeer)->vip = 0, pInfo(currentPeer)->vvip = 0;
						gamepacket_t p, p1;
						p.Insert("OnAddNotification"); p.Insert("interface/atomic_button.rttex"); p1.Insert("OnConsoleMessage");
						p.Insert("Warning from `4System``: You've been demoted from any of ranks you have! Have a nice day...");
						p1.Insert("Warning from `4System``: You've been demoted from any of ranks you have! Have a nice day...");
						p.Insert("audio/hub_open.wav"); p.Insert(0);
						p.CreatePacket(currentPeer); p1.CreatePacket(currentPeer);
						if (is_reseller(currentPeer)) {
							reseller.erase(remove(reseller.begin(), reseller.end(), pInfo(currentPeer)->uid), reseller.end());
							save_reseller();
						}
						for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
							if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
							gamepacket_t p;
							p.Insert("OnConsoleMessage"), p.Insert("`#**`` `$The Ancient Ones`` have `4demoted`` " + pInfo(currentPeer)->tankIDName + " `#**`` (`4/rules`` to see the rules!)"), p.CreatePacket(currentPeer2);
						}
						enet_peer_disconnect_later(currentPeer, 0);
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(currentPeer)->tankIDName + " has been demoted"), p2.CreatePacket(peer);
					
				}
			}
		}
		else if (actual_command == "/shop") {
			/*
			int dls = 0, wls = 0, bgls = 0;
			bgls = pInfo(peer)->gtwl / 10000;
			dls = (pInfo(peer)->gtwl / 100) - (bgls * 100);
			wls = pInfo(peer)->gtwl - ((pInfo(peer)->gtwl / 100) * 100);
			string inventory = (wls + dls != 0 ? "\nadd_textbox|`2Premium World lock you currently have:``|" : "\nadd_textbox|`2You don't have any premium world lock!``|") +
				(bgls != 0 ? "\nadd_button_with_icon|||staticYellowFrame,no_padding_x,|7188|" + to_string(bgls) + "|" : "") + "" +
				(dls != 0 ? "\nadd_button_with_icon|||staticYellowFrame,no_padding_x,|1796|" + to_string(dls) + "|" : "") + "" +
				(wls != 0 ? "\nadd_button_with_icon|||staticYellowFrame,no_padding_x,|242|" + to_string(wls) + "|" : "") + "" + (wls + dls + bgls != 0 ? "\nadd_button_with_icon||END_LIST|noflags|0||" : "");
			gamepacket_t p;
			p.Insert("OnDialogRequest"); // premium shop dialog
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTayoPs `2Shop``|left|10308|\nadd_spacer|small|" +
				inventory +
				"\nadd_textbox|`7Choose what you want to purchase:``|left|\nadd_button_with_icon|shopitems|`wRare Items``|staticBlueFrame|7188|"
				//"|\nadd_button_with_icon|shoprank|`wBuy Ranks ``|staticBlueFrame|9474||"
				//"\nadd_button_with_icon|shopmoney|`wBuy Gems ``|staticBlueFrame|9162||"
				//"\nadd_button_with_icon|shopgrowtoken|`wGrowtoken``|staticBlueFrame|1486||"
				"\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button|cls|Close|noflags|0|0|"
			);
			p.CreatePacket(peer);
			*/
			DialogBuilder db{ "`o" };
			db.add_label_icon(true, 9378, "Tayo Shop")
				.add_textbox("Welcome to TayoPoint Shop, here you can use your TayoPoint to purchase items and roles.")
				.add_button("shopitems", "`wPurchase `1in-game items.``")
				//.add_button("shoprank", "`wPurchase `9in-game assets.``")
				.add_button("cls", "`wClose``");

			gamepacket_t p;
			p.Insert("OnDialogRequest"), p.Insert(db.to_string()), p.CreatePacket(peer);
		}
		else if (actual_command == "/claimtopup" || actual_command == "/redeemtopup" || actual_command == "/receive") SendReceive(peer);
		else if (actual_command == "/tour" && pInfo(peer)->dev) {
			if (pInfo(peer)->owner) reset_tournament();
		}
		else if (actual_command.substr(0, 9) == "/weather " && pInfo(peer)->supermod + pInfo(peer)->dev) {
			int x = atoi(cmd.substr(9, cmd.length() - 9).c_str());
			gamepacket_t p;
			p.Insert("OnSetCurrentWeather");
			p.Insert(x);
			world_->weather = x;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					p.CreatePacket(currentPeer);
				}
			}
		}
		else if ((actual_command.substr(0, 5) == "/eff " || actual_command.substr(0, 5) == "/ef2 ") && pInfo(peer)->dev) {
			int ab = atoi((cmd.substr(5, cmd.length() - 5).c_str()));
			gamepacket_t p;
			p.Insert(actual_command.substr(0, 5) == "/eff " ? "OnParticleEffect" : "OnParticleEffectV2");
			p.Insert(ab);
			p.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
			p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 4) == "/ft " and pInfo(peer)->dev) {
			pInfo(peer)->fish_seconds = atoi(cmd.substr(4, cmd.length() - 4).c_str());
		}
		else if (actual_command.substr(0, 4) == "/fc ") {
			int fonline = 0;
			string message = cmd.substr(4, cmd.length() - 4).c_str();
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
					if (pInfo(currentPeer)->friends[c_].uid == pInfo(peer)->uid) {
						fonline++;
						if (fonline != 0) {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("CT:[FC]_>> `3>> from (``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "```3) in [```$" + pInfo(peer)->world + "```3] > ```$" + message + "``");
							p.CreatePacket(currentPeer);
						}
					}
				}
			}
			if (fonline == 0) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`3>> There isn't any friends online.");
				p.CreatePacket(peer);
			}
			else {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`3>> You friendcasted to `0" + to_string(fonline) + "`` person online.");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command == "/top") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`oWorld Rankings``|left|394|\nadd_spacer|\nadd_textbox|World Rankings are based on unique daily visitors. Where do your worlds stack up?|\nadd_button|toplist|`8Top worlds today``|noflags|0|0|\nadd_button|yesterdaylist|`8Top worlds yesterday``|noflags|0|0|\nadd_button|overalllist|`8Top worlds overall``|noflags|0|0|"/*"\nadd_button|wotwlist|`$World of the Week winners``|noflags|0|0|"*/"\nend_dialog|top|Close||\n");
			p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 6) == "/rate " || actual_command == "/rate") {
			if (actual_command.substr(0, 6) == "/rate ") {
				int Rating = atoi((cmd.substr(6, cmd.length() - 6).c_str()));
				if (pInfo(peer)->level < 10 or pInfo(peer)->account_created == 0 and Rating > 0 and Rating < 6) {
					packet_(peer, "action|log\nmsg|You must be level 10 and have a GrowID to rate worlds.", "");
					return;
				}
				else if (world_->Category == "None" or world_->Category == "" and Rating > 0 and Rating < 6) {
					packet_(peer, "action|log\nmsg|A world needs to have a category set on the World Lock to be rated.", "");
					return;
				}
				else if (world_->owner_name == pInfo(peer)->tankIDName and Rating > 0 and Rating < 6) {
					packet_(peer, "action|log\nmsg|You can't rate your own world!", "");
					return;
				}
				else if (Rating < 1 or Rating > 5) {
					packet_(peer, "action|log\nmsg|Type \"/rate X\" to rate a world. You can rate a world 1-5! A 1 or 2 means you don't like it. 3 is average. 4 or 5 means you liked it! You can't rate a world of your own, or use alts to rate up your world. Nobody will ever see how you rated, so don't pay people to rate your world!", "");
					return;
				}
				else {
					if (Rating >= 2 and Rating <= 5) world_->World_Rating += (float)0.05;
					if (Rating == 1 and world_->World_Rating >= 0.05) world_->World_Rating -= (float)0.05;
					packet_(peer, "action|log\nmsg|Thanks for rating! World ratings are updated once a day. If you rate the same world again, it will replace this rating.", "");
				}
			}
			else if (actual_command == "/rate") {
				packet_(peer, "action|log\nmsg|Type \"/rate X\" to rate a world. You can rate a world 1-5! A 1 or 2 means you don't like it. 3 is average. 4 or 5 means you liked it! You can't rate a world of your own, or use alts to rate up your world. Nobody will ever see how you rated, so don't pay people to rate your world!", "");
				return;
			}
			return;
		}
		else if (actual_command == "/joingame" or actual_command == "/hns") {
			if (pInfo(peer)->hideseek.InGame) {
				enet_peer_send(peer, 0, Variant{ "OnTalkBubble" }.push(pInfo(peer)->netID, "`wYou've already joined the games. Try again later!").pack());
				return;
			}

			if (global::algorithm::hideseek.Hiders >= 1 || global::algorithm::hideseek.Seekers >= 1) {
				enet_peer_send(peer, 0, Variant{ "OnTalkBubble" }.push(pInfo(peer)->netID, "`wThe game has been started. Try again later!").pack());
				return;
			}

			std::string destinateWorlds = "HIDEANDSEEK2";

			global::algorithm::hideseek.Players++;

			pInfo(peer)->hideseek.InGame = true;
			pInfo(peer)->hideseek.JoinGame = true;

			join_world(peer, destinateWorlds);

			enet_peer_send(peer, 0, Variant{ "OnTalkBubble" }.push(pInfo(peer)->netID, std::format("`wJoined the games. There's `5{} people `wothers here.", setGems(global::algorithm::hideseek.Players))).pack());

			pData::Algorithm::loop_players([&](ENetPeer* currentPeer) {
				if (currentPeer != nullptr && pInfo(currentPeer)->hideseek.InGame) {
					enet_peer_send(currentPeer, 0, Variant{ "OnConsoleMessage" }.push(std::format("`1HIDE-SEEK: `w{} `ojust joined the game. [`w{}/15 `opeople left]", pInfo(peer)->tankIDName, setGems(global::algorithm::hideseek.Players))).pack());
				}
				});
		}

		if (actual_command == "/verify" && pInfo(peer)->staff) {
			for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
				if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != pInfo(peer)->world) continue;
				string wname = pInfo(peer)->world;
				World* world_ = world::algorithm::get_world(wname);
				if (world_ == nullptr) return;
				if (world_->verified) {
					world_->verified = false;

					vector<string> verifiedw;
					std::ifstream file("database/verified_worlds.txt");
					if (!file.is_open()) std::cerr << "Error opening file" << std::endl;

					std::string line;
					while (std::getline(file, line)) verifiedw.push_back(line);
					file.close();

					for (int i = 0; i < verifiedw.size(); i++) {
						if (verifiedw[i] == wname) {
							std::ifstream inFile("database/verified_worlds.txt");
							if (!inFile.is_open()) std::cerr << "Error opening file: database/verified_worlds.txt" << std::endl;

							std::string file_content((std::istreambuf_iterator<char>(inFile)),
								std::istreambuf_iterator<char>());

							size_t pos = file_content.find(wname);
							while (pos != std::string::npos) {
								file_content.erase(pos, wname.length());
								pos = file_content.find(wname, pos);
							}
							inFile.close();
							std::ofstream outFile("database/verified_worlds.txt", std::ios::trunc);
							if (!outFile.is_open()) std::cerr << "Error opening file: database/verified_worlds.txt" << std::endl;
							outFile << file_content;
							outFile.close();
						}
						else continue;
					}

					packet_(cp_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
					enet_peer_send(peer, 0, Variant{ "OnTalkBubble" }.push(pInfo(peer)->netID, "`4Removed`` `^verified ``license from `9" + to_upper(wname) + "`` world.").pack());
					enet_peer_send(cp_, 0, Variant{ "OnConsoleMessage" }.push("`4Removed`` `^verified ``license from `9" + to_upper(wname) + "`` world.").pack());
					return;
				}
				else {
					struct tm newtime;
					time_t now = time(0);
					localtime_s(&newtime, &now);

					string ctime = to_string(newtime.tm_mon + 1) + " / " + to_string(newtime.tm_mday) + " at " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min) + "") + " " + (newtime.tm_hour >= 12 ? "PM" : "AM");
					world_->verifiedTime = ctime;
					world_->verified = true;

					vector<string> verifiedw;
					std::ifstream file("database/verified_worlds.txt");
					if (!file.is_open()) std::cerr << "Error opening file" << std::endl;

					std::string line;
					while (std::getline(file, line)) verifiedw.push_back(line);
					file.close();

					if (!(find(verifiedw.begin(), verifiedw.end(), wname) != verifiedw.end())) {
						std::ofstream outFile("database/verified_worlds.txt", std::ios::app);
						if (!outFile.is_open())	std::cerr << "Error opening file: database/verified_worlds.txt" << std::endl;
						outFile << wname << "\n";
						outFile.close();
					}

					packet_(cp_, "action|play_sfx\nfile|audio/pinata_lasso.wav\ndelayMS|0");
					enet_peer_send(peer, 0, Variant{ "OnTalkBubble" }.push(pInfo(peer)->netID, "`2Granted`` a `^verified ``license to `9" + to_upper(wname) + "`` world.").pack());
					enet_peer_send(cp_, 0, Variant{ "OnConsoleMessage" }.push("`2Granted`` a `^verified ``license to `9" + to_upper(wname) + "`` world.").pack());
					return;
				}
				return;
			}
		}
		else if (actual_command == "/generatebedrock" and pInfo(peer)->supermod) {
			int c_ = 200;
			if (modify_inventory(peer, 8, c_) == 0) {
				packet_(peer, "action|log\nmsg|Added Bedrocks to your inventory.");
				PlayerMoving data_{};
				data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
				data_.packetType = 19, data_.plantingTree = 100;
				data_.punchX = 8, data_.punchY = pInfo(peer)->netID;
				int32_t to_netid = pInfo(peer)->netID;
				BYTE* raw = packPlayerMoving(&data_);
				raw[3] = 5;
				memcpy(raw + 8, &to_netid, 4);
				send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				delete[] raw;
			}
			else {
				packet_(peer, "action|log\nmsg|Failed to add Bedrock to your inventory.");
			}
			return;
		}                                      
		else if (actual_command == "/news") news(peer);
		else if (actual_command == "/maintenance" && pInfo(peer)->dev) {
			only_role = (only_role ? false : true);
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`7Maintenance set to `5: " + to_string(only_role));
			p.CreatePacket(peer);
			if (only_role) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or peer == currentPeer or pInfo(currentPeer)->dev) continue;
					gamepacket_t p, p3;
					p.Insert("OnConsoleMessage");
					p.Insert("`5Maintenance has been started!");
					p.CreatePacket(currentPeer);
					enet_peer_disconnect_later(currentPeer, 0);
				}
			}
			ofstream lol("database/extra_events.json");
			json j;
			j["gem_event"] = gem_event;
			j["carnival_open"] = carnival_open;
			j["salesman_open"] = salesman_open;
			j["maintenance"] = only_role;
			j["xp_event"] = xp_event;
			j["far"] = farcount;
			lol << setw(4) << j << endl;
		}
		else if (actual_command == "/save") {
			gnettoken_db_logs(pInfo(peer)->tankIDName + " ran SaveSystem");
			gnettoken_db_logs("Saving " + fixint(worlds.size()) + " Worlds...");
			int p_0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				save_world(pInfo(currentPeer)->world, false);
				save_player(pInfo(currentPeer), false);
				p_0++;
			}
			save_valentine();
			tayo_info("Succesfully saved all worlds and players");
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert(format("Succesfully saved all worlds[{}] and players[{}]", fixint(worlds.size()), p_0));
			p.CreatePacket(peer);
		}
		else if (actual_command == "/offmaint" and pInfo(peer)->dev) {
			read_maintenance(maintenance);
			if (maintenance) {
				write_maintenance(false);
				maintenance = false;
			}
			else return;
			return;
		}
		else if (actual_command == "/sendrestart" and pInfo(peer)->dev) restart_server_status = true;
		else if (actual_command == "/invis" && pInfo(peer)->mod + pInfo(peer)->admin) {
			vector<int> random_{ 32, 64, -32, -64, 0, 0 };
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 105, data_.YSpeed = 105;
			BYTE* raw = packPlayerMoving(&data_);
			if (pInfo(peer)->invis) {
				pInfo(peer)->invis = false;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou are once again visible to mortals.");
				p.CreatePacket(peer);
				{
					gamepacket_t p(750, pInfo(peer)->netID);
					p.Insert("OnInvis");
					p.Insert(0);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							for (int i = 0; i < 6; i++) {
								data_.x = pInfo(peer)->x + 16 + random_[rand() % random_.size()], data_.y = pInfo(peer)->y + 16 + random_[rand() % random_.size()];
								raw = packPlayerMoving(&data_);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							packet_(currentPeer, "action|play_sfx\nfile|audio/reality_tear.wav\ndelayMS|0");
							p.CreatePacket(currentPeer);
						}
					}
				}
				update_clothes(peer);
			}
			else {
				pInfo(peer)->invis = true;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou are now ninja, invisible at all.");
				p.CreatePacket(peer);
				{
					gamepacket_t p(750, pInfo(peer)->netID);
					p.Insert("OnInvis");
					p.Insert(1);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							for (int i = 0; i < 6; i++) {
								data_.x = pInfo(peer)->x + 16 + random_[rand() % random_.size()], data_.y = pInfo(peer)->y + 16 + random_[rand() % random_.size()];
								raw = packPlayerMoving(&data_);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							packet_(currentPeer, "action|play_sfx\nfile|audio/reality_tear.wav\ndelayMS|750");
							p.CreatePacket(currentPeer);
						}
					}
				}
				update_clothes(peer);
			}
			delete[] raw;
		}
		else if (actual_command == "/magic" && pInfo(peer)->mod) {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					packet_(currentPeer, "action|play_sfx\nfile|audio/magic.wav\ndelayMS|0");
					for (int i = 0; i < 14; i++) {
						if (rand() % 100 <= 75) SendParticleEffect(currentPeer, pInfo(peer)->x - 15 * (rand() % 6), pInfo(peer)->y - 15 * (rand() % 6), rand() % 6 + 1, 2, i * 300);
						if (rand() % 100 <= 75) SendParticleEffect(currentPeer, pInfo(peer)->x + 15 * (rand() % 6), pInfo(peer)->y - 15 * (rand() % 6), rand() % 6 + 1, 2, i * 300);
						if (rand() % 100 <= 75) SendParticleEffect(currentPeer, pInfo(peer)->x + 15 * (rand() % 6), pInfo(peer)->y + 15 * (rand() % 6), rand() % 6 + 1, 2, i * 300);
						if (rand() % 100 <= 75) SendParticleEffect(currentPeer, pInfo(peer)->x - 15 * (rand() % 6), pInfo(peer)->y + 15 * (rand() % 6), rand() % 6 + 1, 2, i * 300);

						if (rand() % 100 <= 25) SendParticleEffect(currentPeer, pInfo(peer)->x - 15 * (rand() % 6), pInfo(peer)->y - 15 * (rand() % 6), rand() % 16, 3, i * 300);
						if (rand() % 100 <= 25) SendParticleEffect(currentPeer, pInfo(peer)->x + 15 * (rand() % 6), pInfo(peer)->y - 15 * (rand() % 6), rand() % 16, 3, i * 300);
						if (rand() % 100 <= 25) SendParticleEffect(currentPeer, pInfo(peer)->x + 15 * (rand() % 6), pInfo(peer)->y + 15 * (rand() % 6), rand() % 16, 3, i * 300);
						if (rand() % 100 <= 25) SendParticleEffect(currentPeer, pInfo(peer)->x - 15 * (rand() % 6), pInfo(peer)->y + 15 * (rand() % 6), rand() % 16, 3, i * 300);
					}
				}
			}
		}
		else if (actual_command == "/ghost") {
			if (pInfo(peer)->mod) {
				if (pInfo(peer)->tankIDName != world_->owner_name and not world_->allow_noclip and not pInfo(peer)->dev and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end()) {
					packet_(peer, "action|log\nmsg|The world owner disabled the noclip (/ghost) for you.");
					return;
				}
				packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
				if (pInfo(peer)->ghost) {
					pInfo(peer)->ghost = false;
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`oYour body stops shimmering and returns to normal. (`$Ghost in the Shell `omod removed)``");
					p.CreatePacket(peer);
					update_clothes(peer);
					return;
				}
				pInfo(peer)->ghost = true;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYour atoms are suddenly aware of quantum tunneling. (`$Ghost in the Shell `omod added)``");
				p.CreatePacket(peer);
				update_clothes(peer);
			}
			else if (pInfo(peer)->tankIDName == world_->owner_name || find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) != world_->admins.end()) {
				packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
				if (pInfo(peer)->ghost) {
					pInfo(peer)->ghost = false;
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`oYour body stops shimmering and returns to normal. (`$Ghost in the Shell `omod removed)``");
					p.CreatePacket(peer);
					update_clothes(peer);
					return;
				}
				pInfo(peer)->ghost = true;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYour atoms are suddenly aware of quantum tunneling. (`$Ghost in the Shell `omod added)``");
				p.CreatePacket(peer);
				update_clothes(peer);
			}
			else
			{
				packet_(peer, "action|log\nmsg|The world owner disabled the noclip (/ghost) for you.");
				return;
			}
		}
		else if (actual_command.substr(0, 5) == "/nick" && pInfo(peer)->mod) {
			string error_message = "Usage: /nick <`$nickname``> - This will change your Display Name.";
			vector<string> a_ = explode(" ", cmd);
			a_.erase(a_.begin());
			string new_nick = join(a_, " ");
			if (new_nick.length() <= 0) {
				if (new_nick == "" or to_lower(new_nick) == to_lower(pInfo(peer)->tankIDName)) {
					pInfo(peer)->d_name = "";
					pInfo(peer)->d_name = new_nick;
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Your name changed back to " + pInfo(peer)->tankIDName);
					p.CreatePacket(peer);
					{
						gamepacket_t p2(0, pInfo(peer)->netID);
						p2.Insert("OnNameChanged");
						if (not HasRole(pInfo(peer))) pInfo(peer)->name_color = "`^@";
						p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == pInfo(peer)->world) {
								p2.CreatePacket(currentPeer);
							}
						}
					}
				}
				else {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert(error_message);
					p.CreatePacket(peer);
					return;
				}
			}
			if ((new_nick.find("`") != string::npos or new_nick.find(" of Legend") != string::npos) and not pInfo(peer)->dev) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("You can't do that.");
				p.CreatePacket(peer);
				return;
			}
			if (new_nick.length() >= 3 && new_nick.length() <= 18) {
				pInfo(peer)->d_name = new_nick;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("Your name changed to " + new_nick);
				p.CreatePacket(peer);
				{
					gamepacket_t p2(0, pInfo(peer)->netID);
					p2.Insert("OnNameChanged");
					//if (not HasRole(pInfo(peer))) pInfo(peer)->name_color = "`^";
					p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							p2.CreatePacket(currentPeer);
						}
					}
				}
			}
		}
		else if (actual_command.substr(0, 6) == "/vend " && pInfo(peer)->owner) {
				int quantity = 0;
				try {
					quantity = std::stoi(actual_command.substr(6));

					if (quantity > 2147483647 || quantity <= 0) return;
				}
				catch (std::invalid_argument&) { return; }
				catch (std::out_of_range&) { return; }
				int totalBlocks = 0;
				for (int i = 0; i < world_->width * world_->height; i++) {
					if (world_->blocks[i].fg != 2978 && world_->blocks[i].fg != 9268) continue;
					int itemId = world_->blocks[i].id;
					if (itemId == 0) itemId = world_->blocks[i + world_->width].id;
					if (itemId == 0) continue;
					if (to_lower(items[i].ori_name).find("lock") != string::npos) continue;
					if (to_lower(items[i].ori_name).find("Lock") != string::npos) continue;
					if (items[itemId].blockType == LOCK) continue;
					world_->blocks[i].id = itemId;
					world_->blocks[i].c_ = quantity;
					totalBlocks++;
					gamepacket_t p;
					p.Insert("OnConsoleMassage");
					p.Insert("`2Successfully `7added `o" + fixint(quantity) + "`7 stock to all vending machine in this world.``");
					p.CreatePacket(peer);
			
			}
		}
		else if (actual_command.substr(0, 9) == "/magseed " && pInfo(peer)->owner) {
				int quantity = 0;
				try {
					quantity = std::stoi(actual_command.substr(9));

					if (quantity > 2147483647 || quantity <= 0) return;
				}
				catch (std::invalid_argument&) { return; }
				catch (std::out_of_range&) { return; }
				int totalBlocks = 0;
				for (int i = 0; i < world_->width * world_->height; i++) {
					if (world_->blocks[i].fg != 5638) continue;
					int itemId = world_->blocks[i].id;
					if (items[itemId].blockType != BlockTypes::SEED) continue;
					if (itemId == 0) itemId = world_->blocks[i + world_->width].id;
					if (itemId == 0) continue;
					if (to_lower(items[i].ori_name).find("lock") != string::npos) continue;
					if (to_lower(items[i].ori_name).find("Lock") != string::npos) continue;
					if (items[itemId].blockType == LOCK) continue;
					world_->blocks[i].id = itemId;
					world_->blocks[i].pr = quantity;
					totalBlocks++;
					gamepacket_t p;
					p.Insert("OnConsoleMassage");
					p.Insert("`2Successfully `7added `o" + fixint(quantity) + "`7 stock to all magplant that contain seed in this world.``");
					p.CreatePacket(peer);
				
			}
		}
		else if (actual_command.substr(0, 5) == "/mag " && pInfo(peer)->staff) {
			//if (pInfo(peer)->owner) {
				int quantity = 0;
				try {
					quantity = std::stoi(actual_command.substr(5));

					if (quantity > 2147483647 || quantity <= 0) return;
				}
				catch (std::invalid_argument&) { return; }
				catch (std::out_of_range&) { return; }
				int totalBlocks = 0;
				for (int i = 0; i < world_->width * world_->height; i++) {
					if (world_->blocks[i].fg != 5638) continue;
					int itemId = world_->blocks[i].id;
					if (items[itemId].blockType == BlockTypes::SEED) continue;
					if (to_lower(items[i].ori_name).find("lock") != string::npos) continue;
					if (to_lower(items[i].ori_name).find("Lock") != string::npos) continue;
					if (items[itemId].blockType == LOCK) continue;
					if (itemId == 0) itemId = world_->blocks[i + world_->width].id;
					if (itemId == 0) continue;
					world_->blocks[i].id = itemId;
					world_->blocks[i].pr = quantity;
					totalBlocks++; 
					gamepacket_t p;
					p.Insert("OnConsoleMassage");
					p.Insert("`2Successfully `7added `o" + fixint(quantity) + "`7 stock to all magplant in this world.``");
					p.CreatePacket(peer);
			
			}
		}
		
		else if (actual_command.substr(0, 5) == "/sell") {
			int adaBrpDirt = 0, adaBrpDirtSeed = 0, adaBrpCave = 0, adaBrpCaveSeed = 0, adaBrpRock = 0, adaBrpRockSeed = 0, adaBrpLava = 0, adaBrpLavaSeed = 0;
			modify_inventory(peer, 2, adaBrpDirt), modify_inventory(peer, 3, adaBrpDirtSeed), modify_inventory(peer, 4, adaBrpLava), modify_inventory(peer, 5, adaBrpLavaSeed), modify_inventory(peer, 10, adaBrpRock), modify_inventory(peer, 11, adaBrpRockSeed), modify_inventory(peer, 14, adaBrpCave), modify_inventory(peer, 15, adaBrpCaveSeed);
			string dialog = "", availableItem = "";
			if (adaBrpDirt == 200) availableItem += "\nadd_button_with_icon|sell_2||staticBlueFrame|2|" + to_string(adaBrpDirt) + "|";
			if (adaBrpDirtSeed == 200) availableItem += "\nadd_button_with_icon|sell_3||staticBlueFrame|3|" + to_string(adaBrpDirtSeed) + "|";
			if (adaBrpCave == 200) availableItem += "\nadd_button_with_icon|sell_14||staticBlueFrame|14|" + to_string(adaBrpCave) + "|";
			if (adaBrpCaveSeed == 200) availableItem += "\nadd_button_with_icon|sell_15||staticBlueFrame|15|" + to_string(adaBrpCaveSeed) + "|";
			if (adaBrpRock == 200) availableItem += "\nadd_button_with_icon|sell_10||staticBlueFrame|10|" + to_string(adaBrpRock) + "|";
			if (adaBrpRockSeed == 200) availableItem += "\nadd_button_with_icon|sell_11||staticBlueFrame|11|" + to_string(adaBrpRockSeed) + "|";
			if (adaBrpLava == 200) availableItem += "\nadd_button_with_icon|sell_4||staticBlueFrame|4|" + to_string(adaBrpLava) + "|";
			if (adaBrpLavaSeed == 200) availableItem += "\nadd_button_with_icon|sell_5||staticBlueFrame|5|" + to_string(adaBrpLavaSeed) + "|";
			if (availableItem.empty()) {
				availableItem = "\nadd_textbox|It seems you don't have any items that i'm intrested to, come back later when you have thoose items.|left|";
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|\nadd_label_with_icon|big|`wOffer Something to Janeway``|left|12158|\nadd_spacer|small|\nadd_smalltext|`wHello there i am `9Janeway``<CR>Would you like to make a deal with me? if so please choose down below which item that you want to sell to me``|\nadd_textbox|I'm currently intrested on buying 200pcs of|left|\nadd_label_with_icon|small|Dirt|left|2|\nadd_smalltext|Dirt Seed|\nadd_seed_color_icons|2|\nadd_label_with_icon|small|Cave|left|14|\nadd_smalltext|Cave Seed|\nadd_seed_color_icons|14|\nadd_label_with_icon|small|Rock|left|10|\nadd_smalltext|Rock Seed|\nadd_seed_color_icons|10|\nadd_label_with_icon|small|Lava|left|4|\nadd_smalltext|Lava Seed|\nadd_seed_color_icons|4|\nadd_spacer|small|\nadd_textbox|Press item icon, you want to sell:|left|\nadd_spacer|small|" + availableItem + "\nadd_button_with_icon||END_LIST|noflags|0|0|\nend_dialog|sellstuff|Cancel||\nadd_quick_exit|\n");
			p.CreatePacket(peer);
		}
		
		else if ((actual_command == "/salesman" || actual_command == "/carnival") && pInfo(peer)->owner) {
				if (actual_command == "/salesman")
				{
					string global_message, audio_name;
					if (salesman_open) {
						salesman_open = false;
						global_message = "`2Salesman has left the town! It'll be back soon.``";
						audio_name = "race_end";
					}
					else {
						salesman_open = true;
						global_message = "`2Salesman has visited the town! Don't forget to pay a visit in `9LOCKE`2 because it's limited.``";
						audio_name = "race_start";
					}
					ofstream lol("database/extra_events.json");
					json j;
					j["gem_event"] = gem_event;
					j["carnival_open"] = carnival_open;
					j["salesman_open"] = salesman_open;
					j["maintenance"] = only_role;
					j["xp_event"] = xp_event;
					j["provider_event"] = provider_event;
					j["admin_server"] = admin_server;
					j["far"] = farcount;
					lol << setw(4) << j << endl;
					lol.close();
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						packet_(currentPeer, "action|play_sfx\nfile|audio/" + audio_name + ".wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert(global_message);
						p.CreatePacket(currentPeer);
					}
				}
			
			if (actual_command == "/carnival") {
				string global_message, audio_name;
				if (carnival_open) {
					carnival_open = false;
					global_message = "`2Carnival has left the town! It'll be back soon.``";
					audio_name = "race_end";
				}
				else {
					carnival_open = true;
					global_message = "`2Carnival has visited the town! Don't forget to pay a visit in `9CARNIVAL`2 because it's limited.``";
					audio_name = "race_start";
				}
				ofstream lol("database/extra_events.json");
				json j;
				j["gem_event"] = gem_event;
				j["carnival_open"] = carnival_open;
				j["salesman_open"] = salesman_open;
				j["maintenance"] = only_role;
				j["xp_event"] = xp_event;
				j["provider_event"] = provider_event;
				j["admin_server"] = admin_server;
				j["far"] = farcount;
				lol << setw(4) << j << endl;
				lol.close();
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					packet_(currentPeer, "action|play_sfx\nfile|audio/" + audio_name + ".wav\ndelayMS|0");
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert(global_message);
					p.CreatePacket(currentPeer);
				}
			}
		}

		/*else if (actual_command.substr(0, 8) == "/addcom " && pInfo(peer)->supermod)
		{
			vector<string> args = explode(" ", cmd);
			if (args.size() != 10)
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("Usage: /addcom <berapa1> <id1 nanti di convert jadi nama> <berapa2> <id2 nanti di convert jadi nama> <berapa3> <id3 nanti di convert jadi nama> <id nanti di convert menjadi nama, item yang akan muncul setelah di combine>");
				p.CreatePacket(peer);
				return;
			}

			int berapa1 = stoi(args[1]);
			string id1_name = args[2];
			int berapa2 = stoi(args[3]);
			string id2_name = args[4];
			int berapa3 = stoi(args[5]);
			string id3_name = args[6];
			string combined_item_name = args[7];

			// Temukan ID dari nama item
			int id1 = find_item_id(id1_name);
			int id2 = find_item_id(id2_name);
			int id3 = find_item_id(id3_name);
			int combined_item_id = find_item_id(combined_item_name);

			id1 = get_name(items.at(id1).name);
			id2 = get_name(items.at(id2).name);
			id2 = get_name(items.at(id2).name);



			if (id1 == -1 || id2 == -1 || id3 == -1 || combined_item_id == -1)
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("One or more items not found. Please check the item names.");
				p.CreatePacket(peer);
				return;
			}

			// Tambahkan kombinasi baru ke file combiner.txt
			ofstream combiner_file("./database/combiner.txt", ios::app);
			if (combiner_file.is_open())
			{
				combiner_file << to_string(berapa1) << " " << id1_name << "|" << to_string(berapa2) << " " << id2_name << "|" << to_string(berapa3) << " " << id3_name << "|" << combined_item_name << "\n";
				combiner_file.close();

				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("New combiner added successfully.");
				p.CreatePacket(peer);
			}
			else
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("Error opening combiner.txt file.");
				p.CreatePacket(peer);
			}
			} */


		else if (actual_command.substr(0, 8) == "/search " && pInfo(peer)->admin)
		{
			/*item id searching*/
			bool scanned_not_full = false;
			string search_ = (cmd.substr(8).c_str());
			vector<string> items_found;
			int found_items = 0;
			for (int i = 0; i < items.size(); i++) {
				string items_named = get_string_low(items.at(i).name);
				if (items_named.find(get_string_low(search_)) != string::npos && items.at(i).blockType != SEED) {
					if (found_items >= 20) {
						scanned_not_full = true;
						break;
					}
					found_items++;
					items_found.push_back("`w[`2" + to_string(i) + "``]- " + items.at(i).name + "`w.``");
				}
			}
			if (items_found.size() == 0) {
				/*no found items*/
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("No items found.``");
				p.CreatePacket(peer);
			}
			else
			{
				for (int i = 0; i < items_found.size(); i++) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert(items_found.at(i));
					p.CreatePacket(peer);
				}
			}
			if (scanned_not_full) {
				/*20+ items*/
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("There were 20+ items. Couldn't search them!``");
				p.CreatePacket(peer);
			}
		}

		else if (actual_command == "/clear" && pInfo(peer)->glory + pInfo(peer)->mod + pInfo(peer)->supermod + pInfo(peer)->admin + pInfo(peer)->dev >= 1) {
			// rumus: x (const) * width * height
			string type = "default";
			int price = 100000;
			int price_mt = 100;
			if (world_->width * world_->height == 40000)
				type = "wide";
			//int price = 15 * world_->width * world_->height;
			if (type == "wide") {
				if (pInfo(peer)->gtwl < price_mt) {
					packet_(peer, format("action|log\nmsg|You have {} TayoPoint short!", setGems(price_mt - pInfo(peer)->gtwl)));
					return;
				}
			}
			else {
				if (pInfo(peer)->gems < price) {
					packet_(peer, format("action|log\nmsg|You have {} gems short!", setGems(price - pInfo(peer)->gems)));
					return;
				}
			}
			if ((pInfo(peer)->tankIDName != world_->owner_name) and not pInfo(peer)->staff) {
				packet_(peer, "action|log\nmsg|You must be the world owner to clear");
				return;
			}
			DialogBuilder db{ "`o" };
			db.add_label_icon(true, 2952, "`wClearing world options``")
				.add_textbox(format("Are you sure about clearing this world? This will costs {} {}!", type == "wide" ? setGems(price_mt) :
					setGems(price), type == "wide" ? "TayoPoint" : "gems"))
				.add_button("clear_confirm", "``Clear it for me``")
				.end_dialog("", "`wCancel``", "").add_quick_exit();

			gamepacket_t p;
			p.Insert("OnDialogRequest"), p.Insert(db.to_string()), p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 8) == "/warpto ") {
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			if (pInfo(peer)->mod || pInfo(peer)->supp == 2) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (pInfo(peer)->glory) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(cmd.substr(8, cmd.length() - 8).c_str())) {
							if (pInfo(currentPeer)->world == "") {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Hmm, this person isn't in a world right now."), p.CreatePacket(peer);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTextOverlay"), p.Insert("Moving to location of " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` (`2" + pInfo(currentPeer)->world + "``) ..."), p.CreatePacket(peer);
								if (pInfo(peer)->admin == 1) join_world(peer, pInfo(currentPeer)->world, pInfo(currentPeer)->x / 32, pInfo(currentPeer)->y / 32);
								else join_world(peer, pInfo(currentPeer)->world);
							}
						}
					}
					else {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->invis or pInfo(currentPeer)->dev) continue;
						if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(cmd.substr(8, cmd.length() - 8).c_str())) {
							if (pInfo(currentPeer)->world == "") {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Hmm, this person isn't in a world right now."), p.CreatePacket(peer);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTextOverlay"), p.Insert("Moving to location of " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` (`2" + pInfo(currentPeer)->world + "``) ..."), p.CreatePacket(peer);
								if (pInfo(peer)->admin == 1) join_world(peer, pInfo(currentPeer)->world, pInfo(currentPeer)->x / 32, pInfo(currentPeer)->y / 32);
								else join_world(peer, pInfo(currentPeer)->world);
							}
						}
					}
				}
			}
		}

		else if (actual_command.substr(0, 8) == "/summon " && pInfo(peer)->mod) {
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			if (pInfo(peer)->last_summon + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (not pInfo(peer)->founder) pInfo(peer)->last_summon = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->invis or pInfo(currentPeer)->founder) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						gamepacket_t p, p2;
						p.Insert("OnTextOverlay"), p.Insert("You were summoned by a mod"), p.CreatePacket(currentPeer);
						p2.Insert("OnTextOverlay"), p2.Insert("Summoning..."), p2.CreatePacket(peer);
						//summon_to_world(currentPeer, pInfo(peer)->world, pInfo(peer)->x / 32, pInfo(peer)->y / 32);
						join_world(currentPeer, pInfo(peer)->world, pInfo(peer)->x / 32, pInfo(peer)->y / 32);
					}
				}
			}
			else {
				Algorithm::send_console(peer, "Please wait a moment until you can summon again");
				return;
			}
		}
		else if (actual_command.substr(0, 15) == "/givevalentine " && pInfo(peer)->staff) {
			if (!Algorithm::is_number(cmd.substr(15, cmd.length() - 15).c_str())) return;

			int valentine = std::atoi(cmd.substr(15, cmd.length() - 15).c_str());

			if (valentine > 100'000) {
				Algorithm::send_bubble(peer, pInfo(peer)->netID, "`4Becarefully! `wThis is sensitive for the economies!");
				return;
			}

			std::string message = std::format("`$** `wGiveaway Alert `$(`w{}x`$) Chocolate's from `w{} `$to everyone's! `$**", setGems(valentine), pInfo(peer)->tankIDName);

			ENetPacket* packet = Variant{ "OnConsoleMessage" }.push(message).pack();
			ENetPacket* packet2 = Variant{ "OnAddNotification" }.push("interface/large/special_event.rttex", message, "audio/cumbia_horns.wav", 0).pack();

			pData::Algorithm::loop_players([&](ENetPeer* currentPeer) {
				enet_peer_send(currentPeer, 0, packet);

				pInfo(currentPeer)->valentine.chocolates += valentine;

				enet_peer_send(currentPeer, 0, packet2);
			});
		}
		else if (actual_command.substr(0, 6) == "/givd " && pInfo(peer)->owner == 1) {
			vector<string> args = explode(" ", cmd);
			if (args.size() < 3) return;

			int itemId = 0, quantity = 0;

			try {
				itemId = std::stoi(args[1]);
				quantity = std::stoi(args[2]);

				if (quantity > 200 || quantity < 1) return;

				if (itemId > items.size() - 1 || itemId < 2) return;
			}
			catch (std::exception&) {
				Algorithm::send_console_message(peer, "`4Invalid argument`o: Input is NaN!");
				return;
			}

			std::string message = std::format("`2** Received `ogiveaway from {}`o: `0{} `${}{}`o!", pInfo(peer)->name_color + pInfo(peer)->tankIDName, quantity, items[itemId].name, items[itemId].rarity > 363 ? "" : "`o, rarity: `2" + std::to_string(items[itemId].rarity));

			ENetPacket* packet = Variant{ "OnConsoleMessage" }.push(message).pack();
			ENetPacket* packet2 = Variant{ "OnAddNotification" }.push("interface/large/special_event.rttex", message, "audio/cumbia_horns.wav", 0).pack();

			pData::Algorithm::loop_players([&](ENetPeer* currentPeer) {
				int id = itemId, q = quantity;
				modify_inventory(currentPeer, id, q);

				enet_peer_send(currentPeer, 0, packet);
				enet_peer_send(currentPeer, 0, packet2);
				});
		}
		else if (actual_command == "/trashall" && pInfo(peer)->dev) {
			string recycled = "";
			for (int i_ = 0, remove = 0; i_ < pInfo(peer)->inv.size(); i_++) {
				if (items[pInfo(peer)->inv[i_].id].untradeable == 0) {
					remove = pInfo(peer)->inv[i_].count * -1;
					recycled += to_string(abs(remove)) + " `w" + items[pInfo(peer)->inv[i_].id].ori_name + "`` trashed.\n";
					modify_inventory(peer, pInfo(peer)->inv[i_].id, remove);
					remove = 0;
				}
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert(recycled), p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 14) == "/setfarsevent " && pInfo(peer)->owner) {
			int jawir = atoi(cmd.substr(14, cmd.length() - 14).c_str());
			farcount = jawir;
			string message = format("You has set event far to pickaxe to {} far", jawir);
			ofstream lol("database/extra_events.json");
			json j;
			j["gem_event"] = gem_event;
			j["carnival_open"] = carnival_open;
			j["salesman_open"] = salesman_open;
			j["maintenance"] = only_role;
			j["xp_event"] = xp_event;
			j["provider_event"] = provider_event;
			j["admin_server"] = admin_server;
			j["far"] = farcount;
			lol << setw(4) << j << endl;
			lol.close();
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				packet_(currentPeer, "action|play_sfx\nfile|audio/second_chanxe.wav\ndelayMS|0");
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(format("`4Global System Message:`` {}", message));
				p.CreatePacket(currentPeer);
			}
		}
		else if (actual_command == "/updatepick" && pInfo(peer)->owner) {
			string n_ = pInfo(peer)->world; // Memindahkan deklarasi variabel n_ ke luar loop
			for (int i = 0; i < items.size(); i++) {
				if (i == 98) {
					items[i].place_far = farcount;
					items[i].punch_far = farcount;
				}
			}
			Algorithm::send_overlay(peer, "Successfully load/read file"); // Perbaikan pesan overlay
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == n_) {
					//int x = pInfo(currentPeer)->x, y = pInfo(currentPeer)->y;
					exit_(currentPeer, true);
					join_world(currentPeer, n_);
				}
			}
		}
		else if ((actual_command.substr(0, 18) == "/setproviderevent " || actual_command.substr(0, 13) == "/setgemevent " || actual_command.substr(0, 14) == "/setfarsevent " || actual_command.substr(0, 13) == "/setexpevent ") && pInfo(peer)->dev) {
			if (pInfo(peer)->owner) {
				if (actual_command.substr(0, 13) == "/setgemevent " || actual_command.substr(0, 13) == "/setexpevent ") {
					if (actual_command.substr(0, 13) == "/setgemevent ") gem_event = atoi(cmd.substr(13, cmd.length() - 13).c_str()), gem_event = gem_event < 1 ? 1 : atoi(cmd.substr(13, cmd.length() - 13).c_str());
					else xp_event = atoi(cmd.substr(13, cmd.length() - 13).c_str()), xp_event = xp_event < 1 ? 1 : atoi(cmd.substr(13, cmd.length() - 13).c_str());
					string message = "";
					if (actual_command.substr(0, 13) == "/setgemevent ") message = gem_event <= 1 ? "You removed gem event" : format("You've set gems event to {}x...", gem_event);
					else message = xp_event <= 1 ? "You removed xp event" : format("You've set xp event to {}x...", xp_event);
					string other_message = "";
					if (actual_command.substr(0, 13) == "/setgemevent ") other_message = gem_event <= 1 ? "The gem event has ended!" : format("`9{}x gems event`` is going on! Make sure to grab your farmables.", gem_event);
					else other_message = xp_event <= 1 ? "The xp event has ended!" : format("`9{}x xp event`` is going on! Make sure to grab your farmables.", xp_event);
					packet_(peer, format("action|log\nmsg|{}", message));
					ofstream lol("database/extra_events.json");
					json j;
					j["gem_event"] = gem_event;
					j["carnival_open"] = carnival_open;
					j["salesman_open"] = salesman_open;
					j["maintenance"] = only_role;
					j["xp_event"] = xp_event;
					j["provider_event"] = provider_event;
					j["admin_server"] = admin_server;
					j["far"] = farcount;
					lol << setw(4) << j << endl;
					lol.close();
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						packet_(currentPeer, "action|play_sfx\nfile|audio/second_chanxe.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert(format("`4Global System Message:`` {}", other_message));
						p.CreatePacket(currentPeer);
					}
				}
				if (actual_command.substr(0, 18) == "/setproviderevent ") {
					provider_event = atoi(cmd.substr(18, cmd.length() - 18).c_str());
					provider_event = provider_event < 1 ? 1 : provider_event > 2 ? 2 : atoi(cmd.substr(18, cmd.length() - 18).c_str());
					string message = provider_event <= 1 ? "You removed provider event" : format("You've set provider event to {}x...", provider_event);
					string other_message = provider_event <= 1 ? "The provider event has ended!" : format("`9{}x provider event`` is going on! In this event, your provider will be ready x{} faster. Make sure to grab your providers.", provider_event, provider_event);
					packet_(peer, format("action|log\nmsg|{}", message));
					ofstream lol("database/extra_events.json");
					json j;
					j["gem_event"] = gem_event;
					j["carnival_open"] = carnival_open;
					j["salesman_open"] = salesman_open;
					j["maintenance"] = only_role;
					j["xp_event"] = xp_event;
					j["provider_event"] = provider_event;
					j["admin_server"] = admin_server;
					j["far"] = farcount;
					lol << setw(4) << j << endl;
					lol.close();
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						packet_(currentPeer, "action|play_sfx\nfile|audio/second_chanxe.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert(format("`4Global System Message:`` {}", other_message));
						p.CreatePacket(currentPeer);
					}
				}
			}
		}
		else if (actual_command == "/removedrop" && pInfo(peer)->supermod) {
			if (pInfo(peer)->world == "START" && !(pInfo(peer)->owner)) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("You can't do it here!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
				return;
			}
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert(" >> Removed all dropped items."), p.CreatePacket(peer);
				add_modlogs(peer, (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name), "`4Removed Drop in `#" + pInfo(peer)->world, "");
			}
			world_->drop.clear();
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				exit_(currentPeer);
			}
		}
		else if ((actual_command.substr(0, 10) == "/removeid " || actual_command.substr(0, 12) == "/removetile ") && pInfo(peer)->staff) {
			if (pInfo(peer)->world == "START" || pInfo(peer)->world == "REC") {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("You can't do it here!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
				return;
			}
			vector<string> split_ = explode(" ", cmd);
			if (actual_command.substr(0, 12) == "/removetile ") {
				if (split_.size() != 3) {
					Algorithm::send_console(peer, "Usage: /removetile <x> <y>.");
					return;
				}
				CL_Vec2i tile_pos{ atoi(split_.at(1).c_str()), atoi(split_.at(2).c_str()) };
				if (tile_pos.x >= world_->width || tile_pos.y >= world_->height || tile_pos.x < 0 || tile_pos.y < 0) return;
				auto tile = GetTile(tile_pos, world_);
				if (!tile) return;
				reset_(tile, tile_pos.x, tile_pos.y, world_);

				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						exit_(currentPeer);
					}
				}
			}
			if (actual_command.substr(0, 10) == "/removeid ") {
				if (split_.size() != 2) {
					Algorithm::send_console(peer, "Usage: /removeid <item id>.");
					return;
				}
				int blockid = atoi(split_.at(1).c_str());
				{
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert(" >> Removed item id " + to_string(blockid) + " items."), p.CreatePacket(peer);
					add_modlogs(peer, (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name), "`4Removeid in `#" + pInfo(peer)->world, "");
				}
				for (int i_ = 0; i_ < world_->blocks.size(); i_++) if (world_->blocks[i_].fg == blockid || world_->blocks[i_].bg == blockid) world_->blocks[i_].bg = 0, world_->blocks[i_].fg = 0;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						exit_(currentPeer);
					}
				}
			}
		}
		else if (actual_command == "/fixworld" && pInfo(peer)->supp >= 2) {
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert(" >> Fixed the world."), p.CreatePacket(peer);
			}
			string extra = "";
			add_modlogs(peer, (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name), "`8fixed world " + extra + "``: `#" + pInfo(peer)->world, "");
			int normal = 0;
			for (int i_ = 0; i_ < world_->drop.size(); i_++) {
				if (world_->drop[i_].id == 2034 || world_->drop[i_].id == 2036 || world_->drop[i_].id == 0 || world_->drop[i_].x < 0 || world_->drop[i_].y < 0 || world_->drop[i_].x > world_->width * 32 || world_->drop[i_].y > (world_->height - 1) * 32) {
					world_->drop.erase(world_->drop.begin() + i_);
					i_--;
					for (int a_ = 0; a_ < world_->drop.size(); a_++)
						if (a_ > i_) world_->drop[a_].uid--;
					continue;
				}
				world_->drop[i_].uid = normal;
				normal++;
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == world_->name) {
					exit_(currentPeer);
				}
			}
		}
		else if (actual_command == "/banworld" && pInfo(peer)->mod) {
			if (not world_->nuked) {
				struct tm newtime;
				time_t now = time(0);
				localtime_s(&newtime, &now);
				world_->nuked = true;
				world_->n_t = "" + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + "/2023 " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec) + "";
				world_->n_b = (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``";
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("`o>> `4" + world_->name + " `4was nuked from orbit`o. It's the only way to be sure. Play nice, everybody!");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world and not pInfo(currentPeer)->mod and not pInfo(currentPeer)->admin) exit_(currentPeer);
					packet_(currentPeer, "action|play_sfx\nfile|audio/bigboom.wav\ndelayMS|0");
					p.CreatePacket(currentPeer);
				}
				add_modlogs(peer, (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name), "NUKED WORLD: `#" + pInfo(peer)->world, "");
			}
			else {
				world_->nuked = false, world_->n_t = "", world_->n_b = "";
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("This world is once again available to everyone!"), p.CreatePacket(peer);
				add_modlogs(peer, (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name), "UNNUKED WORLD: `#" + pInfo(peer)->world, "");
			}
		}
		else if (actual_command.substr(0, 8) == "/unmute " && pInfo(peer)->guardian + pInfo(peer)->admin) {
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			if (pInfo(peer)->mod == 1 || pInfo(peer)->admin == 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						for (int i_ = 0; i_ < pInfo(currentPeer)->playmods.size(); i_++) {
							if (pInfo(currentPeer)->playmods[i_].id == 11) {
								pInfo(currentPeer)->playmods[i_].time = 0;
								break;
							}
						}
						add_modlogs(peer, (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name), "UNMUTED: `#" + pInfo(currentPeer)->tankIDName, "");
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`o>> Unmuted person <`2" + pInfo(currentPeer)->tankIDName + "``>``");
						p.CreatePacket(peer);
						break;
					}
				}
			}
		}
		else if (actual_command.substr(0, 9) == "/uncurse " && pInfo(peer)->guardian ) {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			if (pInfo(peer)->mod == 1 || pInfo(peer)->admin == 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						for (int i_ = 0; i_ < pInfo(currentPeer)->playmods.size(); i_++) {
							if (pInfo(currentPeer)->playmods[i_].id == 78) {
								pInfo(currentPeer)->playmods[i_].time = 0;
								break;
							}
						}
						add_modlogs(peer, (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name), "UNCURSED: `#" + pInfo(currentPeer)->tankIDName, "");
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`o>> Uncursed person <`2" + pInfo(currentPeer)->tankIDName + "``>``");
						p.CreatePacket(peer);
						break;
					}
				}
			}
		}
		else if (actual_command.substr(0, 10) == "/unbandev " && pInfo(peer)->staff) {
			vector<string> split = explode(" ", cmd);
			if (split.size() != 2) {
				packet_(peer, "action|log\nmsg|Usage: /unbandev <username>. This will unban player's device.");
				return;
			}
			try {
				ifstream ifs("database/players/" + split.at(1) + "_.json");
				if (ifs.is_open()) {
					json j;
					ifs >> j;
					{
						ifstream rid("database/ridban.json");
						if (rid.is_open())
						{
							json r_;
							rid >> r_;
							vector<string> loaded_ban_rid = r_["rid"].get<vector<string>>();
							if (find(loaded_ban_rid.begin(), loaded_ban_rid.end(), j["rid"].get<string>()) != loaded_ban_rid.end()) {
								for (int i = 0; i < loaded_ban_rid.size(); i++)
									if (loaded_ban_rid[i] == j["rid"].get<string>())
										loaded_ban_rid.erase(loaded_ban_rid.begin() + i);
								ofstream write_("database/ridban.json");
								json j_;
								j_["rid"] = loaded_ban_rid;
								write_ << j_ << endl;
								write_.close();
								ridbans.erase(remove(ridbans.begin(), ridbans.end(), j["rid"]), ridbans.end());
								packet_(peer, "action|log\nmsg|Successfully unbanned that device.");
							}
							else {
								packet_(peer, "action|log\nmsg|That device's relative identifier is not banned.");
							}
						}
					}
					{
						ifstream ip("database/ipban.json");
						if (ip.is_open())
						{
							json i_;
							ip >> i_;
							vector<string> loaded_ban_ip = i_["ip"].get<vector<string>>();
							if (find(loaded_ban_ip.begin(), loaded_ban_ip.end(), j["ip"].get<string>()) != loaded_ban_ip.end()) {
								for (int i = 0; i < loaded_ban_ip.size(); i++)
									if (loaded_ban_ip[i] == j["ip"].get<string>())
										loaded_ban_ip.erase(loaded_ban_ip.begin() + i);
								ofstream write__("database/ipban.json");
								json j__;
								j__["ip"] = loaded_ban_ip;
								write__ << j__ << endl;
								write__.close();
								ipbans.erase(remove(ipbans.begin(), ipbans.end(), j["ip"]), ipbans.end());
								packet_(peer, "action|log\nmsg|Successfully unbanned that device.");
							}
							else {
								packet_(peer, "action|log\nmsg|That device's internet protocol address is not banned.");
							}
						}
					}
				}
				else {
					packet_(peer, "action|log\nmsg|Player not found.");
					return;
				}
			}
			catch (exception& e) {
				cout << e.what() << '\n';
				return;
			}
		}
		else if (actual_command.substr(0, 7) == "/unban " && pInfo(peer)->guardian) {
			string username = cmd.substr(7, cmd.length() - 7).c_str();

			try {
				pInfo(peer)->last_wrenched = username;
				ifstream ifs("database/players/" + username + "_.json");
				string username = "";
				vector<string> _bans;
				int isBanned = 0;
				if (ifs.is_open()) {
					json j;
					ifs >> j;
					username = j["name"].get<string>();
					isBanned = j["b_t"].get<int>();
					_bans == j["bans"].get<vector<string>>();
				}
				if (isBanned == 0) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`o>> That person is not banned.");
					p.CreatePacket(peer);
				}
				else {
					_bans.push_back("`6ON:`` `#" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` `0(" + pInfo(peer)->requestedName + ") #" + "(unbanned by : " + pInfo(peer)->tankIDName + ") ");
					ifstream in("database/players/" + username + "_.json");
					json infile = json::parse(in);
					infile["b_t"] = 0;
					infile["b_s"] = 0;
					infile["b_r"] = "";
					infile["bans"] = _bans;
					ofstream out("database/players/" + username + "_.json");
					out << setw(4) << infile << endl;
					in.close();
					out.close();
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`o>> Success unbanned `5" + username);
					p.CreatePacket(peer);
					add_modlogs(peer, (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name), "UNBANNED: `#" + username, "");
				}
			}
			catch (exception& e) {
				tayo_warn(e.what());
				return;
			}
		}
		/*else if (actual_command == "/online" && HasRole(pInfo(peer))) {
			int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
			get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
			string mods = "", a = "";
			int count = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->tmod == 1 || pInfo(currentPeer)->admin == 1 || pInfo(currentPeer)->dev == 1 || pInfo(currentPeer)->invis == false) {
					count++;
					mods += "" + a + (count == 1 ? "" : ", ") + "" + (pInfo(currentPeer)->admin ? "`6@" : pInfo(currentPeer)->invis == false ? "`w" : (pInfo(currentPeer)->tmod ? "`#@" : "")) + pInfo(currentPeer)->tankIDName + (is_reseller(currentPeer) and not pInfo(currentPeer)->hide_reseller ? " `c[RESELLER]" : "") + "``";
				}
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Player Online (`0" + setGems(s_c) + "`o): " + mods);
			p.CreatePacket(peer);
		} */
		else if (actual_command.substr(0, 9) == "/givecrp " || actual_command.substr(0, 9) == "/givegwl ") {
			vector<string> data = explode(" ", actual_command);
			if (data.size() != 3) {
				packet_(peer, format("action|log\nmsg|Usage: /{} <name> <amount>", actual_command.substr(0, 9) == "/givecrp" ? "givecrp" : "givegwl"));
				return;
			}
			if (!isdigit(data[2][0])) return;
			pInfo(peer)->last_wrenched = data[1];
			string role = "";
			if (pInfo(peer)->owner) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (actual_command.substr(0, 9) == "/givecrp ") pInfo(currentPeer)->opc += atoi(data[2].c_str()), role = data[2] + " Credit Point!";
						if (actual_command.substr(0, 9) == "/givegwl ") pInfo(currentPeer)->gtwl += atoi(data[2].c_str()), role = data[2] + " Premium WLS!";
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Gave " + role + " to <`2" + pInfo(currentPeer)->tankIDName + "``>``"), p.CreatePacket(peer);
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert("`o>> You received " + role + " from <`2" + pInfo(peer)->tankIDName + "``>``"), p2.CreatePacket(currentPeer);
					}
				}
			}
		}
		else if (actual_command.substr(0, 9) == "/give125 " || actual_command.substr(0, 9) == "/givedoc ") {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			string role = "";
			if (pInfo(peer)->staff == 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (actual_command.substr(0, 9) == "/give125 ") pInfo(currentPeer)->level = 125, role = "125 Level";
						if (actual_command.substr(0, 9) == "/givedoc ") pInfo(currentPeer)->drtitle = 1, role = "Doctor Title";
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Gave " + role + " to <`2" + pInfo(currentPeer)->tankIDName + "``>``"), p.CreatePacket(peer);
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert("`o>> You received " + role + " from <`2" + pInfo(peer)->tankIDName + "``>``"), p2.CreatePacket(currentPeer);
					}
				}
			}
		}
		else if (((actual_command == "/knockback" or actual_command == "/izanagi") && pInfo(peer)->tankIDName == "iDems") || ((actual_command == "/clearplaymods" || actual_command.substr(0, 10) == "/testgame ") && pInfo(peer)->dev)) {
			if (actual_command == "/clearplaymods") pInfo(peer)->playmods.clear();
			if (actual_command == "/knockback") pInfo(peer)->knockback = pInfo(peer)->knockback ? false : true;
			if (actual_command == "/izanagi") pInfo(peer)->izanagi = pInfo(peer)->izanagi ? false : true;
			if (actual_command.substr(0, 10) == "/testgame ") {
				int val = atoi(cmd.substr(10, cmd.length() - 10).c_str());
				PlayerMoving data_{};
				data_.packetType = 28, data_.punchX = 0, data_.punchY = 0, data_.characterState = 0x8, data_.netID = pInfo(peer)->netID, data_.plantingTree = 0;
				BYTE* raw = packPlayerMoving(&data_, 56);
				send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				delete[] raw;
				PlayerMoving data;
				//data.packetType = 0x14;
				data.packetType = 0x1B;
				//data.characterState = 0x924; // animation
				data.characterState = 0x0; // animation
				data.x = 0;
				data.y = 0;
				data.punchX = val;
				data.punchY = 0;
				data.XSpeed = 0;
				data.YSpeed = 0;
				data.netID =  pInfo(peer)->netID;
				data.plantingTree = 0;
				BYTE* raw_2 = packPlayerMoving(&data, 56);
				send_raw(peer, 4, raw_2, 56, ENET_PACKET_FLAG_RELIABLE);
				delete[] raw_2;
			}
			pInfo(peer)->spotlight = pInfo(peer)->izanagi;
			update_clothes(peer);
		}
		else if (actual_command.substr(0, 7) == "/track " && pInfo(peer)->glory) {
			string error_message = "Usage: /track <`$player name``> - This will show you the mentioned player.";
			vector<string> a_ = explode(" ", cmd);
			a_.erase(a_.begin());
			if (a_.size() < 1) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(error_message);
				p.CreatePacket(peer);
				return;
			}
			string nick = join(a_, " ");
			pInfo(peer)->last_wrenched = nick;
			string text = "No player found.";
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					text = format("{} is {}!", pInfo(currentPeer)->tankIDName, pInfo(currentPeer)->world.empty() ? "not in world" : format("in {}", pInfo(currentPeer)->world));
				}
			}
			packet_(peer, format("action|log\nmsg|{}", text));
		}
		else if (actual_command.substr(0, 4) == "/buy") {//}&& pInfo(peer)->admin&& pInfo(peer)->glory&& pInfo(peer)->mod&& pInfo(peer)->supermod) {
			string error_message = "Usage: /buy <`$item name``> - This will show you the mentioned item.";
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() <= 1) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(error_message);
				p.CreatePacket(peer);
				return;
			}
			if (a_.size() >= 2) {
				a_.erase(a_.begin());
				string find_target = to_lower(join(a_, " "));
				if (find_target.size() < 3) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Item name must be more than 2 letters!");
					p.CreatePacket(peer);
					return;
				}
				string buy_list_ = "";
				vector<pair<int, string>> found_items;
				//if (pInfo(peer)->admin) 
				{
					for (int i_ = 0; i_ < reservedItems.size(); i_++) {
						uint32_t item_id = items[reservedItems[i_].id].id;
						//if (items[item_id].blockType == SEED) continue;
						if (to_lower(items[reservedItems[i_].id].ori_name).find(find_target) != string::npos) {
							found_items.push_back(make_pair(items[reservedItems[i_].id].id, items[reservedItems[i_].id].ori_name));
						}
					}
				}

				if (found_items.empty()) {
					packet_(peer, "action|log\nmsg| `4Oops: `oThere is no item starting with `w" + find_target + "`o in the reserved items list. Contact the owner at discord to request an item.", "");
					return;
				}
				OldDialogBuilder db;
				db.add_icon_label(std::format("`wFound`` {} items", found_items.size()), 6016, LABEL_BIG)
					->add_spacer()
					->add_smalltext("Select items below.")
					->text_scaling_string("randomitemlolkek");

				for (int i = 0; i < found_items.size(); i++) {
					auto item = found_items.at(i);
					db.text_scaling_string("")
						->add_custom_packet("add_button_with_icon|item_" + to_string(item.first) + "|`$" + item.second + "``|left|" + to_string(item.first) + "||\n");
						//->add_checkicon(std::format("item_{}", item.first), item.second, item.first, std::format("{}", item.first), false);

					if (i == found_items.size() - 1)
						db.add_custom_packet("add_button_with_icon||END_LIST|noflags|0||\n");
				}
				db.add_custom_packet("add_button_with_icon||END_LIST|noflags|0||\n")
					->add_spacer()
					->add_quick_exit()
					->end_dialog("buy_item", "", "Cancel");
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(db.get());
				//p.Insert("add_label_with_icon|big|`wFound item : " + find_target + "``|left|6016|\nadd_spacer|small|\nembed_data|search|" + find_target + "\nend_dialog|buy_option|Cancel|\nadd_spacer|big|\n" + buy_list_ + "add_quick_exit|\n");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command.substr(0, 5) == "/find" && pInfo(peer)->supermod) {
			string error_message = "Usage: /find <`$item name``> - This will show you the mentioned item.";
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() <= 1) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(error_message);
				p.CreatePacket(peer);
				return;
			}
			if (a_.size() >= 2) {
				a_.erase(a_.begin());
				string find_target = to_lower(join(a_, " "));
				if (find_target.size() < 3) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Item name must be more than 2 letters!");
					p.CreatePacket(peer);
					return;
				}
				string buy_list_ = "";
				vector<pair<int, string>> found_items;
				if (pInfo(peer)->staff) {
					for (int i_ = 0; i_ < items.size(); i_++) {
						uint32_t item_id = items[i_].id;
						if (items[item_id].blockType == SEED) continue;
						//if (items[item_id].blockType == LOCK) continue;

						if (to_lower(items[i_].ori_name).find(find_target) != string::npos) {
							found_items.push_back(make_pair(items[i_].id, items[i_].ori_name));
						}
					}
				}
				else if (pInfo(peer)->dev) {
					for (int i_ = 0; i_ < items.size(); i_++) {
						uint32_t item_id = items[i_].id;
						if (items[item_id].blockType == SEED) continue;
						if (items[item_id].blockType == LOCK) continue;
						//if (to_lower(items[i_].ori_name).find("legend") != string::npos) continue;
						if (to_lower(items[i_].ori_name).find(find_target) != string::npos) {
							found_items.push_back(make_pair(items[i_].id, items[i_].ori_name));
						}
					}
				}
				else {
					for (int i_ = 0; i_ < items.size(); i_++) {
						uint32_t item_id = items[i_].id;
						if (items[item_id].blockType == SEED) continue;
					//	if (items[item_id].blockType != FOREGROUND || items[item_id].blockType != BACKGROUND) continue;
						if (items[item_id].clothType == NONE) continue;
						if (items[item_id].blockType == LOCK) continue;

						if (to_lower(items[i_].ori_name).find("legend") != string::npos) continue;
						if (to_lower(items[i_].ori_name).find(find_target) != string::npos) {
							found_items.push_back(make_pair(items[i_].id, items[i_].ori_name));
						}
					}
				}
				
				if (found_items.empty()) {
					packet_(peer, "action|log\nmsg| `4Oops: `oThere is no item starting with `w" + find_target + "`o.", "");
					return;
				}
				OldDialogBuilder db;
				db.add_icon_label(std::format("`wFound`` {} items", found_items.size()), 6016, LABEL_BIG)
					->add_spacer()
					->add_smalltext("Select items below.")
					->text_scaling_string("randomitemlolkek");

				for (int i = 0; i < found_items.size(); i++) {
					auto item = found_items.at(i);
					db.text_scaling_string("")
						->add_checkicon(std::format("item_{}", item.first), item.second, item.first, std::format("{}", item.first), false);

					if (i == found_items.size() - 1)
						db.add_custom_packet("add_button_with_icon||END_LIST|noflags|0||\n");
				}
				db.add_custom_packet("add_button_with_icon||END_LIST|noflags|0||\n")
					->add_spacer()
					->add_quick_exit()
					->end_dialog("buy_option", "`wGet items``", "Cancel");
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(db.get());
				//p.Insert("add_label_with_icon|big|`wFound item : " + find_target + "``|left|6016|\nadd_spacer|small|\nembed_data|search|" + find_target + "\nend_dialog|buy_option|Cancel|\nadd_spacer|big|\n" + buy_list_ + "add_quick_exit|\n");
				p.CreatePacket(peer);
			}
			}
		else if ((actual_command.substr(0, 11) == "/blacklist " || actual_command.substr(0, 13) == "/editreserve " || actual_command.substr(0, 9) == "/reserve ") && pInfo(peer)->staff) {
			auto split = explode(" ", actual_command);
			if (actual_command.substr(0, 13) == "/editreserve ") {
				if (split.size() != 4) {
					packet_(peer, "action|log\nmsg|Usage: /reserve <itemid> <price in count> <per wl> (0/1). The itemid arguments can be obtained via /search <item name>.");
					return;
				}
				int item = atoi(split[1].c_str());
				int price = atoi(split[2].c_str());
				bool the_type = split[3] == "1" ? true : false;

				if (item <= 1 || item >= items.size() || price <= 0 || (price >= (the_type ? 201 : INT_MAX))) {
					packet_(peer, format("action|log\nmsg|Please use item id in this range (2 - {}) and price is the real positive number. (Note: If you're using per_wl mode then the max is 200.)", items.size()));
					return;
				}
				auto it = find_if(reservedItems.begin(), reservedItems.end(), [item](const ReservedItem& my_item) {
					return my_item.id == item;
				});

				if (it == reservedItems.end()) {
					packet_(peer, format("action|log\nmsg|{} is not registered yet, use /reserve to register the item.", items.at(item).name));
					return;
				}
				packet_(peer, format("action|log\nmsg|{} has been modified!", items.at(item).name));
				for (int i = 0; i < reservedItems.size(); i++) {
					if (reservedItems[i].id == item) {
						reservedItems[i].price = price;
						reservedItems[i].per_wl = the_type;
						break;
					}
				}
				/*
				ReservedItem rev;
				rev.id = item, rev.price = price, rev.per_wl = the_type;
				reservedItems.push_back(rev);
				*/
				ofstream over_write("database/reserved_items.json");
				json j;
				json rev_ = json::array();
				for (int i_2 = 0; i_2 < reservedItems.size(); i_2++) {
					json it_;
					it_["id"] = reservedItems[i_2].id;
					it_["price"] = reservedItems[i_2].price;
					it_["per_wl"] = reservedItems[i_2].per_wl;
					rev_.push_back(it_);
				}
				j["items"] = rev_;
				over_write << j << endl;
				over_write.close();
			}
			if (actual_command.substr(0, 9) == "/reserve ") {
				if (split.size() != 4) {
					packet_(peer, "action|log\nmsg|Usage: /reserve <itemid> <price in count> <per wl> (0/1). The itemid arguments can be obtained via /search <item name>.");
					return;
				}
				int item = atoi(split[1].c_str());
				int price = atoi(split[2].c_str());
				bool the_type = split[3] == "1" ? true : false;

				//cout << item << "|" << price << "|" << the_type << '\n';
				if (item <= 1 || item >= items.size() || price <= 0 || (price >= (the_type ? 201 : INT_MAX))) {
					packet_(peer, format("action|log\nmsg|Please use item id in this range (2 - {}) and price is the real positive number. (Note: If you're using per_wl mode then the max is 200.)", items.size()));
					return;
				}
				auto it = find_if(reservedItems.begin(), reservedItems.end(), [item](const ReservedItem& my_item) {
					return my_item.id == item;
					});

				if (it != reservedItems.end()) {
					packet_(peer, format("action|log\nmsg|{} is already reserved! Please use /editreserve <itemid> <price> <per_wl> instead if you're going to modify something from this item.", items.at(item).name));
					return;
				}
				packet_(peer, format("action|log\nmsg|{} has been added to the reserved items list!", items.at(item).name));
				ReservedItem rev;
				rev.id = item, rev.price = price, rev.per_wl = the_type;
				reservedItems.push_back(rev);
				ofstream over_write("database/reserved_items.json");
				json j;
				json rev_ = json::array();
				for (int i_2 = 0; i_2 < reservedItems.size(); i_2++) {
					json it_;
					it_["id"] = reservedItems[i_2].id;
					it_["price"] = reservedItems[i_2].price;
					it_["per_wl"] = reservedItems[i_2].per_wl;
				    rev_.push_back(it_);
				}
				j["items"] = rev_;
				over_write << j << endl;
				over_write.close();
			}
			if (actual_command.substr(0, 11) == "/blacklist ") {
				if (split.size() != 2) {
					packet_(peer, "action|log\nmsg|Usage: /blacklist <itemid>. The itemid arguments can be obtained via /search <item name>.");
					return;
				}
				int item = atoi(split[1].c_str());
				if (item <= 1 || item >= items.size()) {
					packet_(peer, format("action|log\nmsg|Please use item id in this range (2 - {})", items.size()));
					return;
				}
				if (find(blacklisted_items.begin(), blacklisted_items.end(), item) != blacklisted_items.end()) {
					packet_(peer, format("action|log\nmsg|{} is already blacklisted! Please choose another one.", items.at(item).name));
					return;
				}
				packet_(peer, format("action|log\nmsg|{} has been added to the blacklist!", items.at(item).name));
				blacklisted_items.push_back(item);
				ofstream over_write("database/blacklisted_items.json");
				json j;
				j["items"] = blacklisted_items;
				over_write << j << endl;
				over_write.close();
			}
		}
		else if (actual_command.substr(0, 10) == "/givesmod " || actual_command.substr(0, 10) == "/giveltit " || actual_command.substr(0, 9) == "/givesup " || actual_command.substr(0, 9) == "/givespp " || actual_command.substr(0, 9) == "/giveadm " ||
			actual_command.substr(0, 9) == "/givedev " || actual_command.substr(0, 9) == "/givedrt " || actual_command.substr(0, 9) == "/givemod " || actual_command.substr(0, 9) == "/givevip "
			|| actual_command.substr(0, 10) == "/givevvip " || actual_command.substr(0, 11) == "/giveglory " || actual_command.substr(0, 9) == "/givepro " || actual_command.substr(0, 9) == "/giversl "|| actual_command.substr(0, 10) == "/givedate "
			|| actual_command.substr(0, 9) == "/givemvp " || actual_command.substr(0, 11) == "/givestaff " || actual_command.substr(0, 10) == "/giveumod " || actual_command.substr(0, 9) == "/giveown "
			|| actual_command.substr(0, 11) == "/givecrole " || actual_command.substr(0, 9) == "/givefon " || actual_command.substr(0, 9) == "/givegua ") {
				vector<string> split = explode(" ", actual_command);
				if (split.size() != 2) {
					packet_(peer, "action|log\nmsg|Missing args: name");
					return;
				}
			pInfo(peer)->last_wrenched = split.at(1);
			string role = "";
			if (pInfo(peer)->tankIDName == "iDems" || pInfo(peer)->tankIDName == "Aqua" || pInfo(peer)->tankIDName == "Ayano" || pInfo(peer)->tankIDName == "GTPSHAX" || pInfo(peer)->tankIDName == "iEnzo") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						
						if (actual_command.substr(0, 9) == "/givesup ") pInfo(currentPeer)->supp = 1, role = "Supporter";
						if (actual_command.substr(0, 9) == "/givespp ") pInfo(currentPeer)->supp = 2, role = "Super Supporter";
						if (actual_command.substr(0, 9) == "/givedrt ") pInfo(currentPeer)->drtitle = 1, role = "Doctor Title";
						if (actual_command.substr(0, 10) == "/givedate ") pInfo(currentPeer)->dateMasterB_title = 1, role = "DateMaster Title";
						if (actual_command.substr(0, 9) == "/giversl ")
						{
							if (!is_reseller(currentPeer))
								reseller.push_back(pInfo(currentPeer)->uid);
							role = "Reseller";
							pInfo(currentPeer)->supermod = 1;
							save_reseller();
						}
						if (actual_command.substr(0, 10) == "/giveltit ") pInfo(currentPeer)->legend = 1, role = "Legendary Title";
						if (actual_command.substr(0, 11) == "/givecrole ") pInfo(currentPeer)->crole = 1, role = "Cheater";
						if (actual_command.substr(0, 9) == "/givegua ") pInfo(currentPeer)->guardian = 1, role = "Guardian";


						if (actual_command.substr(0, 9) == "/givevip ") pInfo(currentPeer)->vip = 1, role = "VIP"; 
						if (actual_command.substr(0, 10) == "/givevvip ") pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, role = "VVIP";
						if (actual_command.substr(0, 9) == "/givemvp ") pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, role = "MVP";
						if (actual_command.substr(0, 11) == "/giveglory ") pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, pInfo(currentPeer)->glory = 1, role = "GLORY";
						if (actual_command.substr(0, 9) == "/givemod ") pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, pInfo(currentPeer)->glory = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->tmod = 1, role = "Moderator";
						if (actual_command.substr(0, 10) == "/givesmod ") pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, pInfo(currentPeer)->glory = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->tmod = 1, pInfo(currentPeer)->supermod = 1, role = "Super Moderator";
						if (actual_command.substr(0, 10) == "/giveumod ") pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, pInfo(currentPeer)->glory = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->tmod = 1, pInfo(currentPeer)->supermod = 1, pInfo(currentPeer)->umod = 1, role = "Ultra Moderator";
						if (actual_command.substr(0, 9) == "/giveadm ") pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, pInfo(currentPeer)->glory = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->tmod = 1, pInfo(currentPeer)->supermod = 1, pInfo(currentPeer)->umod = 1, pInfo(currentPeer)->admin = 1, role = "Admin";
						if (actual_command.substr(0, 9) == "/givedev ") pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, pInfo(currentPeer)->glory = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->tmod = 1, pInfo(currentPeer)->supermod = 1, pInfo(currentPeer)->umod = 1, pInfo(currentPeer)->admin = 1, pInfo(currentPeer)->dev = 1, role = "Developer";
						if (actual_command.substr(0, 11) == "/givestaff ") pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, pInfo(currentPeer)->glory = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->tmod = 1, pInfo(currentPeer)->supermod = 1, pInfo(currentPeer)->umod = 1, pInfo(currentPeer)->admin = 1, pInfo(currentPeer)->dev = 1, pInfo(currentPeer)->staff = 1, role = "Staff";
						if (actual_command.substr(0, 9) == "/giveown ")pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, pInfo(currentPeer)->glory = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->tmod = 1, pInfo(currentPeer)->supermod = 1, pInfo(currentPeer)->umod = 1, pInfo(currentPeer)->admin = 1, pInfo(currentPeer)->dev = 1, pInfo(currentPeer)->staff = 1, pInfo(currentPeer)->owner = 1, role = "Owner";
						if (actual_command.substr(0, 9) == "/givefon ")pInfo(currentPeer)->vip = 1, pInfo(currentPeer)->vvip = 1, pInfo(currentPeer)->mvp = 1, pInfo(currentPeer)->glory = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->tmod = 1, pInfo(currentPeer)->supermod = 1, pInfo(currentPeer)->umod = 1, pInfo(currentPeer)->admin = 1, pInfo(currentPeer)->dev = 1, pInfo(currentPeer)->staff = 1, pInfo(currentPeer)->owner = 1, pInfo(currentPeer)->founder = 1, role = "Founder";

						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Gave " + role + " to <`2" + pInfo(currentPeer)->tankIDName + "``>``"), p.CreatePacket(peer);
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert("`o>> You received " + role + " from <`2" + pInfo(peer)->tankIDName + "``>``"), p2.CreatePacket(currentPeer);
					}
				}
			}
		}
		/*
		else if (actual_command.substr(0, 9) == "/giveskn " || actual_command.substr(0, 9) == "/giverft " || actual_command.substr(0, 9) == "/giverdt " || actual_command.substr(0, 9) == "/giverct " || actual_command.substr(0, 9) == "/giverst ") {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			string role = "";
			if (pInfo(peer)->tankIDName == "iDems") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (actual_command.substr(0, 9) == "/giveskn ") pInfo(currentPeer)->unlockRoleSkin = true, role = "Extra Skin";
						if (actual_command.substr(0, 9) == "/giverft ") pInfo(currentPeer)->titleFisher = true, role = "Fishter Title";
						if (actual_command.substr(0, 9) == "/giverdt ") pInfo(currentPeer)->titleDoctor = true, role = "Doctor Title";
						if (actual_command.substr(0, 9) == "/giverct ") pInfo(currentPeer)->titleChef = true, role = "Chef Title";
						if (actual_command.substr(0, 9) == "/giverst ") pInfo(currentPeer)->titleStartopia = true, role = "Startopia Title";
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Gave " + role + " to <`2" + pInfo(currentPeer)->tankIDName + "``>``"), p.CreatePacket(peer);
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert("`o>> You received " + role + " from <`2" + pInfo(peer)->tankIDName + "``>``"), p2.CreatePacket(currentPeer);
						if (pInfo(currentPeer)->world != "") exit_(currentPeer, true);
						enet_peer_disconnect_later(currentPeer, 0);
					}
				}
			}
		}
		*/
		else if (actual_command == "/machine") {
			GrowlandGacha(peer);
		}
		else if (actual_command == "/hideatom" and is_reseller(peer)) { 
			if (pInfo(peer)->hide_reseller) {
				Algorithm::send_console(peer, "Back to your reseller status, dude. (`$Hide Reseller Tag`` mod removed.)");
				pInfo(peer)->hide_reseller = false;
			}
			else {
				Algorithm::send_console(peer, "Take a rest from being a reseller, dude. (`$Hide Reseller Tag`` mod added.)");
				pInfo(peer)->hide_reseller = true;
			}
			gamepacket_t p2(0, pInfo(peer)->netID);
			{
				p2.Insert("OnNameChanged");
				//if (not HasRole(pInfo(peer))) pInfo(peer)->name_color = "`0";
				p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (is_reseller(peer) and not pInfo(peer)->hide_reseller ? " `c[RESELLER]" : "") + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				p2.CreatePacket(currentPeer);
			}
		}
		else if (actual_command.substr(0, 7) == "/serum " and pInfo(peer)->dev) { 
			string user = cmd.substr(7, cmd.length() - 7).c_str();
			bool found = false;
			for (ENetPeer* everyPeer = server->peers; everyPeer < &server->peers[server->peerCount]; ++everyPeer) {
				if (everyPeer->state != ENET_PEER_STATE_CONNECTED || everyPeer->data == NULL || pInfo(everyPeer)->isIn == false) continue;
				if (to_lower(user) == to_lower(pInfo(everyPeer)->tankIDName)) {
					pInfo(everyPeer)->roleIcon = 6;
					pInfo(everyPeer)->roleSkin = 6;
					Algorithm::send_console(peer, format("Cleared {}'s face.", pInfo(everyPeer)->tankIDName));
					Algorithm::send_console(everyPeer, "Your face has been cleaned.");
					if (pInfo(everyPeer)->world != "") exit_(everyPeer, true);
					found = true;
					break;
				}
			}
			if (not found) {
				Algorithm::send_console(peer, "Player not found.");
				return;
			}
		}
		else if (actual_command.substr(0, 6) == "!info ") {
			if (pInfo(peer)->mod == 1 || pInfo(peer)->supermod == 1 || pInfo(peer)->admin == 1 || pInfo(peer)->dev == 1) {
				try {
					bool isOnline = false;
					string user = cmd.substr(6, cmd.length() - 6).c_str();
					pInfo(peer)->last_wrenched = user;
					for (ENetPeer* everyPeer = server->peers; everyPeer < &server->peers[server->peerCount]; ++everyPeer) {
						if (everyPeer->state != ENET_PEER_STATE_CONNECTED || everyPeer->data == NULL || pInfo(everyPeer)->isIn == false) continue;
						if (to_lower(user) == to_lower(pInfo(everyPeer)->tankIDName)) {
							string alt = "";
							for (ENetPeer* allPeer = server->peers; allPeer < &server->peers[server->peerCount]; ++allPeer) {
								if (allPeer->state != ENET_PEER_STATE_CONNECTED || allPeer->data == NULL || pInfo(allPeer)->isIn == false) continue;
								if (pInfo(allPeer)->ip == pInfo(everyPeer)->ip && pInfo(allPeer)->tankIDName != pInfo(everyPeer)->tankIDName) {
									alt += pInfo(allPeer)->tankIDName + ", ";
								}
							}
							isOnline = true;
							Algorithm::send_console(peer, "Editing " + pInfo(everyPeer)->tankIDName + " (" + pInfo(everyPeer)->requestedName + ") - #" + to_string(pInfo(everyPeer)->id));
							Algorithm::send_console(peer, "ON: " + pInfo(everyPeer)->tankIDName + " (" + pInfo(everyPeer)->requestedName + ") - #" + to_string(pInfo(everyPeer)->id) + " Hrs: ");
							time_t s__;
							s__ = time(NULL);
							double hours_ = (double)((s__ - pInfo(everyPeer)->playtime) + pInfo(everyPeer)->seconds) / 3600;
							string num_text = to_string(hours_);
							string rounded = num_text.substr(0, num_text.find(".") + 3);
							Algorithm::send_console(peer, rounded + " IP: " + pInfo(everyPeer)->ip);
							Algorithm::send_console(peer, "Lock in bank: " + to_string(pInfo(everyPeer)->lockInBank));
							Algorithm::send_console(peer, "Alt Account: " + (alt == "" ? "Didn't have alt acc" : alt));
							if (!pInfo(everyPeer)->Account_Notes.empty()) {
								Algorithm::send_console(peer, "Account Notes:");
								for (int i = 0; i < pInfo(everyPeer)->Account_Notes.size(); i++) {
									Algorithm::send_console(peer, pInfo(everyPeer)->Account_Notes[i]);
								}
							}
							else {
								Algorithm::send_console(peer, "There's no account notes for this user yet");
							}
						}
					}
					if (!isOnline) {
						Algorithm::send_console(peer, "User is offline");
					}
				}
				catch (exception) {
					Algorithm::send_console(peer, "Something went wrong fetching info for user " + pInfo(peer)->last_wrenched);
				}
			}
			}
		else if (actual_command.substr(0, 6) == "/info ") {
			if (pInfo(peer)->mod == 1 || pInfo(peer)->supermod == 1 || pInfo(peer)->admin == 1 || pInfo(peer)->dev == 1) {
				try {
					bool isOnline = false;
					string user = cmd.substr(6, cmd.length() - 6).c_str();
					pInfo(peer)->last_wrenched = user;
					for (ENetPeer* everyPeer = server->peers; everyPeer < &server->peers[server->peerCount]; ++everyPeer) {
						if (everyPeer->state != ENET_PEER_STATE_CONNECTED || everyPeer->data == NULL || pInfo(everyPeer)->isIn == false) continue;
						if (to_lower(user) == to_lower(pInfo(everyPeer)->tankIDName)) {
							string alt = "";
							for (ENetPeer* allPeer = server->peers; allPeer < &server->peers[server->peerCount]; ++allPeer) {
								if (allPeer->state != ENET_PEER_STATE_CONNECTED || allPeer->data == NULL || pInfo(allPeer)->isIn == false) continue;
								if (pInfo(allPeer)->ip == pInfo(everyPeer)->ip && pInfo(allPeer)->tankIDName != pInfo(everyPeer)->tankIDName) {
									alt += pInfo(allPeer)->tankIDName + ", ";
								}
							}
							isOnline = true;
							DialogBuilder info("`o");
							time_t s__;
							s__ = time(NULL);
							int days_ = int(s__) / (60 * 60 * 24);
							double hours_ = (double)((s__ - pInfo(everyPeer)->playtime) + pInfo(everyPeer)->seconds) / 3600;
							string num_text = to_string(hours_);
							string rounded = num_text.substr(0, num_text.find(".") + 3);
							info.add_textbox("`wEditing " + pInfo(everyPeer)->tankIDName + " (" + pInfo(everyPeer)->requestedName + ") - #" + to_string(pInfo(everyPeer)->id) + "``")
								.add_label_icon(false, 658, "`6ON: `#" + pInfo(everyPeer)->tankIDName + " `w(" + pInfo(everyPeer)->requestedName + ") - #" + to_string(pInfo(everyPeer)->id) + " Hrs: " + rounded + " IP: " + pInfo(everyPeer)->ip + "[? ms]``")
								.add_label_icon(false, 7188, "Lock in bank: `2" + to_string(pInfo(everyPeer)->lockInBank))
								.add_label_icon(false, 32, "Alt Account: `2"+(alt == "" ? "Didn't have alt acc" : alt));
							if (not pInfo(everyPeer)->m_h) info.add_button("warp_to_" + pInfo(everyPeer)->world, "Warp to User (in `5" + pInfo(everyPeer)->world + "``)");
							else info.add_disabled_button("warp_to_" + pInfo(everyPeer)->world, "Warp to User (in `4JAMMED``)");
							if (pInfo(peer)->staff) {
								info.add_button("disconnect", "Disconnect");
							}
							info.add_spacer(false)
								.add_textbox("Account Notes:");
							if (not pInfo(everyPeer)->Account_Notes.empty()) {
								for (int i = 0; i < pInfo(everyPeer)->Account_Notes.size(); i++) info.add_textbox(pInfo(everyPeer)->Account_Notes[i]);
							}
							else info.add_textbox("There's no account notes for this user yet");
							info.add_spacer(false)
								.add_label_icon_button(false, "<-- View Inventory", 9412, "view_inventory").add_spacer(false)
								.add_label_icon_button(false, "<-- 1 hour tape for profanity", 408, "tape1hour").add_spacer(false)
								.add_label_icon_button(false, "<-- 12 hour sanction for scamming", 9428, "curse12hour").add_spacer(false)
								.add_label_icon_button(false, "<-- 1 day DGH", 732, "dgh1d")
								.add_label_icon_button(false, "<-- 1 week DGH", 732, "dgh1w")
								.add_label_icon_button(false, "<-- 2 week DGH", 732, "dgh2w")
							
									.add_label_icon_button(false, "<-- 1 week ban for bad stuff on alt(s)", 732, "dgh1w")
								
										.add_label_icon_button(false, "<-- 4 week ban for hacker", 732, "dgh4w").add_spacer(false);
								
							if (pInfo(peer)->umod || pInfo(peer)->admin) {
								info.add_label_icon_button(false, "<-- Device ban", 732, "ipban").add_spacer(false);
							}
							if (pInfo(peer)->staff || pInfo(peer)->owner) {
								info.add_label_icon_button(false, "<-- Fake auto-ban (use for hackers, confuse them, online only)", 1908, "autoban").add_spacer(false);
							}
								
							if (not pInfo(everyPeer)->Alt_Accounts.empty()) {
								bool Online = false;
								for (int i = 0; i < pInfo(everyPeer)->Alt_Accounts.size(); i++) {
									if (pInfo(everyPeer)->Alt_Accounts[i] == "" or pInfo(everyPeer)->Alt_Accounts[i].empty()) continue;
									int uid = 0;
									string requestedName = "", roundedPlaytime = "";
									ifstream ips("database/players/" + pInfo(everyPeer)->Alt_Accounts[i] + "_.json");
									if (ips.is_open()) {
										json j;
										ips >> j;
										uid = j["userID"].get<int>();
										requestedName = j["reqname"].get<string>();
										roundedPlaytime = j["totalplaytime"].get<string>();
									}
									info.add_label_icon(false, 658, "`#" + pInfo(everyPeer)->Alt_Accounts[i] + " `w(" + (requestedName.empty() ? pInfo(everyPeer)->requestedName : requestedName) + ") `o- #" + to_string(uid) + " `wHrs: " + (roundedPlaytime.empty() ? "0.00" : roundedPlaytime) + " IP : " + pInfo(everyPeer)->ip);
								}
							}
							info.end_dialog("punish_view", "Continue", "");
							enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(info.to_string()).pack());
						}
					}
					if (not isOnline) send_offline_info(peer, pInfo(peer)->last_wrenched);
				}
				catch (exception) {
					tayo_warn("Something wen't wrong fetching info for user " + pInfo(peer)->last_wrenched);
				}
			}
		}
		/* PUHH LANJUTIN PUH ATAU REMAKE AJA
		else if (actual_command.starts_with("/profile")) {
			std::vector<std::string> args = explode(" ", actual_command);
			if (args.size() < 2) return;

			ENetPeer* target = pData::Algorithm::get_player(args[1]);

			if (target == nullptr) {
				enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`oThat player is currently `4offline`o.").pack());
				return;
			}
			bool isOnline = false;
			string user = "";
			pInfo(peer)->last_wrenched = user;
			for (ENetPeer* everyPeer = server->peers; everyPeer < &server->peers[server->peerCount]; ++everyPeer) {
				if (everyPeer->state != ENET_PEER_STATE_CONNECTED || everyPeer->data == NULL || pInfo(everyPeer)->isIn == false) continue;
				if (to_lower(user) == to_lower(pInfo(everyPeer)->tankIDName)) {
					isOnline = true;
					DialogBuilder info("`o");
					time_t s__;
					s__ = time(NULL);
					int days_ = int(s__) / (60 * 60 * 24);
					double hours_ = (double)((s__ - pInfo(everyPeer)->playtime) + pInfo(everyPeer)->seconds) / 3600;
					string num_text = to_string(hours_);
					string rounded = num_text.substr(0, num_text.find(".") + 3);
					info.add_textbox("`oThe Information `0" + pInfo(target)->name_color + pInfo(target)->tankIDName + "`o!");
					info.add_textbox("`wEditing " + pInfo(everyPeer)->tankIDName + " (" + pInfo(everyPeer)->requestedName + ") - #" + to_string(pInfo(everyPeer)->id) + "``")
						.add_label_icon(false, 658, "`6ON: `#" + pInfo(everyPeer)->tankIDName + " `w(" + pInfo(everyPeer)->requestedName + ") - #" + to_string(pInfo(everyPeer)->id) + " Hrs: " + rounded + " IP: " + pInfo(everyPeer)->ip + "[? ms]``");
					if (not pInfo(everyPeer)->m_h) info.add_button("warp_to_" + pInfo(everyPeer)->world, "Warp to User (in `5" + pInfo(everyPeer)->world + "``)");
					else info.add_disabled_button("warp_to_" + pInfo(everyPeer)->world, "Warp to User (in `4JAMMED``)");
					info.add_textbox("Account Notes:");

					if (not pInfo(everyPeer)->Account_Notes.empty()) {
						for (int i = 0; i < pInfo(everyPeer)->Account_Notes.size(); i++) info.add_textbox(pInfo(everyPeer)->Account_Notes[i]);

						if (not pInfo(everyPeer)->Alt_Accounts.empty()) {
							bool Online = false;
							for (int i = 0; i < pInfo(everyPeer)->Alt_Accounts.size(); i++) {
								if (pInfo(everyPeer)->Alt_Accounts[i] == "" or pInfo(everyPeer)->Alt_Accounts[i].empty()) continue;
								int uid = 0;
								string requestedName = "", roundedPlaytime = "";
								ifstream ips("database/players/" + pInfo(everyPeer)->Alt_Accounts[i] + "_.json");
								if (ips.is_open()) {
									json j;
									ips >> j;
									uid = j["userID"].get<int>();
									requestedName = j["reqname"].get<string>();
									roundedPlaytime = j["totalplaytime"].get<string>();
								}
								info.add_label_icon(false, 658, "`#" + pInfo(everyPeer)->Alt_Accounts[i] + " `w(" + (requestedName.empty() ? pInfo(everyPeer)->requestedName : requestedName) + ") `o- #" + to_string(uid) + " `wHrs: " + (roundedPlaytime.empty() ? "0.00" : roundedPlaytime) + " IP : " + pInfo(everyPeer)->ip);
							}
						}
						info.end_dialog("kontol_view", "Continue", "");
						enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(info.to_string()).pack());
					}
				}
				if (not isOnline) send_offline_info(peer, pInfo(peer)->last_wrenched);
			}
			//catch (exception) {
				tayo_warn("Something wen't wrong fetching info for user " + pInfo(peer)->last_wrenched);
			
			}*/
			
			
			
			
			
		else if (actual_command == "/redeem") {
		DialogBuilder db;
		db.add_label_icon(true, 1050, "Redeem a code").add_text_input(120, "r_code", "Input your code:", "GLand")
			.end_dialog("redeem_dialog", "`wClose``", "`wRedeem``").add_quick_exit();

		gamepacket_t p;
		p.Insert("OnDialogRequest"), p.Insert(db.to_string()), p.CreatePacket(peer);
		}
		else if (actual_command == "/rainbow" && pInfo(peer)->mvp) {
			if (pInfo(peer)->rb == 0) pInfo(peer)->rb = 1;
			else pInfo(peer)->rb = 0;
			if (pInfo(peer)->rb == 0) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						gamepacket_t p2(0, pInfo(peer)->netID);
						p2.Insert("OnNameChanged");
						p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend``" : ""));
						p2.CreatePacket(currentPeer);
					}
				}
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Rainbow name status " + a + (pInfo(peer)->rb == 1 ? "visible" : "hidden") + "!");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/togglemods" && pInfo(peer)->mod) {
			if (pInfo(peer)->tmod == 1) pInfo(peer)->tmod = 0;
			else pInfo(peer)->tmod = 1;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (pInfo(peer)->tmod == 0) p.Insert("`o>> You removed your mod tag.``");
			else p.Insert("`o>> You added your mod tag back.``");
			p.CreatePacket(peer);
			pInfo(peer)->name_color = (pInfo(peer)->tmod == 1 ? (pInfo(peer)->dev == 1 ? "`6@" : pInfo(peer)->admin == 1 ? "`8@" : pInfo(peer)->supermod == 1 ? "`b@" : (pInfo(peer)->tmod == 1) ? "`#@" :
				pInfo(peer)->glory == 1 ? "`c[GLORY] " : pInfo(peer)->vvip == 1 ? "`9[VVIP] " : pInfo(peer)->vip == 1 ? "`1[VIP] " : "`0") : "`0");
			gamepacket_t p2(0, pInfo(peer)->netID);
			{
				p2.Insert("OnNameChanged");
				//if (not HasRole(pInfo(peer))) pInfo(peer)->name_color = "`0";
				p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (is_reseller(peer) and not pInfo(peer)->hide_reseller ? " `c[RESELLER]" : "") + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				p2.CreatePacket(currentPeer);
			}
		}
		else if (actual_command == "/hide" && pInfo(peer)->mod + pInfo(peer)->admin + pInfo(peer)->m_h >= 1) {
			if (pInfo(peer)->m_h == 0) pInfo(peer)->m_h = 1;
			else  pInfo(peer)->m_h = 0;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (pInfo(peer)->m_h) p.Insert("`o>> You hide yourself from everyone (You `4won't`` be visible in /mods, /msg etc.)``");
			else p.Insert("`o>> You un-hide yourself from everyone (You `2will`` be visible in /mods, /msg etc.)``");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/radio" && HasRole(pInfo(peer))) {
			if (pInfo(peer)->radio == false) pInfo(peer)->radio = true;
			else pInfo(peer)->radio = false;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (pInfo(peer)->radio) p.Insert("Radio disabled, `4you now won't see`` public broadcasts.");
			else p.Insert("Radio enabled, `2you can now see`` public broadcasts.");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/home") {
			if (pInfo(peer)->home_world.empty()) {
				packet_(peer, "action|log\nmsg|You haven't set a home world yet!");
				return;
			}
			for (pair<string, long long int> p : home_timed) {
				if (p.first == pInfo(peer)->tankIDName) {
					if (p.second + HOME_TIME > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
						packet_(peer, "action|log\nmsg|`4Cooldown active`` - You can use `5/home`` in `5" + to_string(((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) - ((((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) / 60) * 60)) + " ``seconds.");
						return;
					}
				}
			}
			home_timed.push_back(make_pair(pInfo(peer)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
			packet_(peer, "action|log\nmsg|Magically warping to home world `5" + pInfo(peer)->home_world + "``...");
			join_world(peer, pInfo(peer)->home_world);
		}
		else if (actual_command == "/unaccess" && HasRole(pInfo(peer))) {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|small|Remove Your Access From World|left|242|\nadd_textbox|Are you sure you want to remove yourself from all locks in this world?|left|\nadd_textbox|Any locks you placed will still be owned by you, but you will be removed from any other locks that you have access on.|left|\nadd_spacer|small|\nend_dialog|unaccess|No|Yes|");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/status") {
			int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
			get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
			string recently_visited = "";
			for (auto it = pInfo(peer)->last_visited_worlds.rbegin(); it != pInfo(peer)->last_visited_worlds.rend(); ++it) {
				string a_ = *it + (next(it) != pInfo(peer)->last_visited_worlds.rend() ? "``, " : "``");
				recently_visited += "`#" + a_;
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``'s Status:\nCurrent world: `w" + pInfo(peer)->world + "`` (`w" + to_string(pInfo(peer)->x / 32) + "``, `w" + to_string(pInfo(peer)->y / 32) + "``) (`w" + to_string(w_c) + "`` people)\nBackpack slots: `w" + to_string(pInfo(peer)->inv.size() - 1) + "``\nLast visited: " + recently_visited + form_mods(pInfo(peer), 1) + "");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/msg") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/stats" and pInfo(peer)->admin) {
			int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
			get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
			const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
			struct tm newtime;
			time_t now = time(0);
			localtime_s(&newtime, &now);
			string month = months[newtime.tm_mon], translated = "", str = to_string(newtime.tm_mday), locke = "";
			if (str == "1" || str == "21") translated = "st";
			else if (str == "2" || str == "22") translated = "nd";
			else if (str == "3") translated = "rd";
			else translated = "th";
			int fakeSub = rand() % 5 + 1;
			string text = format("S{} Uptime: {} - {}/1000 Players Online.", to_string(fakeSub), uptimeText(serverTimeOn), to_string(s_c));
			string text2 = format("{} Worlds Active, Last Server Save: {}", fixint(worlds.size()), lastServerSave);
			string text3 = format("TayoPs Time (WIB/UTC+7): {} {}{}, {}", month, to_string(newtime.tm_mday), translated, currentTime());
			Algorithm::send_console(peer, text);
			Algorithm::send_console(peer, text2);
			Algorithm::send_console(peer, text3);
		}
		else if (actual_command == "/mods") {
			string mods = "", a = "";
			int count = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->m_h == 1) continue;
				if (pInfo(currentPeer)->invis == true) continue;
				if (pInfo(currentPeer)->tmod && pInfo(currentPeer)->admin || pInfo(currentPeer)->dev || pInfo(currentPeer)->mod) {
					count++;
					mods += "" + a + (count == 1 ? "" : ", ") + "" + (pInfo(currentPeer)->dev == 1 ? "`6@" : pInfo(currentPeer)->admin == 1 ? "`8@" : pInfo(currentPeer)->supermod == 1 ? "`b@" : (pInfo(currentPeer)->tmod == 1) ? "`#@" :
						pInfo(currentPeer)->glory == 1 ? "`c[GLORY] " : pInfo(currentPeer)->vvip == 1 ? "`9[VVIP] " : pInfo(currentPeer)->vip == 1 ? "`1[VIP] " : "") + pInfo(currentPeer)->tankIDName + (is_reseller(currentPeer) and not pInfo(currentPeer)->hide_reseller ? " `c[RESELLER]" : "") + "``";
				}
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Mods online: " + (mods != "" ? mods : "(All are hidden)") + "`o.``");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/go") {
			gamepacket_t p;
			p.Insert("OnTextOverlay");
			if (lastsbworld == pInfo(peer)->world || lastsbworld == "") p.Insert("Unable to track down the location of the last broadcast!");
			else {
				p.Insert("Moving to location of the last broadcast (`2" + lastsbworld + "``) ...");
				packet_(peer, "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0");
				join_world(peer, lastsbworld);
			}
			p.CreatePacket(peer);
		}
		else if (actual_command == "/rgo") {
			gamepacket_t p;
			if (pInfo(peer)->lastmsgworld == pInfo(peer)->world) {
				p.Insert("OnConsoleMessage");
				p.Insert("You magically appear at the world you were already in.  Great job!");
				p.CreatePacket(peer);
				return;
			}
			if (pInfo(peer)->lastmsgworld == "") {
				p.Insert("OnTextOverlay");
				p.Insert("Unable to track down the location of the last broadcast!");
				p.CreatePacket(peer);
				return;
			}
			p.Insert("OnTextOverlay");
			p.Insert("Moving to where `w/" + pInfo(peer)->lastmsg + "`` sent that last `5/msg`` from... (`2" + pInfo(peer)->lastmsgworld + "``) ...");
			p.CreatePacket(peer);
			packet_(peer, "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0");
			join_world(peer, pInfo(peer)->lastmsgworld);
		}
		else if (actual_command == "/pull" || actual_command == "/kick" || actual_command == "/ban") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("You'll need to enter at least the first three characters of the person's name.");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/trade") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("To trade with a specific person in this world, do `2/trade <``full or partial name`2>``");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/sb") {
			int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
			get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
			packet_(peer, "action|log\nmsg|>> This lets you send a message to " + setGems(s_c) + "`` random users online and make an annoying beep noise.  Costs `$30,000 Gems`` to use. Example:`` `w/sb Hey guys, come to my world!", "");
		}
		else if (actual_command == "/sdbkanjutmemekasukocak" && pInfo(peer)->umod) {
			int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
			get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
			gamepacket_t p(0);
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`2Super Duper Broadcast|left|660|\nadd_textbox|Super Duper Broadcasts pop up a box with your message on every player's screen. The box even includes a button to visit your world! It costs 10 Diamond Lock to send.|left|\nadd_spacer|small|\nadd_smalltext|Enter up to 3 lines of text!|left|\nadd_text_input|sdb_1|||128|\nadd_text_input|sdb_2|||128|\nadd_text_input|sdb_3|||128||\nadd_spacer|small|\nend_dialog|sdbsend|Cancel|Send|");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/me") packet_(peer, "action|log\nmsg|`6>> Type `5/me looks around suspiciously`` or any other text, useful for role playing.", "");
		else if (actual_command == "/hidestatus" && pInfo(peer)->supp >= 2) {
			if (pInfo(peer)->hs == 0) pInfo(peer)->hs = 1;
			else pInfo(peer)->hs = 0;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Super Supporter status " + a + (pInfo(peer)->hs == 1 ? "visible" : "hidden") + "!");
			p.CreatePacket(peer);
			update_clothes(peer);
		}
		else if (actual_command.substr(0, 3) == "/w ") {
			string world = actual_command.substr(3, cmd.length() - 3).c_str();
			transform(world.begin(), world.end(), world.begin(), ::toupper);
			gamepacket_t p;
			bool passed = true;
			p.Insert("OnConsoleMessage");
			if (pInfo(peer)->mvp == 0) {
				if (pInfo(peer)->warp_time + 30000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) pInfo(peer)->warp_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				else {
					p.Insert("`4Cooldown active`` - You can use  `5/warp`` in `10" + to_string((pInfo(peer)->warp_time + WARP_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) + "`` seconds.");
					passed = false;
				}
			}
			if (passed) {
				p.Insert("Magically warping to world `5" + world + "``...");
				p.CreatePacket(peer);
				join_world(peer, world);
			}
			else p.CreatePacket(peer);
			}
		else if (actual_command.substr(0, 6) == "/warp " && (HasRole(pInfo(peer)) || pInfo(peer)->supp >= 1)) {
			string world = actual_command.substr(6, cmd.length() - 6).c_str();
			transform(world.begin(), world.end(), world.begin(), ::toupper);
			gamepacket_t p;
			bool passed = true;
			p.Insert("OnConsoleMessage");
			if (pInfo(peer)->admin == 0) {
				if (pInfo(peer)->warp_time + 15000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) pInfo(peer)->warp_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				else {
					p.Insert("`4Cooldown active`` - You can use  `5/warp`` in `5" + to_string((pInfo(peer)->warp_time + WARP_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) + "`` seconds.");
					passed = false;
				}
			}
			if (passed) {
				p.Insert("Magically warping to world `5" + world + "``...");
				p.CreatePacket(peer);
				join_world(peer, world);
			}
			else p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 4) == "/me ") {
			if (pInfo(peer)->world == "") return;
			if (has_playmod(pInfo(peer), "duct tape")) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`6>> That's sort of hard to do while duct-taped.``");
				p.CreatePacket(peer);
				return;
			}
			string text = cmd.substr(4, cmd.length() - 4).c_str();
			if (text.length() <= 0 || text.length() > 120 || text.empty() || std::all_of(text.begin(), text.end(), [](char c) {return std::isspace(c); })) return;
			for (char c : text) if (c < 0x20 || c>0x7A) return;
			{
				if (world_->silence and pInfo(peer)->dev != 1 and world_->owner_name != pInfo(peer)->tankIDName and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end()) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("`1(Peasants must not speak)");
					p.Insert(1);
					p.CreatePacket(peer);
					return;
				}
			}
			gamepacket_t p, p2;
			p.Insert("OnConsoleMessage");
			p.Insert("CP:0_PL:0_OID:__CT:[W]_ `6<``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `#" + text + "```6>``");
			p2.Insert("OnTalkBubble");
			p2.Insert(pInfo(peer)->netID);
			p2.Insert("player_chat= `6<```0" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `#" + text + "```6>``");
			p2.Insert(0);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					p.CreatePacket(currentPeer);
					p2.CreatePacket(currentPeer);
				}
			}
		}
		else if (actual_command == "/who") {
			string who = "`wWho's in `$" + pInfo(peer)->world + "``:`` " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + "``";
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->tankIDName == pInfo(peer)->tankIDName) continue;
				if (pInfo(currentPeer)->invis) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					who += ", " + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name)) + "``";
					gamepacket_t p2;
					p2.Insert("OnTalkBubble");
					p2.Insert(pInfo(currentPeer)->netID);
					p2.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name)));
					p2.Insert(1), p2.Insert(1);
					p2.CreatePacket(peer);
				}
			}
			p.Insert(who);
			p.CreatePacket(peer);
		}
		else if (actual_command == "/r") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Usage: /r <`$your message``> - This will send a private message to the last person who sent you a message. Use /msg to talk to somebody new!");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/1hit" && pInfo(peer)->umod) {
			if (pInfo(peer)->hit1 == false) {
				pInfo(peer)->hit1 = true;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou enabled 1hit Damage");
				p.CreatePacket(peer);
			}
			else {
				pInfo(peer)->hit1 = false;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`2You disabled 1hit Damage");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command == "/2hit" && pInfo(peer)->umod) {
			if (pInfo(peer)->hit2 == false) {
				pInfo(peer)->hit2 = true;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou enabled 2hit Damage");
				p.CreatePacket(peer);
			}
			else {
				pInfo(peer)->hit2 = false;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`2You disabled 2hit Damage");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command.substr(0, 7) == "/trade ") {
			pInfo(peer)->last_wrenched = cmd.substr(7, cmd.length() - 7).c_str();
			if (to_lower(pInfo(peer)->last_wrenched) == to_lower(pInfo(peer)->tankIDName)) {
				packet_(peer, "action|log\nmsg|You trade all your stuff to yourself in exchange for all your stuff.", "");
				return;
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world and to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched) || to_lower(pInfo(currentPeer)->tankIDName.substr(0, 3)) == to_lower(pInfo(peer)->last_wrenched)) {
					for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
						if (pInfo(currentPeer)->friends[c_].uid == pInfo(peer)->uid) {
							if (pInfo(currentPeer)->friends[c_].block_trade)
								return;
						}
					}
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->tankIDName)) {
						packet_(peer, "action|log\nmsg|You trade all your stuff to yourself in exchange for all your stuff.", "");
						return;
					}
					if (pInfo(currentPeer)->trading_with != -1 and pInfo(currentPeer)->trading_with != pInfo(peer)->netID) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("That person is busy.");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						pInfo(peer)->block_trade = false, pInfo(peer)->trading_with = -1;
						{
							gamepacket_t p;
							p.Insert("OnForceTradeEnd");
							p.CreatePacket(peer);
						}
						return;
					}
					pInfo(peer)->trading_with = pInfo(currentPeer)->netID;
					pInfo(peer)->trade_accept = 0;
					pInfo(currentPeer)->trade_accept = 0;
					gamepacket_t p;
					p.Insert("OnStartTrade");
					p.Insert(pInfo(currentPeer)->tankIDName);
					p.Insert(pInfo(currentPeer)->netID);
					p.CreatePacket(peer);
					if (pInfo(currentPeer)->trading_with != -1) {
						// as neisivaizduoju kdl real gt taip daro bet noriu kad butu kaip rgt.
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(peer)->netID);
						p.Insert("");
						p.Insert("`o" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``'s offer.``");
						p.Insert("locked|0\nreset_locks|1\naccepted|0");
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(peer)->netID);
							p.Insert("");
							p.Insert("`o" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``'s offer.``");
							p.Insert("locked|0\naccepted|1");
							p.CreatePacket(peer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(peer)->netID);
							p.Insert("");
							p.Insert("`o" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(peer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
							p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(peer);
							{
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(currentPeer)->netID);
								p.Insert("");
								p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
								p.Insert("locked|0\nreset_locks|1\naccepted|0");
								p.CreatePacket(currentPeer);
							}
							{
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(currentPeer)->netID);
								p.Insert("");
								p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
								p.Insert("locked|0\naccepted|1");
								p.CreatePacket(currentPeer);
							}
							{
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(currentPeer)->netID);
								p.Insert("");
								p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
								p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
								p.CreatePacket(currentPeer);
							}
							{
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(peer)->netID);
								p.Insert("");
								p.Insert("`o" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``'s offer.``");
								p.Insert(make_trade_offer(pInfo(peer), true) + "locked|0\nreset_locks|1\naccepted|0");
								p.CreatePacket(currentPeer);
							}
						}
						break;
					}
					packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`#TRADE ALERT:`` `w" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "```` wants to trade with you!  To start, use the `wWrench`` on that person's wrench icon, or type `w/trade " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``");
						p.CreatePacket(currentPeer);
					}
					break;
				}
			}
		}
		else if (actual_command.substr(0, 6) == "/kick ") {
			if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("Can't `4kick``, is not in a locked area you control!");
				p.CreatePacket(peer);
				return;
			}
			string username = cmd.substr(6, cmd.length() - 6).c_str();
			if (to_lower(pInfo(peer)->tankIDName) == to_lower(username)) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou give yourself a solid boot to the backside. But what did that really accomplish?");
				p.CreatePacket(peer);
				return;
			}
			bool playerFound = false;
			string color = "`o";
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(peer)->world == pInfo(currentPeer)->world) {
					if (to_lower(pInfo(currentPeer)->tankIDName.substr(0, 3)) == to_lower(username) || to_lower(pInfo(currentPeer)->tankIDName) == to_lower(username)) {
						if (not pInfo(currentPeer)->dev) {
							playerFound = true;
							username = pInfo(currentPeer)->tankIDName;
							if (pInfo(currentPeer)->name_color != "`0") color = pInfo(currentPeer)->name_color;
							SendRespawn(currentPeer, true, 0, 1);
						}
						break;
					}
				}
			}
			if (playerFound) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(peer)->world == pInfo(currentPeer)->world) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `4kicks`` `o" + color + username + "``!``");
						p.CreatePacket(currentPeer);
					}
				}
			}
			else {
				packet_(peer, "action|log\nmsg| `4Oops: `oThere is nobody currently in this world with a name starting with `w" + username + "`o.", "");
			}
		}
		else if (actual_command == "/kickall") {
			if (pInfo(peer)->last_kickall + 600000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (not pInfo(peer)->dev) pInfo(peer)->last_kickall = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
					gamepacket_t p;
					p.Insert("OnTextOverlay"), p.Insert("Can't `4kick``, is not in a locked area you control!"), p.CreatePacket(peer);
					return;
				}
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("`4(KICKALL ACTIVATED!)``");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName or pInfo(currentPeer)->admin) continue;
					SendRespawn(currentPeer, true, 0, 1);
					packet_(currentPeer, "action|play_sfx\nfile|audio/weird_hit.wav\ndelayMS|0");
					p.CreatePacket(currentPeer);
				}
				p.CreatePacket(peer);
			}
			else {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("You use `5/kickall`` again in few minutes."), p.CreatePacket(peer);
			}
		}
		else if (actual_command == "/uba") {
			if (world_->owner_name.empty() || world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("You don't have access to the world lock, so you can't unban all!");
				p.CreatePacket(peer);
				return;
			}
			world_->bannedPlayers.clear();
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("CP:_PL:0_OID:_CT:[S]_ You've unbanned everybody from this world.");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/banall" && pInfo(peer)->supermod) {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				if (pInfo(currentPeer)->dev == 0 or pInfo(currentPeer)->admin == 0)
					world_->bannedPlayers.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));// world_->banned_player_uid.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `4world bans`` " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` from `0" + pInfo(currentPeer)->world + "``!");
				if (pInfo(currentPeer)->dev == 0 or pInfo(currentPeer)->admin == 0) {
					p.CreatePacket(currentPeer);
					p.CreatePacket(peer);
					//world_->banned_player_uid.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					world_->bannedPlayers.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					packet_(currentPeer, "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0"); exit_(currentPeer);
				}
			}
		}
		else if (actual_command.substr(0, 5) == "/ban ") {
			string name = cmd.substr(5, cmd.length() - 5).c_str();
			string w_name = pInfo(peer)->world;
			/*
			if (pInfo(peer)->mod + pInfo(peer)->admin and name == world_->owner_name) {
				SendCmd(peer, "/banworld");
				return;
			}
			*/
			if (world_->owner_name.empty() || name == world_->owner_name || world_->owner_name != pInfo(peer)->tankIDName and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("Can't `4world ban``, is not in a world you control!");
				p.CreatePacket(peer);
				return;
			}
			if (to_lower(pInfo(peer)->tankIDName) == to_lower(name)) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou are banned from banning yourself!");
				p.CreatePacket(peer);
				return;
			}
			string color = "`o", named = "";
			bool playerfound = false;
			int found = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName.substr(0, 3)) == to_lower(name) || to_lower(name) == to_lower(pInfo(currentPeer)->tankIDName)) {
					if (pInfo(currentPeer)->tankIDName == world_->owner_name || pInfo(currentPeer)->mod || pInfo(currentPeer)->admin) {
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("Can't `4world ban``, is not in a world you control!");
						p.CreatePacket(peer);
						return;
					}
					if (not pInfo(currentPeer)->dev or not pInfo(currentPeer)->mod or not pInfo(currentPeer)->admin) {
						found++;
						playerfound = true;
						//world_->banned_player_uid.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
						world_->bannedPlayers.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
						if (pInfo(currentPeer)->name_color != "`0") color = pInfo(currentPeer)->name_color;
						named = pInfo(currentPeer)->tankIDName;
						exit_(currentPeer);
					}
					break;
				}
			}
			if (playerfound) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(peer)->world == pInfo(currentPeer)->world or to_lower(name) == to_lower(pInfo(currentPeer)->tankIDName)) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `4world bans`` " + color + named + "`` from `0" + name_ + "``!");
						p.CreatePacket(currentPeer);
						packet_(currentPeer, "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0");
					}
				}
				gamepacket_t p2;
				p2.Insert("OnConsoleMessage");
				p2.Insert("You've banned " + color + named + "`` from `w" + name_ + "`` for one hour.  You can also type `#/uba`` to unban him/her early.");
				p2.CreatePacket(peer);
			}
			else {
				packet_(peer, "action|log\nmsg| `4Oops: `oThere is nobody currently in this world with a name starting with `w" + name + "`o.", "");
			}
		}
		else if (actual_command.substr(0, 6) == "/pull ") {
			string username = cmd.substr(6, cmd.length() - 6).c_str();
			if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->owner and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
				if (not pInfo(peer)->owner) {
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("Can't `5pull``, that player is not standing in an area you control!");
					p.CreatePacket(peer);
					return;
				}
			}
			if (to_lower(pInfo(peer)->tankIDName) == to_lower(username)) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oOuch!");
				p.CreatePacket(peer);
				return;
			}
			bool playerFound = false;
			string color = "`o", huh = "";
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(peer)->world == pInfo(currentPeer)->world) {
					if (to_lower(pInfo(currentPeer)->tankIDName.substr(0, 3)) == to_lower(username) || to_lower(pInfo(currentPeer)->tankIDName) == to_lower(username)) {
						if (not pInfo(currentPeer)->dev or not pInfo(currentPeer)->mod or not pInfo(currentPeer)->admin) {
							playerFound = true;
							pInfo(currentPeer)->x = pInfo(peer)->x, pInfo(currentPeer)->y = pInfo(peer)->y;
							pInfo(currentPeer)->ignore_cheats = true;
							huh = ((pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name));
							gamepacket_t p(0, pInfo(currentPeer)->netID);
							p.Insert("OnSetPos");
							p.Insert(pInfo(peer)->x, pInfo(peer)->y);
							p.CreatePacket(currentPeer);
							{
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("You were pulled by " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name));
								p.CreatePacket(currentPeer);
							}
						}
						break;
					}
				}
			}
			if (playerFound) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(peer)->world == pInfo(currentPeer)->world) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `5pulls`` `o" + huh + "``!``");
						p.CreatePacket(currentPeer);
						packet_(currentPeer, "action|play_sfx\nfile|audio/teleport.wav\ndelayMS|0");
					}
				}
			}
			else {
				packet_(peer, "action|log\nmsg| `4Oops: `oThere is nobody currently in this world with a name starting with `w" + username + "`o.", "");
			}
		}
		else if (actual_command.substr(0, 5) == "/msg " || actual_command.substr(0, 3) == "/r ") {
			if (has_playmod(pInfo(peer), "duct tape")) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`6>> That's sort of hard to do while duct-taped.``");
				p.CreatePacket(peer);
				return;
			}
			string message = "";
			string username = "";
			if (actual_command.substr(0, 5) == "/msg ") {
				if (cmd.substr(5).find(" ") == string::npos) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
					p.CreatePacket(peer);
					return;
				}
				string s = cmd.substr(5);
				stringstream ss(s);
				istream_iterator<string> begin(ss);
				istream_iterator<string> end;
				vector<string> vstrings(begin, end);
				if (vstrings.size() < 1) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
					p.CreatePacket(peer);
					return;
				}
				username = vstrings[0];
				if (username == "") {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
					p.CreatePacket(peer);
					return;
				}
				message = "";
				for (int i = 1; i < vstrings.size(); i++) message = message + vstrings[i] + " ";
			}
			else {
				message = cmd.substr(3, cmd.length() - 3).c_str();
				username = pInfo(peer)->lastmsg;
				if (username == "") {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /r <`$your message``> - This will send a private message to the last person who sent you a message. Use /msg to talk to somebody new!");
					p.CreatePacket(peer);
					return;
				}
			}
			//find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()
			bool playerFound = false;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->m_h == 1 or pInfo(currentPeer)->invis == true) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(username)) {
					playerFound = true;
					if (message.length() < 1) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`6>> `$" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` is online now.``");
						p.CreatePacket(peer);
					}
					else {
						bool muted_ = false;
						for (int c_ = 0; c_ < pInfo(peer)->friends.size(); c_++) {
							if (pInfo(peer)->friends[c_].uid == pInfo(currentPeer)->uid) {
								if (pInfo(peer)->friends[c_].mute) {
									muted_ = true;
									break;
								}
							}
						}
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							if (pInfo(currentPeer)->mod == 1 || pInfo(currentPeer)->admin == 1) p.Insert("CT:[MSG]_`6>> (Sent to `$" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``)`` (`4Note: ``Message a mod `4ONLY ONCE`` about an issue. Mods don't fix scams or replace items, they punish players who break the `5/rules``.  For issues related to account recovery or purchasing, contact support at `1TayoPs `5Discord Server``)");
							else {
								if (muted_) {
									p.Insert("CT:[MSG]_`6>> (Sent to `$" + pInfo(currentPeer)->tankIDName + "``)`` (`4Note: ``You can't send messages to people you muted)");
								}
								else {
									p.Insert("CT:[MSG]_`6>> (Sent to `$" + pInfo(currentPeer)->tankIDName + "``)``");
								}
							}
							p.CreatePacket(peer);
						}
						{
							for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
								if (pInfo(currentPeer)->friends[c_].uid == pInfo(peer)->uid) {
									if (pInfo(currentPeer)->friends[c_].mute) {
										return;
									}
								}
							}
							pInfo(currentPeer)->lastmsg = pInfo(peer)->tankIDName;
							pInfo(currentPeer)->lastmsgworld = pInfo(peer)->world;
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("CP:0_PL:0_OID:_CT:[MSG]_>> `c>> from (```c" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`````c) in [`$" + (pInfo(peer)->m_h || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "``] > ```$" + message + "``");
							p.CreatePacket(currentPeer);
							packet_(currentPeer, "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0");
						}
					}
					break;
				}
			}
			if (!playerFound) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (username.length() < 5) p.Insert("`6>> `$" + username + "`` is not online right now (you need to enter at least 5 letters if you meant a longer name!).``");
				else p.Insert("`6>> No one online who has a name starting with `$" + username + "``.``");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command.substr(0, 10) == "/unfreeze " && pInfo(peer)->guardian) {
			pInfo(peer)->last_wrenched = cmd.substr(10, cmd.length() - 10);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->mod >= 1) continue;
				for (auto& mods : pInfo(currentPeer)->playmods) {
					if (mods.id == 3)
						mods.time = 1;
				}
			}
		}
		else if (actual_command.substr(0, 10) == "/masstape ") {
			if (pInfo(peer)->umod) {
				int Time = atoi(cmd.substr(10, cmd.length() - 10).c_str());
				string By = (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``";
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->mod >= 1) continue;
					if (pInfo(currentPeer)->world == world_->name and pInfo(currentPeer)->tankIDName != pInfo(peer)->tankIDName) {
						add_mute(currentPeer, Time, "Mute All by:" + By, "masstapecommand");
					}
				}
				Send_Mod_Logs2("(``" + By + "`^) in [```$" + pInfo(peer)->world + "```^] > `^Use Mute all``\n`4Time`` : `#" + ((Time / 86400 > 0) ? to_string(Time / 86400) + " days" : (Time / 3600 > 0) ? to_string(Time / 3600) + " hours" : (Time / 60 > 0) ? to_string(Time / 60) + " minutes" : to_string(Time) + " seconds"));
			}
		}
		else if (actual_command.substr(0, 12) == "/massfreeze ") {
			if (pInfo(peer)->umod) {
				int Time = atoi(cmd.substr(12, cmd.length() - 12).c_str());
				string By = (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``";
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->mod >= 1) continue;
					if (pInfo(currentPeer)->world == world_->name and pInfo(currentPeer)->tankIDName != pInfo(peer)->tankIDName) {
						PlayMods new_playmod{};
						new_playmod.id = 3;
						new_playmod.time = time(nullptr) + Time;
						new_playmod.user = pInfo(currentPeer)->tankIDName;
						pInfo(currentPeer)->playmods.push_back(new_playmod);
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("Freeze! (`$Frozen`` mod added, `$" + Algorithm::to_playmod_time(Time) + "``left)");
						p.CreatePacket(currentPeer);
						update_clothes(currentPeer);
					}
				}
				Send_Mod_Logs2("(``" + By + "`^) in [```$" + pInfo(peer)->world + "```^] > `^Use Freeze all``\n`4Time`` : `#" + ((Time / 86400 > 0) ? to_string(Time / 86400) + " days" : (Time / 3600 > 0) ? to_string(Time / 3600) + " hours" : (Time / 60 > 0) ? to_string(Time / 60) + " minutes" : to_string(Time) + " seconds"));
			}
		}
		else if (actual_command.substr(0, 5) == "/csn " && pInfo(peer)->owner) {
			bool valid = true, found = false;
			string x = cmd.substr(5, cmd.length() - 5);
			int pos = x.find(" ");
			string gemcount = x.substr(pos + 1);
			string addrWithMask(x);
			size_t pos1 = addrWithMask.find(" ");
			string playername = addrWithMask.substr(0, pos1);
			bool contains_non_alpha = !regex_match(gemcount, regex("^[0-9]+$"));
			for (char c : playername) {
				if (all_of(playername.begin(), playername.end(), [](char c) {return isspace(c); })) {
					valid = false;
				}
			}
			if (contains_non_alpha || playername == "" || valid == false) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(">> Usage: /csn <TayoPsID> <value 0-36>");
				p.CreatePacket(peer);
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
				if (to_lower(playername) == to_lower(pInfo(currentPeer)->tankIDName)) {
					found = true;
					int csns = atoi(gemcount.c_str());
					if (csns > 36 || csns < 0) pInfo(currentPeer)->csn = -1;
					pInfo(currentPeer)->csn = csns;
					Algorithm::send_overlay(peer, "Set " + pInfo(currentPeer)->tankIDName + "'s next roulette spin to " + to_string(csns));
					break;
				}
			}
			if (not found) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(">> Player not found");
				p.CreatePacket(peer);
				return;
			}
		}

		else if (actual_command.starts_with("/send") && pInfo(peer)->dev == 1) {
			std::vector<std::string> args = explode(" ", cmd);
			if (args.size() < 3) return;

			ENetPeer* target = pData::Algorithm::get_player(to_lower(args[1]));

			if (target == nullptr) {
				Algorithm::send_console_message(peer, "`oThat player is currently `4offline`o.");
				return;
			}

			if (pInfo(target)->dev) return;

			if (algorithm::contains_regex(args[2], "^[0-9A-Z]+$")) {
				Algorithm::send_console_message(peer, "`oPlayer `0" + pInfo(target)->tankIDName + "`o has been `4sent`o to world `$" + args[2] + "`o.");
				join_world(target, args[2]);
				return;
			}
			}

		else if (actual_command.starts_with("/pay")) {
			std::vector<std::string> args = explode(" ", actual_command);
			if (args.size() < 3) return;

			ENetPeer* target = pData::Algorithm::get_player(args[1]);

			if (target == nullptr) {
				enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`oThat player is currently `4offline`o.").pack());
				return;
			}

			int quantity = 0;

			try {
				quantity = std::stoi(args[2]);
				if (quantity <= 0) return;
			}
			catch (std::invalid_argument&) { return; }
			catch (std::out_of_range&) { return; }

			if (pInfo(peer)->gems < quantity) {
				enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`oYou are short of `2" + std::to_string(quantity - pInfo(peer)->gems) + " gems`o to pay!").pack());
				return;
			}

			pInfo(peer)->gems -= quantity;
			Algorithm::set_bux(peer);

			enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`oYou have `2paid `0" + pInfo(target)->name_color + pInfo(target)->tankIDName + "`5 " + std::to_string(quantity) + " gems`o!").pack());

			pInfo(target)->gems += quantity;
			Algorithm::set_bux(target);

			enet_peer_send(target, 0, Variant{ "OnConsoleMessage" }.push("`oYou have `2received `5" + std::to_string(quantity) + " gems`o from `0" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`o!").pack());
			packet_(target, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
		}

		else if (actual_command.starts_with("/givegems") && pInfo(peer)->owner) {
			std::vector<std::string> args = explode(" ", actual_command);
			if (args.size() < 3) return;

			ENetPeer* target = pData::Algorithm::get_player(args[1]);

			if (target == nullptr) {
				enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`oThat player is currently `4offline`o.").pack());
				return;
			}

			int quantity = 0;

			try {
				quantity = std::stoi(args[2]);
				if (quantity <= 0) return;
			}
			catch (std::invalid_argument&) { return; }
			catch (std::out_of_range&) { return; }

			pInfo(target)->gems += quantity;
			Algorithm::set_bux(target);

			enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`oYou have `2given `0" + pInfo(target)->name_color + pInfo(target)->tankIDName + "`5 " + std::to_string(quantity) + " gems`o!").pack());
			enet_peer_send(target, 0, Variant{ "OnConsoleMessage" }.push("`oYou have `2received `5" + std::to_string(quantity) + " gems`o from `0" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`o!").pack());
			}

		else if (actual_command.substr(0, 7) == "/color " && pInfo(peer)->mod) {
			int kolor = atoi(cmd.substr(7, cmd.length() - 7).c_str());
			pInfo(peer)->skin = kolor;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert(">> Your color skin set to " + to_string(kolor));
			p.CreatePacket(peer);
			update_clothes(peer);
		}
		else if (actual_command.substr(0, 6) == "/skip " and pInfo(peer)->dev) {
			//if (find(Access.begin(), Access.end(), pInfo(peer)->tankIDName) != Access.end()) 
			{
				pInfo(peer)->quest_step += atoi(cmd.substr(6, cmd.length() - 6).c_str());
				packet_(peer, "Skipped " + cmd.substr(6, cmd.length() - 6) + " quests!");
			}
		}
		else if (actual_command.substr(0, 4) == "/qp ") {
			if (pInfo(peer)->dev) {
				pInfo(peer)->quest_progress = atoi(cmd.substr(4, cmd.length() - 4).c_str());
			}
		}
		else if (actual_command.substr(0, 4) == "/cp ") {
			if (pInfo(peer)->dev) {
				pInfo(peer)->C_QuestProgress = atoi(cmd.substr(4, cmd.length() - 4).c_str());
			}
		}
		/*
		else if (actual_command.substr(0, 4) == "/ab ") {
			if (pInfo(peer)->owner) {
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnFlagMay2019"), p.Insert(atoi(cmd.substr(4, cmd.length() - 4).c_str()));
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
					if (pInfo(peer)->world == pInfo(currentPeer)->world) p.CreatePacket(currentPeer);
				}
			}
		}
		*/
		else if ((actual_command.substr(0, 6) == "/remd " or actual_command.substr(0, 6) == "/givd ") and pInfo(peer)->owner) {
			if (actual_command.substr(0, 6) == "/remd ")
			{
				if (pInfo(peer)->owner) {
					vector<string> a_ = explode(" ", cmd);
					if (a_.size() != 3) return;
					if (not isdigit(a_[1][0]) or not isdigit(a_[2][0])) return;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						int i_ = atoi(a_[1].c_str()), c_ = atoi(a_[2].c_str());
						int C = 0;
						if (i_ <= 0 or c_ <= 0 or i_ >= items.size()) return;
						if (modify_inventory(currentPeer, i_, C = -c_) == 0) {
							gamepacket_t p, p1;
							p.Insert("OnConsoleMessage");
							p.Insert("`4System `2Took your:`` `w" + a_[2] + " " + items.at(i_).name + "``.");
							p.CreatePacket(currentPeer);
						}
					}
					return;
				}
			}
		}
		else if (actual_command.substr(0, 6) == "/givi " && pInfo(peer)->dev) {
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() != 4) return;
			vector<ENetPeer*> peers_;
			if (not isdigit(a_[1][0]) or not isdigit(a_[2][0]) or not isdigit(a_[3][0])) return;
			int limit_ = atoi(a_[3].c_str());
			int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
			get_players("", w_c, s_c, net_, r_c);
			bool all_ = false;
			if (limit_ >= s_c || limit_ <= 0) {
				packet_(peer, "action|log\nmsg|Set the winner to all peers!");
				limit_ = s_c;
				all_ = true;
			}
			int i_ = atoi(a_[1].c_str());
			int c_ = items[i_].blockType == FISH ? items[i_].fish_max_lb : atoi(a_[2].c_str());
			if (i_ <= 0 or c_ <= 0 or i_ >= items.size()) return;

			if (all_) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					if (modify_inventory(currentPeer, i_, c_) == -1) p.Insert("Failed to add inventory item");
					else p.Insert("`2Received from `4System`2:`` `w" + setGems(items[i_].blockType == FISH ? items[i_].fish_max_lb : atoi(a_[2].c_str())) + " " + items.at(i_).name + "``." + (items.at(i_).rarity > 363 ? "" : " Rarity: `w" + to_string(items.at(i_).rarity) + "``") + "");
					p.CreatePacket(currentPeer);
				}
			}
			else {
				for (int i = 0; i < limit_; i++)
				{
					ENetPeer* currentPeer = &server->peers[rand() % server->peerCount];
					if (find(peers_.begin(), peers_.end(), currentPeer) != peers_.end()) continue;
					peers_.push_back(currentPeer);
				}
			}
			c_ = atoi(a_[2].c_str());

			vector<string> winner_;
			vector<ENetPeer*> proccessed_peer;
			string winner;

			if (not all_)
			{
				for (int i = 0; i < peers_.size(); i++) {
					ENetPeer* peer_ = peers_[rand() % peers_.size()];
					if (find(proccessed_peer.begin(), proccessed_peer.end(), peer_) != proccessed_peer.end())
						peer_ = peers_[rand() % peers_.size()];

					proccessed_peer.push_back(peer_);
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					if (modify_inventory(peer_, i_, c_) == -1) p.Insert("Failed to add inventory item");
					else p.Insert("`2Received from `4System`2:`` `w" + setGems(items[i_].blockType == FISH ? items[i_].fish_max_lb : atoi(a_[2].c_str())) + " " + items.at(i_).name + "``." + (items.at(i_).rarity > 363 ? "" : " Rarity: `w" + to_string(items.at(i_).rarity) + "``") + "");
					p.CreatePacket(peer_);
					winner_.push_back(pInfo(peer_)->tankIDName);
				}

				for (int i = 0; i < winner_.size(); i++)
					winner += i == winner_.size() - 1 ? format("{}.", winner_[i]) : format("{}, ", winner_[i]);

				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					Algorithm::send_console(currentPeer, format("The winners are: {}", winner));
				}
			}
			winner_.clear();
			winner.clear();
			peers_.clear();
			proccessed_peer.clear();
			return;
		}
		
		else if (actual_command.substr(0, 6) == "/warn " && pInfo(peer)->umod) {
			string warn_info = cmd;
			size_t extra_space = warn_info.find("  ");
			if (extra_space != std::string::npos) warn_info.replace(extra_space, 2, " ");
			string delimiter = " ";
			size_t pos = 0;
			string warn_message;
			if ((pos = warn_info.find(delimiter)) != std::string::npos) warn_info.erase(0, pos + delimiter.length());
			else return;
			if ((pos = warn_info.find(delimiter)) != std::string::npos) {
				pInfo(peer)->last_wrenched = warn_info.substr(0, pos);
				warn_info.erase(0, pos + delimiter.length());
			}
			else return;
			warn_message = warn_info;
			if (to_lower(pInfo(peer)->last_wrenched) == "iDems") return;
			if (pInfo(peer)->last_wrenched == pInfo(peer)->tankIDName) {
				gamepacket_t p;
				p.Insert("OnTalkBubble"); p.Insert(pInfo(peer)->netID);
				p.Insert("You can't warn yourself!"); p.Insert(0), p.Insert(1); p.CreatePacket(peer);
				return;
			}
			if (warn_message == "") {
				gamepacket_t p;
				p.Insert("OnTalkBubble"); p.Insert(pInfo(peer)->netID);
				p.Insert("The warning can't be empty!"); p.Insert(0), p.Insert(1); p.CreatePacket(peer);
				return;
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					pInfo(currentPeer)->Warning++; pInfo(currentPeer)->Warning_Message.push_back(warn_message);
					gamepacket_t a, b;
					a.Insert("OnAddNotification"), b.Insert("OnConsoleMessage"); a.Insert("interface/atomic_button.rttex");
					a.Insert("Warning from `4System``: " + warn_message); a.Insert("audio/hub_open.wav"); a.Insert(0);
					b.Insert("Warning from `4System``: " + warn_message);
					a.CreatePacket(currentPeer), b.CreatePacket(currentPeer);
					Send_Mod_Logs2("(``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "```^) in [```$" + pInfo(peer)->world + "```^] > `^Warn : " + pInfo(currentPeer)->tankIDName + "\n`4Warning Message : " + warn_message + "``");
					string Logs = "<:warn:1038681185284542464> " + pInfo(peer)->tankIDName + " has've been warn: " + pInfo(currentPeer)->tankIDName + " | <:hacker:1038632206400233522> Warn Message: " + warn_message;
					//webhook here
					if (pInfo(currentPeer)->Warning >= 5) {
						int Time = 604800;
						add_ban(currentPeer, Time, "Reached 5 Warnings!", "System");
						Send_Mod_Logs2("(```4System```^) in [```$" + pInfo(currentPeer)->world + "```^] > `^AUTO-BANNED (reached 5 warnings!): " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``\n`4Time`` : `#" + ((Time / 86400 > 0) ? to_string(Time / 86400) + " days" : (Time / 3600 > 0) ? to_string(Time / 3600) + " hours" : (Time / 60 > 0) ? to_string(Time / 60) + " minutes" : to_string(Time) + " seconds"));
					}
					return;
				}
			}
			gamepacket_t p;
			p.Insert("OnTalkBubble"); p.Insert(pInfo(peer)->netID);
			p.Insert("The warning send (will work when player's online!)"); p.Insert(0), p.Insert(1); p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 12) == "/removelogs " && pInfo(peer)->staff + pInfo(peer)->admin) {
			string username = cmd.substr(12, cmd.length() - 12).c_str();
			pInfo(peer)->last_wrenched = username;
			if (pInfo(peer)->staff || pInfo(peer)->dev) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(username) == to_lower(pInfo(currentPeer)->tankIDName)) {
						pInfo(currentPeer)->bans = {}, pInfo(currentPeer)->Account_Notes = {}, pInfo(currentPeer)->Alt_Accounts = {};
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage");
						p2.Insert(">> Removed account logs for user " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name));
						p2.CreatePacket(peer);
					}
				}
			}
		}
		else if (actual_command.substr(0, 6) == "/nuke ") {
			if (pInfo(peer)->supermod == 1 || pInfo(peer)->admin == 1) {
				if (world_->owner_name == pInfo(peer)->tankIDName) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("You can't ban your own world!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
					return;
				}
				if (not world_->nuked) {
					string substring = cmd;
					if (substring.find("  ") != std::string::npos) substring.replace(substring.find("  "), 2, " ");
					string delimiter = " ";
					size_t pos = 0;
					string D_Time, Reason = "";
					if ((pos = substring.find(delimiter)) != std::string::npos) substring.erase(0, pos + delimiter.length());
					else return;
					if ((pos = substring.find(delimiter)) != std::string::npos) D_Time = substring.substr(0, pos), substring.erase(0, pos + delimiter.length());
					else return;
					Reason = substring;
					int Time = atoi(D_Time.c_str());
					if (Reason == "") {
						gamepacket_t p;
						p.Insert("OnTalkBubble"); p.Insert(pInfo(peer)->netID);
						p.Insert("The reason can't be empty!"); p.Insert(0), p.Insert(1); p.CreatePacket(peer);
						return;
					}
					if (Time == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"); p.Insert(pInfo(peer)->netID);
						p.Insert("The time can't be zero!"); p.Insert(0), p.Insert(1); p.CreatePacket(peer);
						return;
					}
					bool has_admin = false;
					string cworld_ = pInfo(peer)->world, BannedBy_ = (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``", ban_who = "", admin_who = "";
					struct tm newtime;
					time_t now = time(0);
					localtime_s(&newtime, &now);
					world_->nuked = true;
					world_->n_t = "" + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + "/2023 " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec) + "";
					world_->n_b = (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``";
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert(">> `4" + world_->name + " was nuked from orbit``. It's the only way to be sure. Play nice, everybody!");
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == cworld_) {
							if (pInfo(currentPeer)->world == cworld_ and pInfo(currentPeer)->tankIDName != pInfo(peer)->tankIDName and to_lower(pInfo(currentPeer)->tankIDName) != to_lower(world_->owner_name)) {
								exit_(currentPeer);
							}
							if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(world_->owner_name) or pInfo(currentPeer)->tankIDName == world_->owner_name) {
								ban_who = (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``";
								add_ban(currentPeer, Time, Reason, BannedBy_);
							}
							else {
								ban_who = world_->owner_name;
								writelog(world_->owner_name + " Banned (" + Reason + ") - " + BannedBy_);
								string path_ = "database/players/" + world_->owner_name + "_.json";
								if (_access_s(path_.c_str(), 0) == 0) {
									json r_;
									ifstream f_(path_, ifstream::binary);
									if (f_.fail()) continue;
									f_ >> r_;
									f_.close();
									{
										json f_ = r_["b_t"].get<int>();
										r_["b_s"] = (Time * 1000);
										r_["b_r"] = Reason;
										r_["b_b"] = BannedBy_;
										r_["b_t"] = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									}
									{
										ofstream f_(path_, ifstream::binary);
										f_ << r_;
										f_.close();
									}
								}
							}
							if (find(world_->admins.begin(), world_->admins.end(), pInfo(currentPeer)->uid) == world_->admins.end() and pInfo(peer)->tankIDName != pInfo(currentPeer)->tankIDName) {
								add_ban(currentPeer, Time, Reason, BannedBy_);
								has_admin = true, admin_who = (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``";
							}
						}
						packet_(currentPeer, "action|play_sfx\nfile|audio/bigboom.wav\ndelayMS|0");
						p.CreatePacket(currentPeer);
					}
					Send_Mod_Logs2("(``" + BannedBy_ + "`^) in [```$" + cworld_ + "```^] > `^NUKED WORLD: `#" + cworld_);
					Send_Mod_Logs2("(``" + BannedBy_ + "`^) in [```$" + cworld_ + "```^] > `^BANNED (" + Reason + "): " + ban_who + "\n`4Time`` : `#" + ((Time / 86400 > 0) ? to_string(Time / 86400) + " days" : (Time / 3600 > 0) ? to_string(Time / 3600) + " hours" : (Time / 60 > 0) ? to_string(Time / 60) + " minutes" : to_string(Time) + " seconds"));
					if (has_admin) Send_Mod_Logs2("(``" + BannedBy_ + "`^) in [```$" + cworld_ + "```^] > `^BANNED (" + Reason + "): " + admin_who + "\n`4Time`` : `#" + ((Time / 86400 > 0) ? to_string(Time / 86400) + " days" : (Time / 3600 > 0) ? to_string(Time / 3600) + " hours" : (Time / 60 > 0) ? to_string(Time / 60) + " minutes" : to_string(Time) + " seconds"));
					return;
				}
				else {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("This world already nuked! You can unnuke first and ban this world!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
					return;
				}
			}
		}
		else if (actual_command.substr(0, 7) == "/punch " && pInfo(peer)->dev) {
			int punch = atoi(cmd.substr(7, cmd.length() - 7).c_str());
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (punch >= 0 && punch <= 260) {
				pInfo(peer)->punched = punch;
				p.Insert("`2Set punch effect to ID``: " + to_string(pInfo(peer)->punched) + " (set to `20`` to reset).");
			}
			else p.Insert("`2This punch effect does not exist only (0-260).");
			p.CreatePacket(peer);
			update_clothes(peer);
		}
		else if (actual_command.substr(0, 4) == "/gm " && pInfo(peer)->owner) {
			string text = cmd.substr(4, cmd.length() - 4).c_str();
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `o" + text + "``");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				packet_(currentPeer, "action|play_sfx\nfile|audio/sungate.wav\ndelayMS|0\n");
				p.CreatePacket(currentPeer);
			}
		}
		else if (actual_command.substr(0, 5) == "/msb " && pInfo(peer)->mod) {
			string text = cmd.substr(5, cmd.length() - 5).c_str();

			if (has_playmod(pInfo(peer), "duct tape")) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`6>> That's sort of hard to do while duct-taped.``");
				p.CreatePacket(peer);
				return;
			}
			if (has_playmod(pInfo(peer), "megaphone!")) {
				int time_ = 0;
				for (PlayMods peer_playmod : pInfo(peer)->playmods) {
					if (peer_playmod.id == 13) {
						time_ = peer_playmod.time - time(nullptr);
						break;
					}
				}
				packet_(peer, "action|log\nmsg|>> (" + Algorithm::to_playmod_time(time_) + "before you can broadcast again)", "");
				return;
			}
			int w_c = 0, s_c = 10000, net_ = 1, r_c = 0;
			if (pInfo(peer)->gems >= s_c) {
				pInfo(peer)->gems -= s_c;
				gamepacket_t p;
				p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(0), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
				if (pInfo(peer)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
				p.CreatePacket(peer);
				if (not pInfo(peer)->admin) {
					PlayMods new_playmod{};
					new_playmod.id = 13, new_playmod.time = time(nullptr) + (has_playmod(pInfo(peer), "boosted") ? 10 : 120);
					pInfo(peer)->playmods.push_back(new_playmod);
					{
						packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
						gamepacket_t p, p2;
						p.Insert("OnConsoleMessage"), p.Insert("Broadcasting to ALL! (`$Megaphone!`` mod added)"), p.CreatePacket(peer);
						p2.Insert("OnConsoleMessage"), p2.Insert("MOD-Broadcast sent. Used `$(`$" + setGems(s_c) + " Gems``. (`$" + setGems(pInfo(peer)->gems) + "`` left)`` (2 mins before you can broadcast again)"), p2.CreatePacket(peer);
					}
				}
			}
			else {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert(">> You don't have `$" + setGems(s_c) + " Gems``, you can't broadcast a message!"), p.CreatePacket(peer);
				return;
			}
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (pInfo(peer)->m_h != 1 and find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) {
					lastsbworld = pInfo(peer)->world;
				}
			}
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("CT:[FC]_>> `5>> [MOD-SB] from (`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "`````5) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```5] > ``" + (pInfo(peer)->dev ? "`5" : pInfo(peer)->mod ? "`^" : "`$") + "" + text + "``");
				//p.Insert("CT:[FC]_>> `5>> [MOD-SB] from (``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "```5) in [```$" + pInfo(peer)->world + "```5] > ```^" + text + "``");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio) continue;
					p.CreatePacket(currentPeer);
				}
			}
		}
		else if (actual_command.substr(0, 5) == "/ssb " && pInfo(peer)->dev == 1) {
			std::string contents = std::format("`4** `5DEVELOPER-SB`o from `0{} `4** `o: `{}{}", pInfo(peer)->name_color + pInfo(peer)->tankIDName, player::algorithm::get_chat_color(peer), cmd.substr(5));

			ENetPacket* packet = Variant{ "OnConsoleMessage" }.push(contents).pack();
			ENetPacket* packet2 = Variant{ "OnAddNotification" }.push("interface/atomic_button.rttex", contents, "audio/weird_hit.wav", 0).pack();

			pData::Algorithm::loop_players([&](ENetPeer* currentPeer) {
				enet_peer_send(currentPeer, 0, packet);
				enet_peer_send(currentPeer, 0, packet2);
			});
		}
		else if (actual_command.substr(0, 5) == "/vsb " && HasRole(pInfo(peer))) {
			string text = cmd.substr(5, cmd.length() - 5).c_str();

			if (has_playmod(pInfo(peer), "duct tape")) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`6>> That's sort of hard to do while duct-taped.``");
				p.CreatePacket(peer);
				return;
			}
		/*B	if (has_playmod(pInfo(peer), "megaphone!")) {
				int time_ = 0;
				for (PlayMods peer_playmod : pInfo(peer)->playmods) {
					if (peer_playmod.id == 13) {
						time_ = peer_playmod.time - time(nullptr);
						break;
					}
				}
				packet_(peer, "action|log\nmsg|>> (" + Algorithm::to_playmod_time(time_) + "before you can broadcast again)", "");
				return;
			} */
			int w_c = 0, s_c = 20000, net_ = 1, r_c = 0;
			if (pInfo(peer)->gems >= s_c) {
				pInfo(peer)->gems -= s_c;
				gamepacket_t p;
				p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(0), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
				if (pInfo(peer)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
				p.CreatePacket(peer);
				if (not pInfo(peer)->admin) {
					PlayMods new_playmod{};
					new_playmod.id = 13, new_playmod.time = time(nullptr) + (has_playmod(pInfo(peer), "Boosted") ? 10 : 120);
					pInfo(peer)->playmods.push_back(new_playmod);
					{
						packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
						gamepacket_t p, p2;
						p.Insert("OnConsoleMessage"), p.Insert("Broadcasting to ALL! (`$Megaphone!`` mod added)"), p.CreatePacket(peer);
						p2.Insert("OnConsoleMessage"), p2.Insert("VIP-Broadcast sent. Used `$(`$" + setGems(s_c) + " Gems``. (`$" + setGems(pInfo(peer)->gems) + "`` left)`` (2 mins before you can broadcast again)"), p2.CreatePacket(peer);
					}
				}
			}
			else {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert(">> You don't have `$" + setGems(s_c) + " Gems``, you can't broadcast a message!"), p.CreatePacket(peer);
				return;
			}
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (pInfo(peer)->m_h != 1 and find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) {
					lastsbworld = pInfo(peer)->world;
				}
			}
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("CT:[FC]_>> `1>> [VIP-SB] from (`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "`````1) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```5] > ``" + (pInfo(peer)->dev ? "`5" : pInfo(peer)->mod ? "`^" : pInfo(peer)->vip ? "`1" : "`$") + "" + text + "``");

				//p.Insert("CT:[FC]_>> `1>> [VIP-SB] from (``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "```1) in [```$" + pInfo(peer)->world + "```1] > ```1" + text + "``");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio) continue;
					p.CreatePacket(currentPeer);
				}
			}
		}
		else if (actual_command == "/report") {
			gamepacket_t p(500);
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wReport this world as a scam``|left|3732|\nadd_textbox|If this world is being used to scam or bully players, you can press `3Report`` to flag it for moderators to check.|left|\nadd_smalltext|- This feature is for reporting the `2world``, not the players. If the world is fine, but people are being inappropriate, send a /msg to a mod instead.|left|\nadd_smalltext|- We record who uses this feature. You will be banned if you file false reports.|left|\nadd_smalltext|- Reporting multiple times doesn't do anything - just report once, and the world will be on our list to check.|left|\nadd_smalltext|- There is no way to un-report, so don't report unless you are sure the world is bad!|left|\nadd_smalltext|- Provide a short 32 character description of why you are reporting the world below.|left|\nadd_text_input|report_reason|Reason:||32|\nadd_textbox|`1If you are sure you want to report this world as a scam, press Report below!``|left|\nend_dialog|worldreport|Cancel|Report|");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/time") {
			const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
			struct tm newtime;
			time_t now = time(0);
			localtime_s(&newtime, &now);
			string month = months[newtime.tm_mon];
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`2TayoPs Time (UTC/GMT+7): " + month + " " + to_string(newtime.tm_wday) + "th, " + (newtime.tm_hour < 10 ? "0" + to_string(newtime.tm_hour) + "" : "" + to_string(newtime.tm_hour) + "") + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min) + "") + ".");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/transferworld") {
			if (pInfo(peer)->staff == 1) {
				if (pInfo(peer)->world == "" or pInfo(peer)->world.empty()) return;
				world_->owner_name = pInfo(peer)->tankIDName;
				world_->owner_id = pInfo(peer)->uid;
				world_->owner_named = pInfo(peer)->modName;
				pInfo(peer)->worlds_owned.push_back(pInfo(peer)->world);
				string name_ = pInfo(peer)->world;
				vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (px != worlds.end()) {
					World* world_ = &worlds[px - worlds.begin()];
					update_world(peer, world_, pInfo(peer)->tankIDName, name_);
				}
				Algorithm::send_console(peer, "Modified world " + pInfo(peer)->world + " re-enter world to take effects.");
				Algorithm::log_text("UserLog", pInfo(peer)->tankIDName + " (#" + to_string(pInfo(peer)->id) + ") used transfer world in world: " + pInfo(peer)->world);
			}
			//else packet_(peer, "action|log\nmsg|`4Unknown command.``  Enter `$/?`` for a list of valid commands.");
		}
		/*
		
		*/
		else if (actual_command.substr(0, 5) == "/spk " && pInfo(peer)->owner) {
			/*if (pInfo(peer)->face == 13554) {
				if (!pInfo(peer)->sharingan_control) {
				    Algorithm::send_console(peer, "Please activate the ''Control Jutsu'' first");
				    return;
				} */
				vector<string> a_ = explode(" ", cmd);
				string name = a_[1].c_str(), text = cmd.substr(6 + name.length(), cmd.length() - 5).c_str(), world, a = "";
				gamepacket_t p, p2;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or get_role_level(peer) < get_role_level(currentPeer)) continue;
					if (to_lower(name) == to_lower(pInfo(currentPeer)->tankIDName)) {
						if (text[0] == '/') SendCmd(currentPeer, text);
						else
						{
							world = pInfo(currentPeer)->world;
							p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[W]_ `6<" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``>`` `$" + (has_playmod(pInfo(currentPeer), "Infected!") ? "`2" : "") + "" + (pInfo(currentPeer)->admin == 1 ? "`5" : (pInfo(currentPeer)->mod == 1) ? "`^" : "`$") + text + "`````");
							p2.Insert("OnTalkBubble"), p2.Insert(pInfo(currentPeer)->netID), p2.Insert("CP:_PL:0_OID:_player_chat=" + a + (pInfo(currentPeer)->dev == 1 ? "`5" : (pInfo(currentPeer)->mod == 1) ? "`^" : "`0") + text);
						}
					}
				}

				if (world != "") {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (world == pInfo(currentPeer)->world) p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
					}
				
			}
			else {
				Algorithm::send_console(peer, "Salah Command? Salah PAKE?!");
				return;
			}
			}
			
			
		else if (actual_command.substr(0, 6) == "/give " && pInfo(peer)->owner) {
			//if (pInfo(peer)->owner) return;
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() != 3) return;
			if (not isdigit(a_[1][0]) or not isdigit(a_[2][0])) return;
			int i_ = atoi(a_[1].c_str());
			int c_ = items[i_].blockType == FISH && atoi(a_[2].c_str()) > items[i_].fish_max_lb ? items[i_].fish_max_lb : atoi(a_[2].c_str());
			if (i_ <= 0 or c_ <= 0 or i_ >= items.size()) return;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (modify_inventory(peer, i_, c_) == -1) p.Insert("Failed to add inventory item");
			else
			{
				p.Insert("Collected `w" + to_string(items[i_].blockType == FISH && atoi(a_[2].c_str()) > items[i_].fish_max_lb ? items[i_].fish_max_lb : atoi(a_[2].c_str())) + " " + items[i_].name + "``." + (items[i_].rarity > 363 ? "" : " Rarity: `w" + to_string(items[i_].rarity) + "``") + "");
				PlayerMoving data_{};
				data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
				data_.packetType = 19, data_.plantingTree = 100;
				data_.punchX = i_, data_.punchY = pInfo(peer)->netID;
				int32_t to_netid = pInfo(peer)->netID;
				BYTE* raw = packPlayerMoving(&data_);
				raw[3] = 5;
				memcpy(raw + 8, &to_netid, 4);
				send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				delete[] raw;
			}
			p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 6) == "/drop " && pInfo(peer)->owner) {
			//if (pInfo(peer)->owner) return;
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() != 3) return;
			if (not isdigit(a_[1][0]) or not isdigit(a_[2][0])) return;
			int i_ = atoi(a_[1].c_str());
			int c_ = items[i_].blockType == FISH && atoi(a_[2].c_str()) > items[i_].fish_max_lb ? items[i_].fish_max_lb : atoi(a_[2].c_str());
			if (i_ <= 0 or c_ <= 0 or i_ >= items.size()) return;
			if (c_ <= 0 or c_ > 4000) {
				Algorithm::send_console(peer, "Max drops per tile are 4000.");
				return;
			}
			int rest = c_ % 200, div_200 = c_ / 200;
			if (c_ > 200) {
				for (int i = 0; i < div_200; i++) {
					WorldDrop drop_block_{};
					drop_block_.x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - ((rand() % 12) + 18) : pInfo(peer)->x + ((rand() % 12) + 22)), drop_block_.y = pInfo(peer)->y + rand() % 16, drop_block_.id = i_, drop_block_.count = c_ >= 200 ? 200 : c_, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
					dropas_(world_, drop_block_);
					c_ -= 200;
				}
				if (rest > 0) {
					WorldDrop drop_block_{};
					drop_block_.x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - ((rand() % 12) + 18) : pInfo(peer)->x + ((rand() % 12) + 22)), drop_block_.y = pInfo(peer)->y + rand() % 16, drop_block_.id = i_, drop_block_.count = rest, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
					dropas_(world_, drop_block_);
				}
			}
			else {
				WorldDrop drop_block_{};
				drop_block_.x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - ((rand() % 12) + 18) : pInfo(peer)->x + ((rand() % 12) + 22)), drop_block_.y = pInfo(peer)->y + rand() % 16, drop_block_.id = i_, drop_block_.count = c_, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
				dropas_(world_, drop_block_);
			}
		}
		else if (actual_command.substr(0, 4) == "/gc ") {
			if (pInfo(peer)->guild_id != 0) {
				if (has_playmod(pInfo(peer), "duct tape")) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`6>> That's sort of hard to do while duct-taped.``");
					p.CreatePacket(peer);
					return;
				}
				string text = cmd.substr(4, cmd.length() - 4).c_str();
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (pInfo(peer)->m_h != 1 and find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) {
					lastsbworld = pInfo(peer)->world;
				}
				int sentto = 0;
				p.Insert("CP:_PL:0_OID:_CT:[GL]_ `2Guildcast from (`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "`````2) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```2] ** : ``" + (pInfo(peer)->mod + pInfo(peer)->admin == 0 ? "`$" : "`^") + "" + text + "``");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio or pInfo(peer)->guild_id != pInfo(currentPeer)->guild_id) continue;
					packet_(currentPeer, "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0");
					p.CreatePacket(currentPeer);
				}
			}
			else Algorithm::send_console(peer, "You need guild to use this command");
		}
		else if (actual_command.substr(0, 4) == "/sb " || actual_command.substr(0, 4) == "/bc ") {
			if (pInfo(peer)->level < 20) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(" >> You must be level 20 to broadcast!");
				p.CreatePacket(peer);
			}
			else {
				if (has_playmod(pInfo(peer), "duct tape")) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`6>> That's sort of hard to do while duct-taped.``");
					p.CreatePacket(peer);
					return;
				}
				if (has_playmod(pInfo(peer), "megaphone!")) {
					int time_ = 0;
					for (PlayMods peer_playmod : pInfo(peer)->playmods) {
						if (peer_playmod.id == 13) {
							time_ = peer_playmod.time - time(nullptr);
							break;
						}
					}
					packet_(peer, "action|log\nmsg|>> (" + Algorithm::to_playmod_time(time_) + "before you can broadcast again)", "");
					return;
				}
				int w_c = 0, s_c = 30000, net_ = 1, r_c = 0;
				if (pInfo(peer)->gems >= s_c or pInfo(peer)->usedmegaphone) {
					int removemegaphone = -1, megacount = 0;
					if (pInfo(peer)->usedmegaphone == 0) {
						pInfo(peer)->gems -= s_c;
						gamepacket_t p;
						p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(0), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
						if (pInfo(peer)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
						p.CreatePacket(peer);
					}
					else {
						modify_inventory(peer, 2480, removemegaphone);
						modify_inventory(peer, 2480, megacount);
					}
					if (not pInfo(peer)->admin) {
						PlayMods new_playmod{};
						new_playmod.id = 13, new_playmod.time = time(nullptr) + (has_playmod(pInfo(peer), "Boosted") ? 10 : 300);
						pInfo(peer)->playmods.push_back(new_playmod);
						{
							packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
							gamepacket_t p, p2;
							p.Insert("OnConsoleMessage"), p.Insert("Broadcasting to ALL! (`$Megaphone!`` mod added)"), p.CreatePacket(peer);
							p2.Insert("OnConsoleMessage"), p2.Insert(a + "`#" + (actual_command.substr(0, 4) == "/sb " ? "Super-" : "") + "Broadcast sent. Used `$" + (pInfo(peer)->usedmegaphone ? "1 Megaphone``. (`$" + to_string(megacount) : setGems(s_c) + " Gems``. (`$" + setGems(pInfo(peer)->gems)) + "`` left)`` (5 mins before you can broadcast again)"), p2.CreatePacket(peer);
						}
					}
				}
				else {
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert(">> You don't have `$" + setGems(s_c) + " Gems``, you can't broadcast a message!"), p.CreatePacket(peer);
					return;
				}
				pInfo(peer)->usedmegaphone = 0;
				string text = cmd.substr(4, cmd.length() - 4).c_str();
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (pInfo(peer)->m_h != 1 and find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) {
					lastsbworld = pInfo(peer)->world;
				}
				int sentto = 0;
				if (actual_command.substr(0, 4) == "/sb ") p.Insert("CP:_PL:0_OID:_CT:[SB]_ `5** from (`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "`````5) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```5] ** : ``" + (pInfo(peer)->dev ? "`5" : pInfo(peer)->mod ? "`^" :"`$") + "" + text + "``");
				else p.Insert("CP:_PL:0_OID:_CT:[BC]_ `p** from (`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "`````p) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```p] ** : ``" + (pInfo(peer)->dev ? "`5" : pInfo(peer)->mod ? "`^" : "`$") + "" + text + "``");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio) continue;
					if (actual_command.substr(0, 4) == "/bc " && sentto > 100) continue;
					sentto++;
					packet_(currentPeer, "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0");
					p.CreatePacket(currentPeer);
				}
				// SB LOGS?
			}
		}
		
		else if (actual_command == "/march" || actual_command == "/dance" || actual_command == "/sad" || actual_command == "/wave" || actual_command == "/lol" || actual_command == "/love" || actual_command == "/sleep" || actual_command == "/wink" || actual_command == "/troll" || actual_command == "/cheer" || actual_command == "/fa" || actual_command == "/furious" || actual_command == "/dab" || actual_command == "/dance2" || actual_command == "/cheer" || actual_command == "/laugh" || actual_command == "/cry" || actual_command == "/mad" || actual_command == "/shower" || actual_command == "/rolleyes" || actual_command == "/omg" || actual_command == "/yes" || actual_command == "/idk" || actual_command == "/fold" || actual_command == "/no" || actual_command == "/sassy" || actual_command == "/fp" || actual_command == "/troll" || actual_command == "/facepalm" || actual_command == "/foldarms" || actual_command == "/stubborn" || actual_command == "/grumpy" || actual_command == "/shy" || actual_command == "/smh") {
			if (actual_command == "/cry") {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert(":'(");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
					p.CreatePacket(currentPeer);
				}
			}
			else {
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnAction");
				if (actual_command == "/fa" || actual_command == "/foldarms") actual_command = "/fold";
				p.Insert(actual_command);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						bool muted_ = false;
						for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
							if (pInfo(currentPeer)->friends[c_].uid == pInfo(peer)->uid) {
								if (pInfo(currentPeer)->friends[c_].mute) {
									muted_ = true;
									break;
								}
							}
						}
						if (not muted_) p.CreatePacket(currentPeer);
					}
				}
			}
		}
		else packet_(peer, "action|log\nmsg|`4Unknown command.``  Enter `$/?`` for a list of valid commands.");
	}
}
bool trade_space_check(ENetPeer* peer, ENetPeer* currentPeer) {
	int slots_needed = int(pInfo(currentPeer)->trade_items.size());
	for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
		map<string, int>::iterator it;
		for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
			int c_ = 0;
			modify_inventory(peer, it->first, c_);
			if (c_ != 0) {
				if (c_ + it->second > 200) {
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("`4Oops - " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` is carrying too many " + items[it->first].name + " and can't fit that many in their backpack.");
					p.CreatePacket(peer), p.CreatePacket(currentPeer);
					return false;
				}
				slots_needed--;
			}
		}
	}
	int free_slots = get_free_slots(pInfo(peer));
	if (free_slots < slots_needed) {
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert((pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` needs more backpack room first!");
		p.CreatePacket(peer), p.CreatePacket(currentPeer);
		return false;
	}
	return true;
}
int get_wls(ENetPeer* peer) {
	int my_wls = 0;
	int c_ = 0;
	modify_inventory(peer, 242, c_);
	my_wls += c_;
	c_ = 0;
	modify_inventory(peer, 1796, c_);
	my_wls += c_ * 100;
	return my_wls;
}
string get_sucker(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	if (block_->id == 0) {
		return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|`6The machine is empty.``|left|\nadd_item_picker|selectitem|`wChoose Item``|Choose an item to put in the " + items[block_->fg].name + "!|\nend_dialog|itemsucker_block|Close||";
	}
	bool ar_turi = false;
	int c_ = 0;
	if (block_->id != 0) {
		modify_inventory(peer, block_->id, c_);
		if (c_ != 0) {
			ar_turi = true;
		}
	}
	bool ar_turi_mag = false;
	{
		int c_ = 0;
		if (block_->id != 0) {
			modify_inventory(peer, 5640, c_);
			if (c_ != 0) {
				if (pInfo(peer)->magnetron_x == x_ and pInfo(peer)->magnetron_y == y_ and pInfo(peer)->magnetron_id == block_->id) {
					ar_turi_mag = true;
				}
			}
		}
	}
	bool dont_give = false;
	if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and items[block_->id].blockType != SEED and not items[block_->id].farmable or items[block_->id].rarity == 999) {
		dont_give = true;
	}
	string alalala = (block_->magnetron ? "`5ACTIVE" : "`6DISABLED");
	return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|" + (block_->pr == 0 ? "\nadd_textbox|`6The machine is currently empty!``|left|" : "\nadd_textbox|The machine contains " + to_string(block_->pr) + " `2" + items[block_->id].ori_name + "``|left|") + (ar_turi ? (block_->pr >= (block_->fg == 5638 ? (get_mag_size(pInfo(peer)->lock)) : (get_mag_size(pInfo(peer)->lock))) ? "\nadd_smalltext|`4The machine is at maximum capacity!``|left|" : "\nadd_button|additem|Add Items to the machine|noflags|0|0|") : (block_->pr >= (block_->fg == 5638 ? (get_mag_size(pInfo(peer)->lock)) : (pInfo(peer)->lock == 8470 ? 10000 : 5000)) ? "\nadd_smalltext|`4The machine is at maximum capacity!``|left|" : "")) + (block_->pr != 0 ? (c_ == 200 ? "\nadd_textbox|`6You are already carrying 200 " + items[block_->id].name + "!``|left|" : "\nadd_button|retrieveitem|Retrieve Item|noflags|0|0|") : "\nadd_button|clearitem|Change Item|noflags|0|0|") + (block_->fg == 5638 ? "\nadd_textbox|Building mode: " + alalala + "``|left|" : "") + (block_->fg == 5638 ? "\nadd_textbox|Use the " + items[5640].name + " to build `2" + items[block_->id].name + "`` directly from the " + items[block_->fg].name + "'s storage.|left|" : "") + (block_->fg == 5638 and not ar_turi_mag and not dont_give ? "\nadd_button|getplantationdevice|Get Remote|noflags|0|0|" : "") + "\nadd_checkbox|chk_enablesucking|Enable Collection.|" + (block_->enabled ? "1" : "0") + "\nend_dialog|itemsucker_block|Close|Update|";
}
bool not_mod(World* world_, WorldBlock block_, int x_, int y_) {
	if (x_ < 0 or x_ >= world_->width or y_ >= world_->height or y_ < 0 or block_.locked or items[block_.fg].blockType == LOCK) {
		return false;
	} if (block_.fg == 0) return true;
	if (items[block_.fg].properties & Property_Mod) {
		return false;
	}
	return true;
}
bool not_mod(int width, int height, WorldBlock block_, int x_, int y_) {
	if (x_ < 0 or x_ >= width or y_ >= height or y_ < 0 or block_.locked or items[block_.fg].blockType == LOCK) {
		return false;
	} if (block_.fg == 0) return true;
	if (items[block_.fg].properties & Property_Mod) {
		return false;
	}
	return true;
}
string get_buy_dialog(ENetPeer* peer, int item, int price, bool per_wl, bool last_dialog = false, int item_count = 0) {
	DialogBuilder db{ "`o" };
	
	if (!last_dialog) {
		db.add_label_icon(true, 6016, "`wTayoPs Buy System``")
			.add_spacer(false)
			.embed_data(true, "itemID", to_string(item))
			.add_label_icon(false, item, format("The machine contains a total of `6INFINITY `2{}``.", items[item].name))
			.add_spacer(false)
			.add_textbox("For a cost of: ")
			.add_label_icon(false, 112, (per_wl ? "1 x" : format("{} x", setGems(price))) + " `8Gems``")
			.add_spacer(false)
			.add_textbox("You will get: ")
			.add_label_icon(false, item, (per_wl ? format("{} x", price) : "1 x") + format(" `2{}``", items[item].name))
			.add_spacer(false)
			.add_textbox(format("You have {} Gems.", setGems(pInfo(peer)->gems)))
			.add_text_input(3, "input_wl_buy", "How many would you like to buy?")
			.end_dialog("item_purchase", "`wClose``", "`wBuy``");
	}
	else {
		db.add_label_icon(true, 6016, "`wPurchase Confirmation``")
			.add_spacer(false)
			.embed_data(true, "itemID", to_string(item))
			.embed_data(true, "itemCount", to_string(pInfo(peer)->expected_count))
			//.add_label_icon(false, item, format("The machine contains a total of `6INFINITY `2{}``.", items[item].name))
			.add_spacer(false)
			.add_textbox("`4You'll give: ``")
			.add_spacer(false)
			.add_label_icon(false, 112, (per_wl ? format("(`w{}``)", setGems(pInfo(peer)->expected_count / price)) : format("(`w{}``)", setGems(price * pInfo(peer)->expected_count))) + " `8Gems``")
			.add_spacer(false)
			.add_textbox("`2You'll get: ``")
			.add_spacer(false)
			.add_label_icon(false, item, format("(`w{}``)", pInfo(peer)->expected_count) + format(" `2{}``", items[item].name))
			.add_spacer(false)
			.add_textbox("Are you sure you want to make this purchase?")
			//.add_textbox(format("You have {} World Locks.", get_wls(peer)))
			//.add_text_input(3, "input_wl_buy", "How many would you like to buy?")
			.end_dialog("item_purchase_confirm", "`wCancel``", "`wOK``");
	}

	return db.to_string();
}
string get_vending(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	int c_ = 0;
	string ex_ = "";
	if (block_->id != 0) {
		modify_inventory(peer, block_->id, c_);
		if (c_ != 0 && block_->c_ < (block_->fg == 2978 ? 5199 : 9999)) ex_ = "\nadd_smalltext|You have " + to_string(c_) + " " + items[block_->id].ori_name + " in your backpack.|\nadd_button|addstock|Add them to the machine|noflags|0|0|";
	}
	string a_ = (block_->pr < 0 and (block_->pr * -1 > block_->c_) ? "\nadd_smalltext|`4(You need to add more items or people can't purchase at this price!)``|left|" : "");
	return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "" + (block_->id == 0 ? "\nadd_textbox|This machine is empty.|left|\nadd_item_picker|stockitem|`wPut an item in``|Choose an item to put in the machine!|" : "\nadd_label_with_icon|sml|The machine contains a total of " + to_string(block_->c_) + " `2" + items[block_->id].ori_name + +"``. |left|" + to_string(block_->id) + "|") + (block_->pr == 0 ? (block_->id != 0 ? "\nadd_spacer|small|\nadd_textbox|Not currently for sale!|left|\nadd_button|pullstock|Empty the machine|noflags|0|0|" : "") : "\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? "1" : to_string(block_->pr)) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? to_string(block_->pr * -1) : "1") + " x `2" + items[block_->id].ori_name + "``|left|" + to_string(block_->id) + "|\nadd_spacer|small|" + ex_ + "\nadd_button|pullstock|Empty the machine|noflags|0|0|") + (block_->id != 0 ? "" + a_ + "\nadd_smalltext|`5(" + items[block_->fg].name + " will not function when price is set to 0)``|left|\nadd_text_input|setprice|Price|" + (block_->pr < 0 ? to_string(block_->pr * -1) : to_string(block_->pr)) + "|5|\nadd_checkbox|chk_peritem|World Locks per Item|" + (block_->pr >= 0 ? "1" : "0") + "\nadd_checkbox|chk_perlock|Items per World Lock|" + (block_->pr < 0 ? "1" : "0") + "" : "") + (block_->wl != 0 ? "\nadd_smalltext|You have earned " + to_string(block_->wl) + " World Locks.|left|\nadd_button|withdraw|Withdraw World Locks|noflags|0|0|" : "") + "" + (block_->fg == 2978 ? "\nadd_smalltext|Upgrade to a DigiVend Machine for `44,000 Gems``.|left|\nadd_button|upgradedigital|Upgrade to DigiVend|noflags|0|0|" : "") + "\nadd_spacer|small|\nend_dialog|vending|Close|" + (block_->id != 0 ? "Update" : "") + "|";
}
string get_vending_buyer_side(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "" + (block_->id == 0 or block_->pr == 0 ? "\nadd_textbox|This machine is out of order.|left|\nend_dialog|vending|Close||" : "\nadd_label_with_icon|sml|The machine contains a total of " + to_string(block_->c_) + " `2" + items[block_->id].ori_name + "``. |left|" + to_string(block_->id) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? "1" : to_string(block_->pr)) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? to_string(block_->pr * -1) : "1") + " x `2" + items[block_->id].ori_name + "``|left|" + to_string(block_->id) + "|\nadd_spacer|small|" + (block_->pr < 0 and (block_->pr * -1 > block_->c_) ? "\nadd_textbox|You'll need to wait for the owner to stock up to at least 1 World Lock's worth before you can buy.|left|\nend_dialog|vending|Close||" : "\nadd_textbox|You have " + to_string(get_wls(peer)) + " World Locks.|left|\nadd_text_input|buycount|How many would you like to buy?|0|3|\nembed_data|expectprice|" + to_string(block_->pr) + "\nembed_data|expectitem|" + to_string(block_->id) + "\nend_dialog|vending|Close|Buy|"));
}
uint16_t get_weather_id(uint32_t block_id) {
	switch (block_id) {
	case 3694: {
		return 28;
	}
	case 3832: {
		return 29;
	}
	case 5000: {
		return 34;
	}
	case 5958: {
		return 40;
	}
	case 1490: {
		return 10;
	}
	case 934: {
		return 2;
	}
	case 946: {
		return 3;
	}
	case 932: {
		return 4;
	}
	case 984: {
		return 5;
	}
	case 1210: {
		return 8;
	}
	case 1364: {
		return 11;
	}
	case 1750: {
		return 15;
	}
	case 2046: {
		return 17;
	}
	case 2284: {
		return 18;
	}
	case 2744: {
		return 19;
	}
	case 3252: {
		return 20;
	}
	case 3446: {
		return 21;
	}
	case 3534: {
		return 22;
	}
	case 4242: {
		return 30;
	}
	case 4486: {
		return 31;
	}
	case 4776: {
		return 32;
	}
	case 4892: {
		return 33;
	}
	case 5112: {
		return 35;
	}
	case 5654: {
		return 36;
	}
	case 5716: {
		return 37;
	}
	case 6854: {
		return 42;
	}
	case 7644: {
		return 44;
	}
	case 12054: {
		return 60;
	}
	case 12056: {
		return 61;
	}
	case 8896: {
		return 47;
	}
	case 8836: {
		return 48;
	}
	case 10286: {
		return 51;
	}
	case 11880: {
		return 59;
	}
	case 12408: {
		return 62;
	}
	case 12844: {
		return 64;
	}
	case 13004: {
		return 65;
	}
	case 13070: {
		return 66;
	}
	}
	return 0;
}
bool is_false_state(WorldBlock block_, int t_) {
	if (items[block_.fg].collisionType == 0) return false;
	if (items[block_.fg].collisionType == 1) {
		return true;
	}
	if (block_.flags & t_) {
		return false;
	}
	return true;
}
void ApplyLock(ENetPeer* peer, World* world, int lock, int start_x, int start_y, bool reapply) {
	try
	{
		vector<CL_Vec2i> total;
		int size = lock == 202 ? 10 : lock == 204 ? 48 : 200;
		CL_Vec2i start_pos{ start_x, start_y };
		deque<CL_Vec2i> nodes{start_pos};
		CL_Vec2i door_pos = GetTilePos(MAIN_DOOR, world);
		auto door = GetTile(door_pos, world);
		auto door_bedrock = GetTile(door_pos.x, door_pos.y - 1, world);
		if (!door || !door_bedrock) return;

		int index = start_pos.x + start_pos.y * world->width;
		for (auto& tiles : world->blocks) {
			if (tiles.owner_id != 0 && tiles.locked && tiles.lock_origin == index) {
				tiles.owner_id = 0;
				tiles.lock_origin = -1;
				tiles.locked = false;
			}
		}

		while (nodes.size() <= size) {
			deque<CL_Vec2i> temp;
			for (const auto& node : nodes) {
				vector<CL_Vec2i> neighbours; 
				if (!reapply) {
					if (lock == 202 && node.x == door_pos.x && node.y + 1 == door_pos.y) {
						if (node.x + 1 < world->width) // Right
							neighbours.push_back({ node.x + 1, node.y });
						if (node.x + 2 < world->width) // Right
							neighbours.push_back({ node.x + 2, node.y });

						if (node.x - 1 >= 0) // Left
							neighbours.push_back({ node.x - 1, node.y });
						if (node.x - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y });

						if (node.x + 1 < world->width && node.y + 1 < world->height) // Below
							neighbours.push_back({ node.x + 1, node.y + 1 });
						if (node.x - 1 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 1 });

						if (node.x + 1 < world->width && node.y - 1 >= 0) // Top
							neighbours.push_back({ node.x + 1, node.y - 1 });
						if (node.y - 1 >= 0)
							neighbours.push_back({ node.x, node.y - 1 });
						if (node.y - 2 >= 0)
							neighbours.push_back({ node.x, node.y - 2 });
						if (node.x - 1 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 1 });
					}
					else if (lock == 202) {
						if (node.x + 1 < world->width) // Right
							neighbours.push_back({ node.x + 1, node.y });

						if (node.x - 1 >= 0) // Left
							neighbours.push_back({ node.x - 1, node.y });
						if (node.x - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y });

						if (node.x + 1 < world->width && node.y + 1 < world->height) // Bottom
							neighbours.push_back({ node.x + 1, node.y + 1 });
						if (node.y + 1)
							neighbours.push_back({ node.x, node.y + 1 });
						if (node.x - 1 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 1 });

						if (node.x + 1 < world->width && node.y - 1 >= 0) // Top
							neighbours.push_back({ node.x + 1, node.y - 1 });
						if (node.y - 1 >= 0)
							neighbours.push_back({ node.x, node.y - 1 });
						if (node.y - 2 >= 0)
							neighbours.push_back({ node.x, node.y - 2 });
						if (node.x - 1 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 1 }); 
					}
					else if (lock == 204 && node.x == door_pos.x && node.y + 1 == door_pos.y) {
						if (node.x - 1 >= 0) // Left
							neighbours.push_back({ node.x - 1, node.y });
						if (node.x - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y });
						if (node.x - 3 >= 0)
							neighbours.push_back({ node.x - 3, node.y });
						if (node.x - 4 >= 0)
							neighbours.push_back({ node.x - 4, node.y });

						if (node.x + 1 < world->width) // Right
							neighbours.push_back({ node.x + 1, node.y });
						if (node.x + 2 < world->width)
							neighbours.push_back({ node.x + 2, node.y });
						if (node.x + 3 < world->width)
							neighbours.push_back({ node.x + 3, node.y });

						if (node.y + 3 < world->height) //buttom
							neighbours.push_back({ node.x, node.y + 3 });

						if (node.x - 1 >= 0 && node.y + 1 < world->height) // Bottom  Left
							neighbours.push_back({ node.x - 1, node.y + 1 });
						if (node.x - 2 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 1 });
						if (node.x - 3 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 1 });

						if (node.x - 1 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 2 });
						if (node.x - 2 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 2 });
						if (node.x - 3 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 2 });

						if (node.x - 1 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 3 });
						if (node.x - 2 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 3 });
						if (node.x - 3 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 3 });

						if (node.x + 1 < world->width && node.y + 1 < world->height) // Bottom  Right
							neighbours.push_back({ node.x + 1, node.y + 1 });
						if (node.x + 2 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 1 });
						if (node.x + 3 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 1 });

						if (node.x + 1 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 2 });
						if (node.x + 2 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 2 });
						if (node.x + 3 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 2 });

						if (node.x + 1 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 3 });
						if (node.x + 2 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 3 });
						if (node.x + 3 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 3 });

						if (node.x - 1 >= 0 && node.y - 1 >= 0) // Top  Left
							neighbours.push_back({ node.x - 1, node.y - 1 });
						if (node.x - 2 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 1 });
						if (node.x - 3 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 1 });

						if (node.x - 1 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 2 });
						if (node.x - 2 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 2 });
						if (node.x - 3 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 2 });

						if (node.x - 1 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 3 });
						if (node.x - 2 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 3 });
						if (node.x - 3 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 3 });

						if (node.x + 1 < world->width && node.y - 1 >= 0) // Top  Right
							neighbours.push_back({ node.x + 1, node.y - 1 });
						if (node.x + 2 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 1 });
						if (node.x + 3 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 1 });

						if (node.x + 1 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 2 });
						if (node.x + 2 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 2 });
						if (node.x + 3 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 2 });

						if (node.x + 1 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 3 });
						if (node.x + 2 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 3 });
						if (node.x + 3 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 3 });

						if (node.y - 1 >= 0) // Top
							neighbours.push_back({ node.x, node.y - 1 });
						if (node.y - 2 >= 0)
							neighbours.push_back({ node.x, node.y - 2 });
						if (node.y - 3 >= 0)
							neighbours.push_back({ node.x, node.y - 3 });
						if (node.y - 4 >= 0)
							neighbours.push_back({ node.x, node.y - 4 });
					}
					else if (lock == 204) {
						if (node.x - 1 >= 0) // Left
							neighbours.push_back({ node.x - 1, node.y });
						if (node.x - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y });
						if (node.x - 3 >= 0)
							neighbours.push_back({ node.x - 3, node.y });

						if (node.x + 1 < world->width) // Right
							neighbours.push_back({ node.x + 1, node.y });
						if (node.x + 2 < world->width)
							neighbours.push_back({ node.x + 2, node.y });
						if (node.x + 3 < world->width)
							neighbours.push_back({ node.x + 3, node.y });

						if (node.y + 1 < world->height) // Bottom
							neighbours.push_back({ node.x, node.y + 1 });
						if (node.y + 2 < world->height)
							neighbours.push_back({ node.x, node.y + 2 });
						if (node.y + 3 < world->height)
							neighbours.push_back({ node.x, node.y + 3 });

						if (node.x - 1 >= 0 && node.y + 1 < world->height) // Bottom  Left
							neighbours.push_back({ node.x - 1, node.y + 1 });
						if (node.x - 2 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 1 });
						if (node.x - 3 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 1 });

						if (node.x - 1 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 2 });
						if (node.x - 2 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 2 });
						if (node.x - 3 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 2 });

						if (node.x - 1 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 3 });
						if (node.x - 2 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 3 });
						if (node.x - 3 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 3 });

						if (node.x + 1 < world->width && node.y + 1 < world->height) // Bottom  Right
							neighbours.push_back({ node.x + 1, node.y + 1 });
						if (node.x + 2 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 1 });
						if (node.x + 3 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 1 });

						if (node.x + 1 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 2 });
						if (node.x + 2 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 2 });
						if (node.x + 3 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 2 });

						if (node.x + 1 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 3 });
						if (node.x + 2 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 3 });
						if (node.x + 3 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 3 });

						if (node.x - 1 >= 0 && node.y - 1 >= 0) // Top  Left
							neighbours.push_back({ node.x - 1, node.y - 1 });
						if (node.x - 2 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 1 });
						if (node.x - 3 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 1 });

						if (node.x - 1 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 2 });
						if (node.x - 2 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 2 });
						if (node.x - 3 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 2 });

						if (node.x - 1 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 3 });
						if (node.x - 2 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 3 });
						if (node.x - 3 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 3 });

						if (node.x + 1 < world->width && node.y - 1 >= 0) // Top  Right
							neighbours.push_back({ node.x + 1, node.y - 1 });
						if (node.x + 2 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 1 });
						if (node.x + 3 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 1 });

						if (node.x + 1 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 2 });
						if (node.x + 2 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 2 });
						if (node.x + 3 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 2 });

						if (node.x + 1 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 3 });
						if (node.x + 2 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 3 });
						if (node.x + 3 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 3 });

						if (node.y - 1 >= 0) // Top
							neighbours.push_back({ node.x, node.y - 1 });
						if (node.y - 2 >= 0)
							neighbours.push_back({ node.x, node.y - 2 });
						if (node.y - 3 >= 0)
							neighbours.push_back({ node.x, node.y - 3 });
					}
					else if ((lock == 206 || lock == 4994) && node.x == door_pos.x && node.y + 1 == door_pos.y) {
						if (node.x - 1 >= 0) // Left
							neighbours.push_back({ node.x - 1, node.y });
						if (node.x - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y });
						if (node.x - 3 >= 0)
							neighbours.push_back({ node.x - 3, node.y });
						if (node.x - 4 >= 0)
							neighbours.push_back({ node.x - 4, node.y });
						if (node.x - 5 >= 0)
							neighbours.push_back({ node.x - 5, node.y });
						if (node.x - 6 >= 0)
							neighbours.push_back({ node.x - 6, node.y });
						if (node.x - 7 >= 0)
							neighbours.push_back({ node.x - 7, node.y });

						if (node.x + 1 < world->width) // Right
							neighbours.push_back({ node.x + 1, node.y });
						if (node.x + 2 < world->width)
							neighbours.push_back({ node.x + 2, node.y });
						if (node.x + 3 < world->width)
							neighbours.push_back({ node.x + 3, node.y });
						if (node.x + 4 < world->width)
							neighbours.push_back({ node.x + 4, node.y });
						if (node.x + 5 < world->width)
							neighbours.push_back({ node.x + 5, node.y });
						if (node.x + 6 < world->width)
							neighbours.push_back({ node.x + 6, node.y });
						if (node.x + 7 < world->width)
							neighbours.push_back({ node.x + 7, node.y });

						if (node.y + 1 < world->height) // Bottom
							neighbours.push_back({ node.x, node.y + 1 });
						if (node.y + 2 < world->height)
							neighbours.push_back({ node.x, node.y + 2 });
						if (node.y + 3 < world->height)
							neighbours.push_back({ node.x, node.y + 3 });
						if (node.y + 4 < world->height)
							neighbours.push_back({ node.x, node.y + 4 });
						if (node.y + 5 < world->height)
							neighbours.push_back({ node.x, node.y + 5 });
						if (node.y + 6 < world->height)
							neighbours.push_back({ node.x, node.y + 6 });
						if (node.y + 7 < world->height)
							neighbours.push_back({ node.x, node.y + 7 });

						if (node.y - 1 >= 0) // Top
							neighbours.push_back({ node.x, node.y - 1 });
						if (node.y - 2 >= 0)
							neighbours.push_back({ node.x, node.y - 2 });
						if (node.y - 3 >= 0)
							neighbours.push_back({ node.x, node.y - 3 });
						if (node.y - 4 >= 0)
							neighbours.push_back({ node.x, node.y - 4 });
						if (node.y - 5 >= 0)
							neighbours.push_back({ node.x, node.y - 5 });
						if (node.y - 6 >= 0)
							neighbours.push_back({ node.x, node.y - 6 });
						if (node.y - 7 >= 0)
							neighbours.push_back({ node.x, node.y - 7 });

						if (node.x + 1 < world->width && node.y - 1 >= 0) // Top Right
							neighbours.push_back({ node.x + 1, node.y - 1 });
						if (node.x + 1 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 2 });
						if (node.x + 1 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 3 });
						if (node.x + 1 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 4 });
						if (node.x + 1 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 5 });
						if (node.x + 1 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 6 });
						if (node.x + 1 < world->width && node.y - 7 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 7 });
						if (node.x + 1 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 1 });

						if (node.x + 2 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 1 });
						if (node.x + 2 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 2 });
						if (node.x + 2 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 3 });
						if (node.x + 2 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 4 });
						if (node.x + 2 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 5 });
						if (node.x + 2 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 6 });
						if (node.x + 2 < world->width && node.y - 7 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 7 });

						if (node.x + 3 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 1 });
						if (node.x + 3 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 2 });
						if (node.x + 3 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 3 });
						if (node.x + 3 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 4 });
						if (node.x + 3 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 5 });
						if (node.x + 3 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 6 });
						if (node.x + 3 < world->width && node.y - 7 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 7 });

						if (node.x + 4 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 1 });
						if (node.x + 4 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 2 });
						if (node.x + 4 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 3 });
						if (node.x + 4 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 4 });
						if (node.x + 4 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 5 });
						if (node.x + 4 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 6 });
						if (node.x + 4 < world->width && node.y - 7 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 7 });

						if (node.x + 5 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 1 });
						if (node.x + 5 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 2 });
						if (node.x + 5 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 3 });
						if (node.x + 5 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 4 });
						if (node.x + 5 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 5 });
						if (node.x + 5 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 6 });

						if (node.x + 6 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 1 });
						if (node.x + 6 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 2 });
						if (node.x + 6 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 3 });
						if (node.x + 6 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 4 });
						if (node.x + 6 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 5 });
						if (node.x + 6 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 6 });

						if (node.x + 7 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 7, node.y - 1 });
						if (node.x + 7 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 7, node.y - 2 });
						if (node.x + 7 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 7, node.y - 3 });

						if (node.x + 1 < world->width && node.y + 1 < world->height) // Bottom Right
							neighbours.push_back({ node.x + 1, node.y + 1 });
						if (node.x + 1 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 2 });
						if (node.x + 1 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 3 });
						if (node.x + 1 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 4 });
						if (node.x + 1 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 5 });
						if (node.x + 1 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 6 });
						if (node.x + 1 < world->width && node.y + 7 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 7 });
						if (node.x + 1 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 1 });

						if (node.x + 2 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 1 });
						if (node.x + 2 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 2 });
						if (node.x + 2 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 3 });
						if (node.x + 2 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 4 });
						if (node.x + 2 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 5 });
						if (node.x + 2 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 6 });
						if (node.x + 2 < world->width && node.y + 7 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 7 });

						if (node.x + 3 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 1 });
						if (node.x + 3 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 2 });
						if (node.x + 3 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 3 });
						if (node.x + 3 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 4 });
						if (node.x + 3 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 5 });
						if (node.x + 3 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 6 });
						if (node.x + 3 < world->width && node.y + 7 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 7 });

						if (node.x + 4 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 1 });
						if (node.x + 4 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 2 });
						if (node.x + 4 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 3 });
						if (node.x + 4 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 4 });
						if (node.x + 4 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 5 });
						if (node.x + 4 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 6 });
						if (node.x + 4 < world->width && node.y + 7 >= 0)
							neighbours.push_back({ node.x + 4, node.y + 7 });

						if (node.x + 5 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 1 });
						if (node.x + 5 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 2 });
						if (node.x + 5 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 3 });
						if (node.x + 5 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 4 });
						if (node.x + 5 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 5 });
						if (node.x + 5 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 6 });

						if (node.x + 6 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 1 });
						if (node.x + 6 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 2 });
						if (node.x + 6 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 3 });
						if (node.x + 6 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 4 });
						if (node.x + 6 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 5 });
						if (node.x + 6 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 6 });

						if (node.x + 7 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 7, node.y + 1 });
						if (node.x + 7 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 7, node.y + 2 });
						if (node.x + 7 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 7, node.y + 3 });

						if (node.x - 1 >= 0 && node.y + 1 < world->height) // Bottom Left
							neighbours.push_back({ node.x - 1, node.y + 1 });
						if (node.x - 1 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 2 });
						if (node.x - 1 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 3 });
						if (node.x - 1 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 4 });
						if (node.x - 1 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 5 });
						if (node.x - 1 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 6 });
						if (node.x - 1 >= 0 && node.y + 7 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 7 });

						if (node.x - 2 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 1 });
						if (node.x - 2 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 2 });
						if (node.x - 2 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 3 });
						if (node.x - 2 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 4 });
						if (node.x - 2 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 5 });
						if (node.x - 2 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 6 });
						if (node.x - 2 >= 0 && node.y + 7 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 7 });

						if (node.x - 3 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 1 });
						if (node.x - 3 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 2 });
						if (node.x - 3 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 3 });
						if (node.x - 3 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 4 });
						if (node.x - 3 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 5 });
						if (node.x - 3 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 6 });
						if (node.x - 3 >= 0 && node.y + 7 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 7 });

						if (node.x - 4 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 1 });
						if (node.x - 4 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 2 });
						if (node.x - 4 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 3 });
						if (node.x - 4 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 4 });
						if (node.x - 4 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 5 });
						if (node.x - 4 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 6 });
						if (node.x - 4 >= 0 && node.y + 7 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 7 });

						if (node.x - 5 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 1 });
						if (node.x - 5 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 2 });
						if (node.x - 5 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 3 });
						if (node.x - 5 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 4 });
						if (node.x - 5 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 5 });
						if (node.x - 5 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 6 });

						if (node.x - 6 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 1 });
						if (node.x - 6 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 2 });
						if (node.x - 6 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 3 });
						if (node.x - 6 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 4 });
						if (node.x - 6 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 5 });
						if (node.x - 6 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 6 });

						if (node.x - 7 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 7, node.y + 1 });
						if (node.x - 7 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 7, node.y + 2 });
						if (node.x - 7 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 7, node.y + 3 });
						if (node.x - 7 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 7, node.y + 4 });

						if (node.x - 1 >= 0 && node.y - 1 >= 0) // Bottom Left
							neighbours.push_back({ node.x - 1, node.y - 1 });
						if (node.x - 1 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 2 });
						if (node.x - 1 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 3 });
						if (node.x - 1 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 4 });
						if (node.x - 1 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 5 });
						if (node.x - 1 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 6 });
						if (node.x - 1 >= 0 && node.y - 7 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 7 });

						if (node.x - 2 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 1 });
						if (node.x - 2 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 2 });
						if (node.x - 2 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 3 });
						if (node.x - 2 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 4 });
						if (node.x - 2 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 5 });
						if (node.x - 2 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 6 });
						if (node.x - 2 >= 0 && node.y - 7 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 7 });

						if (node.x - 3 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 1 });
						if (node.x - 3 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 2 });
						if (node.x - 3 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 3 });
						if (node.x - 3 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 4 });
						if (node.x - 3 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 5 });
						if (node.x - 3 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 6 });
						if (node.x - 3 >= 0 && node.y - 7 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 7 });

						if (node.x - 4 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 1 });
						if (node.x - 4 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 2 });
						if (node.x - 4 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 3 });
						if (node.x - 4 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 4 });
						if (node.x - 4 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 5 });
						if (node.x - 4 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 6 });
						if (node.x - 4 >= 0 && node.y - 7 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 7 });

						if (node.x - 5 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 1 });
						if (node.x - 5 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 2 });
						if (node.x - 5 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 3 });
						if (node.x - 5 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 4 });
						if (node.x - 5 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 5 });
						if (node.x - 5 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 6 });

						if (node.x - 6 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 1 });
						if (node.x - 6 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 2 });
						if (node.x - 6 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 3 });
						if (node.x - 6 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 4 });
						if (node.x - 6 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 5 });
						if (node.x - 6 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 6 });

						if (node.x - 7 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 7, node.y - 1 });
						if (node.x - 7 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 7, node.y - 2 });
						if (node.x - 7 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 7, node.y - 3 });
						if (node.x - 7 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 7, node.y - 4 });
					}
					else if (lock == 206 || lock == 4994) {
						if (node.x - 1 >= 0) // Left
							neighbours.push_back({ node.x - 1, node.y });
						if (node.x - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y });
						if (node.x - 3 >= 0)
							neighbours.push_back({ node.x - 3, node.y });
						if (node.x - 4 >= 0)
							neighbours.push_back({ node.x - 4, node.y });
						if (node.x - 5 >= 0)
							neighbours.push_back({ node.x - 5, node.y });
						if (node.x - 6 >= 0)
							neighbours.push_back({ node.x - 6, node.y });
						if (node.x - 7 >= 0)
							neighbours.push_back({ node.x - 7, node.y });

						if (node.x + 1 < world->width) // Right
							neighbours.push_back({ node.x + 1, node.y });
						if (node.x + 2 < world->width)
							neighbours.push_back({ node.x + 2, node.y });
						if (node.x + 3 < world->width)
							neighbours.push_back({ node.x + 3, node.y });
						if (node.x + 4 < world->width)
							neighbours.push_back({ node.x + 4, node.y });
						if (node.x + 5 < world->width)
							neighbours.push_back({ node.x + 5, node.y });
						if (node.x + 6 < world->width)
							neighbours.push_back({ node.x + 6, node.y });
						if (node.x + 7 < world->width)
							neighbours.push_back({ node.x + 7, node.y });


						if (node.y + 1 < world->height) // Bottom
							neighbours.push_back({ node.x, node.y + 1 });
						if (node.y + 2 < world->height)
							neighbours.push_back({ node.x, node.y + 2 });
						if (node.y + 3 < world->height)
							neighbours.push_back({ node.x, node.y + 3 });
						if (node.y + 4 < world->height)
							neighbours.push_back({ node.x, node.y + 4 });
						if (node.y + 5 < world->height)
							neighbours.push_back({ node.x, node.y + 5 });
						if (node.y + 6 < world->height)
							neighbours.push_back({ node.x, node.y + 6 });
						if (node.y + 7 < world->height)
							neighbours.push_back({ node.x, node.y + 7 });

						if (node.y - 1 >= 0) // Top
							neighbours.push_back({ node.x, node.y - 1 });
						if (node.y - 2 >= 0)
							neighbours.push_back({ node.x, node.y - 2 });
						if (node.y - 3 >= 0)
							neighbours.push_back({ node.x, node.y - 3 });
						if (node.y - 4 >= 0)
							neighbours.push_back({ node.x, node.y - 4 });
						if (node.y - 5 >= 0)
							neighbours.push_back({ node.x, node.y - 5 });
						if (node.y - 6 >= 0)
							neighbours.push_back({ node.x, node.y - 6 });
						if (node.y - 7 >= 0)
							neighbours.push_back({ node.x, node.y - 7 });

						if (node.x + 1 < world->width && node.y - 1 >= 0) // Top Right
							neighbours.push_back({ node.x + 1, node.y - 1 });
						if (node.x + 1 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 2 });
						if (node.x + 1 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 3 });
						if (node.x + 1 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 4 });
						if (node.x + 1 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 5 });
						if (node.x + 1 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 6 });
						if (node.x + 1 < world->width && node.y - 7 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 7 });
						if (node.x + 1 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 1, node.y - 1 });

						if (node.x + 2 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 1 });
						if (node.x + 2 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 2 });
						if (node.x + 2 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 3 });
						if (node.x + 2 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 4 });
						if (node.x + 2 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 5 });
						if (node.x + 2 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 6 });
						if (node.x + 2 < world->width && node.y - 7 >= 0)
							neighbours.push_back({ node.x + 2, node.y - 7 });

						if (node.x + 3 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 1 });
						if (node.x + 3 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 2 });
						if (node.x + 3 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 3 });
						if (node.x + 3 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 4 });
						if (node.x + 3 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 5 });
						if (node.x + 3 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 6 });
						if (node.x + 3 < world->width && node.y - 7 >= 0)
							neighbours.push_back({ node.x + 3, node.y - 7 });

						if (node.x + 4 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 1 });
						if (node.x + 4 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 2 });
						if (node.x + 4 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 3 });
						if (node.x + 4 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 4 });
						if (node.x + 4 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 5 });
						if (node.x + 4 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 4, node.y - 6 });

						if (node.x + 5 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 1 });
						if (node.x + 5 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 2 });
						if (node.x + 5 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 3 });
						if (node.x + 5 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 4 });
						if (node.x + 5 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 5 });
						if (node.x + 5 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 5, node.y - 6 });

						if (node.x + 6 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 1 });
						if (node.x + 6 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 2 });
						if (node.x + 6 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 3 });
						if (node.x + 6 < world->width && node.y - 4 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 4 });
						if (node.x + 6 < world->width && node.y - 5 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 5 });
						if (node.x + 6 < world->width && node.y - 6 >= 0)
							neighbours.push_back({ node.x + 6, node.y - 6 });

						if (node.x + 7 < world->width && node.y - 1 >= 0)
							neighbours.push_back({ node.x + 7, node.y - 1 });
						if (node.x + 7 < world->width && node.y - 2 >= 0)
							neighbours.push_back({ node.x + 7, node.y - 2 });
						if (node.x + 7 < world->width && node.y - 3 >= 0)
							neighbours.push_back({ node.x + 7, node.y - 3 });

						if (node.x + 1 < world->width && node.y + 1 < world->height) // Bottom Right
							neighbours.push_back({ node.x + 1, node.y + 1 });
						if (node.x + 1 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 2 });
						if (node.x + 1 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 3 });
						if (node.x + 1 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 4 });
						if (node.x + 1 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 5 });
						if (node.x + 1 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 6 });
						if (node.x + 1 < world->width && node.y + 7 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 7 });
						if (node.x + 1 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 1, node.y + 1 });

						if (node.x + 2 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 1 });
						if (node.x + 2 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 2 });
						if (node.x + 2 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 3 });
						if (node.x + 2 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 4 });
						if (node.x + 2 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 5 });
						if (node.x + 2 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 6 });
						if (node.x + 2 < world->width && node.y + 7 < world->height)
							neighbours.push_back({ node.x + 2, node.y + 7 });

						if (node.x + 3 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 1 });
						if (node.x + 3 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 2 });
						if (node.x + 3 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 3 });
						if (node.x + 3 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 4 });
						if (node.x + 3 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 5 });
						if (node.x + 3 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 6 });
						if (node.x + 3 < world->width && node.y + 7 < world->height)
							neighbours.push_back({ node.x + 3, node.y + 7 });

						if (node.x + 4 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 1 });
						if (node.x + 4 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 2 });
						if (node.x + 4 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 3 });
						if (node.x + 4 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 4 });
						if (node.x + 4 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 5 });
						if (node.x + 4 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 4, node.y + 6 });

						if (node.x + 5 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 1 });
						if (node.x + 5 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 2 });
						if (node.x + 5 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 3 });
						if (node.x + 5 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 4 });
						if (node.x + 5 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 5 });
						if (node.x + 5 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 5, node.y + 6 });

						if (node.x + 6 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 1 });
						if (node.x + 6 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 2 });
						if (node.x + 6 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 3 });
						if (node.x + 6 < world->width && node.y + 4 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 4 });
						if (node.x + 6 < world->width && node.y + 5 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 5 });
						if (node.x + 6 < world->width && node.y + 6 < world->height)
							neighbours.push_back({ node.x + 6, node.y + 6 });

						if (node.x + 7 < world->width && node.y + 1 < world->height)
							neighbours.push_back({ node.x + 7, node.y + 1 });
						if (node.x + 7 < world->width && node.y + 2 < world->height)
							neighbours.push_back({ node.x + 7, node.y + 2 });
						if (node.x + 7 < world->width && node.y + 3 < world->height)
							neighbours.push_back({ node.x + 7, node.y + 3 });

						if (node.x - 1 >= 0 && node.y + 1 < world->height) // Bottom Left
							neighbours.push_back({ node.x - 1, node.y + 1 });
						if (node.x - 1 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 2 });
						if (node.x - 1 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 3 });
						if (node.x - 1 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 4 });
						if (node.x - 1 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 5 });
						if (node.x - 1 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 6 });
						if (node.x - 1 >= 0 && node.y + 7 < world->height)
							neighbours.push_back({ node.x - 1, node.y + 7 });

						if (node.x - 2 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 1 });
						if (node.x - 2 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 2 });
						if (node.x - 2 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 3 });
						if (node.x - 2 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 4 });
						if (node.x - 2 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 5 });
						if (node.x - 2 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 6 });
						if (node.x - 2 >= 0 && node.y + 7 < world->height)
							neighbours.push_back({ node.x - 2, node.y + 7 });

						if (node.x - 3 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 1 });
						if (node.x - 3 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 2 });
						if (node.x - 3 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 3 });
						if (node.x - 3 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 4 });
						if (node.x - 3 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 5 });
						if (node.x - 3 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 6 });
						if (node.x - 3 >= 0 && node.y + 7 < world->height)
							neighbours.push_back({ node.x - 3, node.y + 7 });

						if (node.x - 4 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 1 });
						if (node.x - 4 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 2 });
						if (node.x - 4 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 3 });
						if (node.x - 4 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 4 });
						if (node.x - 4 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 5 });
						if (node.x - 4 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 6 });
						if (node.x - 4 >= 0 && node.y + 7 < world->height)
							neighbours.push_back({ node.x - 4, node.y + 7 });

						if (node.x - 5 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 1 });
						if (node.x - 5 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 2 });
						if (node.x - 5 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 3 });
						if (node.x - 5 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 4 });
						if (node.x - 5 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 5 });
						if (node.x - 5 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 5, node.y + 6 });

						if (node.x - 6 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 1 });
						if (node.x - 6 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 2 });
						if (node.x - 6 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 3 });
						if (node.x - 6 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 4 });
						if (node.x - 6 >= 0 && node.y + 5 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 5 });
						if (node.x - 6 >= 0 && node.y + 6 < world->height)
							neighbours.push_back({ node.x - 6, node.y + 6 });

						if (node.x - 7 >= 0 && node.y + 1 < world->height)
							neighbours.push_back({ node.x - 7, node.y + 1 });
						if (node.x - 7 >= 0 && node.y + 2 < world->height)
							neighbours.push_back({ node.x - 7, node.y + 2 });
						if (node.x - 7 >= 0 && node.y + 3 < world->height)
							neighbours.push_back({ node.x - 7, node.y + 3 });
						if (node.x - 7 >= 0 && node.y + 4 < world->height)
							neighbours.push_back({ node.x - 7, node.y + 4 });

						if (node.x - 1 >= 0 && node.y - 1 >= 0) // Bottom Left
							neighbours.push_back({ node.x - 1, node.y - 1 });
						if (node.x - 1 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 2 });
						if (node.x - 1 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 3 });
						if (node.x - 1 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 4 });
						if (node.x - 1 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 5 });
						if (node.x - 1 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 6 });
						if (node.x - 1 >= 0 && node.y - 7 >= 0)
							neighbours.push_back({ node.x - 1, node.y - 7 });

						if (node.x - 2 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 1 });
						if (node.x - 2 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 2 });
						if (node.x - 2 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 3 });
						if (node.x - 2 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 4 });
						if (node.x - 2 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 5 });
						if (node.x - 2 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 6 });
						if (node.x - 2 >= 0 && node.y - 7 >= 0)
							neighbours.push_back({ node.x - 2, node.y - 7 });

						if (node.x - 3 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 1 });
						if (node.x - 3 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 2 });
						if (node.x - 3 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 3 });
						if (node.x - 3 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 4 });
						if (node.x - 3 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 5 });
						if (node.x - 3 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 6 });
						if (node.x - 3 >= 0 && node.y - 7 >= 0)
							neighbours.push_back({ node.x - 3, node.y - 7 });

						if (node.x - 4 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 1 });
						if (node.x - 4 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 2 });
						if (node.x - 4 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 3 });
						if (node.x - 4 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 4 });
						if (node.x - 4 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 5 });
						if (node.x - 4 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 6 });
						if (node.x - 4 >= 0 && node.y - 7 >= 0)
							neighbours.push_back({ node.x - 4, node.y - 7 });

						if (node.x - 5 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 1 });
						if (node.x - 5 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 2 });
						if (node.x - 5 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 3 });
						if (node.x - 5 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 4 });
						if (node.x - 5 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 5 });
						if (node.x - 5 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 5, node.y - 6 });

						if (node.x - 6 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 1 });
						if (node.x - 6 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 2 });
						if (node.x - 6 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 3 });
						if (node.x - 6 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 4 });
						if (node.x - 6 >= 0 && node.y - 5 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 5 });
						if (node.x - 6 >= 0 && node.y - 6 >= 0)
							neighbours.push_back({ node.x - 6, node.y - 6 });

						if (node.x - 7 >= 0 && node.y - 1 >= 0)
							neighbours.push_back({ node.x - 7, node.y - 1 });
						if (node.x - 7 >= 0 && node.y - 2 >= 0)
							neighbours.push_back({ node.x - 7, node.y - 2 });
						if (node.x - 7 >= 0 && node.y - 3 >= 0)
							neighbours.push_back({ node.x - 7, node.y - 3 });
						if (node.x - 7 >= 0 && node.y - 4 >= 0)
							neighbours.push_back({ node.x - 7, node.y - 4 });
					}
					else {
						if (node.y + 1 < world->height) neighbours.push_back({ node.x, node.y + 1 }); 
						if (node.x + 1 < world->width) neighbours.push_back({ node.x + 1, node.y });
						if (node.y - 1 >= 0) neighbours.push_back({ node.x, node.y - 1 }); 
						if (node.x - 1 >= 0) neighbours.push_back({ node.x - 1, node.y });

						if (node.x + 2 < world->width) {
							auto tile = GetTile(node.x + 1, node.y, world);
							if (!tile) return; 
							if (tile->bg != 0 and tile->fg == 0) neighbours.push_back({ node.x + 2, node.y });
							if (tile->bg == 0 and tile->fg != 0) neighbours.push_back({ node.x + 2, node.y });
							if (tile->bg != 0 and tile->fg != 0) neighbours.push_back({ node.x + 2, node.y });
							else neighbours.push_back({ node.x + 1, node.y });
						}
						if (node.x - 2 >= 0) {
							auto tile = GetTile(node.x - 1, node.y, world);
							if (!tile) return;
							if (tile->bg != 0 and tile->fg == 0) neighbours.push_back({ node.x - 2, node.y });
							if (tile->bg == 0 and tile->fg != 0) neighbours.push_back({ node.x - 2, node.y }); 
							if (tile->bg != 0 and tile->fg != 0) neighbours.push_back({ node.x - 2, node.y });
							else neighbours.push_back({ node.x - 1, node.y });
						}
						if (node.y + 2 < world->height) {
							auto tile = GetTile(node.x, node.y + 1, world);
							if (!tile) return; 
							if (tile->bg != 0 and tile->fg == 0) neighbours.push_back({ node.x, node.y + 2 }); 
							if (tile->bg == 0 and tile->fg != 0) neighbours.push_back({ node.x, node.y + 2 });
							if (tile->bg != 0 and tile->fg != 0) neighbours.push_back({ node.x, node.y + 2 }); 
							else neighbours.push_back({ node.x, node.y + 1 });
						}
						if (node.y - 2 >= 0) {
							auto tile = GetTile(node.x, node.y - 1, world);
							if (!tile) return; 
							if (tile->bg != 0 and tile->fg == 0) neighbours.push_back({ node.x, node.y - 2 }); 
							if (tile->bg == 0 and tile->fg != 0) neighbours.push_back({ node.x, node.y - 2 }); 
							if (tile->bg != 0 and tile->fg != 0) neighbours.push_back({ node.x, node.y - 2 }); 
							else neighbours.push_back({ node.x, node.y - 1 });
						}
						if (node.x - 1 >= 0 and node.y - 1 >= 0) neighbours.push_back({ node.x - 1, node.y - 1 }); 
						if (node.x + 1 < world->width and node.y - 1 >= 0) neighbours.push_back({ node.x + 1, node.y - 1 });
						if (node.x + 1 < world->width and node.y + 1 < world->height) neighbours.push_back({ node.x + 1, node.y + 1 });
						if (node.x - 1 >= 0 and node.y + 1 < world->height) neighbours.push_back({ node.x - 1, node.y + 1 });
					}

					if (reapply) {
						for (const auto& neighbour : neighbours)
						{
							auto tile_ = GetTile(neighbour, world);
							if (!tile_)
								continue;
							const auto& item_ = items[tile_->fg != 0 ? tile_->fg : tile_->bg];
							if (std::find(total.begin(), total.end(), neighbour) != total.end()) continue;
							else if (tile_->locked || tile_->lock_origin != -1) continue;
							else if (item_.blockType == LOCK || item_.blockType == MAIN_DOOR || item_.blockType == BEDROCK) continue;
							else if (tile_->fg == 0 && tile_->fg == 0) continue;

							temp.emplace_back(neighbour);
							total.emplace_back(neighbour);
							if (total.size() > size)
								goto done;
						}
					}
					else {
						for (const auto& neighbour : neighbours)
						{
							auto tile_ = GetTile(neighbour, world); 
							if (!tile_) 
								continue;
							int block_id = tile_->fg != 0 ? tile_->fg : tile_->bg; 
							const auto& item_ = items[block_id]; 
							CL_Vec2i m_pos_tile = neighbour/*GetTilePos(block_id, world)*/; 
							if (m_pos_tile.x < 0 || m_pos_tile.x > world->width || m_pos_tile.y < 0 || m_pos_tile.y > world->height) continue;
							if (std::find(total.begin(), total.end(), neighbour) != total.end()) continue; 
							else if (tile_->locked && world->owner_id != pInfo(peer)->uid) continue; 
							else if (tile_->lock_origin != -1) continue;
							else if (item_.blockType == LOCK || item_.blockType == MAIN_DOOR || item_.blockType == BEDROCK) continue;
							else if (reapply && tile_->fg == 0 && tile_->bg == 0) continue;

							temp.emplace_back(neighbour);
							total.emplace_back(neighbour);
							if (total.size() > size)
								goto done;
						}
					}
				}
				if (nodes.empty())
					goto done;

				nodes.pop_front();

				if (!temp.empty()) {
					auto begin = temp.begin();
					for (auto p = temp.end() - 1; p != begin; --p)
						nodes.emplace_back(*p);
				}
			}
		done:;
			auto extra_tile = GetTile(start_x, start_y, world); 
			if (!extra_tile) return;
			int lock_size = total.size();
			int count = 0;
			if (lock_size > size)
				lock_size = size;
			PlayerMoving data_{};
			data_.packetType = 15, data_.punchX = start_x, data_.punchY = start_y, data_.characterState = 0x8;
			data_.netID = pInfo(peer)->id;
			data_.plantingTree = lock;
			BYTE* raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc_(world, extra_tile));
			int lalala = 8;
			memcpy(raw + 8, &lock_size, 2);
			memcpy(raw + 12, &lalala, 2);
			BYTE* blc = raw + 56;
			if (!reapply) 
			{
				extra_tile->owner_name = pInfo(peer)->tankIDName;
				extra_tile->owner_id = pInfo(peer)->uid;
				if (HasRole(pInfo(peer))) extra_tile->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
				for (int i_ = 0; i_ < total.size(); i_++) {
					CL_Vec2i update_tiles = total[i_];
					int x = update_tiles.x;
					int y = update_tiles.y;
					int sq_ = x + (y * world->width);
					WorldBlock* block_ = GetTile(sq_, world);
					if (!block_) continue;
					if (block_->locked) {
						//cout << "was alrd lock" << endl;
						//continue;
					}
					else {
						block_->locked = true;
						block_->lock_origin = start_x + (start_y * world->width);
						memcpy(blc + (i_ * 2), &sq_, 2);
					}
				}
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Area locked."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
				{
					PlayerMoving data_{};
					data_.packetType = 13, data_.plantingTree = lock;
					BYTE* raw = packPlayerMoving(&data_);
					raw[2] = 1;
					send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					delete[]raw;
				}
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
					send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc_(world, extra_tile), ENET_PACKET_FLAG_RELIABLE);
				}
			}
			
			delete[] raw, blc;
		}
	}
	catch (exception& e) { return; }
}
vector<vector<int>> lock_tiles2(World* w_, int st_x, int st_y, int lock_size) {
	try {
		int layer_ = 0;
		int og_lock_size = lock_size;
		vector<vector<int>> new_tiles{};
		vector<vector<int>> new_lock{};
		if (w_->blocks.at(st_x + (st_y * 100)).locked) {
			return new_lock;
		}
		if (st_x - 1 > 0) {
			new_tiles.push_back({ st_x - 1 + (st_y * 100), 1 });
			if (not_mod(w_, w_->blocks.at(st_x - 1 + (st_y * 100)), st_x - 1, st_y)) new_lock.push_back({ st_x - 1, st_y });
		}
		if (st_y - 1 > 0) {
			new_tiles.push_back({ st_x + ((st_y - 1) * 100), 2 });
			if (not_mod(w_, w_->blocks.at(st_x + ((st_y - 1) * 100)), st_x, st_y - 1)) new_lock.push_back({ st_x, st_y - 1 });
		}
		if (st_x + 1 < 100) {
			new_tiles.push_back({ st_x + 1 + (st_y * 100), 3 });
			if (not_mod(w_, w_->blocks.at(st_x + 1 + (st_y * 100)), st_x + 1, st_y)) new_lock.push_back({ st_x + 1, st_y });
		}
		if (st_y + 1 < 60) {
			new_tiles.push_back({ st_x + ((st_y + 1) * 100), 4 });
			if (not_mod(w_, w_->blocks.at(st_x + ((st_y + 1) * 100)), st_x, st_y + 1)) new_lock.push_back({ st_x, st_y + 1 });
		}
		int ySize = w_->blocks.size() / 100, xSize = w_->blocks.size() / ySize;
		int max_up = 0;
		int max_down = 0;
		int max_right = 0;
		int max_left = 0;
		vector<WorldBlock> shadow_copy = w_->blocks;
		for (int i_ = 0; i_ < new_tiles.size(); i_++) {
			if (new_lock.size() >= og_lock_size) {
				break;
			}
			vector<int> test__ = new_tiles.at(i_);
			int x_ = test__.at(0) % 100, y_ = test__.at(0) / 100;
			int where_ = test__.at(1);
			if (where_ == 1) {
				if (y_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ + ((y_ - 1) * 100)).scanned) {
						if (not_mod(w_, shadow_copy.at(x_ + ((y_ - 1) * 100)), x_, y_ - 1)) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * 100), 1 });
							}
							new_lock.push_back({ x_, y_ - 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * 100), 1 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 2) {
				if (x_ + 1 > 100) {
				}
				else {
					if (not shadow_copy.at(x_ + 1 + (y_ * 100)).scanned) {
						if (not_mod(w_, shadow_copy.at(x_ + 1 + (y_ * 100)), x_ + 1, y_)) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < 100) {
								new_tiles.push_back({ x_ + 1 + (y_ * 100), 2 });
							}
							new_lock.push_back({ x_ + 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < 100) {
								new_tiles.push_back({ x_ + 1 + (y_ * 100), 2 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 3) {
				if (y_ + 1 > 60) {
				}
				else {
					if (not shadow_copy.at(x_ + ((y_ + 1) * 100)).scanned) {
						if (not_mod(w_, shadow_copy.at(x_ + ((y_ + 1) * 100)), x_, y_ + 1)) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < 60) {
								new_tiles.push_back({ x_ + ((y_ + 1) * 100), 3 });
							}
							new_lock.push_back({ x_, y_ + 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < 60) {
								new_tiles.push_back({ x_ + ((y_ + 1) * 100), 3 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 4) {
				if (x_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ - 1 + (y_ * 100)).scanned) {
						if (not_mod(w_, shadow_copy.at(x_ - 1 + (y_ * 100)), x_ - 1, y_)) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * 100), 4 });
							}
							new_lock.push_back({ x_ - 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * 100), 4 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (i_ == new_tiles.size() - 1) {
				layer_++;
				if (og_lock_size <= 10 or lock_size - new_lock.size() <= 5) layer_ = 0;
				int t_ = 1;
				if (st_x - t_ < 0) {
					//lock_size++;
				}
				else {
					while (shadow_copy.at(st_x - t_ + (st_y * 100)).scanned) {
						t_++;
						if (st_x - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x - t_ + (st_y * 100)).scanned) {
								if (not_mod(w_, shadow_copy.at(st_x - t_ + ((st_y + layer_) * 100)), st_x - t_, st_y + layer_)) {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * 100), 1 });
									new_lock.push_back({ st_x - t_, (st_y + layer_) });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * 100), 1 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y - t_ < 0) {
					//lock_size++;
				}
				else {
					while (shadow_copy.at(st_x + ((st_y - t_) * 100)).scanned) {
						t_++;
						if (st_y - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y - t_) * 100)).scanned) {
								if (not_mod(w_, shadow_copy.at(st_x - layer_ + ((st_y - t_) * 100)), st_x - layer_, st_y - t_)) {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * 100), 2 });
									new_lock.push_back({ st_x - layer_, st_y - t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * 100), 2 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_x + t_ > 100) {
				}
				else {
					while (shadow_copy.at(st_x + t_ + (st_y * 100)).scanned) {
						t_++;
						if (st_x + t_ > 100) {
							break;
						}
						else {
							if (st_y - layer_ < 0) layer_ = 0;
							if (not shadow_copy.at(st_x + t_ + (st_y * 100)).scanned) {
								if (not_mod(w_, shadow_copy.at(st_x + t_ + ((st_y - layer_) * 100)), st_x + t_, st_y - layer_)) {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * 100), 3 });
									new_lock.push_back({ st_x + t_, st_y - layer_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * 100), 3 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y + t_ > 60) {
				}
				else {
					while (shadow_copy.at(st_x + ((st_y + t_) * 100)).scanned) {
						t_++;
						if (st_y + t_ > 60) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y + t_) * 100)).scanned) {
								if (not_mod(w_, shadow_copy.at(st_x + layer_ + ((st_y + t_) * 100)), st_x + layer_, st_y + t_)) {
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * 100), 4 });
									new_lock.push_back({ st_x + layer_, st_y + t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * 100), 4 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
			}
		}
		if (new_lock.size() > og_lock_size) {
			int fix_size = (new_lock.size() - og_lock_size);
			for (int i_ = 0; i_ < fix_size; i_++) {
				new_lock.pop_back();
			}
		} vector<int> erase_later{};
		vector<WorldBlock> shadow_copy_2 = w_->blocks;
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * 100)).locked = true;
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * 100)).lock_origin = (st_x + (st_y * 100));
		}
		WorldBlock target_to_reach = shadow_copy_2.at(st_x + (st_y * 100)); // og coordinatess
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			vector<int> new_tiles{};
			new_tiles.push_back(asd_.at(0) + (asd_.at(1) * 100));
			int ySize = w_->blocks.size() / 100, xSize = w_->blocks.size() / ySize;
			bool reachable = false;
			vector<vector<int>> after_process{};
			for (int i2 = 0; i2 < new_tiles.size(); i2++) {
				int x_ = new_tiles.at(i2) % 100, y_ = new_tiles.at(i2) / 100;
				if ((x_ + (y_ * 100)) == st_x + (st_y * 100) or (x_ + 1 + (y_ * 100)) == st_x + (st_y * 100) or (x_ - 1 + (y_ * 100)) == st_x + (st_y * 100) or (x_ + ((y_ + 1) * 100)) == st_x + (st_y * 100) or (x_ + ((y_ - 1) * 100)) == st_x + (st_y * 100)) {
					reachable = true;
				} if (x_ < 99 and shadow_copy_2.at(x_ + 1 + (y_ * 100)).locked and shadow_copy_2.at(x_ + 1 + (y_ * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ + 1 + (y_ * 100)).scanned) {
						shadow_copy_2.at(x_ + 1 + (y_ * 100)).scanned = true;
						after_process.push_back({ x_ + 1, y_ });
						new_tiles.push_back(x_ + 1 + (y_ * 100));
					}
				} if (x_ > 0 and shadow_copy_2.at(x_ - 1 + (y_ * 100)).locked and shadow_copy_2.at(x_ - 1 + (y_ * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ - 1 + (y_ * 100)).scanned) {
						shadow_copy_2.at(x_ - 1 + (y_ * 100)).scanned = true;
						after_process.push_back({ x_ - 1, y_ });
						new_tiles.push_back(x_ - 1 + (y_ * 100));
					}
				} if (y_ < 59 and shadow_copy_2.at(x_ + ((y_ + 1) * 100)).locked and shadow_copy_2.at(x_ + ((y_ + 1) * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ + ((y_ + 1) * 100)).scanned) {
						shadow_copy_2.at(x_ + ((y_ + 1) * 100)).scanned = true;
						after_process.push_back({ x_, y_ + 1 });
						new_tiles.push_back(x_ + ((y_ + 1) * 100));
					}
				} if (y_ > 0 and shadow_copy_2.at(x_ + ((y_ - 1) * 100)).locked and shadow_copy_2.at(x_ + ((y_ - 1) * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ + ((y_ - 1) * 100)).scanned) {
						shadow_copy_2.at(x_ + ((y_ - 1) * 100)).scanned = true;
						after_process.push_back({ x_, y_ - 1 });
						new_tiles.push_back(x_ + ((y_ - 1) * 100));
					}
				}
			}
			for (vector<int> cleanup : after_process) {
				shadow_copy_2.at(cleanup.at(0) + ((cleanup.at(1)) * 100)).scanned = false;
			}
			if (not reachable) {
				erase_later.push_back(i_);
			}
		}
		int er_ = 0;
		for (int a_ : erase_later) {
			int aa = a_ - er_;
			new_lock.erase(new_lock.begin() + aa);
			er_++;
		} return new_lock;
	}
	catch (out_of_range) {
		//fprintf(stdout, "Something is wrong in lock_tiles function...");
		vector<vector<int>> asd{};
		return asd;
	}
}
vector<vector<int>> lock_tiles(World* w_, int st_x, int st_y, int lock_size) {
	try {
		int layer_ = 0;
		int og_lock_size = lock_size;
		vector<vector<int>> new_tiles{};
		vector<vector<int>> new_lock{};
		if (w_->blocks.at(st_x + (st_y * w_->width)).locked) {
			return new_lock;
		}
		if (st_x - 1 > 0) {
			new_tiles.push_back({ st_x - 1 + (st_y * w_->width), 1 });
			if (not_mod(w_->width, w_->height, w_->blocks.at(st_x - 1 + (st_y * w_->width)), st_x - 1, st_y)) new_lock.push_back({ st_x - 1, st_y });
		}
		if (st_y - 1 > 0) {
			new_tiles.push_back({ st_x + ((st_y - 1) * w_->width), 2 });
			if (not_mod(w_->width, w_->height, w_->blocks.at(st_x + ((st_y - 1) * w_->width)), st_x, st_y - 1)) new_lock.push_back({ st_x, st_y - 1 });
		}
		if (st_x + 1 < w_->width) {
			new_tiles.push_back({ st_x + 1 + (st_y * w_->width), 3 });
			if (not_mod(w_->width, w_->height, w_->blocks.at(st_x + 1 + (st_y * w_->width)), st_x + 1, st_y)) new_lock.push_back({ st_x + 1, st_y });
		}
		if (st_y + 1 < w_->height) {
			new_tiles.push_back({ st_x + ((st_y + 1) * w_->width), 4 });
			if (not_mod(w_->width, w_->height, w_->blocks.at(st_x + ((st_y + 1) * w_->width)), st_x, st_y + 1)) new_lock.push_back({ st_x, st_y + 1 });
		}
		//int ySize = w_->blocks.size() / w_->width, xSize = w_->blocks.size() / ySize;
		int max_up = 0;
		int max_down = 0;
		int max_right = 0;
		int max_left = 0;
		vector<WorldBlock> shadow_copy = w_->blocks;
		for (int i_ = 0; i_ < new_tiles.size(); i_++) {
			if (new_lock.size() >= og_lock_size) {
				break;
			}
			vector<int> test__ = new_tiles.at(i_);
			int x_ = test__.at(0) % w_->width, y_ = test__.at(0) / w_->width;
			int where_ = test__.at(1);
			if (where_ == 1) {
				if (y_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ + ((y_ - 1) * w_->width)).scanned) {
						if (not_mod(w_->width, w_->height, shadow_copy.at(x_ + ((y_ - 1) * w_->width)), x_, y_ - 1)) {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * w_->width), 1 });
							}
							new_lock.push_back({ x_, y_ - 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * w_->width), 1 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 2) {
				if (x_ + 1 > w_->width) {
				}
				else {
					if (not shadow_copy.at(x_ + 1 + (y_ * w_->width)).scanned) {
						if (not_mod(w_->width, w_->height, shadow_copy.at(x_ + 1 + (y_ * w_->width)), x_ + 1, y_)) {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < w_->width) {
								new_tiles.push_back({ x_ + 1 + (y_ * w_->width), 2 });
							}
							new_lock.push_back({ x_ + 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < w_->width) {
								new_tiles.push_back({ x_ + 1 + (y_ * w_->width), 2 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 3) {
				if (y_ + 1 > w_->height) {
				}
				else {
					if (not shadow_copy.at(x_ + ((y_ + 1) * w_->width)).scanned) {
						if (not_mod(w_->width, w_->height, shadow_copy.at(x_ + ((y_ + 1) * w_->width)), x_, y_ + 1)) {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < w_->height) {
								new_tiles.push_back({ x_ + ((y_ + 1) * w_->width), 3 });
							}
							new_lock.push_back({ x_, y_ + 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < w_->height) {
								new_tiles.push_back({ x_ + ((y_ + 1) * w_->width), 3 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 4) {
				if (x_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ - 1 + (y_ * w_->width)).scanned) {
						if (not_mod(w_->width, w_->height, shadow_copy.at(x_ - 1 + (y_ * w_->width)), x_ - 1, y_)) {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * w_->width), 4 });
							}
							new_lock.push_back({ x_ - 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * w_->width), 4 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (i_ == new_tiles.size() - 1) {
				layer_++;
				if (og_lock_size <= 10 or lock_size - new_lock.size() <= 5) layer_ = 0;
				int t_ = 1;
				if (st_x - t_ < 0) {
					//lock_size++;
				}
				else {
					while (shadow_copy.at(st_x - t_ + (st_y * w_->width)).scanned) {
						t_++;
						if (st_x - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x - t_ + (st_y * w_->width)).scanned) {
								if (not_mod(w_->width, w_->height, shadow_copy.at(st_x - t_ + ((st_y + layer_) * w_->width)), st_x - t_, st_y + layer_)) {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * w_->width), 1 });
									new_lock.push_back({ st_x - t_, (st_y + layer_) });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * w_->width), 1 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y - t_ < 0) {
					//lock_size++;
				}
				else {
					while (shadow_copy.at(st_x + ((st_y - t_) * w_->width)).scanned) {
						t_++;
						if (st_y - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y - t_) * w_->width)).scanned) {
								if (not_mod(w_->width, w_->height, shadow_copy.at(st_x - layer_ + ((st_y - t_) * w_->width)), st_x - layer_, st_y - t_)) {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * w_->width), 2 });
									new_lock.push_back({ st_x - layer_, st_y - t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * w_->width), 2 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_x + t_ > w_->width) {
				}
				else {
					while (shadow_copy.at(st_x + t_ + (st_y * w_->width)).scanned) {
						t_++;
						if (st_x + t_ > w_->width) {
							break;
						}
						else {
							if (st_y - layer_ < 0) layer_ = 0;
							if (not shadow_copy.at(st_x + t_ + (st_y * w_->width)).scanned) {
								if (not_mod(w_->width, w_->height, shadow_copy.at(st_x + t_ + ((st_y - layer_) * w_->width)), st_x + t_, st_y - layer_)) {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * w_->width), 3 });
									new_lock.push_back({ st_x + t_, st_y - layer_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * w_->width), 3 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y + t_ > w_->height) {
				}
				else {
					while (shadow_copy.at(st_x + ((st_y + t_) * w_->width)).scanned) {
						t_++;
						if (st_y + t_ > w_->height) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y + t_) * w_->width)).scanned) {
								if (not_mod(w_->width, w_->height, shadow_copy.at(st_x + layer_ + ((st_y + t_) * w_->width)), st_x + layer_, st_y + t_)) {
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * w_->width), 4 });
									new_lock.push_back({ st_x + layer_, st_y + t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * w_->width), 4 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
			}
		}
		if (new_lock.size() > og_lock_size) {
			int fix_size = (new_lock.size() - og_lock_size);
			for (int i_ = 0; i_ < fix_size; i_++) {
				new_lock.pop_back();
			}
		} vector<int> erase_later{};
		vector<WorldBlock> shadow_copy_2 = w_->blocks;
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * w_->width)).locked = true;
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * w_->width)).lock_origin = (st_x + (st_y * w_->width));
		}
		WorldBlock target_to_reach = shadow_copy_2.at(st_x + (st_y * w_->width)); // og coordinatess
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			vector<int> new_tiles{};
			new_tiles.push_back(asd_.at(0) + (asd_.at(1) * w_->width));
			//int ySize = w_->blocks.size() / w_->width, xSize = w_->blocks.size() / ySize;
			bool reachable = false;
			vector<vector<int>> after_process{};
			for (int i2 = 0; i2 < new_tiles.size(); i2++) {
				int x_ = new_tiles.at(i2) % w_->width, y_ = new_tiles.at(i2) / w_->width;
				if ((x_ + (y_ * w_->width)) == st_x + (st_y * w_->width) or (x_ + 1 + (y_ * w_->width)) == st_x + (st_y * w_->width) or (x_ - 1 + (y_ * w_->width)) == st_x + (st_y * w_->width) or (x_ + ((y_ + 1) * w_->width)) == st_x + (st_y * w_->width) or (x_ + ((y_ - 1) * w_->width)) == st_x + (st_y * w_->width)) {
					reachable = true;
				} if (x_ < (w_->width - 1) and shadow_copy_2.at(x_ + 1 + (y_ * w_->width)).locked and shadow_copy_2.at(x_ + 1 + (y_ * w_->width)).lock_origin == (st_x + (st_y * w_->width))) {
					if (not shadow_copy_2.at(x_ + 1 + (y_ * w_->width)).scanned) {
						shadow_copy_2.at(x_ + 1 + (y_ * w_->width)).scanned = true;
						after_process.push_back({ x_ + 1, y_ });
						new_tiles.push_back(x_ + 1 + (y_ * w_->width));
					}
				} if (x_ > 0 and shadow_copy_2.at(x_ - 1 + (y_ * w_->width)).locked and shadow_copy_2.at(x_ - 1 + (y_ * w_->width)).lock_origin == (st_x + (st_y * w_->width))) {
					if (not shadow_copy_2.at(x_ - 1 + (y_ * w_->width)).scanned) {
						shadow_copy_2.at(x_ - 1 + (y_ * w_->width)).scanned = true;
						after_process.push_back({ x_ - 1, y_ });
						new_tiles.push_back(x_ - 1 + (y_ * w_->width));
					}
				} if (y_ < (w_->height - 1) and shadow_copy_2.at(x_ + ((y_ + 1) * w_->width)).locked and shadow_copy_2.at(x_ + ((y_ + 1) * w_->width)).lock_origin == (st_x + (st_y * w_->width))) {
					if (not shadow_copy_2.at(x_ + ((y_ + 1) * w_->width)).scanned) {
						shadow_copy_2.at(x_ + ((y_ + 1) * w_->width)).scanned = true;
						after_process.push_back({ x_, y_ + 1 });
						new_tiles.push_back(x_ + ((y_ + 1) * w_->width));
					}
				} if (y_ > 0 and shadow_copy_2.at(x_ + ((y_ - 1) * w_->width)).locked and shadow_copy_2.at(x_ + ((y_ - 1) * w_->width)).lock_origin == (st_x + (st_y * w_->width))) {
					if (not shadow_copy_2.at(x_ + ((y_ - 1) * w_->width)).scanned) {
						shadow_copy_2.at(x_ + ((y_ - 1) * w_->width)).scanned = true;
						after_process.push_back({ x_, y_ - 1 });
						new_tiles.push_back(x_ + ((y_ - 1) * w_->width));
					}
				}
			}
			for (vector<int> cleanup : after_process) {
				shadow_copy_2.at(cleanup.at(0) + ((cleanup.at(1)) * w_->width)).scanned = false;
			}
			if (not reachable) {
				erase_later.push_back(i_);
			}
		}
		int er_ = 0;
		for (int a_ : erase_later) {
			int aa = a_ - er_;
			new_lock.erase(new_lock.begin() + aa);
			er_++;
		} return new_lock;
	}
	catch (out_of_range) {
		//fprintf(stdout, "Something is wrong in lock_tiles function...\n");
		vector<vector<int>> asd{};
		return asd;
	}
}
vector<vector<int>> lock_tiles3(World* w_, int st_x, int st_y, int lock_size) {
	try {
		int layer_ = 0;
		int og_lock_size = lock_size;
		vector<vector<int>> new_tiles{};
		vector<vector<int>> new_lock{};
		if (w_->blocks.at(st_x + (st_y * w_->width)).locked) {
			return new_lock;
		}
		if (st_x - 1 > 0) {
			new_tiles.push_back({ st_x - 1 + (st_y * w_->width), 1 });
			if (not_mod(w_, w_->blocks.at(st_x - 1 + (st_y * w_->width)), st_x - 1, st_y)) new_lock.push_back({ st_x - 1, st_y });
		}
		if (st_y - 1 > 0) {
			new_tiles.push_back({ st_x + ((st_y - 1) * w_->width), 2 });
			if (not_mod(w_, w_->blocks.at(st_x + ((st_y - 1) * w_->width)), st_x, st_y - 1)) new_lock.push_back({ st_x, st_y - 1 });
		}
		if (st_x + 1 < w_->width) {
			new_tiles.push_back({ st_x + 1 + (st_y * w_->width), 3 });
			if (not_mod(w_, w_->blocks.at(st_x + 1 + (st_y * w_->width)), st_x + 1, st_y)) new_lock.push_back({ st_x + 1, st_y });
		}
		if (st_y + 1 < w_->height) {
			new_tiles.push_back({ st_x + ((st_y + 1) * w_->width), 4 });
			if (not_mod(w_, w_->blocks.at(st_x + ((st_y + 1) * w_->width)), st_x, st_y + 1)) new_lock.push_back({ st_x, st_y + 1 });
		}
		int ySize = w_->blocks.size() / w_->width, xSize = w_->blocks.size() / ySize;
		int max_up = 0;
		int max_down = 0;
		int max_right = 0;
		int max_left = 0;
		vector<WorldBlock> shadow_copy = w_->blocks;
		for (int i_ = 0; i_ < new_tiles.size(); i_++) {
			if (new_lock.size() >= og_lock_size) {
				break;
			}
			vector<int> test__ = new_tiles.at(i_);
			int x_ = test__.at(0) % w_->width, y_ = test__.at(0) / w_->width;
			int where_ = test__.at(1);
			if (where_ == 1) {
				if (y_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ + ((y_ - 1) * w_->width)).scanned) {
						if (not_mod(w_, shadow_copy.at(x_ + ((y_ - 1) * w_->width)), x_, y_ - 1)) {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * w_->width), 1 });
							}
							new_lock.push_back({ x_, y_ - 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * w_->width), 1 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 2) {
				if (x_ + 1 > w_->width) {
				}
				else {
					if (not shadow_copy.at(x_ + 1 + (y_ * w_->width)).scanned) {
						if (not_mod(w_, shadow_copy.at(x_ + 1 + (y_ * w_->width)), x_ + 1, y_)) {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < w_->width) {
								new_tiles.push_back({ x_ + 1 + (y_ * w_->width), 2 });
							}
							new_lock.push_back({ x_ + 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < w_->width) {
								new_tiles.push_back({ x_ + 1 + (y_ * w_->width), 2 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 3) {
				if (y_ + 1 > w_->height) {
				}
				else {
					if (not shadow_copy.at(x_ + ((y_ + 1) * w_->width)).scanned) {
						if (not_mod(w_, shadow_copy.at(x_ + ((y_ + 1) * w_->width)), x_, y_ + 1)) {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < w_->height) {
								new_tiles.push_back({ x_ + ((y_ + 1) * w_->width), 3 });
							}
							new_lock.push_back({ x_, y_ + 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < w_->height) {
								new_tiles.push_back({ x_ + ((y_ + 1) * w_->width), 3 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 4) {
				if (x_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ - 1 + (y_ * w_->width)).scanned) {
						if (not_mod(w_, shadow_copy.at(x_ - 1 + (y_ * w_->width)), x_ - 1, y_)) {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * w_->width), 4 });
							}
							new_lock.push_back({ x_ - 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * w_->width)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * w_->width), 4 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (i_ == new_tiles.size() - 1) {
				layer_++;
				if (og_lock_size <= 10 or lock_size - new_lock.size() <= 5) layer_ = 0;
				int t_ = 1;
				if (st_x - t_ < 0) {
					//lock_size++;
				}
				else {
					while (shadow_copy.at(st_x - t_ + (st_y * w_->width)).scanned) {
						t_++;
						if (st_x - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x - t_ + (st_y * w_->width)).scanned) {
								if (not_mod(w_, shadow_copy.at(st_x - t_ + ((st_y + layer_) * w_->width)), st_x - t_, st_y + layer_)) {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * w_->width), 1 });
									new_lock.push_back({ st_x - t_, (st_y + layer_) });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * w_->width), 1 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y - t_ < 0) {
					//lock_size++;
				}
				else {
					while (shadow_copy.at(st_x + ((st_y - t_) * w_->width)).scanned) {
						t_++;
						if (st_y - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y - t_) * w_->width)).scanned) {
								if (not_mod(w_, shadow_copy.at(st_x - layer_ + ((st_y - t_) * w_->width)), st_x - layer_, st_y - t_)) {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * w_->width), 2 });
									new_lock.push_back({ st_x - layer_, st_y - t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * w_->width), 2 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_x + t_ > w_->width) {
				}
				else {
					while (shadow_copy.at(st_x + t_ + (st_y * w_->width)).scanned) {
						t_++;
						if (st_x + t_ > w_->width) {
							break;
						}
						else {
							if (st_y - layer_ < 0) layer_ = 0;
							if (not shadow_copy.at(st_x + t_ + (st_y * w_->width)).scanned) {
								if (not_mod(w_, shadow_copy.at(st_x + t_ + ((st_y - layer_) * w_->width)), st_x + t_, st_y - layer_)) {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * w_->width), 3 });
									new_lock.push_back({ st_x + t_, st_y - layer_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * w_->width), 3 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y + t_ > w_->height) {
				}
				else {
					while (shadow_copy.at(st_x + ((st_y + t_) * w_->width)).scanned) {
						t_++;
						if (st_y + t_ > (w_->height - 1)) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y + t_) * w_->width)).scanned) {
								if (not_mod(w_, shadow_copy.at(st_x + layer_ + ((st_y + t_) * w_->width)), st_x + layer_, st_y + t_)) {
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * w_->width), 4 });
									new_lock.push_back({ st_x + layer_, st_y + t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * w_->width), 4 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
			}
		}
		if (new_lock.size() > og_lock_size) {
			int fix_size = (new_lock.size() - og_lock_size);
			for (int i_ = 0; i_ < fix_size; i_++) {
				new_lock.pop_back();
			}
		} vector<int> erase_later{};
		vector<WorldBlock> shadow_copy_2 = w_->blocks;
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * w_->width)).locked = true;
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * w_->width)).lock_origin = (st_x + (st_y * w_->width));
		}
		WorldBlock target_to_reach = shadow_copy_2.at(st_x + (st_y * w_->width)); // og coordinatess
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			vector<int> new_tiles{};
			new_tiles.push_back(asd_.at(0) + (asd_.at(1) * w_->width));
			int ySize = w_->blocks.size() / w_->width, xSize = w_->blocks.size() / ySize;
			bool reachable = false;
			vector<vector<int>> after_process{};
			for (int i2 = 0; i2 < new_tiles.size(); i2++) {
				int x_ = new_tiles.at(i2) % w_->width, y_ = new_tiles.at(i2) / w_->width;
				if ((x_ + (y_ * w_->width)) == st_x + (st_y * w_->width) or (x_ + 1 + (y_ * w_->width)) == st_x + (st_y * w_->width) or (x_ - 1 + (y_ * w_->width)) == st_x + (st_y * w_->width) or (x_ + ((y_ + 1) * w_->width)) == st_x + (st_y * w_->width) or (x_ + ((y_ - 1) * w_->width)) == st_x + (st_y * w_->width)) {
					reachable = true;
				} if (x_ < (w_->width - 1) and shadow_copy_2.at(x_ + 1 + (y_ * w_->width)).locked and shadow_copy_2.at(x_ + 1 + (y_ * w_->width)).lock_origin == (st_x + (st_y * w_->width))) {
					if (not shadow_copy_2.at(x_ + 1 + (y_ * w_->width)).scanned) {
						shadow_copy_2.at(x_ + 1 + (y_ * w_->width)).scanned = true;
						after_process.push_back({ x_ + 1, y_ });
						new_tiles.push_back(x_ + 1 + (y_ * w_->width));
					}
				} if (x_ > 0 and shadow_copy_2.at(x_ - 1 + (y_ * w_->width)).locked and shadow_copy_2.at(x_ - 1 + (y_ * w_->width)).lock_origin == (st_x + (st_y * w_->width))) {
					if (not shadow_copy_2.at(x_ - 1 + (y_ * w_->width)).scanned) {
						shadow_copy_2.at(x_ - 1 + (y_ * w_->width)).scanned = true;
						after_process.push_back({ x_ - 1, y_ });
						new_tiles.push_back(x_ - 1 + (y_ * w_->width));
					}
				} if (y_ < (w_->height - 1) and shadow_copy_2.at(x_ + ((y_ + 1) * w_->width)).locked and shadow_copy_2.at(x_ + ((y_ + 1) * w_->width)).lock_origin == (st_x + (st_y * w_->width))) {
					if (not shadow_copy_2.at(x_ + ((y_ + 1) * w_->width)).scanned) {
						shadow_copy_2.at(x_ + ((y_ + 1) * w_->width)).scanned = true;
						after_process.push_back({ x_, y_ + 1 });
						new_tiles.push_back(x_ + ((y_ + 1) * w_->width));
					}
				} if (y_ > 0 and shadow_copy_2.at(x_ + ((y_ - 1) * w_->width)).locked and shadow_copy_2.at(x_ + ((y_ - 1) * w_->width)).lock_origin == (st_x + (st_y * w_->width))) {
					if (not shadow_copy_2.at(x_ + ((y_ - 1) * w_->width)).scanned) {
						shadow_copy_2.at(x_ + ((y_ - 1) * w_->width)).scanned = true;
						after_process.push_back({ x_, y_ - 1 });
						new_tiles.push_back(x_ + ((y_ - 1) * w_->width));
					}
				}
			}
			for (vector<int> cleanup : after_process) {
				shadow_copy_2.at(cleanup.at(0) + ((cleanup.at(1)) * w_->width)).scanned = false;
			}
			if (not reachable) {
				erase_later.push_back(i_);
			}
		}
		int er_ = 0;
		for (int a_ : erase_later) {
			int aa = a_ - er_;
			new_lock.erase(new_lock.begin() + aa);
			er_++;
		} return new_lock;
	}
	catch (exception& e) {
		fprintf(stdout, "Something is wrong in the lock_tile function, message: %s...\n", e.what());
		vector<vector<int>> asd{};
		return asd;
	}
}

void send_edit_lock(ENetPeer* peer, World* world_, int t_, int x_, int y_) {
	uint32_t guild_id = world_->guild_id;
	vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
	if (p != guilds.end()) {
		string access_list_ = "";

		for (int i_ = 0; i_ < world_->admins.size(); i_++) {
			access_list_ += "\nadd_checkbox|checkbox_/" + to_string(world_->admins[i_]) + "|`w" + GetNameByUid(world_->admins[i_]) + "``|1";
		}
		if (access_list_.empty()) access_list_ = "\nadd_label|small|Currently, you're the only one with access.``|left";
		Guild* guild_information = &guilds[p - guilds.begin()];
		string guild_key = "\nadd_button|getKey|Get Guild Key|noflags|0|0|";
		string guild_upg = "";
		string guild_mas = "\nadd_textbox|Increase your guild level to `w3`` or more and you can set a guild mascot!|left|";
		int c_ = 0;
		modify_inventory(peer, 5816, c_);
		if (c_ != 0) {
			guild_key = "";
		}
		if (guild_information->guild_level == 1 and guild_information->guild_xp >= 405000) {
			guild_upg = "\nadd_button|upg2|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `2200000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 2 and guild_information->guild_xp >= 1215000) {
			guild_upg = "\nadd_button|upg3|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `2300000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 3 and guild_information->guild_xp >= 2430000) {
			guild_upg = "\nadd_button|upg4|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `2400000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 4 and guild_information->guild_xp >= 4050000) {
			guild_upg = "\nadd_button|upg5|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `2500000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 5 and guild_information->guild_xp >= 7290000) {
			guild_upg = "\nadd_button|upg6|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `21000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 6 and guild_information->guild_xp >= 11430000) {
			guild_upg = "\nadd_button|upg7|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `22000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 7 and guild_information->guild_xp >= 16200000) {
			guild_upg = "\nadd_button|upg8|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `23000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 8 and guild_information->guild_xp >= 21870000) {
			guild_upg = "\nadd_button|upg9|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `24000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 9 and guild_information->guild_xp >= 28350000) {
			guild_upg = "\nadd_button|upg10|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `25000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 10 and guild_information->guild_xp >= 38700000) {
			guild_upg = "\nadd_button|upg11|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost:`26000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 11 and guild_information->guild_xp >= 48600000) {
			guild_upg = "\nadd_button|upg12|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `28000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 12 and guild_information->guild_xp >= 60547500) {
			guild_upg = "\nadd_button|upg13|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `29000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 13 and guild_information->guild_xp >= 73710000) {
			guild_upg = "\nadd_button|upg14|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `210000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 14 and guild_information->guild_xp >= 91125000) {
			guild_upg = "\nadd_button|upg15|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `215000000 Gems|left|\nadd_spacer|small|";
		}
		//create_guild_mascot
		if (guild_information->guild_level >= 3) guild_mas = "\nadd_button|create_guild_mascot|`0Change Guild Mascot|noflags|0|0|";
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("add_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_player_info|" + guild_information->guild_name + " | " + to_string(guild_information->guild_level) + "|" + to_string(guild_information->guild_xp) + "|" + to_string(guild_lvl[guild_information->guild_level - 1][0]) + "|\nadd_spacer|small|" + guild_upg + "\nadd_textbox|`wManage Guild Member access:``|left|\nadd_checkbox|checkbox_coleader|Enable Co-Leader access|" + (guild_information->coleader_access ? "1" : "0") + "\nadd_checkbox|checkbox_elder|Enable Co-Leader and Elder access|" + (guild_information->coleader_elder_access ? "1" : "0") + "\nadd_checkbox|checkbox_member|Enable all Members access|" + (guild_information->all_access ? "1" : "0") + "\nadd_spacer|small|" + (guild_information->all_access ? "\nadd_label|small|`2All guild members have access.``|left" : (guild_information->coleader_elder_access ? "\nadd_label|small|`2Guild Co-Leaders and Elders have access.``|left" : (guild_information->coleader_access ? "\nadd_label|small|`2Guild Co-Leaders have access.``|left" : ""))) + "\nadd_spacer|small|\nadd_label|small|`wAccess List:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_spacer|small|" + guild_mas + "\nadd_spacer|small|\nadd_checkbox|checkbox_displaymascot|Display Guild Mascot on the Guild Lock|" + (guild_information->unlocked_mascot == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_public|Allow anyone to build|" + (world_->open_to_public ? "1" : "0") + "\nadd_checkbox|checkbox_disable_music|Disable Custom Music Blocks|" + (world_->disable_music_blocks ? "1" : "0") + "\nadd_text_input|tempo|Music BPM|" + to_string(world_->music_bpm) + "|3|\nadd_checkbox|checkbox_disable_music_render|Make Custom Music Blocks invisible|" + (world_->make_music_blocks_invisible ? "1" : "0") + (not pInfo(peer)->home_world.empty() ? "\nadd_smalltext|Your current home world is: " + pInfo(peer)->home_world + "|left|" : "") + "\nadd_checkbox|checkbox_set_as_home_world|Set as Home World|" + (pInfo(peer)->home_world == world_->name ? "1" : "0") + "|\nadd_text_input|minimum_entry_level|World Level: |" + to_string(world_->entry_level) + "|3|\nadd_smalltext|Set minimum world entry level.|\nadd_button|sessionlength_dialog|`wSet World Timer``|noflags|0|0|\nadd_button|clear_a_world|`wClear World|noflags|0|0|\nadd_spacer|small|\nadd_button|changecat|`wCategory: None``|noflags|0|0|" + guild_key + "\nadd_button|abondonguildconfirm|`wAbandon Guild``|noflags|0|0|\nend_dialog|editguildlock|Cancel|OK|\nadd_quick_exit|");
		p.CreatePacket(peer);
	}
}
bool check_transmuted(ENetPeer* peer, int id) {
	for (int i = 0; i < pInfo(peer)->inv.size(); i++) {
		if (pInfo(peer)->inv[i].id == id) {
			if (pInfo(peer)->inv[i].transmuted) return true;
		}
	}
	return false;
}


string get_embed(string cch, string name) {
	return explode("|", explode(name + "|", cch)[1])[0];
}
void call_dialog(ENetPeer* p_, string cch) {
	if (pInfo(p_)->trading_with != -1 and cch.find("trade_") == string::npos) {
		cancel_trade(p_, false, true);
		return;
	}
	if (pInfo(p_)->world.empty() and not pInfo(p_)->tankIDName.empty()) return;
	if (cch.find("make_mascotss") != string::npos or cch.find("buttonClicked|upgrade_guild_confirm") != string::npos or cch.find("transmutated_device_edit") != string::npos or cch.find("transmutated_linkitem_edit") != string::npos or cch.find("transmutated_final_edit") != string::npos or cch.find("remove_transmutated_dialog") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool mascot_dialog = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			if (infoDat.size() == 2) {
				if (infoDat.at(0) == "dialog_name" and infoDat.at(1) == "make_mascotss") mascot_dialog = true;
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (mascot_dialog) {
					if (infoDat.at(0) == "select_bg_mascot") {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							int item_ = atoi(infoDat.at(1).c_str());
							if (item_ < 0 or item_ > items.size()) break;
							World* world_ = &worlds[p - worlds.begin()];
							WorldBlock* block_ = &world_->blocks.at(pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width));
							if (block_->fg != 5814) break;
							if (pInfo(p_)->guild_id != world_->guild_id) break;
							uint32_t guild_id = pInfo(p_)->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								uint32_t my_rank = 0;
								for (GuildMember member_search : guild_information->guild_members) {
									if (member_search.member_name == pInfo(p_)->tankIDName) {
										my_rank = member_search.role_id;
										break;
									}
								}
								if (my_rank <= 2) break;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								if (items[item_].blockType != BlockTypes::BACKGROUND) p.Insert("add_label|big|`wGrow Guild Mascot Editor ``|left|\nadd_spacer|small|\nadd_textbox|`4Mascot Background only can use background item!|left|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems! ``Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_item_picker|select_bg_mascot|`wChoose Background Item``|Choose a Background for Guild Mascot|\nadd_item_picker|select_fg_mascot|`wChoose Foreground Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nadd_textbox|`8Exclusive``: Mascot Foreground Only - uses a foreground item only! - `8200,000 Gems ``additional cost (250,000 Gems in total).|left|\nadd_item_picker|select_fgonly_mascot|`wChoose Foreground Only Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nend_dialog|make_mascotss|Cancel||");
								else {
									string btn_ = "";
									if (item_ != 0 and pInfo(p_)->last_fg_mascot != 0) btn_ = "\nadd_button|confirm_mascot|Confirm Guild Mascot|noflags|0|0|";
									p.Insert("add_label|big|`wGrow Guild Mascot Editor ``|left|\nadd_spacer|small|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems! ``Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_button_with_icon|||noflags|6864||" + (pInfo(p_)->last_fg_mascot == 0 ? "\nadd_button_with_icon|||noflags|6864||" : "\nadd_button_with_icon|||left|" + to_string(pInfo(p_)->last_fg_mascot) + "||") + "\nadd_button_with_icon|||noflags|6864||\nadd_button_with_icon|||left|" + to_string(item_) + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_item_picker|select_bg_mascot|`wChoose Background Item``|Choose a Background for Guild Mascot|\nadd_item_picker|select_fg_mascot|`wChoose Foreground Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nadd_textbox|`8Exclusive``: Mascot Foreground Only - uses a foreground item only! - `8200,000 Gems ``additional cost (250,000 Gems in total).|left|\nadd_item_picker|select_fgonly_mascot|`wChoose Foreground Only Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|" + btn_ + "\nend_dialog|make_mascotss|Cancel||");
								}
								p.CreatePacket(p_);
								if (items[item_].blockType == BlockTypes::BACKGROUND) {
									pInfo(p_)->fg_only_mascot = false;
									pInfo(p_)->last_bg_mascot = item_;
								}
							}
						}
						break;
					}
					if (infoDat.at(0) == "select_fg_mascot") {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							int item_ = atoi(infoDat.at(1).c_str());
							if (item_ < 0 or item_ > items.size()) break;
							World* world_ = &worlds[p - worlds.begin()];
							WorldBlock* block_ = &world_->blocks.at(pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width));
							if (block_->fg != 5814) break;
							if (pInfo(p_)->guild_id != world_->guild_id) break;
							uint32_t guild_id = pInfo(p_)->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								uint32_t my_rank = 0;
								for (GuildMember member_search : guild_information->guild_members) {
									if (member_search.member_name == pInfo(p_)->tankIDName) {
										my_rank = member_search.role_id;
										break;
									}
								}
								if (my_rank <= 2) break;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								if (items[item_].blockType == BlockTypes::BACKGROUND or item_ == 18 or item_ == 32 or item_ == 6336 or items[item_].blockType == BlockTypes::SEED) p.Insert("add_label|big|`wGrow Guild Mascot Editor ``|left|\nadd_spacer|small|\nadd_textbox|`4Mascot Foreground only can use foreground item!|left|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems! ``Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_item_picker|select_bg_mascot|`wChoose Background Item``|Choose a Background for Guild Mascot|\nadd_item_picker|select_fg_mascot|`wChoose Foreground Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nadd_textbox|`8Exclusive``: Mascot Foreground Only - uses a foreground item only! - `8200,000 Gems ``additional cost (250,000 Gems in total).|left|\nadd_item_picker|select_fgonly_mascot|`wChoose Foreground Only Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nend_dialog|make_mascotss|Cancel||");
								else {
									string btn_ = "";
									if (item_ != 0 and pInfo(p_)->last_bg_mascot != 0) btn_ = "\nadd_button|confirm_mascot|Confirm Guild Mascot|noflags|0|0|";
									p.Insert("add_label|big|`wGrow Guild Mascot Editor ``|left|\nadd_spacer|small|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems! ``Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_button_with_icon|||noflags|6864||\nadd_button_with_icon|||left|" + to_string(item_) + "||\nadd_button_with_icon|||noflags|6864||" + (pInfo(p_)->last_bg_mascot == 0 ? "\nadd_button_with_icon|||noflags|6864||" : "\nadd_button_with_icon|||left|" + to_string(pInfo(p_)->last_bg_mascot) + "||") + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_item_picker|select_bg_mascot|`wChoose Background Item``|Choose a Background for Guild Mascot|\nadd_item_picker|select_fg_mascot|`wChoose Foreground Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nadd_textbox|`8Exclusive``: Mascot Foreground Only - uses a foreground item only! - `8200,000 Gems ``additional cost (250,000 Gems in total).|left|\nadd_item_picker|select_fgonly_mascot|`wChoose Foreground Only Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|" + btn_ + "\nend_dialog|make_mascotss|Cancel||");
								}
								p.CreatePacket(p_);
								if (items[item_].blockType != BlockTypes::BACKGROUND and item_ != 18 and item_ != 32 and item_ != 6336 and items[item_].blockType != BlockTypes::SEED) {
									pInfo(p_)->fg_only_mascot = false;
									pInfo(p_)->last_fg_mascot = item_;
								}
							}
						}
						break;
					}
					if (infoDat.at(0) == "select_fgonly_mascot") {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							int item_ = atoi(infoDat.at(1).c_str());
							if (item_ < 0 or item_ > items.size()) break;
							World* world_ = &worlds[p - worlds.begin()];
							WorldBlock* block_ = &world_->blocks.at(pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width));
							if (block_->fg != 5814) break;
							if (pInfo(p_)->guild_id != world_->guild_id) break;
							uint32_t guild_id = pInfo(p_)->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								uint32_t my_rank = 0;
								for (GuildMember member_search : guild_information->guild_members) {
									if (member_search.member_name == pInfo(p_)->tankIDName) {
										my_rank = member_search.role_id;
										break;
									}
								}
								if (my_rank <= 2) break;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								if (items[item_].blockType == BlockTypes::BACKGROUND or item_ == 18 or item_ == 32 or item_ == 6336 or items[item_].blockType == BlockTypes::SEED) p.Insert("add_label|big|`wGrow Guild Mascot Editor ``|left|\nadd_spacer|small|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems! ``Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_item_picker|select_bg_mascot|`wChoose Background Item``|Choose a Background for Guild Mascot|\nadd_item_picker|select_fg_mascot|`wChoose Foreground Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nadd_textbox|`4Mascot Foreground only can use foreground item!|left|\nadd_textbox|`8Exclusive``: Mascot Foreground Only - uses a foreground item only! - `8200,000 Gems ``additional cost (250,000 Gems in total).|left|\nadd_item_picker|select_fgonly_mascot|`wChoose Foreground Only Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nend_dialog|make_mascotss|Cancel||");
								else {
									string btn_ = "";
									if (item_ != 0) btn_ = "\nadd_button|confirm_mascot|Confirm Guild Mascot|noflags|0|0|";
									p.Insert("add_label|big|`wGrow Guild Mascot Editor ``|left|\nadd_spacer|small|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems! ``Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_item_picker|select_bg_mascot|`wChoose Background Item``|Choose a Background for Guild Mascot|\nadd_item_picker|select_fg_mascot|`wChoose Foreground Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nadd_textbox|`8Exclusive``: Mascot Foreground Only - uses a foreground item only! - `8200,000 Gems ``additional cost (250,000 Gems in total).|left|\nadd_spacer|small|\nadd_button_with_icon|||noflags|6864||\nadd_button_with_icon|||noflags|6864||\nadd_button_with_icon|||left|" + to_string(item_) + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_item_picker|select_fgonly_mascot|`wChoose Foreground Only Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|" + btn_ + "\nend_dialog|make_mascotss|Cancel||");
								}
								p.CreatePacket(p_);
								if (items[item_].blockType != BlockTypes::BACKGROUND and item_ != 18 and item_ != 32 and item_ != 6336 and items[item_].blockType != BlockTypes::SEED) {
									pInfo(p_)->fg_only_mascot = true;
									pInfo(p_)->last_fg_mascot = item_;
								}
							}
						}
						break;
					}
					if (infoDat.at(0) == "buttonClicked") {
						if (infoDat.at(1) == "confirm_mascot") {
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks.at(pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width));
								if (block_->fg != 5814) break;
								if (pInfo(p_)->guild_id != world_->guild_id) break;
								uint32_t guild_id = pInfo(p_)->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									uint32_t my_rank = 0;
									for (GuildMember member_search : guild_information->guild_members) {
										if (member_search.member_name == pInfo(p_)->tankIDName) {
											my_rank = member_search.role_id;
											break;
										}
									}
									if (my_rank <= 2) break;
									if (pInfo(p_)->fg_only_mascot and pInfo(p_)->last_fg_mascot == 0) break;
									else if (not pInfo(p_)->fg_only_mascot and (pInfo(p_)->last_fg_mascot == 0 or pInfo(p_)->last_bg_mascot == 0)) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_dual_layer_icon_label|big|`wConfirm Guild Mascot``|left|" + (pInfo(p_)->fg_only_mascot ? to_string(pInfo(p_)->last_bg_mascot) : "0") + "|" + to_string(pInfo(p_)->last_fg_mascot) + "|1.0|0|\nadd_spacer|small|\nadd_textbox|Are you sure wish to create this Guild Mascot for `9" + (pInfo(p_)->fg_only_mascot ? "200,000" : "50,000") + " gems``?|left|\nadd_spacer|small|\nadd_textbox|Confirm your choice.|left|\nadd_button|btn_create_mascot|Confirm Guild Mascot|\nend_dialog|make_mascotss|Cancel||");
									p.CreatePacket(p_);
								}
							}
							break;
						}
						if (infoDat.at(1) == "btn_create_mascot") {
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks.at(pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width));
								if (block_->fg != 5814) break;
								if (pInfo(p_)->guild_id != world_->guild_id) break;
								uint32_t guild_id = pInfo(p_)->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									uint32_t my_rank = 0;
									for (GuildMember member_search : guild_information->guild_members) {
										if (member_search.member_name == pInfo(p_)->tankIDName) {
											my_rank = member_search.role_id;
											break;
										}
									}
									if (my_rank <= 2 or pInfo(p_)->lastwrenchx < 0 or pInfo(p_)->lastwrenchy < 0) break;
									if (pInfo(p_)->fg_only_mascot and pInfo(p_)->last_fg_mascot == 0) break;
									else if (not pInfo(p_)->fg_only_mascot and (pInfo(p_)->last_fg_mascot == 0 or pInfo(p_)->last_bg_mascot == 0)) break;

									if (pInfo(p_)->fg_only_mascot) {
										if (pInfo(p_)->gems < 250000) {
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(p_)->netID);
												p.Insert("You can't make mascot!``!  You're `$" + setGems(250000 - pInfo(p_)->gems) + "`` Gems short.");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(p_);
											}
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("You can't make mascot!``!  You're `$" + setGems(250000 - pInfo(p_)->gems) + "`` Gems short.");
												p.CreatePacket(p_);
											}
											pInfo(p_)->fg_only_mascot = false, pInfo(p_)->last_fg_mascot = 0, pInfo(p_)->last_bg_mascot = 0;
											break;
										}
										pInfo(p_)->gems -= 250000;
										{
											gamepacket_t p;
											p.Insert("OnSetBux");
											p.Insert(pInfo(p_)->gems);
											p.Insert(0);
											p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
											if (pInfo(p_)->supp >= 2) {
												p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
											}
											p.CreatePacket(p_);
										}
										guild_information->guild_mascot[0] = pInfo(p_)->last_fg_mascot;
										guild_information->guild_mascot[1] = 0;
										int flag2 = (65536 * guild_information->guild_mascot[1]) + pInfo(p_)->last_fg_mascot;
										gamepacket_t p(0, pInfo(p_)->netID);
										p.Insert("OnGuildDataChanged");
										p.Insert(50478);
										p.Insert(79289404);
										p.Insert(flag2), p.Insert(my_rank);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												p.CreatePacket(currentPeer);
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										break;
									}
									pInfo(p_)->gems -= 50000;
									{
										gamepacket_t p;
										p.Insert("OnSetBux");
										p.Insert(pInfo(p_)->gems);
										p.Insert(0);
										p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) {
											p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										}
										p.CreatePacket(p_);
									}
									guild_information->guild_mascot[0] = pInfo(p_)->last_fg_mascot;
									guild_information->guild_mascot[1] = pInfo(p_)->last_bg_mascot;
									int flag2 = (65536 * pInfo(p_)->last_bg_mascot) + pInfo(p_)->last_fg_mascot;
									gamepacket_t p(0, pInfo(p_)->netID);
									p.Insert("OnGuildDataChanged");
									p.Insert(50478);
									p.Insert(79289404);
									p.Insert(flag2), p.Insert(my_rank);
									PlayerMoving data_{};
									data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
									BYTE* blc = raw + 56;
									form_visual(blc, *block_, *world_, p_, false);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											p.CreatePacket(currentPeer);
											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
								}
							}
							break;
						}
					}
				}
				if (btn == "permanttransmutation") {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(
						"set_default_color|`o\n"
						"add_label_with_icon|big|`wTransmutabooth``|left|9170|\n"
						"add_spacer|small|\n"
						"embed_data|isPermanent|1\n"
						"add_textbox|Tired of how an item looks but want to keep its abilities? Here is where you can overwrite its appearance with that of another item from the SAME slot!|left|\n"
						"add_textbox|Cost: `2100,000`` Gems.|left|\n"
						"add_spacer|small|\n"
						"add_textbox|To begin, you'll need to pick the item you want to change (its mods will remain)...|left|\n"
						"add_spacer|small|\n"
						"add_item_picker|mainitemid|`wStart Transmuting!``|Choose the item you want to change!|\n"
						"add_spacer|small|\n"
						"add_button|beforeMainBackToModes|Back|noflags|0|0|\n"
						"end_dialog|transmutated_device_edit|Close||\n"
						"add_quick_exit|");
					p.CreatePacket(p_);
				}
				if (btn == "temporaltransmutation") {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(
						"set_default_color|`o\n"
						"add_label_with_icon|big|`wTransmutabooth``|left|9170|\n"
						"add_spacer|small|\n"
						"embed_data|isPermanent|-1\n"
						"add_smalltext|Not sure how good a transmute will look? Test your experiments here!|left|\n"
						"add_smalltext|Cost: `2500`` Gems for up to `212`` temporary item tests!|left|\n"
						"add_smalltext|Remember: This is TEMPORARY. You'll only get `25 minutes`` of testing for your Gems! After that, it's back to normal!|left|\n"
						"add_smalltext|`4Warning:`` Temporary tests will only work in THIS WORLD! As soon as you leave, they'll end!|left|\n"
						"add_spacer|small|\n"
						"add_textbox|Ready? To begin, you'll need to pick the item you want to change (its mods will remain)...|left|\n"
						"add_spacer|small|\n"
						"add_item_picker|mainitemid|`wStart Transmuting!``|This item is about to get a TEMPORARY new look!|\n"
						"add_spacer|small|\n"
						"add_button|beforeMainBackToModes|Back|noflags|0|0|\n"
						"end_dialog|transmutated_device_edit|Close||\n"
						"add_quick_exit|");
					p.CreatePacket(p_);
				}
				if (btn == "upgrade_guild_confirm") {
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldBlock* block_ = &world_->blocks.at(pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width));
						if (block_->fg != 5814) return;
						if (pInfo(p_)->guild_id != world_->guild_id) return;
						uint32_t guild_id = pInfo(p_)->guild_id;
						vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
						if (p != guilds.end()) {
							Guild* guild_information = &guilds[p - guilds.begin()];
							uint32_t my_rank = 0;
							for (GuildMember member_search : guild_information->guild_members) {
								if (member_search.member_name == pInfo(p_)->tankIDName) {
									my_rank = member_search.role_id;
									break;
								}
							}
							if (my_rank <= 2 or pInfo(p_)->lastwrenchx < 0 or pInfo(p_)->lastwrenchy < 0) return;
							if (guild_lvl[guild_information->guild_level - 1][0] == guild_information->guild_xp) {
								if (pInfo(p_)->gems < guild_lvl[guild_information->guild_level - 1][1]) {
									{
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You can't upgrade guild!``!  You're `$" + setGems(250000 - pInfo(p_)->gems) + "`` Gems short.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
									}
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You can't upgrade guild!``!  You're `$" + setGems(250000 - pInfo(p_)->gems) + "`` Gems short.");
										p.CreatePacket(p_);
									}
									return;
								}
								pInfo(p_)->gems -= guild_lvl[guild_information->guild_level - 1][1];
								{
									gamepacket_t p;
									p.Insert("OnSetBux");
									p.Insert(pInfo(p_)->gems);
									p.Insert(0);
									p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) {
										p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
									}
									p.CreatePacket(p_);
								}
								guild_information->guild_level += 1;
								guild_information->guild_xp = 0;
								{
									gamepacket_t p;
									p.Insert("OnAddNotification");
									p.Insert("interface/large/guild_levelup.rttex");
									p.Insert("Awesome! You reached Guild Level " + to_string(guild_information->guild_level) + "``");
									p.Insert("audio/hub_open.wav");
									p.Insert(0);
									p.CreatePacket(p_);
								}
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
						}
					}
				}
				if (btn == "transmutationhelp") {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(
						"\nset_default_color | `o"
						"\nadd_label_with_icon|big|`wHELP! Transmutabooth``|left|9170|"
						"\nadd_spacer|small|"
						"\nadd_textbox|Here you will find all the necessary details about the Transmutabooth.|left|"
						"\nadd_spacer|small|"
						"\nadd_smalltext|#1 The Transmutabooth lets you transfer the visuals of one clothing item onto another (of the same slot)! The transmuted item will keep its properties (and mods!).|left|"
						"\nadd_spacer|small|"
						"\nadd_smalltext|#2 You can transmute clothing items in two ways:|left|"
						"\nadd_label_with_icon|small|`5Permanent Transmutes``|left|9230|"
						"\nadd_smalltext|     - Lets you permanently change the visuals of clothing!|left|"
						"\nadd_smalltext|     - Cost is `2100,000 Gems.``|left|"
						"\nadd_smalltext|     - The item will get NEW visuals - remember, it will keep its mods, but it'll look different!|left|"
						"\nadd_smalltext|     - You first pick the item you want to change, you then pick a Transmute Target to give the item a NEW look!|left|"
						"\nadd_smalltext|     - If you attempt to overwrite a permanently-transmuted item, example: Fairy Wings transmuted to look like the Backpack, but you then decide to transmute the Fairy Wings to Ripper Wings!|left|"
						"\nadd_smalltext|          - `4Alert!`` This item already has a permanent transmutation! Are you SURE you want to overwrite it?|left|"
						"\nadd_smalltext|     - Permanent Transmutes are designated with a 'purple circle' icon in the inventory.|left|"
						"\nadd_spacer|small|"
						"\nadd_label_with_icon|small|`5Test a Transmute``|left|9232|"
						"\nadd_smalltext|     - Lets you test out transmutations and change the visuals of clothing for a short time ONLY! If you're not sure how good a transmute will look, this is a perfect way to experiment.|left|"
						"\nadd_smalltext|     - Cost is `2500 Gems.``|left|"
						"\nadd_smalltext|     - You'll only get `25 minutes`` of testing for your gems! After that, the clothing visual will return to normal!|left|"
						"\nadd_smalltext|     - `4Warning!:`` Temporary tests will only work in THIS WORLD (the world where your Transmutabooth is located)! As soon as you leave, the transmutation will end!|left|"
						"\nadd_smalltext|     - Temporary Transmutes are designated with a 'blue clock' icon in the inventory.|left|"
						"\nadd_spacer|small|"
						"\nadd_smalltext|#3 You can view all of your permanent transmutes from the handily named 'Your Permanent Transmutes' menu inside the Transmutabooth! You can also remove unwanted transmutes...|left|"
						"\nadd_smalltext|     - `5Removing Transmutes:`` If you want your original item back and done with a transmutation, you can remove the transmutation from here.|left|"
						"\nadd_spacer|small|"
						"\nadd_smalltext|#4 `5Wasted Transmutes`` - you will be warned if there are no mods on your target item to let you know it is kind of a waste. You can still go ahead with the transmute, but it may not be worth it!|left|"
						"\nadd_smalltext|     - `2Tip:`` Test out your transmutes first to experiment with the items, have fun and see what crazy combos you can create.|left|"
						"\nadd_spacer|small|"
						"\nadd_button|beforeMainBackToModes|Back|noflags|0|0|"
						"\nend_dialog|transmutated_device_edit|Close||"
						"\nadd_quick_exit|");
					p.CreatePacket(p_);
				}//transmute pick
				if (infoDat[0] == "mainitemid") {
					if (atoi(infoDat[1].c_str()) > items.size()) break;
					if (items[atoi(infoDat[1].c_str())].untradeable) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("The Transmutabooth does not accept untradeable items!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
					if (items[atoi(infoDat[1].c_str())].blockType == BlockTypes::CLOTHING && infoDat[1] != "5480") {
						string permanent = get_embed(cch, "isPermanent");
						string extra = (permanent == "-1" ? "add_textbox|Test Transmutation:|left|\nadd_spacer|small|\n" : "");
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert(
							"set_default_color|`o\n"
							"add_label_with_icon|big|`wTransmutabooth``|left|9170|\n"
							"add_spacer|small|\n"
							+ extra +
							"embed_data|mainitemid|" + infoDat[1] + "\n"
							"embed_data|isPermanent|" + permanent + "\n"
							"add_textbox|Okay, this is the item that will get NEW visuals - remember, you'll keep its mods, but it'll look different!|left|\n"
							"add_label_with_icon|small|`w" + items[atoi(infoDat[1].c_str())].name + "``|left|" + infoDat[1] + "|\n"
							"add_spacer|small|\n"
							"add_textbox|Now you'll pick the NEW look for this item. Same slot only!|left|\n"
							"add_item_picker|linkitemid|`wPick Transmute Target!``|Choose the item for your NEW look!|\n"
							"add_spacer|small|\n"
							"end_dialog|transmutated_linkitem_edit|Close||\n"
							"add_quick_exit|"
						);
						p.CreatePacket(p_);
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("The Transmutabooth does not accept this item!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
				}
				if (infoDat[0] == "linkitemid") {
					string mainitemid = get_embed(cch, "mainitemid");
					string permanent = get_embed(cch, "isPermanent");
					string extra = (pInfo(p_)->gems > 100000 ? "add_button|permanenttransmutation|TRANSMUTE!|noflags|0|0|\n" : "add_textbox|You don't have enough Gems right now. Purchase more from the store!|left|\n");
					string extra2 = (pInfo(p_)->gems > 500 ? "add_button|trailtransmutation|TEST THIS TRANSMUTE!|noflags|0|0|\n" : "add_textbox|You don't have enough Gems right now. Purchase more from the store!|left|\n");
					if (atoi(infoDat[1].c_str()) > items.size()) break;
					if (atoi(mainitemid.c_str()) > items.size()) break;
					if (infoDat[1] == mainitemid) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("`4You can't transmute the same item... that would be silly!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
					if (items[atoi(infoDat[1].c_str())].untradeable) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("The Transmutabooth does not accept untradeable items!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
					if (items[atoi(infoDat[1].c_str())].blockType == BlockTypes::CLOTHING) {
						if (items[atoi(infoDat[1].c_str())].clothType == items[atoi(mainitemid.c_str())].clothType && infoDat[1] != "5480") {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							if (permanent == "1") {
								p.Insert(
									"set_default_color|`o\n"
									"add_label_with_icon|big|`wTransmutabooth``|left|9170|\n"
									"embed_data|mainitemid|" + mainitemid + "\n"
									"embed_data|linkeditemid|" + infoDat[1] + "\n"
									"add_spacer|small|\n"
									"add_textbox|This item is about to get a NEW look! |left|\n"
									"add_label_with_icon|small|" + items[atoi(mainitemid.c_str())].name + "``|left|" + mainitemid + "|\n"
									"add_spacer|small|\n"
									"add_textbox|This is the item it's going to look like:|left|\n"
									"add_label_with_icon|small|" + items[atoi(infoDat[1].c_str())].name + "``|left|" + infoDat[1] + "|\n"
									"add_spacer|small|\n"
									"add_textbox|Ready to go? Remember, your `4" + items[atoi(infoDat[1].c_str())].name + "`` will be HELD in the Transmutabooth to power this change until you end the transmutation!|left|\n"
									"add_spacer|small|\n"
									+ extra +
									"add_spacer|small|\n"
									"add_button|beforeMainBackToModes|Back|noflags|0|0|\n"
									"end_dialog|transmutated_final_edit|Cancel||\n"
									"add_quick_exit|"
								);
							}
							else if (permanent == "-1") {
								p.Insert(
									"set_default_color|`o\n"
									"add_label_with_icon|big|`wTransmutabooth``|left|9170|\n"
									"embed_data|mainitemid|" + mainitemid + "\n"
									"embed_data|linkeditemid|" + infoDat[1] + "\n"
									"add_spacer|small|\n"
									"add_textbox|This item is about to get a NEW look! |left|\n"
									"add_label_with_icon|small|" + items[atoi(mainitemid.c_str())].name + "``|left|" + mainitemid + "|\n"
									"add_spacer|small|\n"
									"add_textbox|This is the item it's going to look like:|left|\n"
									"add_label_with_icon|small|" + items[atoi(infoDat[1].c_str())].name + "``|left|" + infoDat[1] + "|\n"
									"add_spacer|small|\n"
									+ extra2 +
									"add_spacer|small|\n"
									"add_button|beforeMainBackToModes|Back|noflags|0|0|\n"
									"end_dialog|transmutated_final_edit|Cancel||\n"
									"add_quick_exit|"
								);
							}
							p.CreatePacket(p_);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You can only transmute belonging to the same clothing slot!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							break;
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("`4" + items[atoi(infoDat[1].c_str())].name + " ``does not fit in the Transmutabooth.");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
				}
				if (btn == "permanenttransmutation") {
					/*
					int got = 0, adaBrp1 = 0, adaBrp2 = 0;
					string mainitemid = get_embed(cch, "mainitemid");
					string linkeditemid = get_embed(cch, "linkeditemid");
					modify_inventory(p_, atoi(linkeditemid.c_str()), adaBrp1);
					modify_inventory(p_, atoi(linkeditemid.c_str()), adaBrp2);
					if (adaBrp1 == 0) break;
					if (adaBrp2 == 0) break;
					if (atoi(linkeditemid.c_str()) > items.size()) break;
					if (atoi(mainitemid.c_str()) > items.size()) break;
					pInfo(p_)->transmute.push_back(mainitemid + ":" + linkeditemid);
					pInfo(p_)->gems -= 100000;
					gamepacket_t p;
					p.Insert("OnSetBux");
					p.Insert(pInfo(p_)->gems);
					p.Insert(0);
					p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
					if (pInfo(p_)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
					p.CreatePacket(p_);
					for (int i = 0; i < pInfo(p_)->inv.size(); i++) {
						if (pInfo(p_)->inv[i].id == atoi(mainitemid.c_str())) pInfo(p_)->inv[i].transmuted = true;
						if (pInfo(p_)->inv[i].id == atoi(linkeditemid.c_str())) {
							if (!pInfo(p_)->inv[i].transmuted) modify_inventory(p_, atoi(linkeditemid.c_str()), got = -1);
						}
					}
					*/
					Algorithm::send_console(p_, "Transmutation is temporary disabled");
					Algorithm::send_bubble(p_, pInfo(p_)->netID, "Transmutation is disabled");
					break;
				}
				if (btn == "trailtransmutation") {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("This feature under development.");
					p.CreatePacket(p_);
					break;
				}
				if (btn == "permanentlist") {
					/*
					string itemid = "";
					for (int i = 0; i < pInfo(p_)->transmute.size(); i++) {
						string item = pInfo(p_)->transmute[i];
						const char a = ':', b = ',';
						replace(item.begin(), item.end(), a, b);
						if (i == pInfo(p_)->transmute.size()) itemid.append(item);
						else itemid.append(item + ",");
					}
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(
						"set_default_color|`o\n"
						"add_label_with_icon|big|`wTransmutabooth``|left|9170|\n"
						"add_textbox|You have transmuted `2" + to_string(pInfo(p_)->transmute.size()) + "/5`` clothing items.|left|\n"
						"add_label_with_icon_button_list|small|`w%s: Transmuted %s to %s|left|removetransmutation_|itemID_transID|" + itemid + "\n"
						"add_spacer|small|\n"
						"add_button|beforeMainBackToModes|Back|noflags|0|0|\n"
						"end_dialog|transmutated_device_edit|Close||\n"
						"add_quick_exit|"
					);
					p.CreatePacket(p_);
					*/
				}
				if (btn == "beforeMainBackToModes") {
					/*
					string extra = "";
					if (pInfo(p_)->transmute.size() > 0) extra = "add_smalltext|You have transmuted `2" + to_string(pInfo(p_)->transmute.size()) + "/5`` clothing items.|left|\n"
						"add_button|permanentlist|`wYour Permanent Transmutes``|noflags|0|0|\n"
						"add_spacer|small|\n";
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\n"
						"add_label_with_icon|big|`wTransmutabooth``|left|9170|\n"
						"add_spacer|small|\n"
						"add_smalltext|This booth will let you transfer the visuals of one clothing item onto another (of the same slot)!|left|\n"
						"add_smalltext|The transmuted item will keep its properties (and mods!), so have fun and experiment with crazy combos!|left|\n"
						"add_spacer|small|\n"
						+ extra +
						"add_smalltext|Here's where you can permanently change the visuals of clothing!|left|\n"
						"add_button|permanttransmutation|`wTransmutate!``|noflags|0|0|\n"
						"add_spacer|small|\n"
						"add_smalltext|Here's where you can test out transmutations for a short time!|left|\n"
						"add_button|temporaltransmutation|`wTest a Transmute!``|noflags|0|0|\n"
						"add_spacer|small|\n"
						"add_button|transmutationhelp|`wHelp``|noflags|0|0|\n"
						"add_spacer|small|\n"
						"end_dialog|transmutated_device_edit|Close||\n"
						"add_quick_exit|");
					p.CreatePacket(p_);
					*/
				}
				if (btn.substr(0, 20) == "removetransmutation_") {
					/*
					string linkeditemid = "";
					string mainitemid = btn.substr(20, btn.length() - 20).c_str();
					for (int i = 0; i < pInfo(p_)->transmute.size(); i++) {
						string list = pInfo(p_)->transmute[i];
						if (list.find(mainitemid) != string::npos) {
							linkeditemid = explode(":", list)[1];
						}
					}
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(
						"set_default_color|`o\n"
						"add_label_with_icon|big|`wTransmutabooth``|left|9170|\n"
						"embed_data|mainitemid|" + mainitemid + "\n"
						"embed_data|linkeditemid|" + linkeditemid + "\n"
						"add_spacer|small|\n"
						"add_textbox|Done with this transmutation? Want your item back? Here's where you can break them apart!|left|\n"
						"add_textbox|You have transmuted `2" + to_string(pInfo(p_)->transmute.size()) + "/5`` clothing items.|left|\n"
						"add_spacer|small|\n"
						"add_textbox|Here's the old item that got a new look:|left|\n"
						"add_label_with_icon|small|" + items[atoi(mainitemid.c_str())].name + "``|left|" + mainitemid + "|\n"
						"add_spacer|small|\n"
						"add_textbox|Here's the item that gave its look (and is held here):|left|\n"
						"add_label_with_icon|small|" + items[atoi(linkeditemid.c_str())].name + "``|left|" + linkeditemid + "|\n"
						"add_spacer|small|\n"
						"add_textbox|`4Warning:`` Are you sure you want to end this transmutation? Your `2" + items[atoi(mainitemid.c_str())].name + "`` will go back to normal, and your `2" + items[atoi(linkeditemid.c_str())].name + "`` will be returned to your backpack!``|left|\n"
						"add_spacer|small|\n"
						"add_button|ConfirmRemoveTransmutation|END TRANSMUTATION!|noflags|0|0|\n"
						"end_dialog|remove_transmutated_dialog|Close|Back|\n"
						"add_quick_exit|"
					);
					p.CreatePacket(p_);
					*/
				}
				else if (btn == "ConfirmRemoveTransmutation") {
					/*
					int got = 0;
					string mainitemid = get_embed(cch, "mainitemid");
					string linkeditemid = get_embed(cch, "linkeditemid");

					int main_item = atoi(mainitemid.c_str());
					int linked_item = atoi(linkeditemid.c_str());
					if (main_item >= items.size() || linked_item >= items.size() ||
						main_item <= 1 || linked_item <= 1) break;
					if (get_item_count(pInfo(p_), main_item) <= 0) break;

					bool valid = false;
					if (pInfo(p_)->transmute.empty()) break;
					{
						for (int i = 0; i < pInfo(p_)->transmute.size(); i++) {
							auto get_link = explode(":", pInfo(p_)->transmute[i])[1];
							if (get_link == linkeditemid) {
								valid = true;
								break;
							}
						}
					}
					if (!valid) break;

					pInfo(p_)->transmute.erase(remove(pInfo(p_)->transmute.begin(), pInfo(p_)->transmute.end(), mainitemid + ":" + linkeditemid), pInfo(p_)->transmute.end());
					pInfo(p_)->updtrans = true;
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You have removed the transmutation!");
					p.Insert(0);
					p.Insert(0);
					p.CreatePacket(p_);
					modify_inventory(p_, atoi(linkeditemid.c_str()), got = +1);
					for (int i = 0; i < pInfo(p_)->inv.size(); i++) {
						if (pInfo(p_)->inv[i].id == atoi(mainitemid.c_str())) pInfo(p_)->inv[i].transmuted = false;
					}
				}*/
					update_clothes(p_);
				}
			}
		}
	}
	else if (cch.find("make_mascotss") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool mascot_dialog = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			auto InfoDat = infoDat;
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "dialog_name" && infoDat[1] == "make_mascotss") mascot_dialog = true;
				if (mascot_dialog) {
					if (InfoDat[0] == "select_bg_mascot") {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							int item = atoi(InfoDat[1].c_str());
							if (item < 0 or item > items.size()) break;
							if (items[item].blockType != BlockTypes::BACKGROUND) {
								get_mascot_dialog(p_, pInfo(p_)->choose_fg, pInfo(p_)->choose_bg, "`4Please only choose Background Items.``");
								break;
							}
							World* world_ = &worlds[p - worlds.begin()];
							WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
							if (block_->fg != 5814) break;
							if (pInfo(p_)->guild_id != world_->guild_id) break;
							uint32_t guild_id = pInfo(p_)->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (item == guild_information->guild_mascot[1]) break;
								uint32_t my_rank = 0;
								for (GuildMember member_search : guild_information->guild_members) {
									if (member_search.member_name == pInfo(p_)->tankIDName) {
										my_rank = member_search.role_id;
										break;
									}
								}
								if (my_rank <= 2) break;
								pInfo(p_)->choose_bg = item;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_mascot_dialog(p_, pInfo(p_)->choose_fg, pInfo(p_)->choose_bg, ""));
								p.CreatePacket(p_);
							}
						}
					}
					if (InfoDat[0] == "select_fg_item") {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							int item = atoi(InfoDat[1].c_str());
							if (item < 0 or item > items.size()) break;
							if (items[item].blockType == BlockTypes::BACKGROUND) {
								get_mascot_dialog(p_, pInfo(p_)->choose_fg, pInfo(p_)->choose_bg, "`4Please only choose Foreground Items.``");
								break;
							}
							World* world_ = &worlds[p - worlds.begin()];
							WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
							if (block_->fg != 5814) break;
							if (pInfo(p_)->guild_id != world_->guild_id) break;
							uint32_t guild_id = pInfo(p_)->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (item == guild_information->guild_mascot[0]) break;
								uint32_t my_rank = 0;
								for (GuildMember member_search : guild_information->guild_members) {
									if (member_search.member_name == pInfo(p_)->tankIDName) {
										my_rank = member_search.role_id;
										break;
									}
								}
								if (my_rank <= 2) break;
								pInfo(p_)->choose_fg = item;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_mascot_dialog(p_, pInfo(p_)->choose_fg, pInfo(p_)->choose_bg, ""));
								p.CreatePacket(p_);
							}
						}
					}
					if (btn == "confirm_mascot") {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("add_dual_layer_icon_label|big|`wConfirm Guild Mascot``|left|" + to_string(pInfo(p_)->choose_bg) + "|" + to_string(pInfo(p_)->choose_fg) + "|1.0|0|\nadd_textbox|Are you sure you wish to create this Guild Mascot for `9250,000 gems`o?|left|\nadd_spacer|small|\nadd_textbox|Confirm your choice.|left|\nend_dialog|confirm_mascot_guild|Cancel|Confirm Guild Mascot|");
						p.CreatePacket(p_);
					}
				}
				update_clothes(p_);
			}
		}
	}
	else if (cch.find("confirm_mascot_guild") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool mascot_dialog = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			auto InfoDat = infoDat;
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "dialog_name" && infoDat[1] == "confirm_mascot_guild") mascot_dialog = true;

				if (mascot_dialog) {
					pInfo(p_)->gems -= 250000;
					string name_ = pInfo(p_)->world;
					gamepacket_t gem_upd;
					gem_upd.Insert("OnSetBux"), gem_upd.Insert(pInfo(p_)->gems), gem_upd.Insert(0), gem_upd.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
					if (pInfo(p_)->supp >= 2) {
						gem_upd.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
					}
					gem_upd.CreatePacket(p_);
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
						if (block_->fg != 5814) break;
						if (pInfo(p_)->guild_id != world_->guild_id) break;
						uint32_t guild_id = pInfo(p_)->guild_id;
						vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
						if (p != guilds.end()) {
							Guild* guild_information = &guilds[p - guilds.begin()];
							uint32_t my_rank = 0;
							for (GuildMember member_search : guild_information->guild_members) {
								if (member_search.member_name == pInfo(p_)->tankIDName) {
									my_rank = member_search.role_id;
									break;
								}
							}
							if (my_rank <= 2) break;
							guild_information->guild_mascot[1] = pInfo(p_)->choose_fg, guild_information->guild_mascot[0] = pInfo(p_)->choose_bg, pInfo(p_)->choose_fg = 0, pInfo(p_)->choose_bg = 0;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, p_, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(p_)->world) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
					}
				}
			}
		}
	}
	else if (cch.find("carnival") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool ringmasterDialog = false;
		bool ringmasterGiveUp = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			if (infoDat[0] == "buttonClicked") btn = infoDat[1];
			if (infoDat[0] == "dialog_name" and infoDat[1] == "carnival") ringmasterDialog = true;
			if (infoDat[0] == "dialog_name" and infoDat[1] == "carnival_give_up") ringmasterGiveUp = true;

			if (ringmasterDialog) {
				if (btn == "c_quest") {
					int removeTicket = -10;
					if (modify_inventory(p_, 1898, removeTicket) == 0) {
						pInfo(p_)->C_QuestActive = true;
						pInfo(p_)->CQ = true;
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Ring``|left|1900|\nadd_textbox|`oYou are about to embark on a magical journey! it won't be easy, but the reward is one of the fine rings from my vast collection. You don't get to pick which one, mind you.<CR>I've got a lot of rings sitting in my bag, with a lot of magical properties. If you want one, picked randomly at my discretion, you'll need to complete 10 little tasks for me.<CR>Doesn't sound so bad does it?<CR>Remember that i travel with the carnival, so if you don't get your quest done this time but don't worry because in TayoPs i won't be travel somewhere and i will be here everyday!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all your progress, and you'll have to pay another 10 Golden Tickets to start again!``|\nadd_spacer|small|\nadd_label|small|`oSo... now that you've received the official disclaimer, are you truly prepared to hand over 10 Golden Tickets and embark on the Quest For The Ring?``|\nend_dialog|carnival|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
				}
				else if (btn == "deliver") {
					if (pInfo(p_)->C_QuestKind == 1 or pInfo(p_)->C_QuestKind == 8) {
						if (pInfo(p_)->C_QuestStep != 10) {
							int adaBrp = 0;
							modify_inventory(p_, pInfo(p_)->C_DeliverID, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->C_QuestProgress + adaBrp > pInfo(p_)->C_ProgressNeeded) adaBrp = pInfo(p_)->C_ProgressNeeded - pInfo(p_)->C_QuestProgress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, pInfo(p_)->C_DeliverID, removeItem);
								pInfo(p_)->C_QuestProgress += adaBrp;
								if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
									pInfo(p_)->C_QuestProgress = 0;
									pInfo(p_)->C_QuestKind = 0;
									pInfo(p_)->C_QuestStep++;
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											p2.CreatePacket(p_);
										}
									}
									RandomizeCQuest(p_);
									SendCarnivalQuest(p_, 500);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GoodLuck;
							}
						}
						else {
							int adaBrp = 0;
							modify_inventory(p_, pInfo(p_)->C_DeliverID, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->C_QuestProgress + adaBrp > pInfo(p_)->C_ProgressNeeded) adaBrp = pInfo(p_)->C_ProgressNeeded - pInfo(p_)->C_QuestProgress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, pInfo(p_)->C_DeliverID, removeItem);
								pInfo(p_)->C_QuestProgress += adaBrp;
								if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
									int amount = 1;
									vector<int> listRing{ 1874, 1876, 1996, 2970, 1932, 3140, 1904, 1986, 3174, 6028, 6846, 8962, 11094 };
									int randomRing = listRing[rand() % listRing.size()];
									modify_inventory(p_, randomRing, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, randomRing);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnConsoleMessage");
											p4.Insert("`9>> " + pInfo(p_)->modName + " `9has completed the Quest For The Ring and earned the " + items[randomRing].ori_name + "!");
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									pInfo(p_)->C_QuestProgress = 0;
									pInfo(p_)->C_ProgressNeeded = 0;
									pInfo(p_)->C_QuestStep = 1;
									pInfo(p_)->C_QuestActive = false;
									pInfo(p_)->C_QuestKind = 0;
									pInfo(p_)->C_DeliverID = 0;
									break;
								}
							}
							else {
								goto GoodLuck;
							}
						}
					}
					else if (pInfo(p_)->C_QuestKind == 7) {
						if (pInfo(p_)->C_QuestStep != 10) {
							int cost = pInfo(p_)->C_ProgressNeeded;
							if (pInfo(p_)->gems >= cost) {
								pInfo(p_)->gems -= cost;
								{
									gamepacket_t p;
									p.Insert("OnSetBux");
									p.Insert(pInfo(p_)->gems);
									p.Insert(0);
									p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) {
										p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
									}
									p.CreatePacket(p_);
								}
								pInfo(p_)->C_QuestProgress = 0;
								pInfo(p_)->C_QuestKind = 0;
								pInfo(p_)->C_QuestStep++;
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										p2.CreatePacket(p_);
									}
								}
								RandomizeCQuest(p_);
								SendCarnivalQuest(p_, 500);
								break;
							}
							else {
								goto GoodLuck;
							}
						}
						else {
							int cost = pInfo(p_)->C_ProgressNeeded;
							if (pInfo(p_)->gems >= cost) {
								pInfo(p_)->gems -= cost;
								{
									gamepacket_t p;
									p.Insert("OnSetBux");
									p.Insert(pInfo(p_)->gems);
									p.Insert(0);
									p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) {
										p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
									}
									p.CreatePacket(p_);
								}
								int amount = 1;
								vector<int> listRing{ 1874, 1876, 1996, 2970, 1932, 3140, 1904, 1986, 3174, 6028, 6846, 8962, 11094 };
								int randomRing = listRing[rand() % listRing.size()];
								modify_inventory(p_, randomRing, amount);
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest completed!!");
								p.CreatePacket(p_);
								SendCmd(p_, "/cheer", true);
								// WEAR CLOTHES
								equip_clothes(p_, randomRing);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										gamepacket_t p3, p4;
										p3.Insert("OnParticleEffect");
										p3.Insert(73);
										p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
										p4.Insert("OnConsoleMessage");
										p4.Insert("`9>> " + pInfo(p_)->modName + " `9has completed the Quest For The Ring and earned the " + items[randomRing].ori_name + "!");
										p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
										packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									}
								}
								pInfo(p_)->C_QuestProgress = 0;
								pInfo(p_)->C_ProgressNeeded = 0;
								pInfo(p_)->C_QuestStep = 1;
								pInfo(p_)->C_QuestActive = false;
								pInfo(p_)->C_QuestKind = 0;
								pInfo(p_)->C_DeliverID = 0;
								break;
							}
							else {
								goto GoodLuck;
							}
						}
					}
					else {
						if (pInfo(p_)->C_QuestStep != 10) {
							if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
								pInfo(p_)->C_QuestProgress = 0;
								pInfo(p_)->C_QuestKind = 0;
								pInfo(p_)->C_QuestStep++;
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										p2.CreatePacket(p_);
									}
								}
								RandomizeCQuest(p_);
								SendCarnivalQuest(p_, 500);
								break;
							}
							else {
								goto GoodLuck;
							}
						}
						else {
							if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
								int amount = 1;
								vector<int> listRing{ 1874, 1876, 1996, 2970, 1932, 3140, 1904, 1986, 3174, 6028, 6846, 8962, 11094 };
								int randomRing = listRing[rand() % listRing.size()];
								modify_inventory(p_, randomRing, amount);
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest completed!!");
								p.CreatePacket(p_);
								SendCmd(p_, "/cheer", true);
								// WEAR CLOTHES
								equip_clothes(p_, randomRing);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										gamepacket_t p3, p4;
										p3.Insert("OnParticleEffect");
										p3.Insert(73);
										p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
										p4.Insert("OnConsoleMessage");
										p4.Insert("`9>> " + pInfo(p_)->modName + " `9has completed the Quest For The Ring and earned the " + items[randomRing].ori_name + "!");
										p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
										packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									}
								}
								pInfo(p_)->C_QuestProgress = 0;
								pInfo(p_)->C_ProgressNeeded = 0;
								pInfo(p_)->C_QuestStep = 1;
								pInfo(p_)->C_QuestActive = false;
								pInfo(p_)->C_QuestKind = 0;
								pInfo(p_)->C_DeliverID = 0;
								break;
							}
							else {
								goto GoodLuck;
							}
						}
					}
				GoodLuck:
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("`9Good luck! You can do it!");
					p.CreatePacket(p_);
					break;
				}
				else if (btn == "give_up") {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("\nadd_label_with_icon|big|`9Quest For The Ring|left|1900|\nadd_textbox|`oIf you quit, any progress you've made will be lost forever.<CR>There is no benefit to quitting the Ring Quest, except that you can start over and hope for easier tasks (not likely!). You'll also have to pay 10 more Golden Tickets when you start again.``|\nadd_spacer|small|\nadd_label|small|`4Are you absolutely sure you want to quit this quest?``|\nadd_spacer|small|\nend_dialog|carnival_give_up|`wNo!|`wYes!|\nadd_quick_exit|\n");
					p.CreatePacket(p_);
					break;
				}
				else if (pInfo(p_)->CQ) {
					RandomizeCQuest(p_);
					SendCarnivalQuest(p_, 500);
					break;
				}
			}
			if (ringmasterGiveUp) {
				pInfo(p_)->C_QuestActive = false;
				pInfo(p_)->C_QuestKind = 0;
				pInfo(p_)->C_DeliverID = 0;
				pInfo(p_)->C_QuestStep = 1;
				pInfo(p_)->C_ProgressNeeded = 0;
				pInfo(p_)->C_QuestProgress = 0;
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("`9Okay! You are no longer on the Ring Quest! Good luck!");
				p.CreatePacket(p_);
				break;
			}
		}
	}
	else if (cch.find("legendary_wizard") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool wizardDialog = false;
		bool wizardGiveUp = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "dialog_name" && infoDat[1] == "legendary_wizard") wizardDialog = true;
				if (infoDat[0] == "dialog_name" && infoDat[1] == "legendary_wizard_give_up") wizardGiveUp = true;

				if (wizardDialog) {
					if (btn == "honor") {
						pInfo(p_)->choosing_quest = "honor";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For Honor``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legendary Title`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For Honor?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
					else if (btn == "fire") {
						pInfo(p_)->choosing_quest = "fire";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For Fire``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Dragon of Legend`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For Fire?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
					else if (btn == "steel") {
						pInfo(p_)->choosing_quest = "steel";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest Of Steel``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legend Bot-009`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest Of Steel?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
				/*	else if (btn == "heavens") {
						pInfo(p_)->choosing_quest = "heavens";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest Of The `4Heavens``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `4Kamish Sword`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest Of The Heavens?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					} */
					else if (btn == "Ruler Sword") {
						pInfo(p_)->choosing_quest = "Ruler Sword";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest Of The `bRuler Sword``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 5 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `4Kamish Sword`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest Of The Ruler Sword?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
					else if (btn == "blade") {
						pInfo(p_)->choosing_quest = "blade";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Blade``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legendary Katana`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For The Blade?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
					else if (btn == "candour") {
						pInfo(p_)->choosing_quest = "candour";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For Candour``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Whip of Truth`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For Candour?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
					else if (btn == "thesky") {
						pInfo(p_)->choosing_quest = "thesky";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Sky``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legendary Dragon Knight's Wings`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For The Sky?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
					else if (btn == "theowl") {
						pInfo(p_)->choosing_quest = "theowl";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest Of The Owl``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legendary Owl`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest Of The Owl?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
					else if (btn == "mech") {
						pInfo(p_)->choosing_quest = "mech";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest Of The Mech``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legendary Destroyer`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest Of The Mech?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
					/*
					else if (btn == "zodiac") {
						pInfo(p_)->choosing_quest = "zodiac";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest Of The Constellation``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `bFist Of Constellation`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest Of The Constellation?``|\nend_dialog|legendary_wizard|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
					*/
					else if (btn == "deliver") {
						cout << pInfo(p_)->lastquest << endl;
						if (pInfo(p_)->lastquest == "zodiac") pInfo(p_)->lastquest = "";
						// LEGEND QUEST STEP 1 STARTS HERE

						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 1) { // pasir
							int adaBrp = 0;
							modify_inventory(p_, 442, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 442, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_honor(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 1) {
							int adaBrp = 0;
							modify_inventory(p_, 4, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 4, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_fire(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 1) {
							int adaBrp = 0;
							modify_inventory(p_, 914, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 914, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_steel(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 1) {
							if (pInfo(p_)->quest_progress >= 5000) { // BREAK 50K BLOCK
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 1) {
							cout << pInfo(p_)->quest_progress << " 5" << endl;
							if (pInfo(p_)->quest_progress >= 50000) { // BREAK 50K BLOCK
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "Ruler Sword") {
									send_QuestView_kamish(p_);
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 1) {
							int adaBrp = 0;
							modify_inventory(p_, 684, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 684, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_blade(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 1) {
							int adaBrp = 0;
							modify_inventory(p_, 924, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 924, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_candour(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 1) {
							int adaBrp = 0;
							modify_inventory(p_, 5042, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 5042, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_thesky(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 1) {
							int adaBrp = 0;
							modify_inventory(p_, 8206, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 8206, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_theowl(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 1) {
							int adaBrp = 0;
							modify_inventory(p_, 9390, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 9390, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_mech(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 1) {
							int adaBrp = 0;
							modify_inventory(p_, 13064, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 13064, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_zodiac(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}

						// LEGEND QUEST STEP 2 STARTS HERE

						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 2) { // PORTRAIT
							int adaBrp = 0;
							modify_inventory(p_, 3818, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 100) adaBrp = 100 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 3818, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 100) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_honor(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 2) {
							int adaBrp = 0;
							modify_inventory(p_, 3494, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 3494, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 10) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_fire(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 2) {
							int adaBrp = 0;
							modify_inventory(p_, 2950, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 2950, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_steel(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 2) {
							if (pInfo(p_)->quest_progress >= 50000) { // PLANT 50K RARITY
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
							}
							else {
								goto GL;
							}
						}
						if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 2) {
							cout << pInfo(p_)->quest_progress << " 4" << endl;
							if (pInfo(p_)->quest_progress >= 50000) { // PLANT 50K RARITY
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "Ruler Sword") {
									send_QuestView_heavens(p_);
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 2) {
							int adaBrp = 0;
							modify_inventory(p_, 2204, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 2204, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 10) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_blade(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 2) {
							int adaBrp = 0;
							modify_inventory(p_, 4778, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 50) adaBrp = 50 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 4778, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 50) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_candour(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 2) {
							int adaBrp = 0;
							modify_inventory(p_, 3936, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 100) adaBrp = 100 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 3936, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 100) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_thesky(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 2) {
							int adaBrp = 0;
							modify_inventory(p_, 5032, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1500) adaBrp = 1500 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 5032, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1500) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_theowl(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 2) {
							int adaBrp = 0;
							modify_inventory(p_, 5044, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2000) adaBrp = 2000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 5044, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_mech(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						/*
						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 2) {
							int adaBrp = 0;
							modify_inventory(p_, 11620, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 11620, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_zodiac(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						*/
						// LEGEND QUEST STEP 3 STARTS HERE

						if (!(pInfo(p_)->lastquest == "Ruler Sword") && pInfo(p_)->quest_active && pInfo(p_)->quest_step == 3) {
							if (pInfo(p_)->quest_progress >= 100000) { // BREAK 100K BLOCK
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "candour") {
									send_QuestView_candour(p_);
								}
								else if (pInfo(p_)->lastquest == "thesky") {
									send_QuestView_thesky(p_);
								}
								else if (pInfo(p_)->lastquest == "theowl") {
									send_QuestView_theowl(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								/*
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								*/
								break;
							}
							else {
								goto GL;
							}
						}

						 if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 3) {
							 if (pInfo(p_)->quest_progress >= 2000000000) { // 4M GEMS
								 pInfo(p_)->blmNotip = true;
								 //pInfo(p_)->gems -= 2000000000;
								 {
									/* gamepacket_t p;
									 p.Insert("OnSetBux");
									 p.Insert(pInfo(p_)->gems);
									 p.Insert(0);
									 p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									 if (pInfo(p_)->supp >= 2) {
										 p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
									 }
									 p.CreatePacket(p_);*/

									 pInfo(p_)->quest_progress = 0;
									 pInfo(p_)->quest_step++;
									 packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									 gamepacket_t p2;
									 p2.Insert("OnTextOverlay");
									 p2.Insert("`9Quest step complete!!");
									 gamepacket_t p3;
									 p3.Insert("OnParticleEffect");
									 p3.Insert(48);
									 p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									 p2.CreatePacket(p_), p3.CreatePacket(p_);
									 send_QuestView_kamish(p_);
									 break;
								 }
							 }
							 else {
								 /*pInfo(p_)->quest_progress += pInfo(p_)->gems;
								 pInfo(p_)->gems = 0;*/
								 gamepacket_t p;
								 p.Insert("OnTextOverlay");
								 p.Insert("`9Thanks! Keep it coming!");
								 p.CreatePacket(p_);
								 break;
							 }
						 }
						 /*else {
							 goto GL;
						 }*/

						

						// LEGEND QUEST STEP 4 STARTS HERE

						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 4) { // DISPLAY BOX
							int adaBrp = 0;
							modify_inventory(p_, 1422, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1422, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 600) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_honor(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 4) {
							cout << pInfo(p_)->quest_progress << " 2" << endl;
							int DariSini = pInfo(p_)->quest_progress;
							int SampaiSini = 100000;
							if (DariSini >= SampaiSini) { // BREAK 100K BLOCK
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p2;
								p2.Insert("OnTextOverlay");
								p2.Insert("`9Quest step complete!!");
								gamepacket_t p3;
								p3.Insert("OnParticleEffect");
								p3.Insert(48);
								p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p2.CreatePacket(p_), p3.CreatePacket(p_);
								send_QuestView_kamish(p_);
								break;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("`9Thanks! Keep it coming!");
								p.CreatePacket(p_);
								break;
							}
						}
						if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 4) {
							int adaBrp = 0;
							modify_inventory(p_, 598, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 598, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 600) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_fire(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 4) {
							int adaBrp = 0;
							modify_inventory(p_, 254, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 254, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 600) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_steel(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}

							if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 10) {
								int cost = 2000000;
								if (pInfo(p_)->gems >= 2000000) { // 4M GEMS
									pInfo(p_)->gems -= cost;
									{
										gamepacket_t p;
										p.Insert("OnSetBux");
										p.Insert(pInfo(p_)->gems);
										p.Insert(0);
										p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) {
											p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										}
										p.CreatePacket(p_);
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									if (pInfo(p_)->lastquest == "heavens") {
										send_QuestView_heavens(p_);
									}
								}
							}
							else {
								goto GL;
							}
						}
							else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 4) {
							int adaBrp = 0;
							modify_inventory(p_, 604, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 604, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 600) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_blade(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 4) {
							int adaBrp = 0;
							modify_inventory(p_, 260, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 260, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_candour(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 4) {
							int adaBrp = 0;
							modify_inventory(p_, 1736, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1736, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_thesky(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 4) {
							int adaBrp = 0;
							modify_inventory(p_, 10160, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 50) adaBrp = 50 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10160, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 50) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_theowl(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 4) {
							int adaBrp = 0;
							modify_inventory(p_, 10786, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 600) adaBrp = 600 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10786, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 600) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_mech(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						/*
						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 4) {
							int adaBrp = 0;
							modify_inventory(p_, 10600, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10600, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_zodiac(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						*/
						//LEGEND QUEST STEP 5 STARTS HERE

						if (!(pInfo(p_)->lastquest == "Ruler Sword") && pInfo(p_)->quest_active && pInfo(p_)->quest_step == 5) {
							if (pInfo(p_)->quest_progress >= 40000) { // PLANT 40K RARITY
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "candour") {
									send_QuestView_candour(p_);
								}
								else if (pInfo(p_)->lastquest == "thesky") {
									send_QuestView_thesky(p_);
								}
								else if (pInfo(p_)->lastquest == "theowl") {
									send_QuestView_theowl(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								/*
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								*/
								break;
							}
							else {
								goto GL;
							}
						}

						
						if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 5) {
							if (pInfo(p_)->quest_progress >= 40000) { // PLANT 40K RARITY
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step = 1;
								pInfo(p_)->lastquest == "";
								int apalah;
								modify_inventory(p_, 13560, apalah = +1);
								equip_clothes(p_, 13560);
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(73);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								string name_ = pInfo(p_)->world;
								vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (px != worlds.end()) {
									World* world_ = &worlds[px - worlds.begin()];
									WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
									if (block_->fg == 1790) {
										block_->fg = 0;
										update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
									}
								}
								pInfo(p_)->quest_active = false;
								break;
							}
							else {
								goto GL;
							}
						}

						//LEGEND QUEST STEP 6 STARTS HERE

						if (pInfo(p_)->quest_active && pInfo(p_)->quest_step == 6) {
							if (pInfo(p_)->quest_progress >= 50000) { // BREAK 50K BLOCK
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "candour") {
									send_QuestView_candour(p_);
								}
								else if (pInfo(p_)->lastquest == "thesky") {
									send_QuestView_thesky(p_);
								}
								else if (pInfo(p_)->lastquest == "theowl") {
									send_QuestView_theowl(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								/*
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								*/
								break;
							}
							else {
								goto GL;
							}
						}

						//LEGEND QUEST STEP 7 STARTS HERE

						if (pInfo(p_)->quest_active && pInfo(p_)->quest_step == 3) {
							if (pInfo(p_)->quest_progress >= 10000) { // BREAK 10K BLOCK
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "candour") {
									send_QuestView_candour(p_);
								}
								else if (pInfo(p_)->lastquest == "thesky") {
									send_QuestView_thesky(p_);
								}
								else if (pInfo(p_)->lastquest == "theowl") {
									send_QuestView_theowl(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								/*
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								*/
								break;
							}
							else {
								goto GL;
							}
						}
						// LEGEND QUEST STEP 8 STARTS HERE

						if (pInfo(p_)->quest_active && pInfo(p_)->quest_step == 8) {
							if (pInfo(p_)->quest_progress >= 10000) { // EARN 10K XP
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "candour") {
									send_QuestView_candour(p_);
								}
								else if (pInfo(p_)->lastquest == "thesky") {
									send_QuestView_thesky(p_);
								}
								else if (pInfo(p_)->lastquest == "theowl") {
									send_QuestView_theowl(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								break;
							}
							else {
								goto GL;
							}
						}

						// LEGEND QUEST STEP 9 STARTS HERE

						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 784, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 784, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_honor(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 1114, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1114, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_fire(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 324, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 324, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_steel(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 678, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 800) adaBrp = 800 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 678, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 800) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_heavens(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 690, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 800) adaBrp = 800 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 690, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 800) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_blade(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 5202, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 5202, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 5) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_candour(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 1936, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 800) adaBrp = 800 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1936, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 800) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_thesky(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 10130, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10130, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 10) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_theowl(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 10332, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10332, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 10) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_mech(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 9) {
							int adaBrp = 0;
							modify_inventory(p_, 10604, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10604, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_zodiac(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						// LEGEND QUEST STEP 10 STARTS HERE

						if (pInfo(p_)->quest_active && pInfo(p_)->quest_step == 10) {
							int cost = 100000;
							if (pInfo(p_)->gems >= 100000) { // 100K GEMS
								pInfo(p_)->gems -= cost;
								{
									gamepacket_t p;
									p.Insert("OnSetBux");
									p.Insert(pInfo(p_)->gems);
									p.Insert(0);
									p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) {
										p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
									}
									p.CreatePacket(p_);
								}
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "candour") {
									send_QuestView_candour(p_);
								}
								else if (pInfo(p_)->lastquest == "thesky") {
									send_QuestView_thesky(p_);
								}
								else if (pInfo(p_)->lastquest == "theowl") {
									send_QuestView_theowl(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								break;
							}
							else {
								goto GL;
							}
						}

						// LEGEND QUEST STEP 11 STARTS HERE
						if (pInfo(p_)->quest_active && pInfo(p_)->quest_step == 11) {
							if (pInfo(p_)->quest_progress >= 100000) { // 100K BLOCKS DESTROYED
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "candour") {
									send_QuestView_candour(p_);
								}
								else if (pInfo(p_)->lastquest == "thesky") {
									send_QuestView_thesky(p_);
								}
								else if (pInfo(p_)->lastquest == "theowl") {
									send_QuestView_theowl(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								break;
							}
							else {
								goto GL;
							}
						}

						// LEGEND QUEST STEP 12 STARTS HERE
						if (pInfo(p_)->quest_active && pInfo(p_)->quest_step == 12) {
							if (pInfo(p_)->quest_progress >= 100) { // 100 Surgery or 100 geiger
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "candour") {
									send_QuestView_candour(p_);
								}
								else if (pInfo(p_)->lastquest == "thesky") {
									send_QuestView_thesky(p_);
								}
								else if (pInfo(p_)->lastquest == "theowl") {
									send_QuestView_theowl(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								break;
							}
							else {
								goto GL;
							}
						}

						// LEGEND QUEST STEP 13 STARTS HERE
						if (pInfo(p_)->quest_active && pInfo(p_)->quest_step == 13) {
							if (pInfo(p_)->lastquest == "candour" or pInfo(p_)->lastquest == "thesky" or pInfo(p_)->lastquest == "theowl") {
								if (pInfo(p_)->quest_progress >= 2500) { // 2500 lbs fishing
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									if (pInfo(p_)->lastquest == "candour") {
										send_QuestView_candour(p_);
									}
									if (pInfo(p_)->lastquest == "thesky") {
										send_QuestView_thesky(p_);
									}
									if (pInfo(p_)->lastquest == "theowl") {
										send_QuestView_theowl(p_);
									}
								}
							}

							if (pInfo(p_)->quest_progress >= 1000) { // 1000 PROVIDER
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								break;
							}
							else {
								goto GL;
							}
						}

						// LEGEND QUEST STEP 14 STARTS HERE
						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 14) { // GHC
							int adaBrp = 0;
							modify_inventory(p_, 1458, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1458, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_honor(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 14) {
							int adaBrp = 0;
							modify_inventory(p_, 1378, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1378, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 5) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_fire(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 14) {
							int adaBrp = 0;
							modify_inventory(p_, 1250, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1250, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_steel(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 14) {
							int adaBrp = 0;
							modify_inventory(p_, 12174, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 12174, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_heavens(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 14) {
							int adaBrp = 0;
							modify_inventory(p_, 810, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 20) adaBrp = 20 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 810, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 20) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_blade(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 14) {
							int adaBrp = 0;
							modify_inventory(p_, 5276, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 5276, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_candour(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 14) {
							int adaBrp = 0;
							modify_inventory(p_, 1824, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1824, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 10) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_thesky(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 14) {
							int adaBrp = 0;
							modify_inventory(p_, 10634, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10634, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_theowl(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 14) {
							int adaBrp = 0;
							modify_inventory(p_, 1662, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1662, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_mech(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 14) {
							int adaBrp = 0;
							modify_inventory(p_, 10606, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10606, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_zodiac(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						// LEGEND QUEST STEP 15 STARTS HERE
						if (pInfo(p_)->quest_active && pInfo(p_)->quest_step == 15) {
							if (pInfo(p_)->quest_progress >= 100000) { // 100K RARITY TREE HARVESTED
								pInfo(p_)->quest_progress = 0;
								pInfo(p_)->quest_step++;
								packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_), p2.CreatePacket(p_);
								if (pInfo(p_)->lastquest == "honor") {
									send_QuestView_honor(p_);
								}
								else if (pInfo(p_)->lastquest == "fire") {
									send_QuestView_fire(p_);
								}
								else if (pInfo(p_)->lastquest == "steel") {
									send_QuestView_steel(p_);
								}
								else if (pInfo(p_)->lastquest == "heavens") {
									send_QuestView_heavens(p_);
								}
								else if (pInfo(p_)->lastquest == "blade") {
									send_QuestView_blade(p_);
								}
								else if (pInfo(p_)->lastquest == "candour") {
									send_QuestView_candour(p_);
								}
								else if (pInfo(p_)->lastquest == "thesky") {
									send_QuestView_thesky(p_);
								}
								else if (pInfo(p_)->lastquest == "theowl") {
									send_QuestView_theowl(p_);
								}
								else if (pInfo(p_)->lastquest == "mech") {
									send_QuestView_mech(p_);
								}
								else if (pInfo(p_)->lastquest == "zodiac") {
									send_QuestView_zodiac(p_);
								}
								break;
							}
							else {
								goto GL;
							}
						}

						// LEGEND QUEST STEP 16 STARTS HERE
						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 1614, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1614, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_honor(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 394, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 394, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_fire(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 1602, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1602, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_steel(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 1460, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1460, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_heavens(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 2002, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 2002, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_blade(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 10678, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10678, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_candour(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 4302, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 4302, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_thesky(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 7416, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2) adaBrp = 2 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 7416, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_theowl(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 11076, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 11076, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_mech(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 16) {
							int adaBrp = 0;
							modify_inventory(p_, 10608, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10608, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_zodiac(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						// LEGEND QUEST STEP 17 STARTS HERE
						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 1680, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1680, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_honor(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 2212, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 2212, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 5) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_fire(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 1354, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1354, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 5) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_steel(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 818, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 100) adaBrp = 100 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 818, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 100) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_heavens(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 2908, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 25) adaBrp = 25 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 2908, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 25) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_blade(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 5650, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 5650, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_candour(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 7762, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 7762, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 5) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_thesky(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 11050, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 11050, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_theowl(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 9376, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 9376, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_mech(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 17) {
							int adaBrp = 0;
							modify_inventory(p_, 10610, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10610, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_zodiac(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						// LEGEND QUEST STEP 18 STARTS HERE
						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 1672, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1672, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 10) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_honor(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 1206, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 2) adaBrp = 2 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1206, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 2) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_fire(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 1396, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1396, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 5) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_steel(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 1674, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1674, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_heavens(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 10334, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10334, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_blade(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 394, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 394, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_candour(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 5754, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 5754, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_thesky(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 10724, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10724, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_theowl(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 11008, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 11008, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_mech(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 18) {
							int adaBrp = 0;
							modify_inventory(p_, 10612, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10612, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_zodiac(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						// LEGEND QUEST STEP 19 STARTS HERE
						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 1280, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1280, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_honor(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 3120, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 3120, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 10) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_fire(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 1492, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 5) adaBrp = 5 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1492, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 5) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_steel(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 5754, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 5754, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_heavens(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 94, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1000) adaBrp = 1000 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 94, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1000) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_blade(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 5078, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 3) adaBrp = 3 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 5078, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 3) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_candour(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 7728, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 10) adaBrp = 10 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 7728, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 10) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_thesky(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 10576, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10576, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_theowl(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 10806, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10806, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_mech(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 19) {
							int adaBrp = 0;
							modify_inventory(p_, 10614, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 10614, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step++;
									packet_(p_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_), p2.CreatePacket(p_);
									send_QuestView_zodiac(p_);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GL;
							}
						}
						// FINALLY LEGEND QUEST STEP 20
						if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p2(0, pInfo(p_)->netID);
											p2.Insert("OnNameChanged");
											pInfo(p_)->name_color = "`9";
											p2.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + " of Legend``");
											p2.CreatePacket(currentPeer);
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									pInfo(p_)->legend = true;
									pInfo(p_)->is_legend = true;
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									int amount = 1;
									modify_inventory(p_, 1782, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, 1782);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									int amount = 1;
									modify_inventory(p_, 1780, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, 1780);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									int amount = 1;
									modify_inventory(p_, 13560, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, 13560);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									int amount = 1;
									modify_inventory(p_, 2592, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, 2592);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									int amount = 1;
									modify_inventory(p_, 6026, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, 6026);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									int amount = 1;
									modify_inventory(p_, 7734, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, 7734);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									int amount = 1;
									modify_inventory(p_, 11142, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, 11142);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									break;
								}
							}
							else {
								goto GL;
							}
						}
						else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									int amount = 1;
									modify_inventory(p_, 11140, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, 11140);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									break;
								}
							}
							else {
								goto GL;
							}
						}
					
						//else if (pInfo(p_)->quest_active && pInfo(p_)->quest_step == 5) {
						//	
						//	if (pInfo(p_)->quest_progress >= 100000) { // BREAK 100K RARITY
						//		pInfo(p_)->quest_progress = 0;
						//		pInfo(p_)->quest_step++;
						//		if (pInfo(p_)->quest_progress >= 1) {
						//			gamepacket_t p;
						//			p.Insert("OnTextOverlay");
						//			p.Insert("`9Quest completed!!");
						//			p.CreatePacket(p_);
						//			SendCmd(p_, "/cheer", true);
						//			// WEAR CLOTHES
						//			equip_clothes(p_, 9510);
						//			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						//				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						//				if (pInfo(currentPeer)->world == pInfo(p_)->world) {
						//					gamepacket_t p3, p4;
						//					p3.Insert("OnParticleEffect");
						//					p3.Insert(73);
						//					p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
						//					p4.Insert("OnTalkBubble");
						//					p4.Insert(pInfo(p_)->netID);
						//					p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
						//					p4.Insert(0), p4.Insert(0);
						//					p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
						//					packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
						//				}
						//			}
						//			string name_ = pInfo(p_)->world;
						//			vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						//			if (px != worlds.end()) {
						//				World* world_ = &worlds[px - worlds.begin()];
						//				WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
						//				if (block_->fg == 1790) {
						//					block_->fg = 0;
						//					update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
						//				}
						//			}
						//			pInfo(p_)->quest_progress = 0;
						//			pInfo(p_)->quest_step = 1;
						//			pInfo(p_)->quest_active = false;
						//			pInfo(p_)->lastquest = "";
						//			break;
						//		}
						//	}
						//	else {
						//		goto GL;
						//		
						//	}
						//	}

						else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 20) {
							int adaBrp = 0;
							modify_inventory(p_, 1794, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->quest_progress + adaBrp > 1) adaBrp = 1 - pInfo(p_)->quest_progress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, 1794, removeItem);
								pInfo(p_)->quest_progress += adaBrp;
								if (pInfo(p_)->quest_progress >= 1) {
									int amount = 1;
									modify_inventory(p_, 8430, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, 8430);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnTalkBubble");
											p4.Insert(pInfo(p_)->netID);
											p4.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + " `5earned the achievement 'DARY! (Classic)'!");
											p4.Insert(0), p4.Insert(0);
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										}
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (px != worlds.end()) {
										World* world_ = &worlds[px - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * world_->width)];
										if (block_->fg == 1790) {
											block_->fg = 0;
											update_tile(p_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy, 0, false, true);
										}
									}
									pInfo(p_)->quest_progress = 0;
									pInfo(p_)->quest_step = 1;
									pInfo(p_)->quest_active = false;
									pInfo(p_)->lastquest = "";
									break;
								}
							}
							else {
								goto GL;
							}
						}
						// END OF LEGEND QUEST STEP LIST
					GL:
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("`9Good luck! You can do it!");
						p.CreatePacket(p_);
						break;
					}
					else if (btn == "give_up") {
						string currentQuest = "";
						if (pInfo(p_)->lastquest == "honor") currentQuest = "Quest For Honor";
						if (pInfo(p_)->lastquest == "fire") currentQuest = "Quest For Fire";
						if (pInfo(p_)->lastquest == "steel") currentQuest = "Quest Of Steel";
						if (pInfo(p_)->lastquest == "heavens") currentQuest = "Quest Of The Heavens";
						if (pInfo(p_)->lastquest == "Ruler Sword") currentQuest = "Quest Of The Ruler Sword";
						if (pInfo(p_)->lastquest == "blade") currentQuest = "Quest For The Blade";
						if (pInfo(p_)->lastquest == "candour") currentQuest = "Quest For Candour";
						if (pInfo(p_)->lastquest == "thesky") currentQuest = "Quest For The Sky";
						if (pInfo(p_)->lastquest == "theowl") currentQuest = "Quest Of The Owl";
						if (pInfo(p_)->lastquest == "mech") currentQuest = "Quest Of The Mech";
						//if (pInfo(p_)->lastquest == "zodiac") currentQuest = "Quest Of The Constellation";
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("\nadd_label_with_icon|big|`9Give UP On Quest|left|1790|\nadd_spacer|small|\nadd_textbox|`4Warning:`oGiving UP on this quest will delete your quest progress! Keep in mind!|\nadd_spacer|small|\nadd_smalltext|`6(Your current quest is: " + currentQuest + ")|\nadd_smalltext|`6(Your current step is: " + to_string(pInfo(p_)->quest_step) + "/20)|\nadd_spacer|small|\nadd_label|big|`oNow, When you read all this, Are you ABSOLUTELY sure you want to give up?|\nadd_spacer|small|\nend_dialog|legendary_wizard_give_up|`wNO!|`wYes, I am Sure!|\nadd_quick_exit|\n");
						p.CreatePacket(p_);
					}
					else if (pInfo(p_)->choosing_quest == "honor") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "honor";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_honor(p_);
						break;
					}
					else if (pInfo(p_)->choosing_quest == "fire") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "fire";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_fire(p_);
						break;
					}
					else if (pInfo(p_)->choosing_quest == "steel") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "steel";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_steel(p_);
						break;
					}
					else if (pInfo(p_)->choosing_quest == "heavens") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "heavens";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_heavens(p_);
						break;
					}
					else if (pInfo(p_)->choosing_quest == "Ruler Sword") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "Ruler Sword";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_kamish(p_);
						break;
					}
					else if (pInfo(p_)->choosing_quest == "blade") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "blade";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_blade(p_);
					}
					else if (pInfo(p_)->choosing_quest == "candour") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "candour";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_candour(p_);
					}
					else if (pInfo(p_)->choosing_quest == "thesky") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "thesky";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_thesky(p_);
					}
					else if (pInfo(p_)->choosing_quest == "theowl") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "theowl";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_theowl(p_);
					}
					else if (pInfo(p_)->choosing_quest == "mech") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "mech";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_mech(p_);
					}
					/*
					else if (pInfo(p_)->choosing_quest == "zodiac") {
						pInfo(p_)->quest_active = true;
						pInfo(p_)->lastquest = "zodiac";
						pInfo(p_)->quest_progress = 0;
						send_QuestView_zodiac(p_);
					}
					*/
				}
				if (wizardGiveUp) { //giveup legendary quest
					pInfo(p_)->quest_active = false;
					pInfo(p_)->lastquest = "";
					pInfo(p_)->quest_step = 1;
					pInfo(p_)->quest_progress = 0;
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("`9Goodbye!");
					p.CreatePacket(p_);
					break;
				}
			}
		}
	}
	else if (cch.find("s4tb") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "donate_rarity") {
					int count = atoi(infoDat[1].c_str());
					int got = 0;
					int item = pInfo(p_)->lastchoosenitem;
					modify_inventory(p_, pInfo(p_)->lastchoosenitem, got);
					if (got <= 0 || count <= 0 || item > items.size()) break;
					if (items[item].untradeable == 1 || item == 1424 || items[item].rarity >= 999 || items[item].rarity == 0 || items[item].rarity < 1 || count > got) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						if (count > got) p.Insert("You don't have that to give!");
						else p.Insert("I'm sorry, we can't accept items without rarity!");
						p.CreatePacket(p_);
					}
					else {
						auto peer = p_;
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							if (pInfo(peer)->staged < growch_prize.size()) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Thank you for your generosity!");
								p.CreatePacket(peer);
								world_->s4tb = { world_->s4tb.first + count, world_->s4tb.second + (count * items[item].rarity) };
								modify_inventory(p_, pInfo(p_)->lastchoosenitem, got = -count);
								pInfo(peer)->s4tb += (count * items[item].rarity);
								int donated_before = 0;
								readSpecificJSONData("database/growch.json", "total_donated", donated_before);
								updateSpecificJSONData("database/growch.json", "total_donated", static_cast<int>(donated_before + (count * items[item].rarity)));
								if (pInfo(p_)->s4tb >= growch_prize[pInfo(p_)->staged].second) {
									int got = 0;
									modify_inventory(p_, growch_prize[pInfo(p_)->staged].first, got = +1);
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Thanks for your charity, claimed 1 " + items[growch_prize[pInfo(peer)->staged].first].name + " from Stuff-4-Toys, your donation rarity reset.");
									p.CreatePacket(p_);
									int toys_before = 0;
									readSpecificJSONData("database/growch.json", "total_toys_given", toys_before); 
									toys_before++;
									updateSpecificJSONData("database/growch.json", "total_toys_given", static_cast<int>(toys_before));
									pInfo(p_)->s4tb -= growch_prize[pInfo(p_)->staged].second;
									if (pInfo(peer)->staged < growch_prize.size()) pInfo(peer)->staged++;
									else if (pInfo(peer)->staged == growch_prize.size()) pInfo(peer)->staged = 0;
								}
							}
						}
					}
				}
			}
		}
	}
	else if (cch.find("epoch_dialog") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				vector<bool> save;
				if (infoDat[0] == "iceage") {
					int x = atoi(get_embed(cch, "tilex").c_str());
					int y = atoi(get_embed(cch, "tiley").c_str());
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldBlock* block_ = &world_->blocks[x + (y * world_->width)];
						block_->epoch_state.first[0] = (atoi(infoDat[1].c_str()));
					}
				}
				if (infoDat[0] == "volcano") {
					int x = atoi(get_embed(cch, "tilex").c_str());
					int y = atoi(get_embed(cch, "tiley").c_str());
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldBlock* block_ = &world_->blocks[x + (y * world_->width)];
						block_->epoch_state.first[1] = (atoi(infoDat[1].c_str()));
					}
				}
				if (infoDat[0] == "islands") {
					int x = atoi(get_embed(cch, "tilex").c_str());
					int y = atoi(get_embed(cch, "tiley").c_str());
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldBlock* block_ = &world_->blocks[x + (y * world_->width)];
						block_->epoch_state.first[2] = (atoi(infoDat[1].c_str()));
					}
				}
				if (infoDat[0] == "cycleTime") {
					int x = atoi(get_embed(cch, "tilex").c_str());
					int y = atoi(get_embed(cch, "tiley").c_str());
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldBlock* block_ = &world_->blocks[x + (y * world_->width)];
						block_->epoch_state.second = (atoi(infoDat[1].c_str()));
					}
				}
				int x = atoi(get_embed(cch, "tilex").c_str());
				int y = atoi(get_embed(cch, "tiley").c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * world_->width)];
					if (block_->flags & 0x00400000) {
						world_->weather = get_epoch_weather(*block_);
						block_->epoch_cycle = time(nullptr) + (block_->epoch_state.second * 60);
						gamepacket_t t;
						t.Insert("OnSetCurrentWeather");
						t.Insert(world_->weather == 0 ? 4 : world_->weather);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								t.CreatePacket(currentPeer);
							}
						}
					}
				}
			}
		}
	}
	vector<string> a_ = explode("|", replace_str(cch, "\n", "|"));
	for (int i_ = 0; i_ < a_.size(); i_++) {
		if (a_[i_] == "dispshelf") {
			if (a_.size() != 13 and a_.size() != 14) break;
			if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
			int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * world_->width));
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (not items[t_].dshelf) break;
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks.at(block_->lock_origin);
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				for (int b_ = 0; b_ < a_.size(); b_++) {
					if (a_.at(b_) == "replace1" || a_.at(b_) == "replace2" || a_.at(b_) == "replace3" || a_.at(b_) == "replace4") {
						if (a_.size() >= (b_ + 1) - 1) {
							if (not isdigit(a_[b_ + 1][0])) break;
							int item_id = atoi(a_[b_ + 1].c_str());
							if (item_id <= 0 || item_id >= items.size()) break;
							if (items[item_id].untradeable) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("You can't display untradeable items.");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								return;
							}
							if (check_transmuted(p_, item_id)) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"),
									p.Insert(pInfo(p_)->netID),
									p.Insert("`4This item has been transmuted. You need to keep at least one item in your inventory!"),
									p.CreatePacket(p_);
								break;
							}
							if ((a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4) != 0) {
								int b = 1;
								if (modify_inventory(p_, (a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4), b) == 0) {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("Picked up 1 " + items[(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + ".");
									p.CreatePacket(p_);
									(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4) = 0;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("No room to take " + items[(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + ".");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									break;
								}
							}
							int b = -1;
							if (modify_inventory(p_, item_id, b) == 0) {
								(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4) = item_id;
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Put " + items[(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + " on display.");
								p.CreatePacket(p_);
							}
						}
					}
					else if (a_.at(b_) == "remove") {
						if (block_->shelf_1 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_1, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_1].name + ".");
								p.CreatePacket(p_);
								block_->shelf_1 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_1].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						if (block_->shelf_2 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_2, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_2].name + ".");
								p.CreatePacket(p_);
								block_->shelf_2 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_2].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						if (block_->shelf_3 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_3, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_3].name + ".");
								p.CreatePacket(p_);
								block_->shelf_3 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_3].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						if (block_->shelf_4 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_4, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_4].name + ".");
								p.CreatePacket(p_);
								block_->shelf_4 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_4].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						break;
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			return;
		}
		else if (a_[i_] == "pianowings") {
			int volume = atoi(a_[i_ + 2].c_str());
			string note = a_[i_ + 4];
			if (not isdigit(a_.at(i_ + 2).at(0))) break;
			if (volume > 100 || volume < 0) {
				if (volume > 100) pInfo(p_)->m_volume = 100;
				if (volume < 0) pInfo(p_)->m_volume = 0;
			}
			else if (note.find_first_not_of("ABCDEFG-#abcdefg") != string::npos) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMusical Wings``|left|10182|\nadd_spacer|small|\nadd_textbox|`4Notes must be from A to G!``|left|\nadd_button|manual|Instructions|noflags|0|0|\nadd_spacer|small|\nadd_text_input|volume|Volume|" + to_string(volume) + "|3|\nadd_text_input|text|Notes|" + note + "|50|\nadd_spacer|small|\nadd_button|resoterdefault|Restore to Default|noflags|0|0|\nend_dialog|pianowings|Cancel|Update|");
				p.CreatePacket(p_);
				break;
			}
			else {
				pInfo(p_)->m_volume = volume;
				pInfo(p_)->m_note = note;
				update_clothes(p_);
				Algorithm::send_bubble(p_, pInfo(p_)->netID, "Updated Musical Wings!");
			}
			return;
		}
		else if (a_[i_] == "sdbrespond") {
			if (a_.size() != 8) break;
			SendCmd(p_, "/go", true);
			return;
		}
		/*
		else if (a_[i_] == "buy_option") {
			for (int i = 0; i < a_.size(); i++) {
				ofstream write("debugtest.txt");
				write << format("Offset {}: {}", i, a_[i]) << endl;
				write.close();
			}
			break;
		}
		*/
		/*
		else if (a_[i_] == "nupirkti") {
			if (a_.size() != 17 and a_.size() != 14) break;
			if (not isdigit(a_[8][0]) or not isdigit(a_[11][0])) break;
			string item_name = a_[5];
			int item_id = atoi(a_[8].c_str());
			//int item_price = atoi(a_[11].c_str());
			if (a_.size() == 17) {
				SendCmd(p_, "/buy " + item_name, true);
				break;
			}
			if (pInfo(p_)->dev) {
				for (int i_ = 0; i_ < items.size(); i_++) {
					uint32_t item_ids = items[i_].id;
					if (items[i_].ori_name == items[item_id].ori_name) {
						int free_slots = get_free_slots(pInfo(p_));
						if (free_slots == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You don't have room in your backpack!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You don't have room in your backpack!");
								p.CreatePacket(p_);
							}
							break;
						}
						int a_ = 1;
						int jau_turi = 0;
						modify_inventory(p_, item_ids, jau_turi);
						a_ = 200 - jau_turi;
						if (modify_inventory(p_, item_ids, a_) == 0) {
							{
								PlayerMoving data_{};
								data_.x = pInfo(p_)->x + 10, data_.y = pInfo(p_)->y + 16;
								data_.packetType = 19, data_.plantingTree = 100;
								data_.punchX = item_ids, data_.punchY = pInfo(p_)->netID;
								int32_t to_netid = pInfo(p_)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								memcpy(raw + 8, &to_netid, 4);
								send_raw(p_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
							gamepacket_t p(0, pInfo(p_)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/cash_register.wav");
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`7[```9" + pInfo(p_)->tankIDName + " bought " + to_string(a_) + " " + items[item_ids].ori_name + " for 0 World Locks.```7]``");
								p.CreatePacket(p_);
							}
						}
						break;
					}
				}
			}
			break;
		}
		*/
		else if (a_[i_] == "sdbsend") {
			if (a_.size() != 11) break;
			if (not pInfo(p_)->supermod) break;
			string line_1 = a_[i_ + 2];
			string line_2 = a_[i_ + 4];
			string line_3 = a_[i_ + 6];
			if (line_1.empty() and line_2.empty() and line_3.empty()) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(p_)->netID);
				p.Insert("`5[`2I'm not wasting Growtokens on an empty broadcast!``]``");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(p_);
				break;
			}
			if (has_playmod(pInfo(p_), "Locke's Megaphone!")) {
				int time_ = 0;
				for (PlayMods peer_playmod : pInfo(p_)->playmods) {
					if (peer_playmod.id == 100) {
						time_ = peer_playmod.time - time(nullptr);
						break;
					}
				}
				packet_(p_, "action|log\nmsg|>> (" + Algorithm::to_playmod_time(time_) + "before you can broadcast again)", "");
				return;
			}
			if (has_playmod(pInfo(p_), "megaphone!")) {
				int time_ = 0;
				for (PlayMods peer_playmod : pInfo(p_)->playmods) {
					if (peer_playmod.id == 13) {
						time_ = peer_playmod.time - time(nullptr);
						break;
					}
				}
				packet_(p_, "action|log\nmsg|>> (" + Algorithm::to_playmod_time(time_) + "before you can broadcast again)", "");
				return;
			}
			string name_ = pInfo(p_)->world;
			bool jammed = true;
			int s_c = 10;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				int b = 0 - s_c;
				if (modify_inventory(p_, 1796, b) == 0) {
					{
						PlayMods new_playmod{};
						new_playmod.id = 13;
						new_playmod.time = time(nullptr) + 300;
						pInfo(p_)->playmods.push_back(new_playmod);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Broadcasting to ALL! (`$Megaphone!`` mod added)");
							p.CreatePacket(p_);
							packet_(p_, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
						}
					}
					if (pInfo(p_)->m_h != 1 and find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) {
						lastsbworld = pInfo(p_)->world;
						jammed = false;
					}
					gamepacket_t p;
					p.Insert("OnSDBroadcast");
					p.Insert(((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + (pInfo(p_)->is_datemaster ? " `4Datemaster" : "") + (pInfo(p_)->is_legend ? " of Legend" : "") + "``") + "\n" + (jammed ? "`4JAMMED!``" : pInfo(p_)->world) + "\n" + line_1 + "\n" + line_2 + "\n" + line_3);
					p.Insert(jammed ? 0 : 1);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio) continue;
						if (pInfo(currentPeer)->world.empty()) continue;
						p.CreatePacket(currentPeer);
					}
				}
				else {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You need " + to_string(s_c) + " Diamond Locks to do this!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You need " + to_string(s_c) + " Diamond Locks to do this!");
						p.CreatePacket(p_);
					}
				}
			}
			return;
		}
		else if (a_[i_] == "portrait") {
			try {
				if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
				int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * world_->width));
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items.at(t_).portrait) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks.at(block_->lock_origin);
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					} for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_.size() > b_ + 1) {
							if (a_.at(b_ + 1) == "chk1") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 1;
								}
							}
							else if (a_.at(b_ + 1) == "chk2") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 2;
								}
							}
							else if (a_.at(b_ + 1) == "chk3") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 3;
								}
							}
							else if (a_.at(b_ + 1) == "chk4") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 4;
								}
							}
							else if (a_.at(b_ + 1) == "chk5") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 5;
								}
							}
							else if (a_.at(b_ + 1) == "chk6") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 6;
								}
							}
							else if (a_.at(b_ + 1) == "chk7") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 7;
								}
							}
							else if (a_.at(b_ + 1) == "chk9") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 9;
								}
							}
							else if (a_.at(b_ + 1) == "chk11") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 11;
								}
							}
							else if (a_.at(b_ + 1) == "chk12") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 12;
								}
							}
							else if (a_.at(b_ + 1) == "chk14") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 14;
								}
							}
							else if (a_.at(b_ + 1) == "chk16") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 16;
								}
							}
							else if (a_.at(b_ + 1) == "chk18") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 18;
								}
							}
							else if (a_.at(b_ + 1) == "chk22") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 22;
								}
							}
							else if (a_.at(b_ + 1) == "chk27") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 27;
								}
							}
							else if (a_.at(b_ + 1) == "chk28") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 28;
								}
							}
						}
						if (a_.at(b_) == "erase") {
							int b = -4;
							if (modify_inventory(p_, 3492, b) == 0) {
								block_->portrait.c_expression = 1;
								block_->portrait.c_skin = 0;
								block_->portrait.c_face = 0;
								block_->portrait.c_head = 0;
								block_->portrait.c_hair = 0;
							}
						}
						else if (a_.at(b_) == "playerNetID") {
							if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) {
								if (a_.size() >= (b_ + 1) - 1) {
									if (not isdigit(a_.at(b_ + 1).at(0))) break;
									uint32_t netID = atoi(a_.at(b_ + 1).c_str());
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == netID) {
											int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
											{
												modify_inventory(p_, 3478, red);
												modify_inventory(p_, 3480, yellow);
												modify_inventory(p_, 3482, green);
												modify_inventory(p_, 3484, aqua);
												modify_inventory(p_, 3486, blue);
												modify_inventory(p_, 3488, purple);
												modify_inventory(p_, 3490, charcoal);
												modify_inventory(p_, 3492, varnish);
												if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
													red = -2, yellow = -2, green = -2, aqua = -2, blue = -2, purple = -2, charcoal = -2, varnish = -2;
													if (modify_inventory(p_, 3478, red) == 0 and modify_inventory(p_, 3480, yellow) == 0 and modify_inventory(p_, 3482, green) == 0
														and modify_inventory(p_, 3484, aqua) == 0 and modify_inventory(p_, 3486, blue) == 0 and modify_inventory(p_, 3488, purple) == 0
														and modify_inventory(p_, 3490, charcoal) == 0 and modify_inventory(p_, 3492, varnish) == 0) {
														block_->portrait.c_expression = 1;
														block_->portrait.c_skin = pInfo(currentPeer)->skin;
														block_->portrait.c_face = pInfo(currentPeer)->face;
														block_->portrait.c_head = pInfo(currentPeer)->hair;
														block_->portrait.c_hair = pInfo(currentPeer)->mask;
														block_->txt = (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name);
													}
												}
											}
											break;
										}
									}
								}
							}
						}
						else if (a_.at(b_) == "artname") {
							if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
							if (a_.size() >= (b_ + 1) - 1) {
								string txt = a_.at(b_ + 1);
								if (txt.size() > 60) break;
								replaceAll(txt, "`%", "");
								block_->txt = txt;
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					int alloc = alloc_(world_, block_);
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false); // fix merah skin
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world) {
							send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, p_);
					}
				}
			}
			catch (out_of_range) {
				return;
			}
			return;
		}
		else if (a_.at(i_) == "artcanvas") {
			try {
				if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
				int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * world_->width));
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items.at(t_).easel) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks.at(block_->lock_origin);
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					} for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_.at(b_) == "erase") {
							int b = -4;
							if (modify_inventory(p_, 3492, b) == 0) {
								block_->id = 0;
							}
						}
						else if (a_.at(b_) == "paint") {
							if (a_.size() >= (b_ + 1) - 1) {
								if (not isdigit(a_.at(b_ + 1).at(0))) break;
								int item_id = atoi(a_.at(b_ + 1).c_str());
								if (item_id <= 0 || item_id >= items.size()) break;
								int kiek_turi = 0;
								modify_inventory(p_, item_id, kiek_turi);
								if (kiek_turi == 0) break;
								{
									int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
									{
										modify_inventory(p_, 3478, red);
										modify_inventory(p_, 3480, yellow);
										modify_inventory(p_, 3482, green);
										modify_inventory(p_, 3484, aqua);
										modify_inventory(p_, 3486, blue);
										modify_inventory(p_, 3488, purple);
										modify_inventory(p_, 3490, charcoal);
										modify_inventory(p_, 3492, varnish);
										if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
											red = -2, yellow = -2, green = -2, aqua = -2, blue = -2, purple = -2, charcoal = -2, varnish = -2;
											if (modify_inventory(p_, 3478, red) == 0 and modify_inventory(p_, 3480, yellow) == 0 and modify_inventory(p_, 3482, green) == 0
												and modify_inventory(p_, 3484, aqua) == 0 and modify_inventory(p_, 3486, blue) == 0 and modify_inventory(p_, 3488, purple) == 0
												and modify_inventory(p_, 3490, charcoal) == 0 and modify_inventory(p_, 3492, varnish) == 0) {
												block_->id = item_id;
											}
										}
									}
								}
							}
						}
						else if (a_.at(b_) == "artname") {
							if (a_.size() >= (b_ + 1) - 1) {
								string txt = a_.at(b_ + 1);
								if (txt.size() > 60) break;
								replaceAll(txt, "`%", "");
								block_->txt = txt;
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					int alloc = alloc_(world_, block_);
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world) {
							send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, p_);
					}
				}
			}
			catch (out_of_range) {
				tayo_warn("Crash try by " + pInfo(p_)->tankIDName);
				return;
			}
			return;
		}
		else if (a_[i_] == "mannequin_edit") {
			if (a_.size() == 14) { // put item
				if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0]) or not isdigit(a_[i_ + 8][0])) break;
				int x_ = 0, y_ = 0, tile_ = 0;
				try {
					x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str()), tile_ = atoi(a_[i_ + 8].c_str());
				}
				catch (out_of_range) {
					return;
				}
				if (tile_ <= 0 || tile_ >= items.size()) break;
				if (items[tile_].blockType != CLOTHING or items[tile_].untradeable or items[tile_].clothType == ClothTypes::ANCES) return;
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items[t_].mannequin) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					}
					uint16_t current_mannequin_item = 0;
					switch (items[tile_].clothingType) {
					case 0: current_mannequin_item = block_->mannequin.c_hair;
						break;
					case 1: current_mannequin_item = block_->mannequin.c_shirt;
						break;
					case 2: current_mannequin_item = block_->mannequin.c_pants;
						break;
					case 3: current_mannequin_item = block_->mannequin.c_feet;
						break;
					case 4: current_mannequin_item = block_->mannequin.c_head;
						break;
					case 5: current_mannequin_item = block_->mannequin.c_hand;
						break;
					case 6: current_mannequin_item = block_->mannequin.c_back;
						break;
					case 7: current_mannequin_item = block_->mannequin.c_mask;
						break;
					case 8: current_mannequin_item = block_->mannequin.c_neck;
						break;
					case 9: {
						return;
					}
					} if (current_mannequin_item == tile_) {
						return;
					}
					else {
						if (current_mannequin_item != 0) {
							int b = 1;
							if (modify_inventory(p_, int(current_mannequin_item), b) != 0) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("`5[`2You don't have inventory space!``]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								return;
							}
						}
						int c_ = -1;
						if (modify_inventory(p_, tile_, c_) == 0) {
							switch (items[tile_].clothingType) {
							case 0: block_->mannequin.c_hair = tile_;
								break;
							case 1: block_->mannequin.c_shirt = tile_;
								break;
							case 2: block_->mannequin.c_pants = tile_;
								break;
							case 3: block_->mannequin.c_feet = tile_;
								break;
							case 4: block_->mannequin.c_head = tile_;
								break;
							case 5: block_->mannequin.c_hand = tile_;
								break;
							case 6: block_->mannequin.c_back = tile_;
								break;
							case 7: block_->mannequin.c_mask = tile_;
								break;
							case 8: block_->mannequin.c_neck = tile_;
								break;
							case 9: {
								return;
							}
							}
							gamepacket_t p(0, pInfo(p_)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/change_clothes.wav");
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							int alloc = alloc_(world_, block_);
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, p_, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(p_)->world) {
									p.CreatePacket(currentPeer);
									send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
					}
				}
			}
			else {
				if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
				int x_ = 0, y_ = 0;
				try {
					x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
				}
				catch (out_of_range) {
					return;
				}
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items[t_].mannequin) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					}
					bool clear_all = false;
					int fkthis = 0;
					for (int b_ = 0; b_ < a_.size(); b_++) {

						if (a_[b_].substr(0, 9) == "checkbox_") {
							if (a_.size() >= (b_ + 1) - 1) {
								vector<string> target_ = explode("_", a_[b_]);
								if (not isdigit(target_[1][0])) continue;
								int item_remove = atoi(target_[1].c_str());
								int aa = 1;
								if (item_remove <= 0 || item_remove >= items.size()) continue;
								if (a_[b_ + 1] == "1" or clear_all) {
									if (block_->mannequin.c_hair != item_remove and block_->mannequin.c_shirt != item_remove and block_->mannequin.c_pants != item_remove and block_->mannequin.c_feet != item_remove
										and block_->mannequin.c_head != item_remove and block_->mannequin.c_hand != item_remove and block_->mannequin.c_back != item_remove
										and block_->mannequin.c_mask != item_remove and block_->mannequin.c_neck != item_remove) return;
									if (modify_inventory(p_, item_remove, aa) == 0) {
										switch (items[item_remove].clothingType) {
										case 0: block_->mannequin.c_hair = 0;
											break;
										case 1: block_->mannequin.c_shirt = 0;
											break;
										case 2: block_->mannequin.c_pants = 0;
											break;
										case 3: block_->mannequin.c_feet = 0;
											break;
										case 4: block_->mannequin.c_head = 0;
											break;
										case 5: block_->mannequin.c_hand = 0;
											break;
										case 6: block_->mannequin.c_back = 0;
											break;
										case 7: block_->mannequin.c_mask = 0;
											break;
										case 8: block_->mannequin.c_neck = 0;
											break;
										}
									}
								}
							}
						}
						else if (a_[b_] == "buttonClicked") {
							if (a_.size() >= (b_ + 1) - 1) {
								if (a_[b_ + 1] == "clear") clear_all = true;
							}
						}
						else if (a_[b_] == "sign_text") {
							if (a_.size() >= (b_ + 1) - 1) {
								string txt = a_[b_ + 1];
								if (txt.size() > 128) break;
								replaceAll(txt, "`%", "");
								block_->txt = txt;
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					int alloc = alloc_(world_, block_);
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
				}
			}
			return;
		}
		else if (a_.at(i_) == "vip_edit") {
			try {
				if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
				int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * world_->width));
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items.at(t_).vipentrance) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty()) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks.at(block_->lock_origin);
							if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
						}
						else {
							break;
						}
					}
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_.at(b_).substr(0, 9) == "checkbox_") {
							vector<string> target_ = explode("_", a_.at(b_));
							if (target_.at(1) == "public") {
								if (not block_->limit_admins and a_.at(b_ + 1) == "1") {
									block_->limit_admins = true;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` has set a `$VIP Entrance`` to `$PUBLIC");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else if (block_->limit_admins and a_[b_ + 1] == "0") {
									block_->limit_admins = false;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` has set a `$VIP Entrance`` to `4PRIVATE``");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
							}
							else if (target_.size() == 2 and a_.at(b_ + 1) == "0") {
								int user_name = atoi(target_.at(1).c_str());
								if (find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
									block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), user_name), block_->admins.end());
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(GetNameByUid(user_name)+" was removed from a VIP List.");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->uid == user_name) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(currentPeer)->netID);
											if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`0";
											p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` has `4removed`` you from a VIP List in `w" + world_->name + "``.");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
							}
						}
						else if (a_.at(b_) == "playerNetID") {
							if (a_.size() >= (b_ + 1) - 1) {
								if (not isdigit(a_.at(b_ + 1).at(0))) break;
								uint32_t netID = atoi(a_.at(b_ + 1).c_str());
								if (netID == pInfo(p_)->netID and not pInfo(p_)->dev) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I'm already a VIP!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									break;
								}
								if (block_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("VIP Entrance has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name and pInfo(currentPeer)->netID == netID) {
										if (find(block_->admins.begin(), block_->admins.end(), pInfo(currentPeer)->uid) != block_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert((pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` is already on the VIP list.");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(p_);
											return;
										}
										block_->admins.push_back(pInfo(currentPeer)->uid);
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Put " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` on the VIP List.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert(pInfo(currentPeer)->tankIDName + " was added to a VIP List.");
											for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
												if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
												if (pInfo(currentPeer2)->world == world_->name) {
													p.CreatePacket(currentPeer2);
												}
											}
										}
										break;
									}
								}
								break;
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
				}
			}
			catch (out_of_range) {
				return;
			}
			return;
		}
		else if (a_[i_] == "crystal_exchange") {
			if (a_.size() != 14) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0]) or not isdigit(a_[11][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			int item_id = atoi(a_[11].c_str());
			if (item_id <= 0 || item_id >= items.size()) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::CRYSTAL) break;
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				vector<vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
				for (int i = 0; i < block_->crystals.size(); i++) {
					vector<int> c_ = block_->crystals[i];
					for (int a = 0; a < current_.size(); a++) {
						if (current_[a][0] == c_[0]) {
							current_[a][1] = block_->crystals[i][1];
							break;
						}
					}
				}
				for (vector<vector<int>> a_ : crystal_receptai) {
					if (a_[5][0] == item_id) {
						bool can_ = true;
						for (vector<int> b_ : a_) {
							for (int i = 0; i < current_.size(); i++) {
								if (current_[i][0] == b_[0] and current_[i][1] < b_[1]) {
									can_ = false;
									break;
								}
							} if (not can_) {
								break;
							}
						} if (can_) {
							if (pInfo(p_)->C_QuestActive && pInfo(p_)->C_QuestKind == 12 && pInfo(p_)->C_QuestProgress < pInfo(p_)->C_ProgressNeeded) {
								pInfo(p_)->C_QuestProgress++;
								if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
									pInfo(p_)->C_QuestProgress = pInfo(p_)->C_ProgressNeeded;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
								}
							}
							PlayerMoving data_{};
							data_.packetType = 0x11, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
							data_.YSpeed = 97, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
							{
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("The crystal shatters and drops " + items[a_[5][0]].name + "!");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);

								WorldDrop drop_block_{};
								drop_block_.id = a_[5][0], drop_block_.count = a_[5][1], drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
								dropas_(world_, drop_block_);
							}
							reset_(block_, x_, y_, world_);
							{
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
						}
						else {
							break;
						}
						break;
					}
				}
			}
			return;
		}
		/*
		else if (a_[i_] == "sellstuff") {
			if (a_.size() != 8) break;
			string itemChosen = a_[5];
			vector<string> cv = explode("_", itemChosen);
			if (cv.size() != 2) break;
			int itemID = atoi(cv[1].c_str()), amount = 0;
			int adaBrp = 0;
			modify_inventory(p_, itemID, adaBrp);
			// Selling Dirt
			if (itemID == 2 and adaBrp == 200) {
				amount = 200;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|1 World Lock|left|242|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
				p.CreatePacket(p_);
				break;
			}
			else if (itemID == 3 and adaBrp == 200) {
				amount = 200;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|4 World Lock|left|242|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
				p.CreatePacket(p_);
				break;
			}
			// Selling Lava
			else if (itemID == 4 and adaBrp == 200) {
				amount = 200;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|2 World Lock|left|242|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
				p.CreatePacket(p_);
				break;
			}
			else if (itemID == 5 and adaBrp == 200) {
				amount = 200;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|8 World Lock|left|242|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
				p.CreatePacket(p_);
				break;
			}
			// Selling Cave
			else if (itemID == 14 and adaBrp == 200) {
				amount = 200;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|1 World Lock|left|242|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
				p.CreatePacket(p_);
				break;
			}
			else if (itemID == 15 and adaBrp == 200) {
				amount = 200;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|4 World Lock|left|242|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
				p.CreatePacket(p_);
				break;
			}
			// Selling Rock
			else if (itemID == 10 and adaBrp == 200) {
				amount = 200;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|2 World Lock|left|242|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
				p.CreatePacket(p_);
				break;
			}
			else if (itemID == 11 and adaBrp == 200) {
				amount = 200;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|8 World Lock|left|242|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
				p.CreatePacket(p_);
				break;
			}
			else {
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("Janeway only intrested in buying 200pcs of item at once");
				p.CreatePacket(p_);
				break;
			}
		}
		else if (a_[i_] == "sellstuffconfirm") {
			if (a_.size() != 12) break;
			string checkItem = a_[5];
			string buttonClick = explode("\n", explode("buttonClicked|", cch)[1])[0];
			vector<string> buttonClicked = explode("|", buttonClick);
			if (buttonClicked[0] == "back") {
				int adaBrpDirt = 0, adaBrpDirtSeed = 0, adaBrpCave = 0, adaBrpCaveSeed = 0, adaBrpRock = 0, adaBrpRockSeed = 0, adaBrpLava = 0, adaBrpLavaSeed = 0;
				modify_inventory(p_, 2, adaBrpDirt), modify_inventory(p_, 3, adaBrpDirtSeed), modify_inventory(p_, 4, adaBrpLava), modify_inventory(p_, 5, adaBrpLavaSeed), modify_inventory(p_, 10, adaBrpRock), modify_inventory(p_, 11, adaBrpRockSeed), modify_inventory(p_, 14, adaBrpCave), modify_inventory(p_, 15, adaBrpCaveSeed);
				string dialog = "", availableItem = "";
				if (adaBrpDirt == 200) availableItem += "\nadd_button_with_icon|sell_2||staticBlueFrame|2|" + to_string(adaBrpDirt) + "|";
				if (adaBrpDirtSeed == 200) availableItem += "\nadd_button_with_icon|sell_3||staticBlueFrame|3|" + to_string(adaBrpDirtSeed) + "|";
				if (adaBrpCave == 200) availableItem += "\nadd_button_with_icon|sell_14||staticBlueFrame|14|" + to_string(adaBrpCave) + "|";
				if (adaBrpCaveSeed == 200) availableItem += "\nadd_button_with_icon|sell_15||staticBlueFrame|15|" + to_string(adaBrpCaveSeed) + "|";
				if (adaBrpRock == 200) availableItem += "\nadd_button_with_icon|sell_10||staticBlueFrame|10|" + to_string(adaBrpRock) + "|";
				if (adaBrpRockSeed == 200) availableItem += "\nadd_button_with_icon|sell_11||staticBlueFrame|11|" + to_string(adaBrpRockSeed) + "|";
				if (adaBrpLava == 200) availableItem += "\nadd_button_with_icon|sell_4||staticBlueFrame|4|" + to_string(adaBrpLava) + "|";
				if (adaBrpLavaSeed == 200) availableItem += "\nadd_button_with_icon|sell_5||staticBlueFrame|5|" + to_string(adaBrpLavaSeed) + "|";
				if (availableItem.empty()) {
					availableItem = "\nadd_textbox|It seems you don't have any items that i'm intrested to, come back later when you have thoose items.|left|";
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|\nadd_label_with_icon|big|`wOffer Something to Janeway``|left|12158|\nadd_spacer|small|\nadd_smalltext|`wHello there i am `9Janeway``<CR>Would you like to make a deal with me? if so please choose down below which item that you want to sell to me``|\nadd_textbox|I'm currently intrested on buying 200pcs of|left|\nadd_label_with_icon|small|Dirt|left|2|\nadd_smalltext|Dirt Seed|\nadd_seed_color_icons|2|\nadd_label_with_icon|small|Cave|left|14|\nadd_smalltext|Cave Seed|\nadd_seed_color_icons|14|\nadd_label_with_icon|small|Rock|left|10|\nadd_smalltext|Rock Seed|\nadd_seed_color_icons|10|\nadd_label_with_icon|small|Lava|left|4|\nadd_smalltext|Lava Seed|\nadd_seed_color_icons|4|\nadd_spacer|small|\nadd_textbox|Press item icon, you want to sell:|left|\nadd_spacer|small|" + availableItem + "\nadd_button_with_icon||END_LIST|noflags|0|0|\nend_dialog|sellstuff|Cancel||\nadd_quick_exit|\n");
				p.CreatePacket(p_);
				break;
			}
			else {
				vector<string> x = explode("_", checkItem);
				if (not isdigit(x[0][0]) and not isdigit(x[1][0])) break;
				int sellID = atoi(x[0].c_str()), sellAmount = atoi(x[1].c_str()), adaBrp = 0, removeItem = -sellAmount, itemPrice = 0;
				if (sellID == 2) itemPrice = 1;
				if (sellID == 3) itemPrice = 4;
				if (sellID == 4) itemPrice = 2;
				if (sellID == 5) itemPrice = 8;
				if (sellID == 10) itemPrice = 2;
				if (sellID == 11) itemPrice = 8;
				if (sellID == 14) itemPrice = 1;
				if (sellID == 15) itemPrice = 4;
				modify_inventory(p_, sellID, adaBrp);
				if (adaBrp != sellAmount) break;
				if (adaBrp == sellAmount) {
					if (modify_inventory(p_, sellID, removeItem) == 0) {
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage");
						p2.Insert("`1You`` traded " + to_string(sellAmount) + " " + items[sellID].ori_name + " to Janeway.``");
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`1Janeway`` traded " + to_string(itemPrice) + " World Lock to You.``");
						p2.CreatePacket(p_), p.CreatePacket(p_);
						modify_inventory(p_, 242, itemPrice);
					}
					{
						gamepacket_t p(1250, pInfo(p_)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/keypad_hit.wav");
						p.CreatePacket(p_), p.CreatePacket(p_);
					}
					break;
				}
			}
		}
		*/
		/*
		else if (a_[i_] == "search_option") {
			if (a_.size() != 11) break;
			string name_ = a_[5];
			string target_ = a_[8];
			vector<string> found = explode("_", target_);
			if (found.size() != 2) break;
			if (not isdigit(found[1][0])) break;
			int item_id = atoi(found[1].c_str());
			if (item_id <= 0 || item_id >= items.size()) break;
			for (int i_ = 0; i_ < items.size(); i_++) {
				uint32_t item_ids = items[i_].id;
				if (items[i_].ori_name == items[item_id].ori_name) {
					int adaBrp = 0;
					modify_inventory(p_, item_id, adaBrp);
					int count = 200 - adaBrp;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[i_].ori_name + "|left|" + to_string(item_ids) + "|\nadd_textbox|How many to take?|left|\nadd_text_input|item_amount||" + to_string(count) + "|3|\nembed_data|itemID|" + to_string(item_ids) + "\nembed_data|lastFind|" + name_ + "\nadd_spacer|small|\nadd_button|get_item|Confirm|\nadd_spacer|small|\nadd_button|back_searchItem|Back|noflags|0|0|");
					p.CreatePacket(p_);
					break;
				}
			}
		}
		else if (a_[i_] == "get_item") {
			if (a_.size() != 16) break;
			try {
				vector<string> sui = explode("|", cch);
				int itemCount = atoi(sui[14].c_str());
				int itemID = atoi(sui[5].c_str());
				//if (not isdigit(itemCount) || not isdigit(itemID)) break;
				if (itemCount >= 200) itemCount = 200;
				if (itemID <= 0 || itemID >= items.size()) break;
				for (int x_ = 0; x_ < items.size(); x_++) {
					uint32_t itemIDs = items[x_].id;
					if (items[x_].ori_name == items[itemID].ori_name) {
						int free_slots = get_free_slots(pInfo(p_));
						if (free_slots == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You don't have room in your backpack!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You don't have room in your backpack!");
								p.CreatePacket(p_);
							}
							break;
						}
						int adaBrp = 0;
						modify_inventory(p_, itemID, adaBrp);
						if (adaBrp + itemCount > 200 || adaBrp + itemCount <= 0) {
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("Couldn't add " + items[x_].ori_name + " to your inventory!");
							p.CreatePacket(p_);
							break;
						}
						else {
							modify_inventory(p_, itemID, itemCount);
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("Receieved " + items[x_].ori_name);
							p.CreatePacket(p_);
							PlayerMoving data_{};
							data_.x = pInfo(p_)->x + 10, data_.y = pInfo(p_)->y + 16;
							data_.packetType = 19, data_.plantingTree = 100;
							data_.punchX = itemIDs, data_.punchY = pInfo(p_)->netID;
							int32_t to_netid = pInfo(p_)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							memcpy(raw + 8, &to_netid, 4);
							send_raw(p_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[] raw;
							break;
						}
					}
				}
			}
			catch (exception& e) {
				tayo_warn(e.what());
			}
			break;
		}
		*/
		else if (a_[i_] == "weatherspcl") {
			if (a_.size() != 13 and a_.size() != 17 and a_.size() != 19) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				if (block_->fg != 5000 and block_->fg != 3832 and block_->fg != 3694) break;
				bool update_ = false;
				if (block_->fg == 3694 and a_.size() == 17) {
					if (not isdigit(a_[i_ + 8][0]) or not isdigit(a_[i_ + 10][0]) or not isdigit(a_[i_ + 12][0])) break;
					int r = atoi(a_[i_ + 8].c_str()), g = atoi(a_[i_ + 10].c_str()), b = atoi(a_[i_ + 12].c_str());
					if (r < 0 or g < 0 or b < 0 or r > 255 or g > 255 or b > 255) return;
					if (r < 40 and g < 40 and b < 40) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You can't make a heatwave that dark (one of the colors must be 40+)!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						return;
					}
					block_->r = r;
					block_->g = g;
					block_->b = b;
					update_ = true;
				}
				else if (block_->fg == 3832 and a_.size() == 19) {
					if (not isdigit(a_[i_ + 8][0])) break;
					uint32_t new_id = atoi(a_[i_ + 8].c_str());
					if (new_id <= items.size()) {
						if (block_->id != new_id) {
							block_->id = new_id;
							update_ = true;
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("`2LOL? WANNA TRY CRASH? `4TAYO LUCU");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
					}
					int new_gravity = atoi(a_[i_ + 10].c_str());
					if (new_gravity > 500) new_gravity = 500;
					if (new_gravity < -500) new_gravity = -500;
					if (block_->gravity != new_gravity) {
						block_->gravity = new_gravity;
						update_ = true;
					}
					if (not isdigit(a_[i_ + 12][0])) break;
					bool new_spin = atoi(a_[i_ + 12].c_str());
					if (block_->spin != new_spin) block_->spin = new_spin, update_ = true;
					if (not isdigit(a_[i_ + 14][0])) break;
					bool new_invert = atoi(a_[i_ + 14].c_str());
					if (block_->invert != new_invert) block_->invert = new_invert, update_ = true;
				}
				else if (block_->fg == 3832 and a_.size() == 17) {
					int new_gravity = atoi(a_[i_ + 8].c_str());
					if (new_gravity > 500) new_gravity = 500;
					if (new_gravity < -500) new_gravity = -500;
					if (block_->gravity != new_gravity) {
						block_->gravity = new_gravity;
						update_ = true;
					}
					if (not isdigit(a_[i_ + 10][0])) break;
					bool new_spin = atoi(a_[i_ + 10].c_str());
					if (block_->spin != new_spin) block_->spin = new_spin, update_ = true;
					if (not isdigit(a_[i_ + 12][0])) break;
					bool new_invert = atoi(a_[i_ + 12].c_str());
					if (block_->invert != new_invert) block_->invert = new_invert, update_ = true;
				}
				else {
					if (not isdigit(a_[i_ + 8][0])) break;
					uint32_t new_id = atoi(a_[i_ + 8].c_str());
					if (block_->fg == 5000 and items[new_id].blockType != BlockTypes::BACKGROUND) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("That's not a background!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						break;
					} if (block_->id != new_id) {
						block_->id = new_id;
						update_ = true;
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
				if (block_->enabled and update_) {
					gamepacket_t p;
					p.Insert("OnSetCurrentWeather");
					p.Insert(world_->weather == 0 ? 80 : world_->weather);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							p.CreatePacket(currentPeer);
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "itemaddedtosucker" or a_[i_] == "itemremovedfromsucker") {
			if (a_.size() != 13) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (owner_name != user_name and not pInfo(p_)->admin and not owner_name.empty()) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
					}
					else {
						break;
					}
				}
				if (not items[block_->fg].item_sucker) break;
				if (not isdigit(a_[i_ + 8][0])) break;
				if (t_ == 6948 and block_->pr >= (get_mag_size(pInfo(p_)->lock)) and a_[i_] != "itemremovedfromsucker" or t_ == 6946 and block_->pr >= (pInfo(p_)->lock == 8470 ? 10000 : 5000) and a_[i_] != "itemremovedfromsucker" or t_ == 5638 and block_->pr >= (get_mag_size(pInfo(p_)->lock)) and a_[i_] != "itemremovedfromsucker") break;
				int add_count = atoi(a_[i_ + 8].c_str());
				if (a_[i_] == "itemremovedfromsucker") {
					if (add_count > block_->pr) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You are removing what you dont have.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You are removing what you dont have.");
							p.CreatePacket(p_);
						}
						break;
					}
					int c_ = 0;
					modify_inventory(p_, block_->id, c_);
					add_count = (add_count + c_ > 200 ? (add_count > 200 ? 200 - c_ : (add_count > c_ ? 200 - add_count : 200 - c_)) : add_count);
					if (add_count > block_->pr or c_ + add_count > 200) break;
					int add_ = add_count;
					if (modify_inventory(p_, block_->id, add_) == 0) {
						block_->pr -= add_count;
					}
				}
				else {
					int c_ = 0;
					modify_inventory(p_, block_->id, c_);
					if (c_ < add_count) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You dont have " + items[block_->id].name);
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You dont have " + items[block_->id].name);
							p.CreatePacket(p_);
						}
						break;
					}
					int remove_count = add_count * -1;
					if (modify_inventory(p_, block_->id, remove_count) == 0) {
						block_->pr += add_count;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("Items added.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Items added.");
							p.CreatePacket(p_);
						}
					}
				}
				bool found_ = false;
				for (int i_ = 0; i_ < world_->machines.size(); i_++) {
					WorldMachines* machine_ = &world_->machines[i_];
					if (machine_->x == x_ and machine_->y == y_) {
						machine_->enabled = block_->enabled;
						machine_->target_item = block_->id;
						found_ = true;
						break;
					}
				} if (not found_) {
					//cout << "created new world machine" << endl;
					WorldMachines new_machine;
					new_machine.enabled = block_->enabled;
					new_machine.x = x_, new_machine.y = y_;
					new_machine.id = block_->fg;
					new_machine.target_item = block_->id;
					world_->machines.push_back(new_machine);
					if (find(t_worlds.begin(), t_worlds.end(), world_->name) == t_worlds.end()) {
						t_worlds.push_back(world_->name);
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				int alloc = alloc_(world_, block_);
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "itemsucker_block") {
			if (a_.size() != 13 and a_.size() != 16 and a_.size() != 14) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (owner_name != user_name and not pInfo(p_)->admin and not owner_name.empty() and a_[11] != "getplantationdevice" and a_.size() != 14) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName and a_[11] != "getplantationdevice" and a_.size() != 14) break;
					}
					else {
						break;
					}
				}
				if (not items[t_].item_sucker) break;
				if (a_.size() == 14 or a_[11] == "getplantationdevice") {
					if (block_->id != 0 and block_->fg == 5638) {
						if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and 
							items[block_->id].blockType != SEED and not items[block_->id].farmable or
							items[block_->id].rarity == 999 and items[block_->id].blockType != CONSUMABLE) {
							break;
						}
						if (pInfo(p_)->magnetron_x != 0 and pInfo(p_)->magnetron_y != 0 and pInfo(p_)->magnetron_x != x_ and pInfo(p_)->magnetron_x != y_) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You received a " + items[5640].name + ".");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You received a " + items[5640].name + ".");
								p.CreatePacket(p_);
							}
							{
								pInfo(p_)->magnetron_id = block_->id;
								pInfo(p_)->magnetron_x = x_;
								pInfo(p_)->magnetron_y = y_;
								gamepacket_t p;
								p.Insert("OnPlanterActivated");
								p.Insert(block_->id);
								p.Insert(x_);
								p.Insert(y_);
								p.CreatePacket(p_);
							}
						}
						else {
							int c_ = 0;
							modify_inventory(p_, 5640, c_);
							if (c_ == 0) {
								{
									int c_ = 1;
									if (modify_inventory(p_, 5640, c_) == 0) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You received a " + items[5640].name + ".");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You received a " + items[5640].name + ".");
											p.CreatePacket(p_);
										}
										{
											pInfo(p_)->magnetron_id = block_->id;
											pInfo(p_)->magnetron_x = x_;
											pInfo(p_)->magnetron_y = y_;
											gamepacket_t p;
											p.Insert("OnPlanterActivated");
											p.Insert(block_->id);
											p.Insert(x_);
											p.Insert(y_);
											p.CreatePacket(p_);
										}
									}
								}
							}
						}
					}
					break;
				}
				if (a_.size() == 13 and a_[i_ + 7] == "selectitem") {
					if (world_->owner_name.empty()) {
						Algorithm::send_bubble(p_, pInfo(p_)->netID, "You cant use this machine if your world not locked!");
						return;
					}
					if (not isdigit(a_[i_ + 8][0])) break;
					uint32_t putting_item = atoi(a_[i_ + 8].c_str());
					if (putting_item >= items.size() or putting_item < 0) break;
					if (t_ == 5638 || t_ == 9850 || t_ == 10266 || t_ == 6948 || t_ == 6946) {
						if (block_->pr != 0) break;
						if (t_ == 6948 && items[putting_item].blockType == BlockTypes::SEED or t_ == 6946 && items[putting_item].blockType != BlockTypes::SEED) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert((t_ == 6948 ? "You cannot store seeds in this machine." : "You can only store seeds in this machine."));
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert((t_ == 6948 ? "You cannot store seeds in this machine." : "You can only store seeds in this machine."));
								p.Insert("You cannot store seeds in this machine.");
								p.CreatePacket(p_);
							}
							break;
						}
						if (block_->pr != 0) break;
						if (items[putting_item].untradeable or items[putting_item].rarity == 999 or items[putting_item].blockType == BlockTypes::CLOTHING or items[putting_item].blockType == BlockTypes::CONSUMABLE or items[putting_item].blockType == BlockTypes::LOCK) {
							if (not items[putting_item].farmable || items[putting_item].blockType == BlockTypes::CLOTHING || items[putting_item].untradeable) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("This item is not compatible.");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("This item is not compatible.");
									p.CreatePacket(p_);
								}
								break;
							}
						}
						if (items[putting_item].blockType == BlockTypes::SUCKER) putting_item = 0;
						if (items[putting_item].id == 6016) putting_item = 0;
						if (items[putting_item].id == 6952) putting_item = 0;
						block_->id = putting_item;
						block_->enabled = true;
					}
				}
				else {
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_] == "retrieveitem") {
							if (block_->id != 0) {
								int c_ = 0;
								modify_inventory(p_, block_->id, c_);
								if (c_ < 200) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|\nadd_textbox|`wHow many `2" + items[block_->id].name + "`` would you like to remove?``|left||\nadd_text_input|itemtoremove|Amount:|" + (block_->pr + c_ > 200 ? (block_->pr > 200 ? to_string(200 - c_) : (block_->pr > c_ ? to_string(200 - block_->pr) : to_string(200 - c_))) : to_string(block_->pr)) + "|20|\nend_dialog|itemremovedfromsucker|Close|Retrieve|\nadd_spacer|small|");
									p.CreatePacket(p_);
								}
							}
							break;
						}
						else if (a_[b_] == "additem") {
							if (block_->id != 0) {
								int c_ = 0;
								modify_inventory(p_, block_->id, c_);
								if (c_ != 0) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|\nadd_smalltext|You have " + to_string(c_) + " `2" + items[block_->id].name + "`` in your backpack.|left|\nadd_textbox|`wHow many `2" + items[block_->id].name + "`` would you like to add?``|left|\nadd_text_input|itemtoadd|Amount:|" + 
										(block_->pr + c_ > (block_->fg == 5638 ? get_mag_size(pInfo(p_)->lock) :
											get_mag_size(pInfo(p_)->lock)) ? to_string((block_->fg == 5638 ? 
												get_mag_size(pInfo(p_)->lock) : (pInfo(p_)->lock == 8470 ? 10000 : 5000))
												- block_->pr) : to_string(c_)) + "|20|\nend_dialog|itemaddedtosucker|Close|Add|\nadd_spacer|small|");
									p.CreatePacket(p_);
								}
							}
							break;
						}
						else if (a_[b_] == "clearitem") {
							if (block_->id != 0 and block_->pr == 0) {
								if (block_->fg == 5638 and pInfo(p_)->magnetron_id != 0 and pInfo(p_)->magnetron_x == x_ and pInfo(p_)->magnetron_y == y_) {
									int c_ = 0;
									modify_inventory(p_, 5640, c_);
									if (c_ != 0) {
										c_ *= -1;
										modify_inventory(p_, 5640, c_);
										pInfo(p_)->magnetron_id = 0;
										pInfo(p_)->magnetron_x = 0;
										pInfo(p_)->magnetron_y = 0;
									}
								}
								block_->id = 0, block_->enabled = true;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_sucker(p_, world_, block_, x_, y_));
								p.CreatePacket(p_);
								break;
							}
							break;
						}
						else if (a_[b_].substr(0, 4) == "chk_") {
							vector<string> target_ = explode("_", a_[b_]);
							if (target_[1] == "enablesucking") {
								block_->enabled = (a_[b_ + 1] == "1" and not block_->enabled ? true : (a_[b_ + 1] == "0" and block_->enabled ? false : false));
							}
						}
					}
				}
				bool found_ = false;
				for (int i_ = 0; i_ < world_->machines.size(); i_++) {
					WorldMachines* machine_ = &world_->machines[i_];
					if (machine_->x == x_ and machine_->y == y_) {
						machine_->enabled = block_->enabled;
						machine_->target_item = block_->id;
						found_ = true;
						break;
					}
				} if (not found_) {
					//cout << "created new world machine" << endl;
					WorldMachines new_machine;
					new_machine.enabled = block_->enabled;
					new_machine.x = x_, new_machine.y = y_;
					new_machine.id = block_->fg;
					new_machine.target_item = block_->id;
					world_->machines.push_back(new_machine);
					if (find(t_worlds.begin(), t_worlds.end(), world_->name) == t_worlds.end()) {
						t_worlds.push_back(world_->name);
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				int alloc = alloc_(world_, block_);
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "autoactionblock") {
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;//tadi crash dibagian sini
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (owner_name != user_name and not pInfo(p_)->admin) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
					}
					else {
						break;
					}
				}
				switch (t_) {
				case 6950: case 6952:
				{
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_] == "refillfuel" && block_->pr < 8000) {
							if (not isdigit(a_[b_ + 1][0])) return;
							int target_amount = atoi(a_[b_ + 1].c_str());
							if (target_amount > pInfo(p_)->gems) target_amount = pInfo(p_)->gems;
							if (target_amount == 0) continue;
							if (block_->pr + target_amount > 8000) {
								target_amount = 8000 - block_->pr;
							}
							pInfo(p_)->gems -= target_amount;
							{
								gamepacket_t p;
								p.Insert("OnSetBux");
								p.Insert(pInfo(p_)->gems);
								p.Insert(0);
								p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
								if (pInfo(p_)->supp >= 2) {
									p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
								}
								p.CreatePacket(p_);
							}
							block_->pr += target_amount;
						}
						else if (a_[b_] == "selecttarget") {
							if (not isdigit(a_[b_ + 1][0])) return;
							uint32_t target_item = atoi(a_[b_ + 1].c_str());
							if (t_ == 6952) {
								if (items[target_item].blockType == BlockTypes::SEED) target_item--;
								if (target_item == 610 || target_item == 611 || target_item == 9380 || target_item == 9148 || target_item == 9386 || target_item == 5136 || target_item == 9600 || items[target_item].untradeable || items[target_item].rarity == 999 || target_item == 9380 || target_item == 5136 || target_item == 9600 || target_item == 9381 || target_item == 9387 || target_item == 9385 || target_item == 5137 || target_item == 9601) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
										p.CreatePacket(p_);
									}
									return;
								} if (items[target_item].blockType == BlockTypes::CLOTHING or items[target_item].properties & Property_Mod) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4NOPE!``");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`4NOPE!``");
										p.CreatePacket(p_);
									}
									return;
								}
							}
							else {
								if (items[target_item].blockType != BlockTypes::SEED) target_item++;
								if (target_item == 611 || items[target_item].rarity == 999 || target_item == 9148 || target_item == 9380 || target_item == 5136 || target_item == 9600 || target_item == 9381 || target_item == 9387 || target_item == 9385 || target_item == 5137 || target_item == 9601) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
										p.CreatePacket(p_);
									}
									return;
								}
								if (items[target_item].collisionType != 1 and items[target_item].blockType != BlockTypes::SEED) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4NOPE!``");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`4NOPE!``");
										p.CreatePacket(p_);
									}
									return;
								}
							}
							block_->id = target_item;
						}
					}
					{
						bool found_ = false;
						for (int i_ = 0; i_ < world_->machines.size(); i_++) {
							WorldMachines* machine_ = &world_->machines[i_];
							if (machine_->x == x_ and machine_->y == y_) {
								machine_->enabled = block_->enabled;
								machine_->target_item = block_->id;
								found_ = true;
								break;
							}
						} if (not found_) {
							//cout << "created new world machine" << endl;
							WorldMachines new_machine;
							new_machine.enabled = block_->enabled;
							new_machine.x = x_, new_machine.y = y_;
							new_machine.id = block_->fg;
							new_machine.target_item = block_->id;
							world_->machines.push_back(new_machine);
							if (find(t_worlds.begin(), t_worlds.end(), world_->name) == t_worlds.end()) {
								t_worlds.push_back(world_->name);
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					int alloc = alloc_(world_, block_);
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, p_);
					}
					break;
				}
				default:
					break;
				}
			}
			break;
		}
		else if (a_[i_] == "blaster") {
			if (a_.size() != 17) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0]) or not isdigit(a_[i_ + 8][0]) or not isdigit(a_[i_ + 10][0]) or not isdigit(a_[i_ + 12][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str()), often_ = atoi(a_[i_ + 8].c_str()), speed_ = atoi(a_[i_ + 10].c_str());

			if (speed_ > 250) speed_ = 250;
			if (speed_ < 10) speed_ = 10;
			if (often_ > 20) often_ = 20;
			if (often_ < 2) often_ = 2;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				if (not items[t_].trickster) break;
				block_->flags = (block_->flags & 0x00400000 and a_[i_ + 12] == "1" ? block_->flags ^ 0x00400000 : (a_[i_ + 12] == "0" ? block_->flags | 0x00400000 : block_->flags));
				bool found_ = false;
				block_->rate_of_fire = often_;
				block_->projectile_speed = speed_;
				for (int i_ = 0; i_ < world_->npc.size(); i_++) {
					WorldNPC* npc_ = &world_->npc[i_];
					if (npc_->x == x_ and npc_->y == y_) {
						npc_->enabled = (block_->flags & 0x00400000 ? true : false);
						npc_->rate_of_fire = often_;
						npc_->projectile_speed = speed_;
						npc_->kryptis = (block_->flags & 0x00200000 ? 180 : 0);
						found_ = true;
						break;
					}
				} if (not found_) {
					WorldNPC new_npc;
					new_npc.enabled = (block_->flags & 0x00400000 ? true : false);
					new_npc.x = x_, new_npc.y = y_;
					new_npc.id = block_->fg;
					new_npc.projectile_speed = speed_;
					new_npc.rate_of_fire = often_;
					new_npc.kryptis = (block_->flags & 0x00200000 ? 180 : 0);
					world_->npc.push_back(new_npc);
					if (find(t_worlds.begin(), t_worlds.end(), world_->name) == t_worlds.end()) {
						t_worlds.push_back(world_->name);
					}
				}
				block_->enabled = (block_->flags & 0x00400000 ? true : false);
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(p_)->netID);
				p.Insert("Settings updated!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "boombox_edit") {
			if (a_.size() != 15) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()]; 
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				if (not items[t_].can_be_changed_two_types) break;
				block_->flags = (block_->flags & 0x00800000 and a_[i_ + 8] == "0" ? block_->flags ^ 0x00800000 : (a_[i_ + 8] == "1" ? block_->flags | 0x00800000 : block_->flags));
				block_->flags = (block_->flags & 0x02000000 and a_[i_ + 10] == "0" ? block_->flags ^ 0x02000000 : (a_[i_ + 10] == "1" ? block_->flags | 0x02000000 : block_->flags));
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "switcheroo_edit") {
			if (a_.size() != 13) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				if (not items[t_].entrance and not items[t_].can_be_changed_to_public) break;
				block_->flags = (block_->flags & 0x00800000 and a_[i_ + 8] == "0" ? block_->flags ^ 0x00800000 : (a_[i_ + 8] == "1" ? block_->flags | 0x00800000 : block_->flags));
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "trade_item") {
			if (a_.size() != 10) break;
			if (not isdigit(a_[5][0]) or not isdigit(a_[8][0])) break;
			int item_id = atoi(a_[5].c_str()), item_count = atoi(a_[8].c_str()), c_ = 0;
			modify_inventory(p_, item_id, c_);
			if (c_ < item_count or c_ == 0) break;
			mod_trade(p_, atoi(a_[5].c_str()), atoi(a_[8].c_str()));
			break;
		}
		else if (a_[i_] == "door_edit") {
			if (a_.size() != 19 and a_.size() != 17) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::DOOR and items[t_].blockType != BlockTypes::PORTAL) break;
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->admin and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->uid) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				string door_name = a_[i_ + 8];
				string door_target = a_[i_ + 10];
				string door_id = a_[i_ + 12];
				if (a_.size() == 19) {
					string checkbox_locked = a_[i_ + 14];
					block_->open = (checkbox_locked == "0" ? false : true);
				}
				if (door_name.size() > 100) break;
				if (door_target.size() > 24) break;
				if (door_id.size() > 11) break;
				transform(door_target.begin(), door_target.end(), door_target.begin(), ::toupper);
				transform(door_id.begin(), door_id.end(), door_id.begin(), ::toupper);
				block_->door_destination = door_target, block_->door_id = door_id;
				block_->txt = door_name;
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + door_name.size() + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + door_name.size() + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "vending") {
			if (a_.size() != 14 and a_.size() != 13 and a_.size() != 20 and a_.size() != 17 and a_.size() != 19 and a_.size() != 23) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			if (a_.size() == 13 and not isdigit(a_[i_ + 8][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (abs(x_ * 32 - pInfo(p_)->x) > 15 || abs(y_ * 32 - pInfo(p_)->y) > 15) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(p_)->netID);
				p.Insert("Get closer!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(p_);
				break;
			}
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::VENDING) break;
				if (a_.size() == 19 or a_.size() == 23) {
					if (not isdigit(a_[i_ + 11][0])) break;
					int expectprice = atoi(a_[i_ + 8].c_str()), expectitem = atoi(a_[i_ + 11].c_str()), buycount = atoi(a_[i_ + 14].c_str());
					if (a_.size() == 23) {
						buycount = atoi(a_[i_ + 11].c_str()), expectprice = atoi(a_[i_ + 14].c_str()), expectitem = atoi(a_[i_ + 17].c_str());
					}
					if (expectprice != block_->pr) break;
					if (expectitem != block_->id) break;
					if (buycount < 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("NEGATIVE, DOES NOT COMPUTE");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
					if (buycount == 0) break;
					int normal_price = (block_->pr > 0 ? block_->pr : (block_->pr * -1));
					int actual_buy_count = (block_->pr > 0 ? buycount : (normal_price < buycount ? buycount / normal_price : normal_price / buycount) * (block_->pr * -1));
					if (actual_buy_count == 0 or actual_buy_count > block_->c_) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("There aren't enough available to fulfill your order!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("There aren't enough available to fulfill your order!");
							p.CreatePacket(p_);
						}
						break;
					}
					if (block_->pr < 0) {
						if (buycount < (block_->pr * -1)) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You have to buy at least 1 World Lock's worth.");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You have to buy at least 1 World Lock's worth.");
								p.CreatePacket(p_);
							}
							break;
						}
					}
					int my_wls = get_wls(p_);
					int cost_ = (block_->pr > 0 ? block_->pr * buycount : (normal_price < buycount ? buycount / normal_price : normal_price / buycount));
					if (cost_ > my_wls) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You can't afford that many!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You can't afford that many!");
							p.CreatePacket(p_);
						}
						break;
					}
					int has_alr = 0;
					modify_inventory(p_, block_->id, has_alr);
					if (has_alr + actual_buy_count > 200) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You don't have room in your backpack!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You don't have room in your backpack!");
							p.CreatePacket(p_);
						}
						break;
					}
					int free_slots = get_free_slots(pInfo(p_));
					if (free_slots == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You don't have room in your backpack!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You don't have room in your backpack!");
							p.CreatePacket(p_);
						}
						break;
					}
					if (a_.size() == 19) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(cost_) + "``) `8World Locks``|left|242|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(actual_buy_count) + "``) `2" + items[block_->id].ori_name + "``|left|" + to_string(block_->id) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nembed_data|verify|1\nembed_data|buycount|" + to_string(buycount) + "\nembed_data|expectprice|" + to_string(expectprice) + "\nembed_data|expectitem|" + to_string(expectitem) + "\nend_dialog|vending|Cancel|OK|");
						p.CreatePacket(p_);
						break;
					}
					int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
					int is_viso_worldlock = cost_;
					while (is_viso_worldlock >= 100) {
						is_viso_worldlock -= 100;
						diamond_lock++;
					}
					world_lock = is_viso_worldlock;
					int c_ = 0;
					modify_inventory(p_, 242, c_);
					int turi_world_lock = c_, t_w = c_ * -1;
					c_ = 0;
					modify_inventory(p_, 1796, c_);
					int turi_diamond_lock = c_, t_d = c_ * -1;
					while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
						turi_diamond_lock++, turi_world_lock -= 100;
					} if (diamond_lock > turi_diamond_lock) break;
					while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
						turi_diamond_lock--, turi_world_lock += 100;
					} if (world_lock > turi_world_lock) break;
					turi_world_lock -= world_lock, turi_diamond_lock -= diamond_lock;
					int a_ = actual_buy_count;
					if (modify_inventory(p_, block_->id, a_) == 0) {
						modify_inventory(p_, 242, t_w), modify_inventory(p_, 1796, t_d);
						modify_inventory(p_, 242, turi_world_lock), modify_inventory(p_, 1796, turi_diamond_lock);
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`7[```9" + pInfo(p_)->tankIDName + " bought " + to_string(actual_buy_count) + " " + items[block_->id].ori_name + " for " + to_string(cost_) + " World Locks.```7]``");
						gamepacket_t p2(0, pInfo(p_)->netID);
						p2.Insert("OnPlayPositioned");
						p2.Insert("audio/cash_register.wav");
						PlayerMoving data_{};
						data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
						data_.packetType = 19, data_.plantingTree = 100;
						data_.punchX = block_->id, data_.punchY = pInfo(p_)->netID;
						int32_t to_netid = pInfo(p_)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						memcpy(raw + 8, &to_netid, 4);
						block_->c_ -= actual_buy_count, block_->wl += cost_;
						if (block_->c_ <= 0) {
							block_->id = 0, block_->pr = 0;
						}
						PlayerMoving data_vending{};
						data_vending.packetType = 5, data_vending.punchX = x_, data_vending.punchY = y_, data_vending.characterState = 0x8;
						BYTE* v_ = packPlayerMoving(&data_vending, 112 + alloc_(world_, block_));
						BYTE* blc = v_ + 56;
						form_visual(blc, *block_, *world_, p_, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, v_, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw, v_, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, p_);
						}
						break;
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You don't have room in your backpack!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You don't have room in your backpack!");
						p.CreatePacket(p_);
					}
					break;
				}
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if ((owner_name != user_name and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() && world_->v_p == false) and not is_block_owner(p_, world_, block_)) {
					break;
				}
				bool access = block_access(p_, world_, block_, true);
				if (access == false) break;
				bool update_ = false;
				if (cch.find("chk_peritem|1") != string::npos and cch.find("chk_perlock|1") != string::npos) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You can't have it both ways.");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You can't have it both ways.");
						p.CreatePacket(p_);
					}
					break;
				} if (a_.size() == 20 or a_.size() == 17 or a_.size() == 14) {
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_].substr(0, 4) == "chk_") {
							vector<string> target_ = explode("_", a_[b_]);
							if (target_[1] == "peritem") {
								if (block_->pr < 0 and a_[b_ + 1] == "1") {
									block_->pr *= -1, update_ = true;
								}
							}
							else if (target_[1] == "perlock") {
								if (block_->pr > 0 and a_[b_ + 1] == "1") {
									if (block_->pr > block_->c_) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough in there for anyone to buy at that price!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You don't have enough in there for anyone to buy at that price!");
											p.CreatePacket(p_);
										}
										update_ = false;
										break;
									}
									block_->pr = block_->pr * -1;
									update_ = true;
								}
							}
						}
						else if (a_[b_] == "setprice") {
							int price_ = atoi(a_[b_ + 1].c_str());
							if (price_ == 0 or not isdigit(a_[b_ + 1][0]) and price_ >= 0) {
								block_->pr = 0;
								update_ = true;
							}
							else if (price_ < 0 or price_ > 20000) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("Well, that's a silly price.");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								break;
							}
							else {
								if (block_->pr < 0) {
									if (price_ > block_->c_) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough in there for anyone to buy at that price!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You don't have enough in there for anyone to buy at that price!");
											p.CreatePacket(p_);
										}
										update_ = false;
										break;
									} if (price_ > 200) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("That price is so low, nobody can carry a World Lock worth of items!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("That price is so low, nobody can carry a World Lock worth of items!");
											p.CreatePacket(p_);
										}
										break;
									}
								}
								block_->pr = (block_->pr < 0 ? price_ * -1 : price_);
								update_ = true;
							}
						}
						else if (a_[b_] == "addstock") {
							if (block_->id != 0) {
								int c_ = 0;
								modify_inventory(p_, block_->id, c_);
								int has_ = c_;
								c_ *= -1;
								if (modify_inventory(p_, block_->id, c_) == 0) {
									block_->c_ += has_;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Added " + to_string(has_) + " items to the machine.");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Added " + to_string(has_) + " items to the machine.");
										p.CreatePacket(p_);
									}
								}
							}
							update_ = false;
							break;
						}
						else if (a_[b_] == "withdraw") {
							if (is_block_owner(p_, world_, block_, true) or pInfo(p_)->tankIDName == world_->owner_name or find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) != world_->admins.end() && world_->v_p) {
								if (block_->wl != 0) {
									int a_ = block_->wl;
									if (get_free_slots(pInfo(p_)) < 2) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have room in your backpack!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You don't have room in your backpack!");
											p.CreatePacket(p_);
										}
										break;
									}
									if (modify_inventory(p_, 242, a_) != 0) {
										if (a_ < 100) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert("You don't have room in your backpack!");
											p.Insert(0), p.Insert(1);
											p.CreatePacket(p_);
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("You don't have room in your backpack!");
												p.CreatePacket(p_);
											}
											break;
										}
										int diamond_locks = a_ / 100;
										int world_locks = a_ - (diamond_locks * 100);
										int turi_dl = 0;
										modify_inventory(p_, 1796, turi_dl);
										int turi_wl = 0;
										modify_inventory(p_, 242, turi_wl);
										uint32_t grazinti = -1;
										if (diamond_locks > 200) {
											grazinti = diamond_locks - 200;
											diamond_locks = 200;
										}
										if (turi_wl + world_locks > 200 or turi_dl + diamond_locks > 200) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert("You don't have room in your backpack!");
											p.Insert(0), p.Insert(1);
											p.CreatePacket(p_);
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("You don't have room in your backpack!");
												p.CreatePacket(p_);
											}
											break;
										}
										int as2 = world_locks, as4 = diamond_locks;
										/*
										if (modify_inventory(p_, 242, world_locks) != 0 or
											modify_inventory(p_, 1796, diamond_locks) != 0)
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert("Free some spaces to withdraw this wls.");
											p.Insert(0), p.Insert(1);
											p.CreatePacket(p_);
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("Free some spaces to withdraw this wls.");
												p.CreatePacket(p_);
											}
											break;
										}
										else 
										*/
										modify_inventory(p_, 242, world_locks);
										modify_inventory(p_, 1796, diamond_locks);
										{
											block_->wl = grazinti != -1 ? grazinti * 100 : 0;
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											string collected_ = "";
											collected_ += (as4 != 0 ? "" + to_string(as4) + " Diamond Locks" : "");
											string aa_ = (not collected_.empty() ? " and " : " ");
											collected_ += (as2 != 0 ? aa_ + to_string(as2) + " World Locks" : "");
											collected_ += ".";
											p.Insert("You collected " + collected_);
											p.Insert(0), p.Insert(1);
											p.CreatePacket(p_);
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("You collected " + collected_);
												p.CreatePacket(p_);
											}
											break;
										}
										break;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You collected " + to_string(block_->wl) + " World Locks.");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You collected " + to_string(block_->wl) + " World Locks.");
											p.CreatePacket(p_);
										}
										block_->wl = 0;
									}
								}
								update_ = false;
							}
							break;
						}
						else if (a_[b_] == "upgradedigital") {
							if (is_block_owner(p_, world_, block_, true) or pInfo(p_)->tankIDName == world_->owner_name or find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) != world_->admins.end() && world_->v_p) {
								gamepacket_t p;
								if (pInfo(p_)->gems >= 4000) {
									pInfo(p_)->gems -= 4000;
									p.Insert("OnSetBux"), p.Insert(pInfo(p_)->gems), p.Insert(0), p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
									p.CreatePacket(p_);
									block_->fg = 9268;
									PlayerMoving data_{};
									data_.packetType = 17, data_.netID = 44, data_.YSpeed = 44, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
									BYTE* raw = packPlayerMoving(&data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
									update_ = false;
								}
								else p.Insert("OnTalkBubble"), p.Insert(pInfo(p_)->netID), p.Insert("You don't have enough gems!."), p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								break;
							}
						}
						else if (a_[b_] == "pullstock") {
							if (is_block_owner(p_, world_, block_, true) or pInfo(p_)->tankIDName == world_->owner_name or find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) != world_->admins.end() && world_->v_p) {
								int c_ = block_->c_;
								if (get_free_slots(pInfo(p_)) < 2) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have room in your backpack!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You don't have room in your backpack!");
										p.CreatePacket(p_);
									}
									break;
								}
								if (modify_inventory(p_, block_->id, c_) == 0) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You picked up " + to_string(block_->c_) + " " + items[block_->id].ori_name + ".");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You picked up " + to_string(block_->c_) + " " + items[block_->id].ori_name + ".");
										p.CreatePacket(p_);
									}
									block_->c_ = 0, block_->id = 0, block_->pr = 0;
								}
								else if (block_->c_ > 200) {
									int has_ = 0;
									modify_inventory(p_, block_->id, has_);
									int give_ = 200 - has_;
									block_->c_ -= give_;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You picked up " + to_string(give_) + " " + items[block_->id].ori_name + ", leaving " + to_string(block_->c_) + " in the machine.");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You picked up " + to_string(give_) + " " + items[block_->id].ori_name + ", leaving " + to_string(block_->c_) + " in the machine.");
										p.CreatePacket(p_);
									}
									modify_inventory(p_, block_->id, give_);
								}
								update_ = false;
								break;
							}
						}
					}
				}
				else {
					if (pInfo(p_)->tankIDName == world_->owner_name or is_block_owner(p_, world_, block_, true) or find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) != world_->admins.end() && world_->v_p) {
						if (block_->id != 0) break;
						int item_id = atoi(a_[i_ + 8].c_str());
						int c_ = 0, am_ = 0;
						modify_inventory(p_, item_id, c_);
						if (c_ == 0) break;
						if (items[item_id].untradeable or item_id == 1424 or item_id == 5816 or item_id == 242 or item_id == 1796 or item_id == 7188 or items[item_id].blockType == BlockTypes::FISH) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert((items[item_id].blockType == BlockTypes::LOCK or item_id == 1424 or item_id == 5816 ? "No no no." : "Can't put that in a " + items[block_->fg].name + "."));
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert((items[item_id].blockType == BlockTypes::LOCK or item_id == 1424 or item_id == 5816 ? "No no no." : "Can't put that in a " + items[block_->fg].name + "."));
								p.CreatePacket(p_);
							}
							break;
						}
						am_ = c_;
						c_ *= -1;
						if (modify_inventory(p_, item_id, c_) == 0) {
							block_->id = item_id;
							block_->c_ = am_;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("`7[``" + pInfo(p_)->tankIDName + " put `2" + items[item_id].ori_name + "`` in the " + items[block_->fg].name + ".`7]``");
							p.Insert(0);
							gamepacket_t p2;
							p2.Insert("OnConsoleMessage");
							p2.Insert("`7[``" + pInfo(p_)->tankIDName + " put `2" + items[item_id].ori_name + "`` in the " + items[block_->fg].name + ".`7]``");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									p.CreatePacket(currentPeer);
									p2.CreatePacket(currentPeer);
								}
							}
							{
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_vending(p_, world_, block_, x_, y_));
								p.CreatePacket(p_);
							}
						}
					}
				}
				if (update_) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert((block_->pr == 0 ? "`7[``" + pInfo(p_)->tankIDName + " disabled the Vending Machine.```7]``" : "`7[``" + pInfo(p_)->tankIDName + " changed the price of `2" + items[block_->id].ori_name + "`` to " + (block_->pr < 0 ? "`6" + to_string(block_->pr * -1) + " per World Lock.```7]``" : "`5" + to_string(block_->pr) + " World Locks each.```7]``")));
					p.Insert(0);
					gamepacket_t p2;
					p2.Insert("OnConsoleMessage");
					p2.Insert((block_->pr == 0 ? "`7[``" + pInfo(p_)->tankIDName + " disabled the Vending Machine.```7]``" : "`7[``" + pInfo(p_)->tankIDName + " changed the price of `2" + items[block_->id].ori_name + "`` to " + (block_->pr < 0 ? "`6" + to_string(block_->pr * -1) + " per World Lock.```7]``" : "`5" + to_string(block_->pr) + " World Locks each.```7]``")));
					PlayerMoving data_{};
					data_.packetType = 17;
					data_.netID = 44;
					data_.YSpeed = 44;
					data_.x = x_ * 32 + 16;
					data_.y = y_ * 32 + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							p.CreatePacket(currentPeer);
							p2.CreatePacket(currentPeer);
							packet_(currentPeer, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw;
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "displayblock") {
			if (a_.size() != 11) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::DISPLAY) break;
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if ((owner_name != user_name and not owner_name.empty() and not pInfo(p_)->dev) and not is_block_owner(p_, world_, block_)) {
					break;
				}
				if (a_.size() == 11) {
					int c_ = 1;
					if (modify_inventory(p_, block_->id, c_) == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You removed `5" + items[block_->id].name + "`` from the " + items[block_->fg].name + ".");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						block_->id = 0;
						{
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, p_, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You don't have room to pick that up!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
					}
				}
			}
			break;
		}
		else if (a_[i_] == "trade_confirm") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				cancel_trade(p_, true);
			}
			else if (a_[5] == "accept") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world) {
						if (pInfo(currentPeer)->netID == pInfo(p_)->trading_with and pInfo(p_)->netID == pInfo(currentPeer)->trading_with) {
							pInfo(p_)->accept_the_offer = true;
							if (pInfo(currentPeer)->accept_the_offer and pInfo(p_)->accept_the_offer) {
								string name_ = pInfo(p_)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									if (not trade_space_check(p_, currentPeer)) {
										cancel_trade(p_);
										return;
									}
									else if (not trade_space_check(currentPeer, p_)) {
										cancel_trade(p_);
										return;
									}
									bool c_ = false;
									for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
										if (c_) break;
										map<string, int>::iterator it;
										for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
											if (it->first == 1424 or it->first == 5816) {
												for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
													if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
														uint16_t id_ = world_->blocks[i_].fg;
														if (id_ == 202 or id_ == 204 or id_ == 206 or id_ == 4994) {
															cancel_trade(p_);
															return;
														}
													}
												}
												c_ = true;
												break;
											}
										}
									}
									c_ = false;
									for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
										if (c_) break;
										map<string, int>::iterator it;
										for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
											if (it->first == 1424 or it->first == 5816) {
												for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
													if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
														uint16_t id_ = world_->blocks[i_].fg;
														if (id_ == 202 or id_ == 204 or id_ == 206 or id_ == 4994) {
															cancel_trade(currentPeer);
															return;
														}
													}
												}
												c_ = true;
												break;
											}
										}
									}
									vector<string> traded_p;
									int time_out = 0;
									for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
										map<string, int>::iterator it;
										for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
											int c_ = it->second * -1;
											if (modify_inventory(p_, it->first, c_, true) == 0) {
												traded_p.push_back(to_string(it->second) + " " + items[it->first].name);
												if (it->first == 1424 or it->first == 5816) {
													transfer_world(world_, p_, currentPeer);
												}
												else {
													int c2_ = it->second;
													modify_inventory(currentPeer, it->first, c2_, true);
												}
												PlayerMoving data_{};
												time_out += 450;
												data_.packetType = 19, data_.plantingTree = (i_ + 1) * 450, data_.netID = pInfo(currentPeer)->netID;
												data_.punchX = it->first, data_.punchY = it->first;
												int32_t to_netid = pInfo(p_)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 3;
												memcpy(raw + 8, &to_netid, 4);
												for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
													if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
													if (pInfo(currentPeer2)->world == world_->name) {
														send_raw(currentPeer2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[]raw;
												{
													gamepacket_t p((i_ + 1) * 450, pInfo(p_)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(p_);
												}
												{
													gamepacket_t p((i_ + 1) * 450, pInfo(currentPeer)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(currentPeer);
												}
											}
										}
									}
									string traded_ = "";
									if (traded_p.size() != 0) {
										for (int i_ = 0; i_ < traded_p.size(); i_++) {
											if (traded_p.size() == i_ + 1)
												traded_ += traded_p[i_];
											else if (traded_p.size() - 2 == i_)
												traded_ += traded_p[i_] + " and ";
											else
												traded_ += traded_p[i_] + ", ";
										}
									}
									else {
										traded_ = "nothing";
									}
									traded_p.clear();
									for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
										map<string, int>::iterator it;
										for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
											int c_ = it->second * -1;
											if (modify_inventory(currentPeer, it->first, c_, true) == 0) {
												traded_p.push_back(to_string(it->second) + " " + items[it->first].name);
												if (it->first == 1424 or it->first == 5816) {
													transfer_world(world_, currentPeer, p_);
												}
												else {
													int c2_ = it->second;
													modify_inventory(p_, it->first, c2_, true);
												}
												PlayerMoving data_{};
												data_.packetType = 19, data_.plantingTree = (i_ + 1) * 450 + time_out, data_.netID = pInfo(p_)->netID;
												data_.punchX = it->first, data_.punchY = it->first;
												int32_t to_netid = pInfo(currentPeer)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 3;
												memcpy(raw + 8, &to_netid, 4);
												for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
													if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
													if (pInfo(currentPeer2)->world == world_->name) {
														send_raw(currentPeer2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[]raw;
												{
													gamepacket_t p((i_ + 1) * 450 + time_out, pInfo(p_)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(p_);
												}
												{
													gamepacket_t p((i_ + 1) * 450 + time_out, pInfo(currentPeer)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(currentPeer);
												}
											}
										}
									}
									string traded2_ = "";
									if (traded_p.size() != 0) {
										for (int i_ = 0; i_ < traded_p.size(); i_++) {
											if (traded_p.size() == i_ + 1)
												traded2_ += traded_p[i_];
											else if (traded_p.size() - 2 == i_)
												traded2_ += traded_p[i_] + " and ";
											else
												traded2_ += traded_p[i_] + ", ";
										}
									}
									else {
										traded2_ = "nothing";
									}
									{
										gamepacket_t p2;
										p2.Insert("OnConsoleMessage");
										p2.Insert("`1" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` traded " + traded2_ + " to " + pInfo(p_)->tankIDName + ".``");
										tradelog(pInfo(currentPeer)->tankIDName + " traded " + traded2_ + " to " + pInfo(p_)->tankIDName);
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`1" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` traded " + traded_ + " to " + pInfo(currentPeer)->tankIDName + ".``");
										tradelog(pInfo(p_)->tankIDName + " traded " + traded_ + " to " + pInfo(currentPeer)->tankIDName);
										string trade_logs = "";
										time_t currentTime;
										time(&currentTime);
										const auto localTime = localtime(&currentTime);
										const auto Hour = localTime->tm_hour;
										const auto Min = localTime->tm_min;
										const auto Sec = localTime->tm_sec;
										const auto Year = localTime->tm_year + 1900;
										const auto Day = localTime->tm_mday;
										const auto Month = localTime->tm_mon + 1;
										std::string asdasdasd;
										if (Sec < 10) asdasdasd = "0";
										std::string asdasdasd2;
										if (Min < 10) asdasdasd2 = "0";
										std::string asdasdasd3;
										if (Hour < 10) asdasdasd3 = "0";
										std::string asdasdasd31;
										if (Month < 10) asdasdasd31 = "0";
										std::string asdasdasd32;
										if (Day < 10) asdasdasd32 = "0";
										std::string asdasdasd33;
										if (Year < 10) asdasdasd33 = "0";
										pInfo(p_)->trade_history.push_back("`9You traded [" + traded_ + "] with `1" + pInfo(currentPeer)->tankIDName + "`9 in `2" + pInfo(p_)->world + "`9 and received [" + traded2_ + "] `0at " + asdasdasd3 + to_string(Hour) + ":" + asdasdasd2 + to_string(Min) + " on " + asdasdasd31 + to_string(Month) + "/" + asdasdasd32 + to_string(Day) + ".");
										pInfo(currentPeer)->trade_history.push_back("`9You traded [" + traded2_ + "] with `1" + pInfo(p_)->tankIDName + "`9 in `2" + pInfo(currentPeer)->world + "`9 and received [" + traded_ + "] `0at " + asdasdasd3 + to_string(Hour) + ":" + asdasdasd2 + to_string(Min) + " on " + asdasdasd31 + to_string(Month) + "/" + asdasdasd32 + to_string(Day) + ".");
										for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
											if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
											if (pInfo(currentPeer2)->world == world_->name) {
												p.CreatePacket(currentPeer2);
												p2.CreatePacket(currentPeer2);
											}
										}
									}
									{
										gamepacket_t p(1250, pInfo(currentPeer)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/keypad_hit.wav");
										p.CreatePacket(currentPeer), p.CreatePacket(p_);
									}
									//if (not pInfo(currentPeer)->invalid_data) save_player(pInfo(currentPeer), (f_saving_ ? false : true));
									//if (not pInfo(p_)->invalid_data) save_player(pInfo(p_), (f_saving_ ? false : true));
									pInfo(currentPeer)->block_trade = false, pInfo(currentPeer)->accept_the_offer = false, pInfo(currentPeer)->trade_accept = false, pInfo(currentPeer)->trading_with = -1, pInfo(currentPeer)->trade_items.clear();
									pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
								}
								return;
							}
							for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
								map<string, int>::iterator it;
								for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
									if (it->first == 1424 or it->first == 5816) {
										pInfo(p_)->accept_the_offer = false;
										send_trade_confirm_dialog(p_, currentPeer, true);
										{
											gamepacket_t p;
											p.Insert("OnTextOverlay");
											p.Insert("`6[``you must wait for the other player to accept first`6]``");
											p.CreatePacket(p_);
										}
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("`6[``You must accept first because you're selling a World Key`6]``");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(currentPeer);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`6[``You must accept first because you're selling a World Key`6]``");
											p.CreatePacket(currentPeer);
										}
										return;
									}
								}
							}
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("`6[``Trade accepted, waiting for other player to accept`6]``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`6[``Trade accepted, waiting for other player to accept`6]``");
								p.CreatePacket(p_);
							}
							{
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(currentPeer)->netID);
								p.Insert("`6[``Trade accepted by other player, waiting for you`6]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(currentPeer);
							}
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`6[``Trade accepted by other player, waiting for you`6]``");
								p.CreatePacket(currentPeer);
							}
							return;
						}
					}
				}
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("The other person left the trade!");
				p.CreatePacket(p_);
				pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
			}
			break;
		}
		else if (a_[i_] == "friends_remove_finish") {
			send_friends(p_);
			break;
		}
		else if (a_[i_] == "friends_remove") {
			if (a_.size() != 11) break;
			if (a_[8] == "back") {
				send_info_friend(p_, a_[5]);
				break;
			}
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				remove_friend(p_, world_, a_[5]);
			}
			break;
		}
		else if (a_[i_] == "mute_friend" or a_[i_] == "block_friend") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				send_info_friend(p_, pInfo(p_)->last_edit);
			}
			else if (a_[i_] == "mute_friend" and a_[5] == "ok") {
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (pInfo(p_)->friends[c_].name == pInfo(p_)->last_edit) {
						if (pInfo(p_)->friends[c_].mute)
							pInfo(p_)->friends[c_].mute = false;
						else
							pInfo(p_)->friends[c_].mute = true;
					}
				}
				send_info_friend(p_, pInfo(p_)->last_edit);
			}
			else if (a_[i_] == "block_friend" and a_[5] == "ok") {
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (pInfo(p_)->friends[c_].name == pInfo(p_)->last_edit) {
						if (pInfo(p_)->friends[c_].block_trade)
							pInfo(p_)->friends[c_].block_trade = false;
						else
							pInfo(p_)->friends[c_].block_trade = true;
					}
				}
				send_info_friend(p_, pInfo(p_)->last_edit);
			}
			break;
		}
		else if (a_[i_] == "friends_message") {
			if (a_.size() != 13) break;
			if (a_[8] == "back") {
				send_info_friend(p_, a_[5]);
			}
			else if (a_[8] == "send") {
				string message = explode("\n", explode("|", cch)[11])[0].c_str();
				SendCmd(p_, "/msg " + pInfo(p_)->last_wrenched + " " + message, true);
			}
			break;
		}
		else if (a_[i_] == "warplocation") {
			string worldname = "";
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->tankIDName == a_[5]) {
					worldname = pInfo(currentPeer)->world;
					break;
				}
			}
			if (worldname == "EXIT") {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(p_)->netID);
				p.Insert("`wPlayer isn't in world!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(p_);
				break;
			}
			else {
				if (worldname == pInfo(p_)->world) {
					gamepacket_t p2;
					p2.Insert("OnTalkBubble");
					p2.Insert(pInfo(p_)->netID);
					p2.Insert("You're in same world with player");
					p2.Insert(0), p2.Insert(0);
					p2.CreatePacket(p_);
					break;
				}
				gamepacket_t p3;
				p3.Insert("OnTalkBubble");
				p3.Insert(pInfo(p_)->netID);
				p3.Insert("`wWarping to Player...");
				p3.Insert(0), p3.Insert(0);
				p3.CreatePacket(p_);
				join_world(p_, worldname);
			}
			break;
		}
		else if (a_[i_] == "pullall") {
			if (not pInfo(p_)->mod or pInfo(p_)->admin) {
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("Can't `5pull``, that player is not standing in an area you control!");
				p.CreatePacket(p_);
				return;
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(p_)->world == pInfo(currentPeer)->world) {
					pInfo(currentPeer)->x = pInfo(p_)->x, pInfo(currentPeer)->y = pInfo(p_)->y;
					gamepacket_t p(0, pInfo(currentPeer)->netID);
					p.Insert("OnSetPos");
					p.Insert(pInfo(p_)->x, pInfo(p_)->y);
					p.CreatePacket(currentPeer);
					{
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("You were pulled by " + pInfo(p_)->tankIDName);
						p.CreatePacket(currentPeer);
					}
				}
			}
		}
		else if (a_[i_] == "banall") {
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			World* world_ = &worlds[p - worlds.begin()];
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(p_)->tankIDName == pInfo(currentPeer)->tankIDName or pInfo(p_)->world != pInfo(currentPeer)->world) continue;
				if (pInfo(currentPeer)->dev == 0 or pInfo(currentPeer)->admin == 0)
					world_->bannedPlayers.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));// world_->banned_player_uid.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` `4world bans`` " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` from `0" + pInfo(currentPeer)->world + "``!");
				if (pInfo(currentPeer)->dev == 0 or pInfo(currentPeer)->admin == 0) {
					p.CreatePacket(currentPeer);
					p.CreatePacket(p_);
					//world_->banned_player_uid.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					world_->bannedPlayers.push_back(make_pair(pInfo(currentPeer)->uid, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					packet_(currentPeer, "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0"); exit_(currentPeer);
				}
			}
		}
		else if (a_[i_] == "friends_edit" || a_[i_] == "friends_message") {
			if (a_.size() != 11) break;
			if (a_[8] == "back") {
				send_friends(p_);
			}
			else if (a_[8] == "remove" or a_[8] == "back") {
				edit_friend(p_, a_[5], (a_[8] == "back" ? true : false));
			}
			else if (a_[8] == "goto") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->uid == GetUidByName(a_[5])) {
						for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
							if (pInfo(currentPeer)->friends[c_].uid == pInfo(p_)->uid) {
								if (pInfo(currentPeer)->show_location_) {
									if (pInfo(currentPeer)->world.empty()) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Hmm, my friend isn't in a world right now.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
									else if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
									join_world(p_, pInfo(currentPeer)->world);
								}
								break;
							}
						}
					}
				}
			}
			else if (a_[8] == "msg") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`5Message to ``" + GetNameByUid(GetUidByName(a_[5])) + "|left|660|\nadd_spacer|small|\nadd_text_input|text|||80|left|\nadd_spacer|small|\nembed_data|friendID|" + to_string(GetUidByName(a_[5])) + "\nadd_button|send|`5Send``|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_message|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_[8] == "mute" or a_[8] == "trade_block") {
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (pInfo(p_)->friends[c_].uid == GetUidByName(a_[5])) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						if (a_[8] == "mute") {
							if (not pInfo(p_)->friends[c_].mute)
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Mute`` " + a_[5] + "? You will not receive any messages from this player until you unmute, consider this /ignore a friend|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mute_friend|||\nadd_quick_exit|");
							else
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Un Mute`` " + a_[5] + "? You will receive any messages from this player until you mute.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mute_friend|||\nadd_quick_exit|");
						}
						else {
							if (not pInfo(p_)->friends[c_].block_trade)
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Disable Trade`` with " + a_[5] + "? You will not receive any trade request until you enable trading again.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|block_friend|||\nadd_quick_exit|");
							else
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Enable Trade`` with " + a_[5] + "? You will receive any trade request until you disable trading again.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|block_friend|||\nadd_quick_exit|");
						}
						p.CreatePacket(p_);
					}
				}
			}
			break;
		}
		else if (a_[i_] == "friends_options") {
			if (a_.size() != 12) break;
			if (a_[7] == "checkbox_public") {
				if (not pInfo(p_)->show_location_ and a_[8] == "1") {
					pInfo(p_)->show_location_ = true;
				}
				else if (pInfo(p_)->show_location_ and a_[8] == "0") {
					pInfo(p_)->show_location_ = false;
				}
			}
			if (a_[9] == "checkbox_notifications") {
				if (not pInfo(p_)->show_friend_notifications_ and a_[10] == "1") {
					pInfo(p_)->show_friend_notifications_ = true;
				}
				else if (pInfo(p_)->show_friend_notifications_ and a_[10] == "0") {
					pInfo(p_)->show_friend_notifications_ = false;
				}
			}
			if (a_[5] == "back") {
				vector<int> friends_;
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					friends_.push_back(pInfo(p_)->friends[c_].uid);
				}
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (find(friends_.begin(), friends_.end(), pInfo(currentPeer)->uid) != friends_.end()) {
						send_friends(p_, true);
						return;
					}
				}
				send_friends(p_);
			}
			break;
		}
		else if (a_[i_] == "mute_all_friends" or a_[i_] == "remove_all_friends" or a_[i_] == "block_all_friends") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				send_all_edit_friends(p_);
				break;
			}
			if (a_[5] == "close")
				break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (find(pInfo(p_)->last_friends_selection.begin(), pInfo(p_)->last_friends_selection.end(), c_) != pInfo(p_)->last_friends_selection.end()) {
						if (a_[i_] == "mute_all_friends") {
							if (pInfo(p_)->friends[c_].mute)
								pInfo(p_)->friends[c_].mute = false;
							else
								pInfo(p_)->friends[c_].mute = true;
						}
						else if (a_[i_] == "block_all_friends") {
							if (pInfo(p_)->friends[c_].block_trade)
								pInfo(p_)->friends[c_].block_trade = false;
							else
								pInfo(p_)->friends[c_].block_trade = true;
						}
						else if (a_[i_] == "remove_all_friends") {
							remove_friend(p_, world_, pInfo(p_)->friends[c_].name, false);
						}
					}
				}
				send_all_edit_friends(p_);
			}
			break;
		}
		else if (a_[i_] == "all_friends") {
			if (a_.size() < 10) break;
			if (a_[5] == "back") {
				vector<int> friends_;
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					friends_.push_back(pInfo(p_)->friends[c_].uid);
				} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (find(friends_.begin(), friends_.end(), pInfo(currentPeer)->uid) != friends_.end()) {
						send_friends(p_, true);
						return;
					}
				}
				send_friends(p_);
				break;
			}
			pInfo(p_)->last_friends_selection.clear();
			string action_ = a_[5];
			try {
				for (int b_ = 0; b_ < a_.size(); b_++) {
					if (a_.at(b_).substr(0, 3) == "cf_") {
						if (a_.at(b_ + 1) == "1")
							pInfo(p_)->last_friends_selection.push_back(atoi(explode("_", a_.at(b_)).at(1).c_str()));
					}
				}
			}
			catch (out_of_range) {
				break;
			}
			if (pInfo(p_)->last_friends_selection.size() == 0) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oYou have not selected any friends|left|\nadd_spacer|small|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|remove_all_friends|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (action_ == "mute_multi_friends")
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oAre you sure you want to `4mute`` " + to_string(pInfo(p_)->last_friends_selection.size()) + " friends?|left|\nadd_spacer|small|\nadd_button|confirm|`wYes``|noflags|0|0|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|mute_all_friends|||\nadd_quick_exit|");
				else if (action_ == "block_multi_friends")
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oAre you sure you want to `4block trade`` " + to_string(pInfo(p_)->last_friends_selection.size()) + " friends?|left|\nadd_spacer|small|\nadd_button|confirm|`wYes``|noflags|0|0|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|block_all_friends|||\nadd_quick_exit|");
				else
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oAre you sure you want to `4remove`` " + to_string(pInfo(p_)->last_friends_selection.size()) + " friends?|left|\nadd_spacer|small|\nadd_button|confirm|`wYes``|noflags|0|0|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|remove_all_friends|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "leave_guild") {
			if (pInfo(p_)->guild_id == 0) break;
			uint32_t guild_id = pInfo(p_)->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				leave_guild(p_);
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Leave Guild``|left|1366|\nadd_spacer|small|\nadd_textbox|`o You are no longer in the guild.|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog||||\nadd_quick_exit|");
				p.CreatePacket(p_);
				if (guild_information->guild_world == pInfo(p_)->world) {
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p_w != worlds.end()) {
						World* world_ = &worlds[p_w - worlds.begin()];
						int x_ = 0, y_ = 0;
						int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
							if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
								uint16_t id_ = world_->blocks[i_].fg;
								if (id_ == 5814) {
									x_ = i_ % xSize;
									y_ = i_ / xSize;
									break;
								}
							}
						}
						WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, p_, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == guild_information->guild_world) {
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
					}
				}
			}
			break;
		}
		else if (a_[i_] == "show_guild_logs") {
			if (a_.size() != 8) break;
			if (pInfo(p_)->guild_id == 0) break;
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guildpage") {
			if (a_.size() != 10) break;
			if (a_[5] == "changestatementsubmit") {
				string new_stat = a_[8];
				if (new_stat.size() < 6 or new_stat.size() > 24) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(get_guild_statement_edit(p_, "`1You need to enter at least `$6 characters`` to add a guild statement!``"));
					p.CreatePacket(p_);
					break;
				}
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (new_stat == guild_information->guild_description) break;
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							my_rank = member_search.role_id;
							break;
						}
					}
					if (my_rank <= 2) break;
					guild_information->guild_description = new_stat;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(get_guild_info(p_));
					p.CreatePacket(p_);
					create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `wchanged guild statement to `$" + new_stat + "``", 658);
				}
			}
			break;
		}
		else if (a_[i_] == "guild_members_options") {
			if (a_.size() != 12) break;
			if (pInfo(p_)->guild_id == 0) break;
			string public_ = a_[8];
			if (public_ != "0" and public_ != "1") break;
			string notifications_ = a_[10];
			if (notifications_ != "0" and notifications_ != "1") break;
			uint32_t guild_id = pInfo(p_)->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
					GuildMember* member_search = &guild_information->guild_members[i_];
					if (member_search->member_name == pInfo(p_)->tankIDName) {
						if (not member_search->public_location and public_ == "1") {
							member_search->public_location = true;
						}
						else if (member_search->public_location and public_ == "0") {
							member_search->public_location = false;
						}
						{
							if (not member_search->show_notifications and notifications_ == "1") {
								member_search->show_notifications = true;
							}
							else if (member_search->show_notifications and notifications_ == "0") {
								member_search->show_notifications = false;
							}
						}
						break;
					}
				}
			}
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guildmembers") {
			if (a_.size() != 8) break;
			if (pInfo(p_)->guild_id == 0) break;
			if (a_[5] == "guild_members_all") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_, true));
				p.CreatePacket(p_);
			}
			else if (a_[5] == "guild_members_options") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							string notify_ = (member_search.show_notifications ? "1" : "0");
							string public_ = (member_search.public_location ? "1" : "0");
							string guild_foreground = (guild_information->guild_mascot[0] == 0 ? "5814" : to_string(guild_information->guild_mascot[0]));
							string guild_background = (guild_information->guild_mascot[1] == 0 ? "0" : to_string(guild_information->guild_mascot[1]));
							p.Insert("set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Member Options``|left|" + guild_background + "|" + guild_foreground + "|1.0|0|\nadd_spacer|small|\nadd_checkbox|checkbox_public|Show location to guild members|" + public_ + "\nadd_checkbox|checkbox_notifications|Show guild member notifications|" + notify_ + "\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_members_options|||\nadd_quick_exit|");
							p.CreatePacket(p_);
							break;
						}
					}
				}
			}
			else if (a_[5] == "changestatement") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_statement_edit(p_));
				p.CreatePacket(p_);
			}
			else if (a_[5] == "guild_logs") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					vector<string> logs{};
					vector<vector<string>> sort_by_time;
					for (GuildLog log_ : guild_information->guild_logs) {
						sort_by_time.push_back({
							to_string(log_.date),
							log_.info,
							to_string(log_.display_id)
							});
					}
					sort(sort_by_time.begin(), sort_by_time.end(), [](const vector< string >& a, const vector< string >& b) {
						return atoi(a[1].c_str()) > atoi(b[1].c_str());
						});
					for (int i = sort_by_time.size() - 1; i >= 0; i--) {
						char* endptr = NULL;
						long long laikas_ = strtoll(sort_by_time[i][0].c_str(), &endptr, 10);
						const time_t* temp = &laikas_;
						string the_time = strtok(ctime(temp), "\n");
						logs.push_back("\nadd_label_with_icon|small|" + sort_by_time[i][1] + " `wat " + the_time + "|left|" + sort_by_time[i][2] + "|\nadd_spacer|small|");
					}
					if (logs.size() == 0) {
						logs.push_back("\nadd_label_with_icon|small|There are no logs at the moment!|left|8|\nadd_spacer|small|");
					}
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big| `w" + guild_information->guild_name + " Logs``|left|1436\nadd_spacer|small|" + join(logs, "") + "\nadd_button|back|`wBack``|noflags|0|0|\nend_dialog|show_guild_logs|||\nadd_quick_exit|");
					p.CreatePacket(p_);
				}
			}
			else if (a_[5] == "warphome") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (pInfo(p_)->world == guild_information->guild_world) {
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
						}

						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
						p.CreatePacket(p_);
						break;
					}
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("Moving to guild home (`2" + guild_information->guild_world + "``) ...");
					p.CreatePacket(p_);
					join_world(p_, guild_information->guild_world);
				}
			}
			else if (a_[5] == "back") {
				send_social(p_);
			}
			else if (a_[5] == "leave_guild") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wLeave Guild``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4leave`` the guild?|left|\nadd_spacer|small|\nadd_button|leave_guild_confirmed|`4Leave Guild``|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|leave_guild|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, guild_member_name);
			}
			break;
		}
		else if (a_[i_] == "guild_member_role_change_finish") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guild_member_role_change") {
			if (a_.size() != 14) break;
			if (a_[11] == "back") {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, guild_member_name);
			}
			else if (a_[11] == "promote" or a_[11] == "demote") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							my_rank = member_search.role_id;
							break;
						}
					}
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (member_search->member_name == a_[5]) {
							bool can_promote = false;
							bool can_demote = false;
							if (member_search->role_id != 3) {
								if (member_search->role_id == 1 and my_rank == 3) {
									can_promote = true;
									can_demote = true;
								}
								else if (member_search->role_id == 2 and my_rank == 3) {
									can_promote = false;
									can_demote = true;
								}
								else if (member_search->role_id != 3 and my_rank >= 2 and member_search->role_id != 2) {
									can_promote = true;
								}
							}
							if (can_promote and a_[11] == "promote") {
								member_search->role_id++;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGuild Member Promoted``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + a_[8] + " is `2promoted`` to " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_role_change_finish|||\nadd_quick_exit|");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5[GUILD ALERT]`` `2" + a_[8] + "`` has been `2promoted`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->guild_id == guild_id) {
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->tankIDName == a_[8]) {
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(currentPeer, guild_information->guild_world, world_);
												if (pInfo(currentPeer)->world == guild_information->guild_world) {
													string name_ = pInfo(currentPeer)->world;
													vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
														for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
															if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
																uint16_t id_ = world_->blocks[i_].fg;
																if (id_ == 5814) {
																	x_ = i_ % xSize;
																	y_ = i_ / xSize;
																	break;
																}
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
														PlayerMoving data_{};
														data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
														BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
														BYTE* blc = raw + 56;
														form_visual(blc, *block_, *world_, currentPeer, false);
														for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
															if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
															if (pInfo(currentPeer2)->world == name_) {
																send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
															}
														}
														delete[] raw, blc;
													}
												}
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `2promoted `$" + a_[8] + "`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member"), 484);
							}
							else if (can_demote and a_[11] == "demote") {
								member_search->role_id--;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGuild Member Demoted``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + a_[8] + " is `4demoted`` to " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_role_change_finish|||\nadd_quick_exit|");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5[GUILD ALERT]`` `2" + a_[8] + "`` has been `4demoted`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->guild_id == guild_id) {
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->tankIDName == a_[8]) {
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(currentPeer, guild_information->guild_world, world_);
												if (pInfo(currentPeer)->world == guild_information->guild_world) {
													string name_ = pInfo(currentPeer)->world;
													vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
														for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
															if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
																uint16_t id_ = world_->blocks[i_].fg;
																if (id_ == 5814) {
																	x_ = i_ % xSize;
																	y_ = i_ / xSize;
																	break;
																}
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
														PlayerMoving data_{};
														data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
														BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
														BYTE* blc = raw + 56;
														form_visual(blc, *block_, *world_, currentPeer, false);
														for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
															if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
															if (pInfo(currentPeer2)->world == name_) {
																send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
															}
														}
														delete[] raw, blc;
													}
												}
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `4demoted `$" + a_[8] + "`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member"), 486);
							}
							break;
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "guild_member_remove_finish") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guild_member_remove") {
			if (a_.size() != 11) break;
			if (a_[8] == "remove") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							my_rank = member_search.role_id;
							break;
						}
					}
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (member_search->member_name == a_[5]) {
							bool can_kick = my_rank >= 1 and member_search->role_id < my_rank;
							if (can_kick) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGuild Member removed``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + a_[5] + " is no longer in the guild.|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_remove_finish|||\nadd_quick_exit|");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5[GUILD ALERT]`` " + a_[5] + " kicked from the guild by " + pInfo(p_)->tankIDName);
									bool on_ = false;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->guild_id == guild_id) {
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->tankIDName == a_[5]) {
											pInfo(currentPeer)->guild_id = 0;
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(currentPeer, guild_information->guild_world, world_);
												if (not guild_access(currentPeer, guild_id) and pInfo(currentPeer)->world == guild_information->guild_world) {
													string name_ = pInfo(currentPeer)->world;
													vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
														for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
															if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
																uint16_t id_ = world_->blocks[i_].fg;
																if (id_ == 5814) {
																	x_ = i_ % xSize;
																	y_ = i_ / xSize;
																	break;
																}
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
														PlayerMoving data_{};
														data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
														BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
														BYTE* blc = raw + 56;
														form_visual(blc, *block_, *world_, currentPeer, false);
														for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
															if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
															if (pInfo(currentPeer2)->world == name_) {
																send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
															}
														}
														delete[] raw, blc;
													}
												}
											}
											on_ = true;
										}
									}
									if (not on_) {
										string path_ = "database/players/" + a_[5] + "_.json";
										if (_access_s(path_.c_str(), 0) == 0) {
											json r_;
											ifstream f_(path_, ifstream::binary);
											f_ >> r_;
											f_.close();
											r_["guild_id"] = 0;
											{
												ofstream f_(path_, ifstream::binary);
												f_ << r_;
												f_.close();
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `wkicked `$" + a_[5] + "`` from the guild", 6);
								guild_information->guild_members.erase(guild_information->guild_members.begin() + i_);
							}
							break;
						}
					}
				}
			}
			else if (a_[8] == "back") {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, guild_member_name);
			}
			break;
		}
		else if (a_[i_] == "guild_member_edit") {
			if (a_.size() != 14) break;
			if (a_[11] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			else if (a_[11] == "promote" or a_[11] == "demote" or a_[11] == "goto" or a_[11] == "remove") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (member_search->member_name == a_[8]) {
							if (a_[11] == "remove") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wKick Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4kick`` " + a_[8] + " from the guild?|left|\nadd_spacer|small|\nadd_button|remove|`4Kick " + a_[8] + "``|noflags|0|0|\nembed_data|guildMemberID|" + a_[8] + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_remove|||\nadd_quick_exit|");
								p.CreatePacket(p_);
							}
							else if (a_[11] == "goto") {
								string world_name = "";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->tankIDName == a_[8]) {
										world_name = pInfo(currentPeer)->world;
										break;
									}
								}
								if (world_name.empty()) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Hmm, my friend isn't in a world right now.");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									break;
								}
								else {
									if (world_name == pInfo(p_)->world) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("Moving to guild member location (`2" + world_name + "``) ...");
									p.CreatePacket(p_);
									join_world(p_, world_name);
								}
							}
							else if (a_[11] == "promote") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPromote Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `2promote`` " + a_[8] + " to " + (member_search->role_id == 3 ? "" : member_search->role_id == 2 ? "" : member_search->role_id == 1 ? "Co-Leader" : "Elder") + "?|left|\nadd_spacer|small|\nadd_button|promote|`wPromote " + a_[8] + "``|noflags|0|0|\nembed_data|guildMemberID|" + a_[8] + "\nembed_data|guildmembername|" + a_[8] + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_role_change|||\nadd_quick_exit|");
								p.CreatePacket(p_);
							}
							else if (a_[11] == "demote") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDemote Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4demote`` " + a_[8] + " to " + (member_search->role_id == 3 ? "" : member_search->role_id == 2 ? "Elder" : member_search->role_id == 1 ? "Member" : "") + "?|left|\nadd_spacer|small|\nadd_button|demote|`wDemote " + a_[8] + "``|noflags|0|0|\nembed_data|guildMemberID|" + a_[8] + "\nembed_data|guildmembername|" + a_[8] + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_role_change|||\nadd_quick_exit|");
								p.CreatePacket(p_);
							}
							break;
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "friends") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				send_social(p_);
			}
			else if (a_[5] == "all_friends") {
				send_all_edit_friends(p_);
			}
			
			else if (a_[5] == "friends_options") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFriend Options``|left|1366|\nadd_spacer|small|\nadd_checkbox|checkbox_public|Show location to friends|" + to_string(pInfo(p_)->show_location_) + "\nadd_checkbox|checkbox_notifications|Show friend notifications|" + to_string(pInfo(p_)->show_friend_notifications_) + "\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|friends_options|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_[5] == "friend_all") {
				send_friends(p_, true);
			}
			else {
				send_info_friend(p_, a_[5]);
			}
			break;
		}
		else if (a_[i_] == "unaccess") {
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
				bool upd_ = false;
				for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
					if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
						WorldBlock* block_ = &world_->blocks[i_];
						if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
							if (find(block_->admins.begin(), block_->admins.end(), pInfo(p_)->uid) != block_->admins.end()) {
								block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), pInfo(p_)->uid), block_->admins.end());
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = i_ % xSize, data_.punchY = i_ / xSize, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]raw, blc;
								if (block_->locked) {
									upd_lock(*block_, *world_, p_);
								}
								upd_ = true;
							}
							//...
						}
						else {
							if (find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) != world_->admins.end()) {
								world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid), world_->admins.end());
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = i_ % xSize, data_.punchY = i_ / xSize, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]raw, blc;
								upd_ = true;
								gamepacket_t p2(0, pInfo(p_)->netID);
								{
									p2.Insert("OnNameChanged");
									if (not HasRole(pInfo(p_)) and not pInfo(p_)->is_legend) pInfo(p_)->name_color = "`0";
									else if (pInfo(p_)->is_legend) pInfo(p_)->name_color = "`9";
									p2.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + (pInfo(p_)->is_datemaster ? " `4Datemaster" : "") + (pInfo(p_)->is_legend ? " of Legend" : "") + "``");
								}
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										p2.CreatePacket(currentPeer);
									}
								}
							}
						}
					}
				} if (upd_) {
					packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("Removed your access from all locks.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
					}
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("Removed your access from all locks.");
						p.CreatePacket(p_);
					}

					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert(pInfo(p_)->tankIDName + " removed their own access from all locks.");
					gamepacket_t p2(0, pInfo(p_)->netID);
					{
						p2.Insert("OnNameChanged");
						if (not HasRole(pInfo(p_)) and not pInfo(p_)->is_legend) pInfo(p_)->name_color = "`0";
						else if (pInfo(p_)->is_legend) pInfo(p_)->name_color = "`9";
						p2.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + (pInfo(p_)->is_datemaster ? " `4Datemaster" : "") + (pInfo(p_)->is_legend ? " of Legend" : "") + "``");
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							p.CreatePacket(currentPeer);
						}
					}
				}
				else {
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You didn't have access on any locks!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
					}
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("You didn't have access on any locks!");
					p.CreatePacket(p_);
				}
			}
			break;
		}
		else if (a_[i_] == "confirmguild") {
			if (a_.size() != 14) break;
			string name_ = pInfo(p_)->world;
			int price = 200000;
			if (pInfo(p_)->supp > 1) price = 100000;
			if (pInfo(p_)->gems >= price) {
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					string guild_name = a_[5];
					string guild_description = a_[8];
					bool bad_name = false, already_taken = false;
					string check_name = to_lower(guild_name);
					for (int i = 0; i < swear_words.size(); i++) {
						if (check_name.find(swear_words[i]) != string::npos) {
							bad_name = true;
							break;
						}
					} for (Guild check_guild_name : guilds) {
						if (to_lower(check_guild_name.guild_name) == check_name) {
							already_taken = true;
							break;
						}
					}
					if (already_taken or bad_name or guild_name.size() < 3 or guild_name.size() > 15 or guild_description.size() < 6 or guild_description.size() > 24 or special_char(guild_name) or world_->owner_name != pInfo(p_)->tankIDName) break;
					Guild new_guild{};
					new_guild.guild_id = GlobalStats.totalGuildIDGenerated;
					new_guild.guild_name = guild_name;
					new_guild.guild_description = guild_description;
					new_guild.guild_world = world_->name;
					GuildMember new_member{};
					new_member.member_name = pInfo(p_)->tankIDName;
					new_member.role_id = 3;
					new_member.last_online = time(NULL);
					new_guild.guild_members.push_back(new_member);
					guilds.push_back(new_guild);
					GlobalStats.totalGuildIDGenerated++;
					pInfo(p_)->guild_id = new_guild.guild_id;
					ifstream in("database/server_statistic.json");
					json infile = json::parse(in);
					infile["totalGuildIDGenerated"] = GlobalStats.totalGuildIDGenerated;
					ofstream out("database/server_statistic.json");
					out << setw(4) << infile << endl;
					in.close();
					out.close();
					{
						int x_ = 0, y_ = 0;
						int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
							if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
								uint16_t id_ = world_->blocks[i_].fg;
								if (id_ != 202 and id_ != 204 and id_ != 206 and id_ != 4994) {
									x_ = i_ % xSize;
									y_ = i_ / xSize;
									break;
								}
							}
						}
						WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
						world_->guild_id = new_guild.guild_id;
						world_->Category = "Guild";
						block_->fg = 5814;
						PlayerMoving data_{};
						data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						data_.netID = pInfo(p_)->id;
						data_.plantingTree = block_->fg;
						BYTE* raw = packPlayerMoving(&data_, 56);
						PlayerMoving data_2{};
						data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
						BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
						BYTE* blc = raw2 + 56;
						form_visual(blc, *block_, *world_, p_, false);
						gamepacket_t p(0, pInfo(p_)->netID);
						p.Insert("OnGuildDataChanged");
						//p.Insert(pInfo(p_)->guild_id);
						p.Insert(50478);
						p.Insert(79289404);
						p.Insert(0), p.Insert(3);
						gamepacket_t p2(0, pInfo(p_)->netID);
						p2.Insert("OnCountryState");
						p2.Insert(pInfo(p_)->country + "|showGuild");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
							}
						}
						delete[] raw, raw2, blc;
						pInfo(p_)->gems -= price;
						{
							gamepacket_t p;
							p.Insert("OnSetBux");
							p.Insert(pInfo(p_)->gems);
							p.Insert(0);
							p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
							if (pInfo(p_)->supp >= 2) {
								p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
							}
							p.CreatePacket(p_);
						}
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("Guild created");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "createguild") {
			if (a_.size() != 12) break;
			int price = 200000;
			if (pInfo(p_)->supp > 1) price = 100000;
			if (pInfo(p_)->gems >= price) {
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					string guild_name = a_[8];
					string guild_description = a_[10];
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					bool bad_name = false, already_taken = false;
					string check_name = to_lower(guild_name);
					for (int i = 0; i < swear_words.size(); i++) {
						if (check_name.find(swear_words[i]) != string::npos) {
							bad_name = true;
							break;
						}
					} for (Guild check_guild_name : guilds) {
						if (to_lower(check_guild_name.guild_name) == check_name) {
							already_taken = true;
							break;
						}
					} if (already_taken)
						p.Insert(get_guild_create(p_, "`4The guild name is not available!``", guild_name, guild_description));
					else if (bad_name)
						p.Insert(get_guild_create(p_, "`4Oops!`` Guild name cannot contain `$swear words``.", guild_name, guild_description));
					else if (guild_name.size() < 3 or guild_name.size() > 15)
						p.Insert(get_guild_create(p_, "You'll need a name `$3 characters`` or longer to create a Guild - select cancel and enter a longer name.", guild_name, guild_description));
					else if (guild_description.size() < 6 or guild_description.size() > 24)
						p.Insert(get_guild_create(p_, "You need to enter at least `$6 characters`` to add a guild statement!", guild_name, guild_description));
					else if (special_char(guild_name))
						p.Insert(get_guild_create(p_, "`4Oops!`` You can only use letters and numbers in your `$Guild`` name.", guild_name, guild_description));
					else if (world_->owner_name != pInfo(p_)->tankIDName)
						p.Insert(get_guild_create(p_, "You can only create the guild inside a world which is owned by you!", guild_name, guild_description));
					else
						p.Insert(get_guild_create(p_, "", guild_name, guild_description, true));
					p.CreatePacket(p_);
				}
			}
			break;
		}
		else if (a_[i_] == "requestcreateguildpage") {
			if (a_.size() != 8) break;
			string b_ = a_[5];
			if (b_ == "back") {
				send_social(p_);
			}
			else if (b_ == "showcreateguild") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_create(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "socialportal") {
			if (a_.size() != 8) break;
			string b_ = a_[5];
			if (b_ == "showfriend") {
				send_friends(p_);
			}
			if (b_ == "punch_e") {
				punch_event(p_);
			}
			else if (b_ == "spotifymain") spotify(p_);
			if (b_ == "rayman_up") {
				if (pInfo(p_)->udahan == 0) {
					if (pInfo(p_)->udah_daftar == false) {
						rayman_upgrade(p_, 1);
						return;
					}
					else if (pInfo(p_)->raylvl < 50) {
						rayman_upgrade(p_, 2);
						return;
					}
					else if (pInfo(p_)->raylvl == 50) {
						rayman_upgrade(p_, 3);
						return;
					}
				}
				else {
				Algorithm::send_overlay(p_, color(p_, "green", "You already completed the quest"));
					return;
				}
			}
			else if (b_ == "verifiedw") {
				vector<string> verifiedw;
				std::ifstream file("database/verified_worlds.txt");
				if (!file.is_open()) std::cerr << "Error opening file" << std::endl;

				std::string line;
				while (std::getline(file, line)) verifiedw.push_back(line);
				file.close();

				string v_;
				v_ += "\nadd_label_with_icon|big|List of Verified World|left|6292|";
				v_ += "\nadd_spacer|small";
				for (size_t i = 0; i < verifiedw.size(); ++i) {
					std::string wname = verifiedw[i];
					if (wname != "") {
						string ownV = "";
						bool isV = false;
						readSpecificJSONData("database/worlds/" + wname + "_.json", "verified", isV);
						readSpecificJSONData("database/worlds/" + wname + "_.json", "owner", ownV);
						if (isV == true)
							v_ += std::format("\nadd_url_button||`0[`c{}`0] By: `2{}``|NOFLAGS|OPENWORLD|{}|0|0|", to_upper(wname), ownV, wname);
						else continue;
					}
					else continue;
				}
				v_ += "\nadd_spacer|small";
				v_ += "\nend_dialog|socialportal|Close||";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(v_);
				p.CreatePacket(p_);
				break;
			}

			else if (b_ == "lmboS") {
				int chckB = 0, chckD = 0, chckW = 0;
				modify_inventory(p_, 7188, chckB);
				modify_inventory(p_, 1796, chckD);
				modify_inventory(p_, 242, chckW);

				if (((chckB + chckD + chckW) == 0) or (chckB + chckD < 1 && chckW < 10))
				{
					packet_(p_, "action|log\nmsg|You dont have enough wls to play limbo, but if you have bgls or dls, please convert it first.", "");
					break;
				}
				DialogBuilder lim;
				lim.add_label_icon(1, 456, "`9Limbo `0[`2x1000``]")
					.add_spacer(0)
					.add_smalltext("`oTo play limbo, the bet must between `$10 `9World Locks `o- `$3 `9Blue Gem Locks`o, a the multiplier must between 1.10-1000.00\n`4NOTE: ``the multiplier must contains dot, example: 12.20 2.00 3.33 5.0\n`4Warning! if your locks are 190 and above please do not play limbo as it will drop automatically if not enough.``")
					.add_spacer(0)
					.add_label(0, "`oChoose the bet type:")
					.raw("max_checks|1")
					.raw("add_checkicon|wl|||242||1|")
					.raw("add_checkicon|dl|||1796||0|")
					.raw("add_checkicon|bgl|||7188||0|")
					.raw("add_button_with_icon||END_LIST|noflags|0||")
					.add_text_input(3, "bet", "Bet:", "10")
					.add_text_input(6, "mul", "Multiplier (contains dot):", "2.00")
					.add_spacer(0)
					.end_dialog("limbo", "Cancel", "`2Play!");
				enet_peer_send(p_, 0, Variant{ "OnDialogRequest" }.push(lim.to_string()).pack());
				break;
			}
			else if (b_ == "gamble_game") {
				if (pInfo(p_)->isBet) {
					pInfo(p_)->isBet = false; pInfo(p_)->Mine_Pos = -5;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBeware of the Mine!``|left|6994|\nadd_textbox|Would you like to play `6Beware of the Mine``? It's only cost you 1 Diamond Lock!|left|\nadd_smalltext|There will be 5 box you can choose, 1 is true the others is a mines(bomb)!|left|\nadd_spacer|small|\nend_dialog|mine_games|Nevermind|Play|");
				p.CreatePacket(p_);
			}
			if (b_ == "s_gamble") {
				//mines_(p_);
			}
			else if (b_ == "slot_game") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("add_label_with_icon|big|`6TayoPs  Slot Game|left|756|\nadd_image_button||interface/large/reme.rttex|bannerlayout|||\n"
					"add_spacer|small|\n"
					"add_textbox|`oWOW! Hi, Netopians You Can Play Slot With This Feature /Troll, In This Game You Should Have `c1DL `oTo Play. If You Luck, Your Dl Getting x2 And If You Lose You Will Rip Your Dl|left|\n"
					"add_spacer|small|\n"
					"add_button|playslot|`2PLAY SLOT GAME!|\n"
					"add_spacer|small|\n"
					"add_button||Okay!|"
				);
				p.CreatePacket(p_);
			}
			else if (b_ == "mining") {
				if (pInfo(p_)->isMinner == true) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("add_label_with_icon|big|`bHOHOHO! `6TayoPs  Minner!|left|6896|\nadd_spacer|small|\nadd_textbox|`6Hi Netopian Player!, Welcome To Survive Ps Minner Feature,You Can Invest Your DL Into This Minner (2 growland Min = 0.01 Diamond Lock). Invest Your Diamond Lock Now, Price: `o70 Diamond Lock!|left|\nadd_spacer|small|\nadd_button|invest|`bInvest 70 DL To Minner!|\nadd_spacer|small|\nadd_button|dawdawd|Okay!|");
					p.CreatePacket(p_);
				}
				else {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("add_label_with_icon|big|`bHOHOHO! `6TayoPs Minner!|left|6896|\nadd_spacer|small|\nadd_textbox|`6Hi, Welcome Back Minners!,`wYour Miner: " + to_string(pInfo(p_)->levelMinner) + " `6 & Your Currently Diamond Lock On Minner [" + to_string(pInfo(p_)->minnerData) + "] You Can Upgrade Your Minner Later `o(Updating)|left|\nadd_spacer|small|\nadd_button|updatemining|`6Buy More Minner! (1 Bgl)|\nadd_spacer|small|\nadd_button|dawdawd|Okay!|");
					p.CreatePacket(p_);
				}
			}
			else if (b_ == "trade_history") {
				string trade_history2 = "";
				for (string a : pInfo(p_)->trade_history) trade_history2 += "add_smalltext|" + a + "|";
				if (trade_history2 == "") trade_history2 = "add_smalltext|You haven't done any trades yet.|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("add_label_with_icon|big|`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "'s Trade History``|left|242|\nadd_spacer|small|\n" + trade_history2 + "\nadd_spacer|small|\nend_dialog|trd-history|Close||");
				p.CreatePacket(p_);
			}
			else if (b_ == "showguild") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			else if (b_ == "classic_bank") {
				classic_bank_show(p_);
				break;
			}
			break;
		}
		else if (a_[i_] == "acceptaccess") {
			if (pInfo(p_)->ac_.size() == 0) break;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(p_)->world) {
					if (pInfo(p_)->ac_.find(pInfo(currentPeer)->netID) != pInfo(p_)->ac_.end()) {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							if (world_->admins.size() >= 26) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("World has reached access limit!");
								p.Insert(0);
								p.Insert(0);
								p.CreatePacket(p_);
								continue;
							}
							string peer_name = pInfo(p_)->tankIDName, owner_name = world_->owner_name, user_name = pInfo(currentPeer)->tankIDName;
							if (owner_name != user_name and not pInfo(currentPeer)->dev) break;
							//world_->admins.push_back(peer_name);
							int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
							int x_ = (pInfo(p_)->ac_[pInfo(currentPeer)->netID]) % xSize, y_ = (pInfo(p_)->ac_[pInfo(currentPeer)->netID]) / xSize;
							if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
							WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								if (block_->owner_name != user_name and not pInfo(currentPeer)->dev) break;
								if (block_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Lock has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								block_->admins.push_back(pInfo(p_)->uid);
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` was given access to a " + items[block_->fg].name + ".");
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										p.CreatePacket(currentPeer);
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
							else {
								if (owner_name != user_name and not pInfo(currentPeer)->dev) break;
								if (world_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("World has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								world_->admins.push_back(pInfo(p_)->uid);
								gamepacket_t p2(0, pInfo(p_)->netID);
								{
									p2.Insert("OnNameChanged");
									if (not HasRole(pInfo(p_))) pInfo(p_)->name_color = "`^";
									p2.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + (pInfo(p_)->is_datemaster ? " `4Datemaster" : "") + (pInfo(p_)->is_legend ? " of Legend" : "") + "``");
								}
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` was given access to a " + items[block_->fg].name + ".");
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
							packet_(p_, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
						pInfo(p_)->ac_.clear();
						return;
					}
				}
			}
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(p_)->netID);
			p.Insert("The lock owner has left!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(p_);
			pInfo(p_)->ac_.clear();
			break;
		}
		else if (a_[i_] == "worlds_list") {
			if (a_.size() != 8 and a_.size() != 5) break;
			if (a_.size() == 5) {
				send_wrench_self(p_);
				break;
			} if (pInfo(p_)->home_world == a_[5]) {
				bool a___ = false;
				for (pair<string, long long int> p : home_timed) {
					if (p.first == pInfo(p_)->tankIDName) {
						if (p.second + HOME_TIME > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
							a___ = true;
							gamepacket_t no;
							no.Insert("OnTalkBubble");
							no.Insert(pInfo(p_)->netID);
							no.Insert("`4Cooldown active`` - You can use `5home warp`` in `5" + to_string(((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) - ((((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) / 60) * 60)) + " ``seconds.");
							no.Insert(0), no.Insert(0);
							no.CreatePacket(p_);
							break;
						}
					}
				}
				if (a___)
					break;
				home_timed.push_back(make_pair(pInfo(p_)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
			}
			join_world(p_, a_[5]);
			break;
		}
		else if (a_[i_] == "popup") {
			if (a_.size() == 8 and a_[5] == "my_worlds") {
				string home_world_ = "";
				string worlds_owned_ = "";
				if (not pInfo(p_)->home_world.empty()) {
					home_world_ += "\nadd_textbox|Your home world|left|\nadd_button|" + pInfo(p_)->home_world + "|" + pInfo(p_)->home_world + "|noflags|0|0|\nadd_spacer|small|";
				} for (int w_ = 0; w_ < pInfo(p_)->worlds_owned.size(); w_++) {
					worlds_owned_ += "\nadd_button|" + pInfo(p_)->worlds_owned[w_] + "|" + pInfo(p_)->worlds_owned[w_] + "|noflags|0|0|";
				} if (worlds_owned_.empty()) {
					worlds_owned_ = "\nadd_textbox|You do not have any World-Locked worlds.``|left|";
				}

				vector<string> verifiedw;
				std::ifstream file("database/verified_worlds.txt");
				if (!file.is_open()) std::cerr << "Error opening file" << std::endl;

				std::string line;
				while (std::getline(file, line)) verifiedw.push_back(line);
				file.close();

				string v_;
				v_ += "\nadd_spacer|small";
				v_ += "\nadd_label_with_icon|small|List of Your Verified World|left|6292|";
				for (size_t i = 0; i < verifiedw.size(); ++i) {
					std::string wname = verifiedw[i];
					if (wname != "") {
						bool isV = false;
						string ownV = "";
						readSpecificJSONData("database/worlds/" + wname + "_.json", "verified", isV);
						readSpecificJSONData("database/worlds/" + wname + "_.json", "owner", ownV);
						if (isV == true and ownV == pInfo(p_)->tankIDName)
							v_ += std::format("\nadd_url_button||`c{}|NOFLAGS|OPENWORLD|{}|0|0|", to_upper(wname), wname);
						else continue;
					}
					else continue;
				}
				v_ += "\nadd_spacer|small";

				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label|big|Worlds Locked|right\nadd_spacer|small|" + home_world_ + "\nadd_textbox|Your locked worlds|left|\nadd_textbox|You must be a Supporter or Super Supporter to warp to these worlds.|left|" + worlds_owned_ + "\nadd_quick_exit|\nadd_spacer|small|\nend_dialog|worlds_list||Back|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "bonus") {
				if (pInfo(p_)->gp == 1) {
					if (pInfo(p_)->startedKit) SendKitDialog(p_);
					else {
						DialogBuilder dialog("`o");
						dialog.add_label_icon(true, 5136, "`1TayoPs `wKit``")
							.add_spacer(false)
							.add_smalltext("You are about to embark on a magical journey! it won't be easy, but the reward is multiple various interesting stuff. You don't get to pick which one, you will get all of the prizes depending on the level you reach.<CR>I've got a lot of stuffs sitting in my bag, with a lot of magical properties. If you want one, you'll need to earn some xp and reach some levels needed for the items to be unlocked.<CR>Doesn't sound so bad does it?<CR>Remember that you can only start this journey on 1 device/ip only so make sure you are starting this magical journey on your main account!<CR>There's one last thing you should know before you begin. The progress is resetting every month, be aware that if you do, you'll lose all your progress, and you'll have to start again!")
							.add_spacer(false)
							.end_dialog("start_kit_dialog", "Cancel", "Start Kit");
						enet_peer_send(p_, 0, Variant{ "OnDialogRequest" }.push(dialog.to_string()).pack());
					}
				}
			}
			else if (a_.size() == 8 and a_[5] == "account_security") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Network Info``|left|\nadd_smalltext|Status: `2ONLINE``|left|\nadd_smalltext|Email: `5" + pInfo(p_)->email + "``|left|\nadd_smalltext|IP: `5" + pInfo(p_)->ip + "``|left|\nadd_smalltext|RID: `5" + pInfo(p_)->rid + "``|left|\nadd_smalltext|MAC Address: `5" + pInfo(p_)->mac + "``|left|\nadd_smalltext|Country Code: `5" + pInfo(p_)->country + "``|left|\nadd_spacer|small\nadd_textbox|`6Assets Info``|left|\nadd_smalltext|Level: `5" + to_string(pInfo(p_)->level) + "``|left|\nadd_smalltext|Gems: `5" + setGems(pInfo(p_)->gems) + "``|left|\nadd_smalltext|XP: `5" + setGems(pInfo(p_)->xp) + "``|left|\nadd_smalltext|You need " + setGems((50 * (pInfo(p_)->level * pInfo(p_)->level) + 2) - pInfo(p_)->xp) + " XP to be level " + to_string(pInfo(p_)->level + 1) + "|left|\nadd_spacer|small|\nadd_smalltext|Type what do you want to `5change``? (email/password)|left|\nadd_text_input|change|||10|\nend_dialog|account_security|OK|Continue|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "aff_upgrade") {
				if (pInfo(p_)->affinity_type != NO_AFFINITY)
				{
					int price = 80 + (20 * pInfo(p_)->affinity_level);
					int my_wls = 0;
					int c_ = 0;
					modify_inventory(p_, 242, c_);
					my_wls += c_;
					c_ = 0;
					modify_inventory(p_, 1796, c_);
					my_wls += c_ * 100;
					c_ = 0;
					modify_inventory(p_, 7188, c_);
					my_wls += c_ * 10000;
					c_ = 0;
					DialogBuilder db{ "`o" };
					db.add_label_icon(true, pInfo(p_)->affinity_type == LOVER ? 190 : 1366, affinity_to_string(pInfo(p_)->affinity_type))
						.add_spacer(false)
						.add_textbox(format("You're {}'s {}, current affinity level: {}. Click the button if you mind to upgrade it. "
							"More level you have more unique buffs you get, max level is 5.",
							GetNameByUid(pInfo(p_)->affinity_with), affinity_to_string(pInfo(p_)->affinity_type), pInfo(p_)->affinity_level))
						.add_spacer(false)
						.add_textbox(format("You currently have {} world locks in your backpack.", setGems(my_wls)));
					if (pInfo(p_)->affinity_level < 5) {
						db.add_textbox(format("Estimated price of upgrade to next level: {} Diamond Locks.", price))
							.add_button("upgrade_aff", format("Upgrade affinity to level {}!", pInfo(p_)->affinity_level + 1));
					}
					else {
						db.add_textbox("You have max level of affinity.");
					}
					db.add_button("breakup", "Break up")
						.add_spacer(false)
						.add_button("", "Close");
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(db.to_string());
					p.CreatePacket(p_);
				}
			}
			else if (a_.size() == 8 and (a_[5] == "info" || a_[5] == "cheats" || a_[5] == "skills" || a_[5] == "level" || a_[5] == "badges" || a_[5] == "quests" || a_[5] == "mod")) send_wrench_self(p_, a_[5]);
			else if (a_.size() == 8 and a_[5] == "glory") glory_show(p_);
			else if (a_.size() == 8 and a_[5] == "cheat_menu") cheat_show(p_);
			

			//else if (a_.size() == 8 and a_[5] == "spotify_music") spotify_list(p_);

			else if (a_.size() == 8 and a_[5] == "void_ray") {
				if (pInfo(p_)->hand == 8532) {
					DialogBuilder db{ "`o" };
					db.add_label_icon(false, 8532, format("`w{} Settings``", items[8532].name))
						.add_checkbox(pInfo(p_)->void_ray_1hit, "checkbox_void_ray", "Membuat 1 Hit Apapun Itu Dalam Jangka Waktu")
						.end_dialog("void_ray_settings", "", "`wOK``");

					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(db.to_string());
					p.CreatePacket(p_);
				}
			}
			else if (a_.size() == 8 and a_[5] == "sharingan") {
				if (pInfo(p_)->face == 13554) {
					DialogBuilder db{ "`o" };
					db.add_label_icon(false, 13554, format("`w{} Settings``", items[13554].name))
						.add_checkbox(pInfo(p_)->izanagi, "checkbox_izanagi", "Cleave (Kamu Bisa Mendapatkan Boost 10x Lipat)")
						.add_checkbox(pInfo(p_)->knockback, "checkbox_izanami", "Flames Arrow's (Kamuh Bisa Memundurkan Org Sejauh Mungkin Dev Only)")
						.add_checkbox(pInfo(p_)->Cheat_Speed, "checkbox_speed", "Dismantle (Memberikan Fisik Sehingga Lari Secepat Mungkin)")
						.add_checkbox(pInfo(p_)->sharingan_control, "checkbox_s_control", "Ryoiki Tenkai (Mengotrol Org Summon Mahoraga Soon)")
						.add_spacer(false)
						.add_smalltext("`4WARNING``: The changes won't be saved.")
						.end_dialog("sharingan_settings", "", "`wOK``");

					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(db.to_string());
					p.CreatePacket(p_);
				}
			}
			else if (a_.size() == 8 and a_[5] == "kamish_sword") {
				if (pInfo(p_)->dev) {
					if (pInfo(p_)->hand == 9508) {
						DialogBuilder db{ "`o" };
						db.add_label_icon(false, 9508, format("`w{} Settings``", items[9508].ori_name));
						//else (pInfo(p_)->hand == 9508); db.add_label_icon(false, 9508, format("`w{} Settings``", items[9508].name));
						db.add_checkbox(pInfo(p_)->knockback, "checkbox_izanagi", "Mornach Targets (Knockback)");
						db.add_checkbox(pInfo(p_)->void_ray_1hit, "checkbox_void_ray", "God Hits (1Hit)");
						db.add_checkbox(pInfo(p_)->wide_place, "checkbox_wide_place", "Manipulate Block (Notsure)");
						db.add_checkbox(pInfo(p_)->wide_punch, "checkbox_wide_place", "Mendapatkan Arisee (Notsure)");
						//if (pInfo(p_)->hand == 13560) db.add_checkbox(pInfo(p_)->genjutsu2, "checkbox_genjutsu2", "Mode Manip Sword");
						db.add_spacer(false)
							.add_smalltext("`4WARNING``: This item is only available for Developers for now and the changes won't be saved.")
							.end_dialog("kamish_word", "", "`wOK``");

						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert(db.to_string());
						p.CreatePacket(p_);
					}
				}
			}
			else if (a_.size() == 8 and a_[5] == "ruler_sword") {
				if (pInfo(p_)->dev) {
					if (pInfo(p_)->face == 13896) {
						DialogBuilder db{ "`o" };
						db.add_label_icon(false, 13896, format("`w{} Settings``", items[13896].ori_name));
						//else (pInfo(p_)->hand == 9508); db.add_label_icon(false, 9508, format("`w{} Settings``", items[9508].name));
						db.add_checkbox(pInfo(p_)->kill_mode, "checkbox_killer", "Infinite (Menahan Semua Serangan Berguna Utk Pvp Adm Only)");
							if (pInfo(p_)->face == 13896) db.add_checkbox(pInfo(p_)->genjutsu, "checkbox_genjutsu", "Ryoiki Tenkai (Membuat Semua Org Tidak Bergerak Dalam Jangka Waktu Dev Only)");
							db.add_checkbox(pInfo(p_)->wide_punch, "checkbox_wide_punch", "Lapse Blue (Membuat Semua Benda Menjadi Far Put 100 Dev Only")
								.add_checkbox(pInfo(p_)->wide_place, "checkbox_wide_place", "Reversal Red (Membuat Semua Benda Menjadi Far Punch 100 Dev Only)");
							if (pInfo(p_)->face == 13896) db.add_checkbox(pInfo(p_)->genjutsu2, "checkbox_genjutsu2", "Murasaki (Membuat Org Menjadi Abu Abu Kyk Curse Adm Only)");
							db.add_spacer(false)
							.add_smalltext("`4WARNING``: This item is only available for Developers for now and the changes won't be saved.")
							.end_dialog("ruler_sword_settings", "", "`wOK``");

						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert(db.to_string());
						p.CreatePacket(p_);
					}
				}
			}
			else if (a_.size() == 8 and a_[5] == "show_backpack") backpack_show(p_);
			else if (a_.size() == 8 and a_[5] == "emojis") {
				string emoji = "", first_emoji = "\nadd_spacer|small|", chest_title = "", chest_have = "", chest_dont_have = "";
				if (pInfo(p_)->level >= 5) first_emoji += "\nadd_smalltext_forced| (sigh) |left|\nadd_smalltext_forced| (mad) |left|\nadd_smalltext_forced| (smile) |left|\nadd_smalltext_forced| (tongue) |left|\nadd_smalltext_forced| (wow) |left|";
				if (pInfo(p_)->supp >= 1) first_emoji += "\nadd_smalltext_forced| (no) |left|\nadd_smalltext_forced| (shy) |left|\nadd_smalltext_forced| (wink) |left|\nadd_smalltext_forced| (music) |left|\nadd_smalltext_forced| (lol) |left|";
				if (pInfo(p_)->supp == 2) first_emoji += "\nadd_smalltext_forced| (yes) |left|\nadd_smalltext_forced| (love) |left|\nadd_smalltext_forced| (megaphone) |left|\nadd_smalltext_forced| (heart) |left|\nadd_smalltext_forced| (cool) |left|";
				if (pInfo(p_)->friends.size() >= 10)  first_emoji += "\nadd_smalltext_forced| (kiss) |left|";
				if (pInfo(p_)->friends.size() >= 20)  first_emoji += "\nadd_smalltext_forced| (agree) |left|";
				if (pInfo(p_)->friends.size() >= 30)  first_emoji += "\nadd_smalltext_forced| (see-no-evil) |left|";
				if (pInfo(p_)->friends.size() >= 40)  first_emoji += "\nadd_smalltext_forced| (dance) |left|";
				if (pInfo(p_)->friends.size() >= 50)  first_emoji += "\nadd_smalltext_forced| (build) |left|";
				string cch = pInfo(p_)->growmoji;
				vector<string> a_ = explode("(", replace_str(cch, ")", "|"));
				for (int i_ = 0; i_ < a_.size(); i_++) {
					string str = a_[i_];
					size_t i = 0;
					for (; i < str.length(); i++) { if (isdigit(str[i])) break; }
					str = str.substr(i, str.length() - i);
					int id = atoi(str.c_str());
					if (not a_[i_].empty()) {
						string emojied = fixchar3(a_[i_]);
						if (emojied == "oops" || emojied == "sleep" || emojied == "punch" || emojied == "bheart" || emojied == "cry" || emojied == "bunny" || emojied == "cactus" || emojied == "pine" || emojied == "peace" || emojied == "terror" || emojied == "troll" || emojied == "fireworks" || emojied == "party" || emojied == "song" || emojied == "ghost" || emojied == "nuke" || emojied == "halo" || emojied == "lucky" || emojied == "weary" || emojied == "moyai" || emojied == "plead" || emojied == "wl" || emojied == "grow" || emojied == "gems" || emojied == "gtoken" || emojied == "vend" || emojied == "football") {
							if (id) first_emoji += "\nadd_smalltext_forced| (" + emojied + ") |left|";
							else emoji += "\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (" + emojied + ") | 0.5|left|\nadd_spacer|small|";
						}
						else {
							if (id) {
								chest_have += "\nadd_smalltext_forced| (" + emojied + ") |left|";
							}
							else {
								chest_title = "\nadd_spacer|small|\nadd_smalltext|`9These Growmojis can be found in the Growmoji Chest sold by Locke the Traveling Salesman.``|left|";
								chest_dont_have += "\nadd_smalltext_forced_alpha| (" + emojied + ") |0.5|left|";
							}
						}
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|Growmojis|left|1366|" + a + first_emoji + chest_have + (pInfo(p_)->level >= 5 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need to be Level 5 to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (sigh) |0.5|left|\nadd_smalltext_forced_alpha| (mad) |0.5|left|\nadd_smalltext_forced_alpha| (smile) |0.5|left|\nadd_smalltext_forced_alpha| (tongue) |0.5|left|\nadd_smalltext_forced_alpha| (wow) |0.5|left|") + "" + (pInfo(p_)->supp >= 1 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need to be a Supporter to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (no) |0.5|left|\nadd_smalltext_forced_alpha| (shy) |0.5|left|\nadd_smalltext_forced_alpha| (wink) |0.5|left|\nadd_smalltext_forced_alpha| (music) |0.5|left|\nadd_smalltext_forced_alpha| (lol) |0.5|left|") + "" + (pInfo(p_)->supp == 2 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need to be a Super Supporter to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (yes) |0.5|left|\nadd_smalltext_forced_alpha| (love) |0.5|left|\nadd_smalltext_forced_alpha| (megaphone) |0.5|left|\nadd_smalltext_forced_alpha| (heart) |0.5|left|\nadd_smalltext_forced_alpha| (cool) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 10 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 10 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (kiss) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 20 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 20 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (agree) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 30 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 30 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (see-no-evil) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 40 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 40 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (dance) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 50 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 50 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (build) |0.5|left|") + emoji + chest_title + chest_dont_have + "\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "title_edit") {
			/*	string titles = "";
				if (pInfo(p_)->drtitle) titles += "\nadd_checkbox|1|'Dr.'|" + to_string(pInfo(p_)->drt) + "|";
				if (pInfo(p_)->level >= 125) titles += "\nadd_checkbox|2|Level 125|" + to_string(pInfo(p_)->lvl125) + "|";
				if (pInfo(p_)->legend) titles += "\nadd_checkbox|3|'of Legend'|" + to_string(pInfo(p_)->is_legend) + "|";
				if (pInfo(p_)->supp == 2) titles += "\nadd_checkbox|4|'Grow4Good Title'|" + to_string(pInfo(p_)->donor) + "|\nadd_checkbox|5|'Mentor Title'|" + to_string(pInfo(p_)->master) + "|";
				if (pInfo(p_)->admin) titles += "\nadd_checkbox|ttBadge|TikTok Badge Creator|" + to_string(pInfo(p_)->ttBadge) + "|";
				if (pInfo(p_)->dev) titles += "\nadd_checkbox|ccBadge|TikTok Verified Creator|" + to_string(pInfo(p_)->ccBadge) + "|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(a + "set_default_color|`o\nadd_label|big|" + (titles == "" ? "No Titles Obtained" : "Select Title:") + "|right|" + titles + "\nadd_spacer|small|\nadd_button||OK|noflags|0|0|\nend_dialog|title_edit||\n");
				p.CreatePacket(p_); */
			/*	string titles = "";
				if (pInfo(p_)->drtitle) titles += "\nadd_checkbox|1|'Dr.'|" + to_string(pInfo(p_)->drt) + "|";
				if (pInfo(p_)->level >= 125) titles += "\nadd_checkbox|2|Level 125|" + to_string(pInfo(p_)->lvl125) + "|";
				if (pInfo(p_)->gp) titles += "\nadd_checkbox|3|'Grow4Good Title'|" + to_string(pInfo(p_)->donor) + "|\nadd_checkbox|4|'Mentor Title'|" + to_string(pInfo(p_)->master) + "|";
				if (pInfo(p_)->legend) titles += "\nadd_checkbox|5|'of Legend'|" + to_string(pInfo(p_)->is_legend) + "|";
				//if (pInfo(p_)->level >= 250) titles += "\nadd_checkbox|6|Blue Name|" + to_string(pInfo(p_)->lvl125) + "|";
				//if (pInfo(p_)->ownership_role) titles += "\nadd_checkbox|7|Hamumu Flag|" + a + (pInfo(p_)->country == "ha" ? "1" : "0") + "|\nadd_checkbox|8|RTSoft Flag|" + (pInfo(p_)->country == "rt" ? "1" : "0") + "|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(a + "set_default_color|`o\nadd_label|big|" + (titles.empty() ? "No Titles Obtained" : "Select Title:") + "|right|" + titles + "\nadd_spacer|small|\nadd_button||OK|noflags|0|0|\nend_dialog|title_edit||\n");
				p.CreatePacket(p_); */
				string titles = "";
				if (pInfo(p_)->drtitle) titles += "\nadd_checkbox|1|'Dr.'|" + to_string(pInfo(p_)->drt) + "|";
				if (pInfo(p_)->level >= 125) titles += "\nadd_checkbox|2|Level 125|" + to_string(pInfo(p_)->lvl125) + "|";
				if (pInfo(p_)->legend) titles += "\nadd_checkbox|3|'of Legend'|" + to_string(pInfo(p_)->is_legend) + "|";
				if (pInfo(p_)->gp) titles += "\nadd_checkbox|4|'Grow4Good Title'|" + to_string(pInfo(p_)->donor) + "|\nadd_checkbox|5|'Mentor Title'|" + to_string(pInfo(p_)->master) + "|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(a + "set_default_color|`o\nadd_label|big|" + (titles == "" ? "No Titles Obtained" : "Select Title:") + "|right|" + titles + "\nadd_spacer|small|\nadd_button||OK|noflags|0|0|\nend_dialog|title_edit||\n");
				p.CreatePacket(p_);

			}
			else if (a_.size() == 8 and a_[5] == "u_transform") pInfo(p_)->flagmay = pInfo(p_)->flagmay == 1048576 ? 256 : 1048576, update_clothes(p_);
			else if (a_.size() == 8 and a_[5] == "pps_transform") pInfo(p_)->flagmay = pInfo(p_)->flagmay == 4096 ? 256 : 4096, update_clothes(p_);
			else if (a_.size() == 8 and a_[5] == "dsf_transform") pInfo(p_)->flagmay = pInfo(p_)->flagmay == 64 ? 256 : 64, update_clothes(p_);
			else if (a_.size() == 8 and a_[5] == "red_panda_transform") pInfo(p_)->flagmay = pInfo(p_)->flagmay == 67108864 ? 256 : 67108864, update_clothes(p_);
			else if (a_.size() == 8 and a_[5] == "eq_aura_edit") {
				pInfo(p_)->eq_a_update = false;
				if (pInfo(p_)->eq_a != 0) pInfo(p_)->eq_a_1 = pInfo(p_)->eq_a;
				else pInfo(p_)->eq_a_1 = 0;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEQ Aura``|left|12634|\nadd_spacer|small|\nadd_textbox|Play music wherever you are with the EQ Aura! Choose a musical block from your inventory to play the song.|left|\nadd_spacer|small|" + (string(pInfo(p_)->eq_a != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(p_)->eq_a].name + "``|left|" + to_string(pInfo(p_)->eq_a) + "|\nadd_spacer|small|" : "")) + "\nadd_item_picker|button_item_selection|`wChange Block Item``|Choose Musical Block Item!|\nadd_button|restore_default|`wRemove Block Item``|noflags|0|0|\nadd_spacer|small|\nadd_spacer|small|\nend_dialog|dialog_eq_aura|Cancel|Update|\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "minokawa_wings_edit") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMinokawa Wings``|left|12640|\nadd_spacer|small|\nadd_textbox|Choose which items you would like to appear. You can choose one item or two!|left|\nadd_spacer|small|\nadd_checkbox|checkbox_minokawa_wings|Minokawa Wings|" + (string(pInfo(p_)->MKW ? "1" : "0")) + "\nadd_checkbox|checkbox_minokawa_pet|Minokawa Pet|" + (string(pInfo(p_)->MKP ? "1" : "0")) + "\nadd_spacer|small|\nend_dialog|dialog_minokawa_wings|Cancel|Update|\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "ac15_transform") pInfo(p_)->flagmay = pInfo(p_)->flagmay == 8388608 ? 256 : 8388608, update_clothes(p_);
			else if (a_.size() == 8 and a_[5] == "dragon_mask_transform") pInfo(p_)->flagmay = pInfo(p_)->flagmay == 524288 ? 256 : 524288, update_clothes(p_);
			else if (a_.size() == 8 and a_[5] == "tmnt_transform") pInfo(p_)->flagmay = pInfo(p_)->flagmay == 262400 ? 256 : 262400, update_clothes(p_);
			else if (a_.size() == 8 and a_[5] == "Startek") pInfo(p_)->flagmay = pInfo(p_)->flagmay == 2097168 ? 256 : 2097168, update_clothes(p_);
			else if (a_.size() == 8 and a_[5] == "street_transform") pInfo(p_)->flagmay = pInfo(p_)->flagmay == 33554432 ? 256 : 33554432, update_clothes(p_);
			else if (a_.size() == 8 and a_[5] == "rift_cape_edit") {
				SendDialogRiftCape(p_, false);
			}
			else if (a_.size() == 8 and a_[5] == "pianowings_edit") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMusical Wings``|left|10182|\nadd_spacer|small|\nadd_button|manual|Instructions|noflags|0|0|\nadd_spacer|small|\nadd_text_input|volume|Volume|" + to_string(pInfo(p_)->m_volume) + "|3|\nadd_text_input|text|Notes|" + pInfo(p_)->m_note + "|50|\nadd_spacer|small|\nadd_button|resoterdefault|Restore to Default|noflags|0|0|\nend_dialog|pianowings|Cancel|Update|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "billboard_edit") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Billboard``|left|8282|\nadd_spacer|small|" + (pInfo(p_)->b_i != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(p_)->b_i].name + "``|left|" + to_string(pInfo(p_)->b_i) + "|" : "") + "\nadd_item_picker|billboard_item|`wSelect Billboard Item``|Choose an item to put on your billboard!|\nadd_spacer|small|\nadd_checkbox|billboard_toggle|`$Show Billboard``|" + (pInfo(p_)->b_a == 0 ? "0" : "1") + "\nadd_text_input|setprice|Price of item:|" + to_string(pInfo(p_)->b_p) + "|5|\nadd_checkbox|chk_peritem|World Locks per Item|" + (pInfo(p_)->b_w == 0 ? "0" : "1") + "\nadd_checkbox|chk_perlock|Items per World Lock|" + (pInfo(p_)->b_w == 0 ? "1" : "0") + "\nadd_spacer|small|\nend_dialog|billboard_edit|Close|Update|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "rift_wings_edit") {
				SendDialogRiftWings(p_, false);
			}
			else if (a_.size() == 8 and a_[5] == "bannerbandolier") {
				SendBannerBandolier(p_);
			}
			else if (a_.size() == 8 and a_[5] == "cernuous_mask_edit") {
				SendCernuousEdit(p_);
			}
			else if (a_.size() == 8 and a_[5] == "infinity_crown_edit") {
				SendDialogInfinityCrown(p_);
			}
			else if (a_.size() == 8 and a_[5] == "alist") {
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("Achievement still under development ć");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "set_online_status") {
				SendDialogOnlineStatus(p_);
			}
			else if (a_.size() == 8 and a_[5] == "open_personlize_profile") {
				SendDialogPersonalizeProfile(p_);
			}
			else if (a_.size() == 8 and a_[5] == "notebook_edit") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label|big|Notebook|left|0|\nadd_text_box_input|personal_note||" + pInfo(p_)->note + "|128|5|\nadd_spacer|small|\nadd_button|save|Save|noflags|0|0|\nadd_button|clear|Clear|noflags|0|0|\nadd_button|cancel|Cancel|noflags|0|0|\nend_dialog|notebook_edit||\nadd_quick_exit|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "scarf_of_seasons_edit") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wEquinox Scarf``|left|11818|\nadd_spacer|small|\nadd_textbox|Scarf Design|left|\nadd_spacer|small|\nadd_checkbox|checkbox_color_0|      Spring |" + (pInfo(p_)->i_11818_1 == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_color_1|      Summer |" + (pInfo(p_)->i_11818_1 == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_color_2|      Autumn |" + (pInfo(p_)->i_11818_1 == 2 ? "2" : "0") + "\nadd_checkbox|checkbox_color_3|      Winter |" + (pInfo(p_)->i_11818_1 == 3 ? "1" : "0") + "\nadd_textbox|Scarf Attack|left|\nadd_spacer|small|\nadd_checkbox|checkbox_punch_0|      Spring |" + (pInfo(p_)->i_11818_2 == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_1|      Summer |" + (pInfo(p_)->i_11818_2 == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_2|      Autumn |" + (pInfo(p_)->i_11818_2 == 2 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_3|      Winter |" + (pInfo(p_)->i_11818_2 == 3 ? "1" : "0") + "\nadd_spacer|small|\nadd_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|dialog_scarf_of_seasons|Cancel|Update|\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "goals") {
				string extra = "", extra2 = "", questType = "";
				string CQ = "", quest_info = "";
				if (pInfo(p_)->lastquest == "honor") questType = "Quest For Honor";
				else if (pInfo(p_)->lastquest == "fire") questType = "Quest For Fire";
				else if (pInfo(p_)->lastquest == "steel") questType = "Quest Of Steel";
				else if (pInfo(p_)->lastquest == "heavens") questType = "Quest Of The Heavens";
				else if (pInfo(p_)->lastquest == "Ruler Sword") questType = "Quest Of The Ruler Sword";
				else if (pInfo(p_)->lastquest == "blade") questType = "Quest For The Blade";
				else if (pInfo(p_)->lastquest == "candour") questType = "Quest For Candour";
				else if (pInfo(p_)->lastquest == "thesky") questType = "Quest For The Sky";
				else if (pInfo(p_)->lastquest == "theowl") questType = "Quest Of The Owl";
				else if (pInfo(p_)->lastquest == "mech") questType = "Quest Of The Mech";
				//else if (pInfo(p_)->lastquest == "zodiac") questType = "Quest Of The Constellation";
				// honor
				if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 1) extra2 = "of 2,000 Sand delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 2) extra2 = "of 100 Portrait delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 4) extra2 = "of 600 Display Box delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 6) extra2 = "of 28 Growtoken earned";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 7) extra2 = "of 3 Golden Diaper delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 9) extra2 = "of 1,000 Tombstones delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Successful surgeries";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 13) extra2 = "of 1,000 providers collected";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 14) extra2 = "of 3 Golden Heart Crystals delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 16) extra2 = "of 1 Growie Award delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 17) extra2 = "of 3 Super Fireworks delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 18) extra2 = "of 10 Rainbow Wings delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 19) extra2 = "of 3 Birth Certificates delivered";
				else if (pInfo(p_)->lastquest == "honor" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// fire
				if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 1) extra2 = "of 2,000 Lava delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 2) extra2 = "of 10 Paintbrush delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 4) extra2 = "of 600 Dragon Gate delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 6) extra2 = "of 28 Growtoken earned";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 7) extra2 = "of 10 Dragon Hands delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 9) extra2 = "of 1,000 Dragon Tail delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Successful surgeries";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 13) extra2 = "of 1,000 providers collected";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 14) extra2 = "of 5 Ice Dragon Hand delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 16) extra2 = "of 1 Ultra Trophy 3000 delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 17) extra2 = "of 5 Black Crystal Dragon delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 18) extra2 = "of 2 Devil Wings delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 19) extra2 = "of 10 Teeny Devil Wings delivered";
				else if (pInfo(p_)->lastquest == "fire" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// steel
				if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 1) extra2 = "of 2,000 Chemical G delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 2) extra2 = "of 3 Robotic Lock delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 4) extra2 = "of 600 Robot Wants Dubstep delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 6) extra2 = "of 28 Growtoken earned";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 7) extra2 = "of 10 Edison Zoomster delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 9) extra2 = "of 1,000 High Tech Block delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Successful surgeries";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 13) extra2 = "of 1,000 providers collected";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 14) extra2 = "of 3 Bride Of Reanimator Remote delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 16) extra2 = "of 1 Mint Julep delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 17) extra2 = "of 5 Kerjigger delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 18) extra2 = "of 5 Doohickey delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 19) extra2 = "of 5 Doodad delivered";
				else if (pInfo(p_)->lastquest == "steel" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// heavens
				if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 1) extra2 = "of 1,000 Clouds delivered";
				
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 2) extra2 = "of 1 Pegasus Wings delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 4) extra2 = "of 600 Fairy Wings delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 6) extra2 = "of 50,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 7) extra2 = "of 3 Bubble Wings delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 9) extra2 = "of 800 Crimson Eagle Wings delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Successful surgeries";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 13) extra2 = "of 1,000 providers collected";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 14) extra2 = "of 1 Pearl Butterfly Wings delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 16) extra2 = "of 3 Golden Angel Wings delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 17) extra2 = "of 100 Ripper Wings delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 18) extra2 = "of 1 Phoenix Wings delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 19) extra2 = "of 1 Draconic Wings delivered";
				else if (pInfo(p_)->lastquest == "heavens" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// Ruler Sword
				 if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 1) extra2 = "of 50,000 Blocks destroyed";
				 else if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 2) extra2 = "of 50,000 seed of trees planted";
				 else if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 3) extra2 = "of 2,000,000,000 Gems earned";
				 else if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 4) extra2 = "of 50,000 Blocks destroyed";
				 else if (pInfo(p_)->lastquest == "Ruler Sword" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 Blocks destroyed";
				// blade
				if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 1) extra2 = "of 1,000 Iron Bars delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 2) extra2 = "of 10 Geiger Counter delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 4) extra2 = "of 600 Golden Swords delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 6) extra2 = "of 28 Growtoken earned";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 7) extra2 = "of 3 Heavenly Scythe delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 9) extra2 = "of 800 Headsman's Axe delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Radioactive items found";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 13) extra2 = "of 1,000 providers collected";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 14) extra2 = "of 20 Flamesaber delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 16) extra2 = "of 1 Golden Apple delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 17) extra2 = "of 25 Carrot Sword delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 18) extra2 = "of 1 Black Balrog's Tail delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 19) extra2 = "of 1,000 Sword delivered";
				else if (pInfo(p_)->lastquest == "blade" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// candour
				if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 1) extra2 = "of 2,000 Chemical Y delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 2) extra2 = "of 50 Adventure's Whip delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 4) extra2 = "of 1,000 Golden Block delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 6) extra2 = "of 28 Growtoken earned";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 7) extra2 = "of 10 Super Squirt Gun Jetpack delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 9) extra2 = "of 5 Soul Stone delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Radioactive items found";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 13) extra2 = "of 2,500lbs fish caught";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 14) extra2 = "of 3 Celestial Lance delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 16) extra2 = "of 3 Hooves of Cernunnos delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 17) extra2 = "of 3 Golden Talaria delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 18) extra2 = "of 1 Ultra trophy 3000 delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 19) extra2 = "of 3 Ancestral Totem of Wisdom delivered";
				else if (pInfo(p_)->lastquest == "candour" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// thesky
				if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 1) extra2 = "of 2,000 Obsidian delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 2) extra2 = "of 100 Fossil delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 4) extra2 = "of 1,000 Knight Helmet delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 6) extra2 = "of 28 Growtoken earned";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 7) extra2 = "of 10 Blanket Cape delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 9) extra2 = "of 800 Blazing Electro Wing delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Successful surgeries";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 13) extra2 = "of 2,500lbs fish caught";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 14) extra2 = "of 10 Autumn Wing delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 16) extra2 = "of 1 Golden Dragon Statue delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 17) extra2 = "of 5 Chaos Dragon delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 18) extra2 = "of 1 Draconic Wing delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 19) extra2 = "of 10 Dragon Knight's Chestplate delivered";
				else if (pInfo(p_)->lastquest == "thesky" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// theowl
				if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 1) extra2 = "of 2,000 Dwarven Background delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 2) extra2 = "of 2,000 Lava Lamp delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 4) extra2 = "of 600 Floating Hand delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 6) extra2 = "of 28 Growtoken earned";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 7) extra2 = "of 15 Monster Truck delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 9) extra2 = "of 10 Matrix Aura delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Successful surgeries";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 13) extra2 = "of 2,500lbs fish caught";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 14) extra2 = "of 1 Golden Silk Scarf delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 16) extra2 = "of 2 Snow Leopard Tail delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 17) extra2 = "of 3 Ultraviolet Aura delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 18) extra2 = "of 1 Lil Growpeep's Baaaa Blaster delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 19) extra2 = "of 1 Draconic Soul Aura delivered";
				else if (pInfo(p_)->lastquest == "theowl" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// mech
				if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 1) extra2 = "of 2,000 Dwarven Backgrounds delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 2) extra2 = "of 2,000 Lava Lamp delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 4) extra2 = "of 600 Floating Hand delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 6) extra2 = "of 28 Growtoken earned";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 7) extra2 = "of 15 Monster Truck delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 9) extra2 = "of 10 Matrix Aura delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Radioactive items found";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 13) extra2 = "of 1,000 providers collected";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 14) extra2 = "of 3 Spike Juice delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 16) extra2 = "of 3 Ambu-Lance delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 17) extra2 = "of 1 Mining Mech delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 18) extra2 = "of 1 Phoenix Armor delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 19) extra2 = "of 1 Volcanic Cape delivered";
				else if (pInfo(p_)->lastquest == "mech" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// zodiac
				if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 1) extra2 = "of 1 Zodiac Year of the Rabbit delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 2) extra2 = "of 1 Zodiac Year of the Tiger delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 3) extra2 = "of 5,000 Blocks destroyed";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 4) extra2 = "of 1 Zodiac Year of the Horse delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 5) extra2 = "of 50,000 rarity of trees planted";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 6) extra2 = "of 28 Growtoken earned";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 7) extra2 = "of 1 Zodiac Year of the Goat delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 8) extra2 = "of 10,000 XP earned";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 9) extra2 = "of 1 Zodiac Year of the Monkey delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 10) extra2 = "of 100.000 Gems delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 11) extra2 = "of 100,000 rarity of blocks destroyed";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 12) extra2 = "of 100 Radioactive items found";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 13) extra2 = "of 1,000 providers collected";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 14) extra2 = "of 1 Zodiac Year of the Rooster delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 15) extra2 = "of 100,000 rarity of fruits plucked";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 16) extra2 = "of 1 Zodiac Year of the Dog delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 17) extra2 = "of 1 Zodiac Year of the Pig delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 18) extra2 = "of 1 Zodiac Year of the Rat delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 19) extra2 = "of 1 Zodiac Year of the Ox delivered";
				else if (pInfo(p_)->lastquest == "zodiac" && pInfo(p_)->quest_step == 20) extra2 = "of 1 Legendary Orb delivered";
				// Carnival Quest
				if (pInfo(p_)->C_QuestKind == 1) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Delivered";
				else if (pInfo(p_)->C_QuestKind == 2) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Rarity of fruits plucked";
				else if (pInfo(p_)->C_QuestKind == 3) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Rarity of trees planted";
				else if (pInfo(p_)->C_QuestKind == 4) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Blocks destroyed";
				else if (pInfo(p_)->C_QuestKind == 5) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Rarity of blocks destroyed";
				else if (pInfo(p_)->C_QuestKind == 6) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " XP earned";
				else if (pInfo(p_)->C_QuestKind == 7) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Gems delivered";
				else if (pInfo(p_)->C_QuestKind == 8) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " World Lock Delivered";
				else if (pInfo(p_)->C_QuestKind == 9) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Growtopians saved";
				else if (pInfo(p_)->C_QuestKind == 10) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Providers collected";
				else if (pInfo(p_)->C_QuestKind == 11) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Growtoken earned";
				else if (pInfo(p_)->C_QuestKind == 12) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Crystal shattered";
				else if (pInfo(p_)->C_QuestKind == 13) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Radioactive found";
				else if (pInfo(p_)->C_QuestKind == 14) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + "lbs fish caught";
				else if (pInfo(p_)->C_QuestKind == 15) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " DNA Spliced";
				//
				if (pInfo(p_)->quest_active) {
					extra = "\nadd_textbox|`9Legendary Quest``|left|\nadd_label_with_icon|small|`9" + questType + " ``(Step " + to_string(pInfo(p_)->quest_step) + "/20) - " + fixint(pInfo(p_)->quest_progress) + " " + extra2 + "|left|1794|";
				}
				if (pInfo(p_)->C_QuestActive) {
					CQ = "\nadd_textbox|`9Ringmaster Quest``|left|\nadd_label_with_icon|small|`9Quest For The Ring `` (Step " + to_string(pInfo(p_)->C_QuestStep) + "/10) - " + fixint(pInfo(p_)->C_QuestProgress) + " " + quest_info + "|left|1900|";
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|small|" + pInfo(p_)->tankIDName + "'s Goals|left|982|\nadd_spacer|small|"/*"\nadd_textbox|`9Life Goals``|left|\nadd_smalltext|`9Awesomeness: 13%``|left|\nadd_label_with_icon|small|`3Seed Goal:`` Deliver 200 Rock (0/200)``|left|3|\nadd_label_with_icon|small|`3Gem Goal:`` Smash 5000 rarity of blocks (2884/5000)``|left|112|\nadd_label_with_icon|small|`3Experience Goal:`` Defeat 10 players in Games (0/10)``|left|1488|\nadd_smalltext|Completed Life Goals will reset in 4 hours, 20 mins|left|\nadd_spacer|small|"*/"\nadd_textbox|`9Daily Quest``|left|\nadd_label_with_icon|small|" + (!pInfo(p_)->AlreadyDailyQ ? "Deliver `2" + to_string(gems_c) + " gems`` to Crazy Jim" : "`2COMPLETE!`` Check again tomorrow.") + "|left|1486|" + extra + CQ + "\nadd_spacer|small|\nadd_textbox|`9Finish and receive awesome rewards from farming, geiger finding or trees removing, checkout the prizes below.``|left|\nadd_player_info|`oSurgeon``|" + to_string(pInfo(p_)->s_lvl) + "|" + to_string(pInfo(p_)->s_xp) + "|" + to_string(10 * ((pInfo(p_)->s_lvl * pInfo(p_)->s_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|surgery_reward|View Surgery Rewards|noflags|0|0|\nadd_player_info|`oFishing``|" + to_string(pInfo(p_)->ff_lvl) + "|" + to_string(pInfo(p_)->ff_xp) + "|" + to_string(5 * ((pInfo(p_)->ff_lvl * pInfo(p_)->ff_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|fishing_reward|View Fishing Rewards|noflags|0|0|\nadd_player_info|`oBuilder``|" + to_string(pInfo(p_)->bb_lvl) + "|" + to_string(pInfo(p_)->bb_xp) + "|" + to_string(100 * ((pInfo(p_)->bb_lvl * pInfo(p_)->bb_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|builder_reward|View Builder Rewards|noflags|0|0|\nadd_spacer|small|\nadd_player_info|`oFarmer``|" + to_string(pInfo(p_)->t_lvl) + "|" + to_string(pInfo(p_)->t_xp) + "|" + to_string(100 * ((pInfo(p_)->t_lvl * pInfo(p_)->t_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|farmer_reward|View Farmer Rewards|noflags|0|0|\nadd_spacer|small|\nadd_player_info|`oProvider``|" + to_string(pInfo(p_)->p_lvl) + "|" + to_string(pInfo(p_)->p_xp) + "|" + to_string(75 * ((pInfo(p_)->p_lvl * pInfo(p_)->p_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|provider_reward|View Provider Rewards|noflags|0|0|\nadd_spacer|small|\nadd_player_info|`oGeiger Hunting``|" + to_string(pInfo(p_)->g_lvl) + "|" + to_string(pInfo(p_)->g_xp) + "|" + to_string(5 * ((pInfo(p_)->g_lvl * pInfo(p_)->g_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|geiger_reward|View Geiger Hunting Rewards|noflags|0|0|\nadd_spacer|small|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 14 and a_[11] == "trade" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_ and not pInfo(currentPeer)->invis) {
							for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
								if (pInfo(currentPeer)->friends[c_].uid == pInfo(p_)->uid) {
									if (pInfo(currentPeer)->friends[c_].block_trade)
										return;
								}
							}
							if (pInfo(currentPeer)->trading_with != -1 and pInfo(currentPeer)->trading_with != pInfo(p_)->netID) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("That person is busy.");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1;
								{
									gamepacket_t p;
									p.Insert("OnForceTradeEnd");
									p.CreatePacket(p_);
								}
								return;
							}
							pInfo(p_)->trading_with = pInfo(currentPeer)->netID;
							pInfo(p_)->trade_accept = 0;
							pInfo(currentPeer)->trade_accept = 0;
							gamepacket_t p;
							p.Insert("OnStartTrade");
							p.Insert(pInfo(currentPeer)->tankIDName);
							p.Insert(pInfo(currentPeer)->netID);
							p.CreatePacket(p_);
							if (pInfo(currentPeer)->trading_with != -1) {
								// as neisivaizduoju kdl real gt taip daro bet noriu kad butu kaip rgt.
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(p_)->netID);
								p.Insert("");
								p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
								p.Insert("locked|0\nreset_locks|1\naccepted|0");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnTradeStatus");
									p.Insert(pInfo(p_)->netID);
									p.Insert("");
									p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
									p.Insert("locked|0\naccepted|1");
									p.CreatePacket(p_);
								}
								{
									gamepacket_t p;
									p.Insert("OnTradeStatus");
									p.Insert(pInfo(p_)->netID);
									p.Insert("");
									p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
									p.Insert("locked|0\nreset_locks|1\naccepted|0");
									p.CreatePacket(p_);
								}
								{
									gamepacket_t p;
									p.Insert("OnTradeStatus");
									p.Insert(pInfo(currentPeer)->netID);
									p.Insert("");
									p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
									p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnTradeStatus");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("");
										p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
										p.Insert("locked|0\nreset_locks|1\naccepted|0");
										p.CreatePacket(currentPeer);
									}
									{
										gamepacket_t p;
										p.Insert("OnTradeStatus");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("");
										p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
										p.Insert("locked|0\naccepted|1");
										p.CreatePacket(currentPeer);
									}
									{
										gamepacket_t p;
										p.Insert("OnTradeStatus");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("");
										p.Insert("`o" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``'s offer.``");
										p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
										p.CreatePacket(currentPeer);
									}
									{
										gamepacket_t p;
										p.Insert("OnTradeStatus");
										p.Insert(pInfo(p_)->netID);
										p.Insert("");
										p.Insert("`o" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``'s offer.``");
										p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\nreset_locks|1\naccepted|0");
										p.CreatePacket(currentPeer);
									}
								}
								break;
							}
							packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`#TRADE ALERT:`` `w" + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "```` wants to trade with you!  To start, use the `wWrench`` on that person's wrench icon, or type `w/trade " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``");
								p.CreatePacket(currentPeer);
							}
							break;
						}
					}
				}
			}
			else if (a_.size() == 14 and a_[11] == "mute_player" and isdigit(a_[5][0]) and isdigit(a_[8][0]) or a_.size() == 14 and a_[11] == "unmute_player" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
						for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
							if (pInfo(p_)->friends[c_].uid == pInfo(currentPeer)->uid) {
								if (a_[11] == "mute_player")
									pInfo(p_)->friends[c_].mute = true;
								else
									pInfo(p_)->friends[c_].mute = false;
								break;
							}
						}
						break;
					}
				}
			}
			else if (a_.size() == 14 and a_[11] == "freeze_player" and isdigit(a_[5][0]) and isdigit(a_[8][0]) or a_.size() == 14 and a_[11] == "thaw_player" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
						if (a_[11] == "freeze_player")
							pInfo(p_)->isFrozen = true;
						else
						if (a_[11] == "thaw_player")
							pInfo(p_)->isFrozen = false;
						break;
					}
				}
				break;
			}
			else if (a_.size() == 14 and a_[11] == "worldban" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				SendCmd(p_, "/ban " + pInfo(p_)->last_wrenched, true);
			}
			else if (a_.size() == 14 and a_[11] == "pull" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				SendCmd(p_, "/pull " + pInfo(p_)->last_wrenched, true);
			}
			else if (a_.size() == 14 and a_[11] == "kick" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				SendCmd(p_, "/kick " + pInfo(p_)->last_wrenched, true);
			}
			else if (a_.size() == 14 and a_[11] == "punish_view" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				if (pInfo(p_)->mod == 1 || pInfo(p_)->admin == 1) {
					SendCmd(p_, "/info " + pInfo(p_)->last_wrenched, true);
				}
			}
			else if (a_.size() == 14 and a_[11] == "start_surg" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				bool has_recovery = false;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world or pInfo(p_)->last_wrenched != pInfo(currentPeer)->tankIDName or pInfo(currentPeer)->hospital_bed == false) continue;
					for (int i_ = 0; i_ < pInfo(currentPeer)->playmods.size(); i_++) if (pInfo(currentPeer)->playmods[i_].id == 89) has_recovery = true;
					if (has_recovery == false) {
						if (setstats(p_, pInfo(currentPeer)->surgery_type, pInfo(currentPeer)->tankIDName, (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``")) {
							PlayMods new_playmod{};
							int seconds = 3600;
							if (pInfo(currentPeer)->necklace == 8954) seconds *= 0.75;
							new_playmod.id = 89, new_playmod.time = time(nullptr) + seconds;
							pInfo(currentPeer)->playmods.push_back(new_playmod);
							gamepacket_t p2;
							p2.Insert("OnConsoleMessage"), p2.Insert(a + "You are recovering from surgery. (`$Recovery`` mod added, `$" + (pInfo(currentPeer)->necklace == 8954 ? "45 mins" : "1 hour") + "`` left)"), p2.CreatePacket(currentPeer);
							pInfo(currentPeer)->surgery_type = rand() % 30;
						}
					}
				}
			}
			else if (a_.size() == 14 and a_[11] == "battle_pvp" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world or pInfo(p_)->last_wrenched != pInfo(currentPeer)->tankIDName) continue;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|small|Asking " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` for PVP?|left|8950|\nembed_data|netID|" + to_string(pInfo(currentPeer)->netID) + "\nadd_smalltext|How much bet would you like to put?|left|\nadd_text_input|bet|||5|\nadd_smalltext|The bet can only between 100 - 5000<CR>You can only bet the same amount of your enemy!<CR>You have 2 minutes to get the highest score.|left|\nend_dialog|battle_pvp|Nevermind|Ask|\nadd_quick_exit|\n");
					p.CreatePacket(p_);
				}
			}
			else if (a_.size() == 14 and a_[11] == "invitetoguild" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
				if (pInfo(p_)->guild_id == 0) break;
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							if (member_search.role_id != 3 and member_search.role_id != 2 and member_search.role_id != 1) return;
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
									if (pInfo(currentPeer)->guild_id != 0) return;
									if (guild_information->guild_members.size() >= guild_information->guild_level * 5) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
											p.CreatePacket(p_);
										}
										return;
									}
									pInfo(currentPeer)->pending_guild = pInfo(p_)->guild_id;
									packet_(currentPeer, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
									{
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("`5[``Guild request sent to " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "```5]``");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
									}
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5GUILD REQUEST:`` You've been invited to join `2" + guild_information->guild_name + " `` by " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``! To accept, `wwrench yourself`` and then choose `2Join " + guild_information->guild_name + "``.");
									p.CreatePacket(currentPeer);
									create_guild_log(guild_information, "`$" + pInfo(currentPeer)->tankIDName + "`` `wwas invited by`` `$" + pInfo(p_)->tankIDName + "``", 6);
									return;
								}
							}
							break;
						}
					}
				}
				{
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("Hmm, that person left.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
				}
			}
			else if (a_.size() == 14 and a_[11] == "aff_bestie" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				if (pInfo(p_)->affinity_with <= 0 || pInfo(p_)->affinity_level <= 0) pInfo(p_)->affinity_type = NO_AFFINITY;
				if (pInfo(p_)->affinity_type != NO_AFFINITY) break;
				if (pInfo(p_)->affinity_with != 0) break;
				int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
							if (pInfo(currentPeer)->affinity_with <= 0 || pInfo(currentPeer)->affinity_level <= 0) pInfo(currentPeer)->affinity_type = NO_AFFINITY;
							if (pInfo(currentPeer)->affinity_type != NO_AFFINITY) break;
							if (pInfo(currentPeer)->affinity_level >= 1) break;
							if (pInfo(currentPeer)->affinity_with != 0) break;

							if (to_lower(pInfo(currentPeer)->pending_affinity) == to_lower(pInfo(p_)->tankIDName) && pInfo(currentPeer)->pending_affinity_type == BESTIE) {
								packet_(p_, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`3AFFINITY APPLIED:`` You're now bestie with " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``!");
								p.CreatePacket(p_);
								pInfo(p_)->affinity_level = 1;
								pInfo(p_)->affinity_with = pInfo(currentPeer)->uid;
								pInfo(p_)->affinity_type = BESTIE;
								//pInfo(p_)->titleStartopia = true;
								//pInfo(p_)->roleSkin = 5;
								//pInfo(p_)->roleIcon = 5;
								gamepacket_t p51(0, pInfo(p_)->netID);
								p51.Insert("OnSetRoleSkinsAndIcons"), p51.Insert(pInfo(p_)->roleSkin), p51.Insert(pInfo(p_)->roleIcon), p51.Insert(0);
								p51.CreatePacket(p_);
								p51.CreatePacket(currentPeer);
								gamepacket_t p_1;
								p_1.Insert("OnConsoleMessage");
								p_1.Insert("Friendship is the key of victory. (`$Power of Friendship: Reduce Provider Growth`` mod added)");
								p_1.CreatePacket(p_);
								{
									packet_(currentPeer, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`3AFFINITY APPLIED:`` You're now bestie with " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``!");
									p.CreatePacket(currentPeer);
									pInfo(currentPeer)->affinity_level = 1;
									pInfo(currentPeer)->affinity_with = pInfo(p_)->uid;
									pInfo(currentPeer)->affinity_type = BESTIE;
									//pInfo(currentPeer)->titleStartopia = true;
									//pInfo(currentPeer)->roleSkin = 5;
									//pInfo(currentPeer)->roleIcon = 5;
									gamepacket_t p5(0, pInfo(currentPeer)->netID);
									p5.Insert("OnSetRoleSkinsAndIcons"), p5.Insert(pInfo(currentPeer)->roleSkin), p5.Insert(pInfo(currentPeer)->roleIcon), p5.Insert(0);
									p5.CreatePacket(p_);
									p5.CreatePacket(currentPeer);
									gamepacket_t p2;
									p2.Insert("OnConsoleMessage");
									p2.Insert("Friendship is the key of victory. (`$Power of Friendship: Reduce Provider Growth`` mod added)");
									p2.CreatePacket(currentPeer);
								}
								pInfo(currentPeer)->pending_affinity.clear();
								pInfo(currentPeer)->pending_affinity_type = 0;
								save_player(pInfo(p_), false);
								save_player(pInfo(currentPeer), false);
							}
							else {
								if ((pInfo(p_)->affinity_with) == (pInfo(currentPeer)->uid)) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I already have an affinity with this person.");
									p.Insert(0), p.Insert(0);
									return;
								}
								if (abs((pInfo(currentPeer)->x / 32) - (pInfo(p_)->x / 32)) >= 3) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`5[```4Too far away`` `0- Stand closer to`` " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "```0 first!```5]``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
								pInfo(p_)->pending_affinity = pInfo(currentPeer)->tankIDName;
								pInfo(p_)->pending_affinity_type = BESTIE;
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("`5[``Affinity request sent to " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "```5]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								{
									packet_(currentPeer, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`3AFFINITY REQUEST:`` You've received an `waffinity request`` from " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``! To accept, press the `wwrench by his/her name`` and then choose `2Request for bestie affinity``.");
									p.CreatePacket(currentPeer);
								}
							}
							return;
						}
					}
				}
				}
			else if (a_.size() == 14 and a_[11] == "aff_lover" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				if (pInfo(p_)->affinity_type != NO_AFFINITY) break;
				if (pInfo(p_)->affinity_level >= 1) break;
				if (pInfo(p_)->affinity_with != 0) break;
				int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
							if (pInfo(currentPeer)->affinity_type != NO_AFFINITY) break;
							if (pInfo(currentPeer)->affinity_level >= 1) break;
							if (pInfo(currentPeer)->affinity_with != 0) break;

							if (to_lower(pInfo(currentPeer)->pending_affinity) == to_lower(pInfo(p_)->tankIDName) && pInfo(currentPeer)->pending_affinity_type == LOVER) {
								packet_(p_, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`3AFFINITY APPLIED:`` You're now lover with " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``!");
								p.CreatePacket(p_);
								pInfo(p_)->affinity_level = 1;
								pInfo(p_)->affinity_with = pInfo(currentPeer)->uid;
								pInfo(p_)->affinity_type = LOVER;
								pInfo(p_)->titleDoctor = true;
								pInfo(p_)->roleSkin = 2;
								pInfo(p_)->roleIcon = 2;
								gamepacket_t p51(0, pInfo(p_)->netID);
								p51.Insert("OnSetRoleSkinsAndIcons"), p51.Insert(pInfo(p_)->roleSkin), p51.Insert(pInfo(p_)->roleIcon), p51.Insert(0);
								p51.CreatePacket(p_);
								p51.CreatePacket(currentPeer);
								gamepacket_t pck;
								pck.Insert("OnConsoleMessage");
								pck.Insert("Without love, everyone will feel lonely. (`$Power of Love: Reduce Provider Growth`` mod added)");
								pck.CreatePacket(p_);
								{
									packet_(currentPeer, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`3AFFINITY APPLIED:`` You're now lover with " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``!");
									p.CreatePacket(currentPeer);
									pInfo(currentPeer)->affinity_level = 1;
									pInfo(currentPeer)->affinity_with = pInfo(p_)->uid;
									pInfo(currentPeer)->affinity_type = LOVER;
									pInfo(currentPeer)->titleDoctor = true;
									pInfo(currentPeer)->roleSkin = 2;
									pInfo(currentPeer)->roleIcon = 2;
									gamepacket_t p5(0, pInfo(currentPeer)->netID);
									p5.Insert("OnSetRoleSkinsAndIcons"), p5.Insert(pInfo(currentPeer)->roleSkin), p5.Insert(pInfo(currentPeer)->roleIcon), p5.Insert(0);
									p5.CreatePacket(p_);
									p5.CreatePacket(currentPeer);
									gamepacket_t p_2;
									p_2.Insert("OnConsoleMessage");
									p_2.Insert("Without love, everyone will feel lonely. (`$Power of Love: Reduce Provided Growth`` mod added)");
									p_2.CreatePacket(currentPeer);
								}
								pInfo(currentPeer)->pending_affinity.clear();
								pInfo(currentPeer)->pending_affinity_type = 0;

								save_player(pInfo(p_), false);
								save_player(pInfo(currentPeer), false);
							}
							else {
								if ((pInfo(p_)->affinity_with) == (pInfo(currentPeer)->uid)) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I already have an affinity with this person.");
									p.Insert(0), p.Insert(0);
									return;
								}
								if (abs((pInfo(currentPeer)->x / 32) - (pInfo(p_)->x / 32)) >= 3) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`5[```4Too far away`` `0- Stand closer to`` " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "```0 first!```5]``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
								pInfo(p_)->pending_affinity = pInfo(currentPeer)->tankIDName;
								pInfo(p_)->pending_affinity_type = LOVER;
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("`5[``Affinity request sent to " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "```5]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								{
									packet_(currentPeer, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`3AFFINITY REQUEST:`` You've received an `waffinity request`` from " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``! To accept, press the `wwrench by his/her name`` and then choose `2Request for lover affinity``.");
									p.CreatePacket(currentPeer);
								}
							}
							return;
						}
					}
				}
			}
			else if (a_.size() == 14 and a_[11] == "friend_add" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
							if (find(pInfo(currentPeer)->pending_friends.begin(), pInfo(currentPeer)->pending_friends.end(), pInfo(p_)->uid) != pInfo(currentPeer)->pending_friends.end()) {
								packet_(p_, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
								long long time_t = time(NULL);
								Friends new_friend_;
								new_friend_.name = pInfo(currentPeer)->tankIDName;
								new_friend_.uid = pInfo(currentPeer)->uid;
								new_friend_.mute = false;
								new_friend_.block_trade = false;
								new_friend_.last_seen = time_t;
								pInfo(p_)->friends.push_back(new_friend_);
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`3FRIEND ADDED:`` You're now friends with " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "``!");
								p.CreatePacket(p_);
								{
									packet_(currentPeer, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
									Friends new_friend_;
									new_friend_.name = pInfo(p_)->tankIDName;
									new_friend_.uid = pInfo(p_)->uid;
									new_friend_.mute = false;
									new_friend_.block_trade = false;
									new_friend_.last_seen = time_t;
									pInfo(currentPeer)->friends.push_back(new_friend_);
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`3FRIEND ADDED:`` You're now friends with " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``!");
									p.CreatePacket(currentPeer);
									if (pInfo(p_)->friends.size() == 10 || pInfo(p_)->friends.size() == 20 || pInfo(p_)->friends.size() == 30 || pInfo(p_)->friends.size() == 40 || pInfo(p_)->friends.size() == 50) form_emoji(p_, true);
									if (pInfo(currentPeer)->friends.size() == 10 || pInfo(p_)->friends.size() == 20 || pInfo(p_)->friends.size() == 30 || pInfo(p_)->friends.size() == 40 || pInfo(p_)->friends.size() == 50) form_emoji(currentPeer, true);
								}
								pInfo(currentPeer)->pending_friends.erase(remove(pInfo(currentPeer)->pending_friends.begin(), pInfo(currentPeer)->pending_friends.end(), pInfo(p_)->uid), pInfo(currentPeer)->pending_friends.end());
							}
							else {
								for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
									if (pInfo(p_)->friends[c_].uid == pInfo(currentPeer)->uid) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("That's already my friend!");
										p.Insert(0), p.Insert(0);
										return;
									}
								}
								if (abs((pInfo(currentPeer)->x / 32) - (pInfo(p_)->x / 32)) >= 3) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`5[```4Too far away`` `0- Stand closer to`` " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "```0 first!```5]``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
								pInfo(p_)->pending_friends.push_back(pInfo(currentPeer)->uid);
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("`5[``Friend request sent to " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "```5]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								{
									packet_(currentPeer, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`3FRIEND REQUEST:`` You've received a `wfriend request`` from " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "``! To accept, press the `wwrench by his/her name`` and then choose `wAdd as friend``.");
									p.CreatePacket(currentPeer);
								}
							}
							return;
						}
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("Hmm, that person left.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
				}
			}
			else if (a_.size() == 8 and a_[5] == "acceptguild") {
				if (pInfo(p_)->pending_guild == 0 or pInfo(p_)->guild_id != 0) break;
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					uint32_t guild_id = pInfo(p_)->pending_guild;
					vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
					if (p != guilds.end()) {
						Guild* guild_information = &guilds[p - guilds.begin()];
						if (guild_information->guild_members.size() >= guild_information->guild_level * 5) {
							pInfo(p_)->pending_guild = 0;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("The Guild is full and cannot accept any new members at this time!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							break;
						}
						GuildMember new_member{};
						new_member.member_name = pInfo(p_)->tankIDName;
						new_member.role_id = 0;
						new_member.last_online = time(NULL);
						guild_information->guild_members.push_back(new_member);
						pInfo(p_)->pending_guild = 0;
						pInfo(p_)->guild_id = guild_information->guild_id;
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You Succesfully joined " + guild_information->guild_name);
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
						}
						update_clothes(p_);
						gamepacket_t p_2;
						p_2.Insert("OnConsoleMessage");
						p_2.Insert("`5[GUILD ALERT]`` " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` joined the guild!");
						if (pInfo(p_)->world == guild_information->guild_world and guild_access(p_, guild_id)) {
							int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
							for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
								if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
									uint16_t id_ = world_->blocks[i_].fg;
									if (id_ == 5814) {
										int x_ = i_ % xSize;
										int y_ = i_ / xSize;
										WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
										PlayerMoving data_2{};
										data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
										BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
										BYTE* blc = raw2 + 56;
										form_visual(blc, *block_, *world_, p_, false);
										update_clothes(p_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
											if (pInfo(currentPeer)->guild_id == pInfo(p_)->guild_id) {
												p_2.CreatePacket(currentPeer);
											}
										}
										delete[] raw2, blc;
										break;
									}
								}
							}
						}
						else {
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->guild_id == pInfo(p_)->guild_id) {
									p_2.CreatePacket(currentPeer);
								}
							}
						}
						create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `wjoined the guild", 5948);
					}
				}
			}
			else if (a_.size() == 8 and a_[5] == "acceptlock") {
				if (pInfo(p_)->ac_.size() == 0) break;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world) {
						if (pInfo(p_)->ac_.find(pInfo(currentPeer)->netID) != pInfo(p_)->ac_.end()) {
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								string owner_name = world_->owner_name, user_name = pInfo(currentPeer)->tankIDName;
								if (owner_name != user_name and not pInfo(p_)->admin) break;
								int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
								int x_ = (pInfo(p_)->ac_[pInfo(currentPeer)->netID]) % xSize, y_ = (pInfo(p_)->ac_[pInfo(currentPeer)->netID]) / xSize;
								if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
								WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
									if (block_->owner_name != user_name and not pInfo(currentPeer)->dev) break;
								}
								else {
									if (owner_name != user_name and not pInfo(currentPeer)->dev) break;
								}
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|small|Accept Access To World|left|242|\nadd_smalltext|When you have access to a world, you are responsible for anything the world's owners or other admins do.|left|\nadd_smalltext|Don't accept access to a world unless it is from people you trust.|left|\nadd_smalltext|You can remove your access later by either wrenching the lock, or typing `2/unaccess`` to remove yourself from all locks in the world.|left|\nadd_spacer|small|\nadd_textbox|Are you sure you want to be added to this " + items[block_->fg].name + "?|left|\nend_dialog|acceptaccess|No|Yes|");
								p.CreatePacket(p_);
							}
							break;
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "lock_edit" or a_[i_] == "editguildlock") {
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				/*if (a_.size() != 23 and a_.size() != 25 and a_.size() != 26 and a_.size() != 11) break;
				if (not isdigit(a_[i_+2][0]) and a_.size() != 11 or not isdigit(a_[i_+5][0]) and a_.size() != 11) break;*/
				int x_ = 0, y_ = 0;

				try {
					x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				}
				catch (out_of_range) {
					return;
				}
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				if (p != worlds.end()) {
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (items[t_].blockType != BlockTypes::LOCK) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (a_.size() == 11) { // remove my access
						if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
							if (find(block_->admins.begin(), block_->admins.end(), pInfo(p_)->uid) != block_->admins.end()) {
								block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), pInfo(p_)->uid), block_->admins.end());
								packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert(user_name + " removed their access from a " + items[t_].name);
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										p.CreatePacket(currentPeer);
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									} if (pInfo(currentPeer)->world == world_->name and pInfo(currentPeer)->tankIDName == user_name) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("I've removed my access!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(currentPeer);
									}
								}
								delete[] raw, blc;
								if (block_->locked) {
									upd_lock(*block_, *world_, p_);
								}
							}
						}
						else if (find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) != world_->admins.end()) {
							world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid), world_->admins.end());
							packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert(user_name + " removed their access from a " + items[t_].name);
							gamepacket_t p2(0, pInfo(p_)->netID);
							{
								p2.Insert("OnNameChanged");
								if (not HasRole(pInfo(p_)) and not pInfo(p_)->is_legend) pInfo(p_)->name_color = "`0";
								else if (pInfo(p_)->is_legend) pInfo(p_)->name_color = "`9";
								p2.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name)) + (pInfo(p_)->is_datemaster ? " `4Datemaster" : "") + (pInfo(p_)->is_legend ? " of Legend" : "") + "``");
							}
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, p_, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								} if (pInfo(currentPeer)->world == world_->name and pInfo(currentPeer)->tankIDName == user_name) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I've removed my access!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(currentPeer);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
						break;
					}
					if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
						if (block_->owner_name != user_name and not pInfo(p_)->admin) break;
					}
					else {
						if (owner_name != user_name and not pInfo(p_)->admin) break;
					}
					bool reapply = false;
					for (int b_ = 0; b_ < a_.size(); b_++) {
						bool upd_ = false;
						if (a_[b_] == "getKey") {
							if (pInfo(p_)->tankIDName != world_->owner_name) break;
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
							int key_ = 1424;
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									uint32_t my_rank = 0;
									for (GuildMember member_search : guild_information->guild_members) {
										if (member_search.member_name == pInfo(p_)->tankIDName) {
											my_rank = member_search.role_id;
											break;
										}
									}
									if (my_rank < 3) break;
									key_ = 5816;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert((guild_information->guild_mascot[0] != 0 || guild_information->guild_mascot[1] != 0 ? "add_dual_layer_icon_label|big|`wGet Guild Key``|left|" + to_string(guild_information->guild_mascot[0]) + "|" + to_string(guild_information->guild_mascot[1]) + "|1.0|0|" : "add_label_with_icon|big|`wGet Guild Key``|left|" + to_string(key_) + "|") + "\nadd_spacer|small|\nadd_textbox|The key to this lock can be used to transfer leadership of the guild to another guild Member.|left|\nadd_textbox|Use it like a `5World Lock Key``, but you can only give it to another Member of your guild!|left|\nadd_spacer|small|\nadd_textbox|`4Warning!`` By giving the `5Guild Key`` to another Member, you are effectively `rpromoting`` them to Guild Leader and `4demoting`` yourself at the same time!|left|\nadd_textbox|Are you sure you want to take the `5" + items[key_].name + "`` from the " + items[block_->fg].name + "?|left|\nend_dialog|confirmguildlockkey|Cancel|OK|\nadd_quick_exit|");
									p.CreatePacket(p_);
									return;
								}
							}
							int c_ = 0;
							if (pInfo(p_)->tankIDName == world_->owner_name) modify_inventory(p_, 1424, c_);
							if (c_ != 0) break;
							for (int i_ = 0; i_ < world_->drop.size(); i_++) {
								if (world_->drop[i_].x == -1 or world_->drop[i_].id == 0) continue;
								WorldBlock* block_ = &world_->blocks[(world_->drop[i_].x / 32) + ((world_->drop[i_].y / 32) * world_->width)];
								if (items[block_->fg].collisionType != 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4Oops!... Can't trade a world with floating items that are unblocked or in treasure chests!``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
							}
							for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
								if (world_->blocks[i_].fg == 4516) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4To trade a world, you will need to remove Untrade-a-Box!``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
							}
							for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
								if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
									uint16_t id_ = world_->blocks[i_].fg;
									if (id_ == 202 or id_ == 204 or id_ == 206 or id_ == 4994) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("To trade a world, you can only have one lock on it, the `5World Lock``.  Remove the rest!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										return;
									}
								}
							}
							if (world_->admins.size() != 0) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("You'll first need to remove all players with access to your " + items[block_->fg].name + " to get a " + items[key_].name + ".");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								return;
							}
							c_ = 1;
							if (modify_inventory(p_, key_, c_) == 0) {
								packet_(p_, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("You got a `#" + items[key_].name + "``! You can now trade this world to other players.");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
							}
						}
						else if (a_[b_] == "minimum_entry_level" and isdigit(a_[b_ + 1][0])) {
							if (world_->owner_name != pInfo(p_)->tankIDName) break;
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
							int new_entry_level_ = atoi(a_[b_ + 1].c_str());
							if (world_->entry_level != new_entry_level_) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								if (new_entry_level_ < 1) {
									p.Insert("Minimum entry level can't be lower than 1.");
									p.CreatePacket(p_);
									continue;
								}
								if (new_entry_level_ > 124) {
									p.Insert("Minimum entry level can't be higher than 124.");
									p.CreatePacket(p_);
									continue;
								}
								world_->entry_level = new_entry_level_;
								p.Insert("Minimum entry level for this world is set to `2Level " + to_string(new_entry_level_) + "``.");
								p.CreatePacket(p_);
							}
						}
						else if (a_[b_] == "clear_a_world") {
							// rumus: x (const) * width * height

							string type = "default";
							int price = 200000;
							int price_mt = 100;
							if (world_->width * world_->height == 40000)
								type = "wide";

							//int price = 15 * world_->width * world_->height;
							if (type == "wide") {
								if (pInfo(p_)->gems == price) {
									packet_(p_, format("action|log\nmsg|You have {} gems short!", setGems(price - pInfo(p_)->gems)));
									return;
								}
							}

							if ((pInfo(p_)->tankIDName != world_->owner_name) and not pInfo(p_)->dev) {
								packet_(p_, "action|log\nmsg|You must be the world owner to clear");
								return;
							}

							DialogBuilder db{ "`o" };
							db.add_label_icon(true, 2952, "`wClearing world options``")
								.add_textbox(format("Are you sure about clearing this world? This will costs {} {}!", type == "wide" ? setGems(price_mt) :
									setGems(price), type == "wide" ? "TayoPoint" : "gems"))
								.add_button("clear_confirm", "``Clear it for me``")
								.end_dialog("", "`wCancel``", "").add_quick_exit();

							gamepacket_t p;
							p.Insert("OnDialogRequest"), p.Insert(db.to_string()), p.CreatePacket(p_);
						}
						else if (a_[b_] == "sessionlength_dialog") {
							if (pInfo(p_)->tankIDName != world_->owner_name) break;
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSet World Timer``|left|1482|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|\nadd_textbox|Select a time limit for how long guests can stay in your world.|left|\nadd_checkbox|checkbox_0|None|" + (world_->World_Time == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_5|5 minutes|" + (world_->World_Time == 5 ? "1" : "0") + "\nadd_checkbox|checkbox_10|10 minutes|" + (world_->World_Time == 10 ? "1" : "0") + "\nadd_checkbox|checkbox_20|20 minutes|" + (world_->World_Time == 20 ? "1" : "0") + "\nadd_checkbox|checkbox_30|30 minutes|" + (world_->World_Time == 30 ? "1" : "0") + "\nadd_checkbox|checkbox_40|40 minutes|" + (world_->World_Time == 40 ? "1" : "0") + "\nadd_checkbox|checkbox_50|50 minutes|" + (world_->World_Time == 50 ? "1" : "0") + "\nadd_checkbox|checkbox_60|60 minutes|" + (world_->World_Time == 60 ? "1" : "0") + "\nend_dialog|sessionlength_edit|Nevermind|Set Time Limit|");
							p.CreatePacket(p_);
						}
						else if (a_[b_] == "changecat") {
							if (pInfo(p_)->tankIDName != world_->owner_name) break;
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|-1\nadd_textbox|Select a category for your world.|left|\nadd_button|cat0|None|noflags|0|0|\nadd_button|cat1|Adventure|noflags|0|0|\nadd_button|cat2|Art|noflags|0|0|\nadd_button|cat3|Farm|noflags|0|0|\nadd_button|cat4|Game|noflags|0|0|\nadd_button|cat5|Information|noflags|0|0|\nadd_button|cat15|Music|noflags|0|0|\nadd_button|cat6|Parkour|noflags|0|0|\nadd_button|cat14|Puzzle|noflags|0|0|\nadd_button|cat7|Roleplay|noflags|0|0|\nadd_button|cat8|Shop|noflags|0|0|\nadd_button|cat9|Social|noflags|0|0|\nadd_button|cat10|Storage|noflags|0|0|\nadd_button|cat11|Story|noflags|0|0|\nadd_button|cat12|Trade|noflags|0|0|\nadd_smalltext|Worlds in the category \"None\" can't be rated by players, and they are only listed on the normal World Select screen.|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world.|left|\nend_dialog|worldcategory|Nevermind||");
							p.CreatePacket(p_);
						}
						else if (a_[b_] == "tempo" and isdigit(a_[b_ + 1][0])) {
							if (world_->owner_name != pInfo(p_)->tankIDName) break;
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
							uint32_t new_bpm_ = atoi(a_[b_ + 1].c_str());
							if (world_->music_bpm != new_bpm_) {
								if (new_bpm_ < 20 or new_bpm_ > 200) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Tempo must be from 20-200 BPM.");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								world_->music_bpm = new_bpm_, upd_ = true;
							}
						}
						//recalcLock
						else if (a_[b_] == "recalcLock") {
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								reapply = true;
							}
							//break;
						}
						else if (a_[b_] == "editguildmascot") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									uint32_t my_rank = 0;
									for (GuildMember member_search : guild_information->guild_members) {
										if (member_search.member_name == pInfo(p_)->tankIDName) {
											my_rank = member_search.role_id;
											break;
										}
									}
									if (my_rank < 3) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert((guild_information->guild_mascot[0] != 0 || guild_information->guild_mascot[1] != 0 ? "add_dual_layer_icon_label|big|`wGrow Guild Mascot Editor ``|left|" + to_string(guild_information->guild_mascot[0]) + "|" + to_string(guild_information->guild_mascot[1]) + "|1.0|0|" : "add_label_with_icon|big|`wGrow Guild Mascot Editor ``|left|5814|") + "\nadd_spacer|small|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems``!|left|\nadd_textbox|Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_item_picker|selectitembackground|`wChoose Background Item``|Choose the mascot background item!|\nadd_item_picker|selectitemforeground|`wChoose Foreground Item``|Choose the mascot foreground item!|\nadd_spacer|small|\nadd_dual_layer_icon_label|small|`wGuild Mascot Preview: ``|left|" + to_string(guild_information->guild_mascot[0]) + "|" + to_string(guild_information->guild_mascot[1]) + "|5.0|1|\nadd_spacer|small|\nadd_textbox|Increase your membership to `w30`` or more for access exclusive foreground only mascots!|left|\nadd_spacer|small|\nadd_textbox|You have not yet changed your Guild Mascot!|left|\nembed_data|bgID|" + to_string(guild_information->guild_mascot[0]) + "\nembed_data|fgID|" + to_string(guild_information->guild_mascot[1]) + "\nend_dialog|editmascot|Cancel||\nadd_quick_exit|");
									p.CreatePacket(p_);
								}
							}
						}
						else if (a_[b_] == "abondonguildconfirm") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									uint32_t my_rank = 0;
									for (GuildMember member_search : guild_information->guild_members) {
										if (member_search.member_name == pInfo(p_)->tankIDName) {
											my_rank = member_search.role_id;
											break;
										}
									}
									if (my_rank < 3) break;
									if (guild_information->guild_members.size() != 1) {
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert((guild_information->guild_mascot[0] != 0 || guild_information->guild_mascot[1] != 0 ? "add_dual_layer_icon_label|big|`wAbandon Guild``|left|" + to_string(guild_information->guild_mascot[0]) + "|" + to_string(guild_information->guild_mascot[1]) + "|1.0|0|" : "add_label_with_icon|big|`wAbandon Guild``|left|5814|") + "\nadd_textbox|`1You need to kick all guild members before you can abandon the guild! `` |left|\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
										p.CreatePacket(p_);
										break;
									}
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert((guild_information->guild_mascot[0] != 0 || guild_information->guild_mascot[1] != 0 ? "add_dual_layer_icon_label|big|`wAbandon Guild``|left|" + to_string(guild_information->guild_mascot[0]) + "|" + to_string(guild_information->guild_mascot[1]) + "|1.0|0|" : "add_label_with_icon|big|`wAbandon Guild``|left|5814|") + "\nadd_spacer|small|\nadd_item_picker|selectworldlock|`wSelect a World Lock``|Choose a World Lock to replace the Guild Lock|\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
									p.CreatePacket(p_);
								}
								break;
							}
						}
						else if (a_[b_] == "upgrade_guild") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (guild_lvl[guild_information->guild_level - 1][0] == guild_information->guild_xp) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("add_dual_layer_icon_label|big|`wGuild Upgrade``|left|" + to_string(guild_information->guild_mascot[1]) + "|" + to_string(guild_information->guild_mascot[0]) + "|1.0|0|\nadd_textbox|Are you sure you want to upgrade the guild for `2" + to_string(guild_lvl[guild_information->guild_level - 1][1]) + " Gems``?|left|\nadd_spacer|small|\nadd_button|upgrade_guild_confirm|`wUpgrade Guild|\nend_dialog|upgrade_guilddss|Give Up!||");
									p.CreatePacket(p_);
								}
							}
							break;
						}
						}

						else if (a_[b_] == "create_guild_mascot") {
							/*
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									uint32_t my_rank = 0;
									for (GuildMember member_search : guild_information->guild_members) {
										if (member_search.member_name == pInfo(p_)->tankIDName) {
											my_rank = member_search.role_id;
											break;
										}
									}
									if (my_rank < 3) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert((guild_information->guild_mascot[0] != 0 || guild_information->guild_mascot[1] != 0 ? "add_dual_layer_icon_label|big|`wGrow Guild Mascot Editor ``|left|" + to_string(guild_information->guild_mascot[0]) + "|" + to_string(guild_information->guild_mascot[1]) + "|1.0|0|" : "add_label_with_icon|big|`wGrow Guild Mascot Editor ``|left|5814|") + "\nadd_spacer|small|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems``!|left|\nadd_textbox|Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_item_picker|selectitembackground|`wChoose Background Item``|Choose the mascot background item!|\nadd_item_picker|selectitemforeground|`wChoose Foreground Item``|Choose the mascot foreground item!|\nadd_spacer|small|\nadd_dual_layer_icon_label|small|`wGuild Mascot Preview: ``|left|" + to_string(guild_information->guild_mascot[0]) + "|" + to_string(guild_information->guild_mascot[1]) + "|5.0|1|\nadd_spacer|small|\nadd_textbox|Increase your membership to `w30`` or more for access exclusive foreground only mascots!|left|\nadd_spacer|small|\nadd_textbox|You have not yet changed your Guild Mascot!|left|\nembed_data|bgID|" + to_string(guild_information->guild_mascot[0]) + "\nembed_data|fgID|" + to_string(guild_information->guild_mascot[1]) + "\nend_dialog|editmascot|Cancel||\nadd_quick_exit|");
									p.CreatePacket(p_);
								}
							}
							*/
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("add_label|big|`wChange Guild Mascot``|left|\nadd_spacer|small|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `9250,000 Gems! ``Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_item_picker|select_bg_mascot|`wChoose Background Item``|Choose a Background for Guild Mascot|\nadd_item_picker|select_fg_mascot|`wChoose Foreground Item``|Choose a Foreground for Guild Mascot|\nadd_spacer|small|\nend_dialog|make_mascotss|Cancel||");
							p.CreatePacket(p_);
						}
						else if (a_[b_] == "upg2") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 200000) {
										pInfo(p_)->gems -= 200000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 2!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg3") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 300000) {
										pInfo(p_)->gems -= 300000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 3!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg4") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 400000) {
										pInfo(p_)->gems -= 400000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 4!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg5") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 500000) {
										pInfo(p_)->gems -= 500000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 5!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg6") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 1000000) {
										pInfo(p_)->gems -= 1000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 6!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg7") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 2000000) {
										pInfo(p_)->gems -= 2000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 7!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										//cout << "called upgradeguild function [LVL 2]" << endl;
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg8") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 3000000) {
										pInfo(p_)->gems -= 3000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 8!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										//cout << "called upgradeguild function [LVL 2]" << endl;
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg9") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 4000000) {
										pInfo(p_)->gems -= 4000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 9!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg10") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 5000000) {
										pInfo(p_)->gems -= 5000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 10!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg11") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 6000000) {
										pInfo(p_)->gems -= 6000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 11!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg12") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 8000000) {
										pInfo(p_)->gems -= 8000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 12!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg13") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 9000000) {
										pInfo(p_)->gems -= 9000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 13!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										//cout << "called upgradeguild function [LVL 2]" << endl;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg14") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 10000000) {
										pInfo(p_)->gems -= 10000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level 14!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										//cout << "called upgradeguild function [LVL 2]" << endl;
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_] == "upg15") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (pInfo(p_)->gems >= 15000000) {
										pInfo(p_)->gems -= 15000000;
										gamepacket_t pg;
										pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
										if (pInfo(p_)->supp >= 2) pg.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
										pg.CreatePacket(p_);
										guild_information->guild_level += 1;
										guild_information->guild_xp = 0;
										gamepacket_t p0;
										p0.Insert("OnAddNotification");
										p0.Insert("interface/large/gd_lup.rttex");
										p0.Insert("Awesome! You reached Guild Level Max!");
										p0.Insert("audio/hub_open.wav");
										p0.Insert(0);
										p0.CreatePacket(p_);
										//cout << "called upgradeguild function [LVL 2]" << endl;
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough gems!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(p_);
										break;
									}
								}
								break;
							}
						}
						else if (a_[b_].substr(0, 9) == "checkbox_") {
							if (world_->owner_name != pInfo(p_)->tankIDName) break;
							// checkboxes
							vector<string> target_ = explode("_", a_[b_]);
							if (target_[1] == "disable") {
								if (target_.size() == 4 and target_[2] == "music" and target_[3] == "render") {
									if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
									if (not world_->make_music_blocks_invisible and a_[b_ + 1] == "1") {
										world_->make_music_blocks_invisible = true, upd_ = true;
									}
									else if (world_->make_music_blocks_invisible and a_[b_ + 1] == "0") {
										world_->make_music_blocks_invisible = false, upd_ = true;
									}
								}
								else if (target_[2] == "music") {
									if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
									// music disable
									if (not world_->disable_music_blocks and a_[b_ + 1] == "1") {
										world_->disable_music_blocks = true, upd_ = true;
									}
									else if (world_->disable_music_blocks and a_[b_ + 1] == "0") {
										world_->disable_music_blocks = false, upd_ = true;
									}
								}
							}
							else if (target_.size() == 5 and target_[4] == "world") {
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
								// set as home world
								if (pInfo(p_)->home_world != world_->name and a_[b_ + 1] == "1") {
									pInfo(p_)->home_world = world_->name;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert(world_->name + " has been set as your home world!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
								}
								else if (pInfo(p_)->home_world == world_->name and a_[b_ + 1] == "0") {
									pInfo(p_)->home_world = "";
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert(world_->name + " has been removed as your home world!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
								}
							}
							else if (target_[1] == "member") {
								if (block_->fg == 5814) {
									uint32_t guild_id = world_->guild_id;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										if (not guild_information->all_access and a_[b_ + 1] == "1") {
											guild_information->all_access = true;
											upd_ = true;
										}
										else if (guild_information->all_access and a_[b_ + 1] == "0") {
											guild_information->all_access = false;
											upd_ = true;
										}
									}
								}
							}
							else if (target_[1] == "elder") {
								if (block_->fg == 5814) {
									uint32_t guild_id = world_->guild_id;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										if (not guild_information->coleader_elder_access and a_[b_ + 1] == "1") {
											guild_information->coleader_elder_access = true;
											upd_ = true;
										}
										else if (guild_information->coleader_elder_access and a_[b_ + 1] == "0") {
											guild_information->coleader_elder_access = false;
											upd_ = true;
										}
									}
								}
							}
							else if (target_[1] == "coleader") {
								if (block_->fg == 5814) {
									uint32_t guild_id = world_->guild_id;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										if (not guild_information->coleader_access and a_[b_ + 1] == "1") {
											guild_information->coleader_access = true;
											upd_ = true;
										}
										else if (guild_information->coleader_access and a_[b_ + 1] == "0") {
											guild_information->coleader_access = false;
											upd_ = true;
										}
									}
								}
							}
							else if (target_[1] == "displaymascot") {
								if (block_->fg == 5814) {
									uint32_t guild_id = world_->guild_id;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, p_, false);
										if (not guild_information->unlocked_mascot and a_[b_ + 1] == "1") {
											guild_information->unlocked_mascot = true;
										}
										else if (guild_information->unlocked_mascot and a_[b_ + 1] == "0") {
											guild_information->unlocked_mascot = false;
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(p_)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
									}
								}
							}
							else if (target_[1] == "ignore") {
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
									if (not block_->empty_air and a_[b_ + 1] == "1") {
										block_->empty_air = true;
									}
									else if (block_->empty_air and a_[b_ + 1] == "0") {
										block_->empty_air = false;
									}
								}
							}
							else if (target_[1] == "buildonly") {
								if (block_->fg == 4994) {
									if (not block_->build_only and a_[b_ + 1] == "1") {
										block_->build_only = true;
									}
									else if (block_->build_only and a_[b_ + 1] == "0") {
										block_->build_only = false;
									}
									upd_ = true;
								}
							}
							else if (target_[1] == "admins") {
								if (block_->fg == 4994) {
									if (not block_->limit_admins and a_[b_ + 1] == "1") {
										block_->limit_admins = true;
									}
									else if (block_->limit_admins and a_[b_ + 1] == "0") {
										block_->limit_admins = false;
									}
								}
							}
							else if (target_[1] == "silence") {
								if (block_->fg == 4802) {
									if (not world_->silence and a_[b_ + 1] == "1") {
										world_->silence = true;
									}
									else if (world_->silence and a_[b_ + 1] == "0") {
										world_->silence = false;
									}
								}
							}
							else if (target_[1] == "rainbows") {
								if (block_->fg == 4802) {
									if (not world_->rainbows and a_[b_ + 1] == "1") {
										world_->rainbows = true;
									}
									else if (world_->rainbows and a_[b_ + 1] == "0") {
										world_->rainbows = false;
									}
									upd_ = true;
								}
							}
							else if (target_[1] == "noclip") {
							if (block_->fg != 8470) {
							}
							else {
								if (not world_->allow_noclip and a_[b_ + 1] == "1") {
									world_->allow_noclip = true;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
									p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` allows moderators to do noclip.``");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else if (world_->allow_noclip and a_[b_ + 1] == "0") {
									world_->allow_noclip = false;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
									p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` disallow moderators to do noclip.``");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->ghost and not pInfo(currentPeer)->dev and pInfo(currentPeer)->tankIDName != world_->owner_name and find(world_->admins.begin(), world_->admins.end(), pInfo(currentPeer)->uid) == world_->admins.end())
											pInfo(currentPeer)->ghost = false;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
							}
							}
							else if (target_[1] == "public") {
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
									if (not block_->open_to_public and a_[b_ + 1] == "1") {
										block_->open_to_public = true;
										upd_ = true;
									}
									else if (block_->open_to_public and a_[b_ + 1] == "0") {
										block_->open_to_public = false;
										upd_ = true;
									}
								}
								else {
									if (not world_->open_to_public and a_[b_ + 1] == "1") {
										world_->open_to_public = true;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
										p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` has set the `$World Lock`` to `$PUBLIC");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else if (world_->open_to_public and a_[b_ + 1] == "0") {
										world_->open_to_public = false;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
										p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` has set the `$World Lock`` to `4PRIVATE``");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
								}
							}
							else if (target_[1] == "cheat_antibounce") {
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								}
								else {
									if (not world_->no_antibounce and a_[b_ + 1] == "1") {
										world_->no_antibounce = true;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
										p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` disallow players to use `$Antibounce Cheat``");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or not pInfo(currentPeer)->Cheat_AB) continue;
											pInfo(currentPeer)->Cheat_AB = false;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else if (world_->no_antibounce and a_[b_ + 1] == "0") {
										world_->no_antibounce = false;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
										p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` allows players to use `$Antibounce Cheat``");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
								}
							}
							else if (target_[1] == "vending") {
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								}
								else {
									if (not world_->v_p and a_[b_ + 1] == "1") {
										world_->v_p = true;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
										p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` allows admin to edit `$Vending``");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else if (world_->v_p and a_[b_ + 1] == "0") {
										world_->v_p = false;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
										p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` disallow admins to edit `$Vending``");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
								}
							}
							else if (target_.size() == 2 and a_[b_ + 1] == "0") {
								int user_name = atoi(target_[1].erase(0, 1).c_str());
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
									if (find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
										block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), user_name), block_->admins.end());
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert(GetNameByUid(user_name)+" was removed from a " + items[block_->fg].name + ".");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
											if (pInfo(currentPeer)->uid == user_name) {
												packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(currentPeer)->netID);
												if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
												p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` has `4removed`` your access from a lock on world `w" + world_->name + "``.");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(currentPeer);
												if (pInfo(currentPeer)->world == world_->name) {
													PlayerMoving data_{};
													data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
													BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
													BYTE* blc = raw + 56;
													form_visual(blc, *block_, *world_, p_, false);
													for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
														if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
														if (pInfo(currentPeer2)->world == world_->name) {
															send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
														}
													}
													delete[] raw, blc;
													if (block_->locked) {
														upd_lock(*block_, *world_, p_);
													}
												}
											}
										}
									}
								}
								else if (find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end()) {
									world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), user_name), world_->admins.end());
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(GetNameByUid(user_name)+" was removed from a " + items[block_->fg].name + ".");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->uid == user_name) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(currentPeer)->netID);
											if (not HasRole(pInfo(p_)))pInfo(p_)->name_color = "`2";
											p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` has `4removed`` your access from a lock on world `w" + world_->name + "``.");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(currentPeer);
											gamepacket_t p2(0, pInfo(currentPeer)->netID);
											{
												p2.Insert("OnNameChanged");
												if (not HasRole(pInfo(currentPeer)) and not pInfo(currentPeer)->is_legend)pInfo(currentPeer)->name_color = "`0";
												else if (pInfo(currentPeer)->is_legend) pInfo(currentPeer)->is_legend;
												p2.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name)) + (pInfo(p_)->is_datemaster ? " `4Datemaster" : "") + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``");
											}
											if (pInfo(currentPeer)->world == world_->name) {
												PlayerMoving data_{};
												data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
												BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
												BYTE* blc = raw + 56;
												form_visual(blc, *block_, *world_, p_, false);
												for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
													if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
													if (pInfo(currentPeer2)->world == world_->name) {
														p2.CreatePacket(currentPeer2);
														send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[] raw, blc;
												if (block_->locked) {
													upd_lock(*block_, *world_, p_);
												}
											}
										}
									}
								}
							}
						}
						else if (a_[b_] == "playerNetID" and isdigit(a_[b_ + 1][0])) { // access kazka
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								if (block_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Lock has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								size_t id_ = atoi(a_[b_ + 1].c_str());
								if (id_ == pInfo(p_)->netID and not pInfo(p_)->dev) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I already have access!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								/*---- end debug print ----
								0: OnTalkBubble
								1: 3
								2: `wG2W`` already has access to the lock.
								3: 0
								4: 0*/
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->netID == id_ and pInfo(currentPeer)->world == world_->name) {
										if (pInfo(currentPeer)->ac_.find(pInfo(p_)->netID) != pInfo(currentPeer)->ac_.end()) break;
										int user_name = pInfo(currentPeer)->uid;
										if (user_name == block_->owner_id or find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert((pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` already has access to the lock.");
											p.Insert(0);
											p.Insert(0);
											p.CreatePacket(p_);
											break;
										}
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Offered " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` access to lock.");
										p.Insert(0);
										p.Insert(0);
										p.CreatePacket(p_);
										{
											pInfo(currentPeer)->ac_.insert({ pInfo(p_)->netID, (x_ + (y_ * world_->width)) });
											packet_(currentPeer, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` wants to add you to a " + items[block_->fg].name + ". Wrench yourself to accept.");
											p.CreatePacket(currentPeer);
										}
										break;
									}
								}
							}
							else {
								if (world_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("World has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								size_t id_ = atoi(a_[b_ + 1].c_str());
								if (id_ == pInfo(p_)->netID and not pInfo(p_)->dev) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I already have access!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								/*---- end debug print ----
								0: OnTalkBubble
								1: 3
								2: `wG2W`` already has access to the lock.
								3: 0
								4: 0*/
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->netID == id_ and pInfo(currentPeer)->world == world_->name) {
										if (pInfo(currentPeer)->ac_.find(pInfo(p_)->netID) != pInfo(currentPeer)->ac_.end()) break;
										string user_name = pInfo(currentPeer)->tankIDName;
										if (user_name == world_->owner_name or find(world_->admins.begin(), world_->admins.end(), pInfo(currentPeer)->uid) != world_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert((pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` already has access to the lock.");
											p.Insert(0);
											p.Insert(0);
											p.CreatePacket(p_);
											break;
										}
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Offered " + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` access to lock.");
										p.Insert(0);
										p.Insert(0);
										p.CreatePacket(p_);
										{
											pInfo(currentPeer)->ac_.insert({ pInfo(p_)->netID, (x_ + (y_ * world_->width)) });
											packet_(currentPeer, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert((pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` wants to add you to a " + items[block_->fg].name + ". Wrench yourself to accept.");
											p.CreatePacket(currentPeer);
										}
										break;
									}
									//break;
								}
							}
							break;
						}
						if (upd_) {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											if (pInfo(currentPeer)->guild_id == guild_information->guild_id) {
												if (guild_access(currentPeer, guild_id)) {
													gamepacket_t p2(0, pInfo(currentPeer)->netID);
													{
														p2.Insert("OnNameChanged");
														if (not HasRole(pInfo(currentPeer))) pInfo(currentPeer)->name_color = "`^";
														p2.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + (pInfo(p_)->is_datemaster ? " `4Datemaster" : "") + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``");
													} for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
														if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
														if (pInfo(currentPeer2)->world == world_->name) {
															p2.CreatePacket(currentPeer2);
														}
													}
												}
												else if (find(world_->admins.begin(), world_->admins.end(), pInfo(currentPeer)->uid) == world_->admins.end()) {
													if (pInfo(currentPeer)->tankIDName != world_->owner_name) {
														gamepacket_t p2(0, pInfo(currentPeer)->netID);
														{
															p2.Insert("OnNameChanged");
															if (not HasRole(pInfo(currentPeer)) and not pInfo(currentPeer)->is_legend)pInfo(currentPeer)->name_color = "`0";
															else if (pInfo(currentPeer)->is_legend) pInfo(currentPeer)->is_legend;
															p2.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + (pInfo(p_)->is_datemaster ? " `4Datemaster" : "") + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``");
														} for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
															if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
															if (pInfo(currentPeer2)->world == world_->name) {
																p2.CreatePacket(currentPeer2);
															}
														}
													}
												}
											}
										}
									}
								}
							}
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
							else {
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
					}
					if (reapply) {
						//remove lock from current
						{
							vector<int> new_tiles{};
							vector<WorldBlock> shadow_copy_2 = world_->blocks;
							new_tiles.push_back(x_ + (y_ * world_->width));
							int ySize = world_->blocks.size() / world_->width, xSize = world_->blocks.size() / ySize;
							for (int i2 = 0; i2 < new_tiles.size(); i2++) {
								int s_x_ = new_tiles[i2] % world_->width, s_y_ = new_tiles[i2] / world_->width;
								if (s_x_ < (world_->width - 1) and shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].lock_origin == (x_ + (y_ * world_->width))) {
									if (not shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].scanned) {
										shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].scanned = true;
										new_tiles.push_back(s_x_ + 1 + (s_y_ * world_->width));
										world_->blocks[s_x_ + 1 + (s_y_ * world_->width)].locked = false;
										world_->blocks[s_x_ + 1 + (s_y_ * world_->width)].lock_origin = -1;
									}
								} if (s_x_ > 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].lock_origin == (x_ + (y_ * world_->width))) {
									if (not shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].scanned) {
										shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].scanned = true;
										new_tiles.push_back(s_x_ - 1 + (s_y_ * world_->width));
										world_->blocks[s_x_ - 1 + (s_y_ * world_->width)].locked = false;
										world_->blocks[s_x_ - 1 + (s_y_ * world_->width)].lock_origin = -1;
									}
								} if (s_y_ < (world_->height - 1) and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].lock_origin == (x_ + (y_ * world_->width))) {
									if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].scanned) {
										shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].scanned = true;
										new_tiles.push_back(s_x_ + ((s_y_ + 1) * world_->width));
										world_->blocks[s_x_ + ((s_y_ + 1) * world_->width)].locked = false;
										world_->blocks[s_x_ + ((s_y_ + 1) * world_->width)].lock_origin = -1;
									}
								} if (s_y_ > 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].lock_origin == (x_ + (y_ * world_->width))) {
									if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].scanned) {
										shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].scanned = true;
										new_tiles.push_back(s_x_ + ((s_y_ - 1) * world_->width));
										world_->blocks[s_x_ + ((s_y_ - 1) * world_->width)].locked = false;
										world_->blocks[s_x_ + ((s_y_ - 1) * world_->width)].lock_origin = -1;
									}
								}
							}
						}
						int lock_size = block_->fg == 202 ? 10 : (block_->fg == 204 ? 48 : (block_->fg == 202 ? 200 : 200));
						if (not block_->empty_air) {
							{
								//apply new without empty air
								vector<vector<int>> tiles_ = lock_tiles(world_, x_, y_, lock_size);
								lock_size = tiles_.size();
								PlayerMoving data_{};
								data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								data_.netID = pInfo(p_)->id;
								data_.plantingTree = block_->fg;
								BYTE* raw;
								if (tiles_.size() != 0) {
									raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc_(world_, block_));
									int lalala = 8;
									memcpy(raw + 8, &lock_size, 2);
									memcpy(raw + 12, &lalala, 2);
									BYTE* blc = raw + 56;
									for (int i_ = 0; i_ < tiles_.size(); i_++) {
										vector<int> update_tiles = tiles_[i_];
										int x = update_tiles[0];
										int y = update_tiles[1];
										int sq_ = x + (y * world_->width);
										WorldBlock* block_ = &world_->blocks[sq_];
										if (block_->locked) {
											//continue;
										}
										else {
											block_->locked = true;
											block_->lock_origin = x_ + (y_ * world_->width);
											memcpy(blc + (i_ * 2), &sq_, 2);
										}
									}
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
											send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
								}
								else {
									raw = packPlayerMoving(&data_, 56);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw;
								}
							}
						}
						else {
							vector<int> new_tiles{};
							vector<int> lock_tiles{};
							vector<WorldBlock> shadow_copy_2 = world_->blocks;
							new_tiles.push_back(x_ + (y_ * world_->width));
							//int ySize = world_->blocks.size() / world_->width, xSize = world_->blocks.size() / ySize;
							for (int i2 = 0; i2 < new_tiles.size(); i2++) {
								if (lock_tiles.size() >= lock_size) break;
								int s_x_ = new_tiles[i2] % world_->width, s_y_ = new_tiles[i2] / world_->width;
								if (s_x_ < (world_->width - 1) and not shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].locked and 
									shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].fg != 0 and not_mod(world_, shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)], s_x_, s_y_) or s_x_ < (world_->width - 1) and not shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].bg != 0 and shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].fg == 0) {
									if (not shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].scanned) {
										shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].scanned = true;
										new_tiles.push_back(s_x_ + 1 + (s_y_ * world_->width));
										lock_tiles.push_back(s_x_ + 1 + (s_y_ * world_->width));
										world_->blocks[s_x_ + 1 + (s_y_ * world_->width)].locked = true;
										world_->blocks[s_x_ + 1 + (s_y_ * world_->width)].lock_origin = x_ + (y_ * world_->width);
									}
								} if (s_x_ > 0 and not shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].fg != 0 and not_mod(world_, shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)], s_x_, s_y_) or s_x_ > 0 and not shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].bg != 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].fg == 0) {
									if (not shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].scanned) {
										shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].scanned = true;
										new_tiles.push_back(s_x_ - 1 + (s_y_ * world_->width));
										lock_tiles.push_back(s_x_ - 1 + (s_y_ * world_->width));
										world_->blocks[s_x_ - 1 + (s_y_ * world_->width)].locked = true;
										world_->blocks[s_x_ - 1 + (s_y_ * world_->width)].lock_origin = x_ + (y_ * world_->width);
									}
								} if (s_y_ < (world_->height - 1) and not shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].fg != 0 and not_mod(world_, shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)], s_x_, s_y_) or s_y_ < (world_->height - 1) and not shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].bg != 0 and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].fg == 0) {
									if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].scanned) {
										shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].scanned = true;
										new_tiles.push_back(s_x_ + ((s_y_ + 1) * world_->width));
										lock_tiles.push_back(s_x_ + ((s_y_ + 1) * world_->width));
										world_->blocks[s_x_ + ((s_y_ + 1) * world_->width)].locked = true;
										world_->blocks[s_x_ + ((s_y_ + 1) * world_->width)].lock_origin = x_ + (y_ * world_->width);
									}
								} if (s_y_ > 0 and not shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].fg != 0 and not_mod(world_, shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)], s_x_, s_y_) or s_y_ > 0 and not shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].bg != 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].fg == 0) {
									if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].scanned) {
										shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].scanned = true;
										new_tiles.push_back(s_x_ + ((s_y_ - 1) * world_->width));
										lock_tiles.push_back(s_x_ + ((s_y_ - 1) * world_->width));
										world_->blocks[s_x_ + ((s_y_ - 1) * world_->width)].locked = true;
										world_->blocks[s_x_ + ((s_y_ - 1) * world_->width)].lock_origin = x_ + (y_ * world_->width);
									}
								}
							}
							//upd_lock(*block_, *world_, p_);
							lock_size = lock_tiles.size();
							if (lock_tiles.size() > 0) {
								PlayerMoving data_{};
								data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								data_.netID = block_->owner_name == pInfo(p_)->tankIDName ? pInfo(p_)->id : -1;
								data_.plantingTree = block_->fg;
								BYTE* raw;
								raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc_(world_, block_));
								int lalala = 8;
								memcpy(raw + 8, &lock_size, 2);
								memcpy(raw + 12, &lalala, 2);
								BYTE* blc = raw + 56;
								for (int i_ = 0; i_ < lock_tiles.size(); i_++) memcpy(blc + (i_ * 2), &lock_tiles[i_], 2);
								PlayerMoving data_2{};
								data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
								BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
								BYTE* blc2 = raw2 + 56;
								form_visual(blc2, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
										send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc, raw2, blc2;
							}
							else {
								PlayerMoving data_{};
								data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								data_.netID = block_->owner_name == pInfo(p_)->tankIDName ? pInfo(p_)->id : -1;
								data_.plantingTree = block_->fg;
								BYTE* raw = packPlayerMoving(&data_, 56);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (world_->name == pInfo(currentPeer)->world) {
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										PlayerMoving data_2{};
										data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
										BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
										BYTE* blc2 = raw2 + 56;
										form_visual(blc2, *block_, *world_, currentPeer, false);
										packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
										send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										delete[] raw2, blc2;
									}
								}
								delete[] raw;
							}
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "abondonguild") {
			if (a_.size() != 7 and a_.size() != 8 and a_.size() != 11) break;
			if (pInfo(p_)->guild_id == 0) break;
			if (a_.size() == 8 or a_.size() == 11) {
				string button_clicked = a_.size() == 8 ? a_[5] : a_[8];
				if (button_clicked == "back") {
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						int x_ = 0, y_ = 0;
						int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
							if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
								uint16_t id_ = world_->blocks[i_].fg;
								if (id_ == 5814) {
									x_ = i_ % xSize;
									y_ = i_ / xSize;
									break;
								}
							}
						}
						WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
						send_edit_lock(p_, world_, block_->fg, x_, y_);
					}
				}
				else if (button_clicked == "abondonguild") {
					if (not isdigit(a_[5][0])) break;
					int planting_id_ = atoi(a_[5].c_str());
					if (planting_id_ >= items.size() or planting_id_ < 0) break;
					if (items[planting_id_].blockType != LOCK or planting_id_ == 202 or planting_id_ == 204 or planting_id_ == 206 or planting_id_ == 4994) {
						break;
					}
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						uint32_t guild_id = world_->guild_id;
						vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
						if (p != guilds.end()) {
							Guild* guild_information = &guilds[p - guilds.begin()];
							for (GuildMember member_search : guild_information->guild_members) {
								if (member_search.member_name == pInfo(p_)->tankIDName) {
									if (member_search.role_id != 3) break;
									int ySize = (int)world_->blocks.size() / world_->width, xSize = (int)world_->blocks.size() / ySize;
									for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
										if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
											uint16_t id_ = world_->blocks[i_].fg;
											if (id_ == 5814) {
												int x_ = i_ % xSize;
												int y_ = i_ / xSize;
												WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
												int c_ = -1;
												if (modify_inventory(p_, planting_id_, c_) == 0) {
													leave_guild(p_);
													block_->fg = planting_id_;
													world_->guild_id = 0;
													PlayerMoving data_{};
													data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
													data_.netID = pInfo(p_)->id;
													data_.plantingTree = block_->fg;
													BYTE* raw = packPlayerMoving(&data_, 56);
													PlayerMoving data_2{};
													data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
													BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
													BYTE* blc = raw2 + 56;
													form_visual(blc, *block_, *world_, p_, false);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == world_->name) {
															send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
															send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
														}
													}
													delete[] raw, raw2, blc;
													gamepacket_t p;
													p.Insert("OnConsoleMessage");
													p.Insert("`5[GUILD ALERT]`` Guild Abandoned!");
													p.CreatePacket(p_);
												}
												break;
											}
										}
									}
									break;
								}
							}
						}
					}
				}
				break;
			}
			if (not isdigit(a_[5][0])) break;
			int planting_id_ = atoi(a_[5].c_str());
			if (planting_id_ >= items.size() or planting_id_ < 0) break;
			if (items[planting_id_].blockType != LOCK or planting_id_ == 202 or planting_id_ == 204 or planting_id_ == 206 or planting_id_ == 4994) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_textbox|`4You need to select a World Lock!|left||\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
				p.CreatePacket(p_);
				break;
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_textbox|`1Are you sure you want to abandon the guild?``|left|\nadd_textbox|`4BEWARE:``|left|\nadd_spacer|small|\nadd_textbox|`8- The Guild Lock will NOT return to your inventory!``|left|\nadd_textbox|`8- If you purchased a Guild Mascot this will be lost and will be made available to other guilds to buy!``|left|\nadd_textbox|`8- You will not get back any of the Gems you invested in the Guild!``|left|\nadd_textbox|`8- You will lose all Guild XP and levels the guild accomplished!``|left|\nadd_textbox|`8- When the Guild is abandoned it cannot be recovered!``|left|\nembed_data|worldlockId|" + to_string(planting_id_) + "\nadd_spacer|small|\nadd_button|abondonguild|Abandon Guild|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
			p.CreatePacket(p_);
			break;
		}
		else if (a_[i_] == "confirmguildlockkey") {
			if (a_.size() != 5) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (world_->owner_name != pInfo(p_)->tankIDName) break;
				int c_ = 0;
				modify_inventory(p_, 5816, c_);
				if (c_ != 0) break;
				for (int i_ = 0; i_ < world_->drop.size(); i_++) {
					if (world_->drop[i_].x == -1 or world_->drop[i_].id == 0) continue;
					WorldBlock* block_ = &world_->blocks[(world_->drop[i_].x / 32) + ((world_->drop[i_].y / 32) * world_->width)];
					if (items[block_->fg].collisionType != 1) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("`4Oops!... Can't trade a world with floating items that are unblocked or in treasure chests!``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						return;
					}
				}
				uint16_t locked_with = 0;
				bool alr_failed = false, untradebox = false;
				for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
					if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
						uint16_t id_ = world_->blocks[i_].fg;
						if (id_ == 202 or id_ == 204 or id_ == 206 or id_ == 4994) {
							alr_failed = true;
						}
						else {
							locked_with = id_;
						}
					}
				}
				for (int i_ = 0; i_ < world_->blocks.size(); i_++) if (world_->blocks[i_].fg == 4516) untradebox = true;
				if (locked_with == 0) break;
				if (untradebox) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("`4To trade a world, you will need to remove Untrade-a-Box!``");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
					return;
				}
				if (alr_failed) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("To trade a world, you can only have one lock on it, the `5World Lock``.  Remove the rest!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
					return;
				}
				if (world_->admins.size() != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You'll first need to remove all players with access to your " + items[locked_with].name + " to get a " + items[5816].name + ".");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					return;
				}
				c_ = 1;
				if (modify_inventory(p_, 5816, c_) == 0) {
					packet_(p_, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You got a `#" + items[5816].name + "``! You can now transfer leadership of the guild!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
				}
			}
			break;
		}
		else if (a_[i_] == "sign_edit") {
			if (a_.size() != 13) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height) break;
				if (abs(pInfo(p_)->x / 32 - x_) > 5 || abs(pInfo(p_)->y / 32 - y_) > 5) break;
				string tekstas = a_[i_ + 8];
				if (tekstas.size() > 128) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
				if (block_->txt == tekstas or block_->fg == 0 or items[block_->fg].blockType != BlockTypes::SIGN) break;
				if (block_access(p_, world_, block_)) {
					if (block_->fg == 1684 || block_->fg == 1912 || block_->fg == 4482) {
						transform(tekstas.begin(), tekstas.end(), tekstas.begin(), ::toupper);
						block_->door_id = tekstas;
					}
					else {
						replaceAll(tekstas, "`%", "");
						block_->txt = tekstas;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						int alloc = alloc_(world_, block_);
						BYTE* raw = packPlayerMoving(&data_, 112 + tekstas.size() + alloc);
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, p_, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 112 + tekstas.size() + alloc, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, p_);
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "trash_item" or a_[i_] == "drop_item" or a_[i_] == "trash_item2") {
			if (a_.size() != 10 and a_[i_] != "trash_item2") break;
			if (a_[i_] == "trash_item2" and a_.size() != 11) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int id_ = atoi(a_[i_ + 2].c_str()), c_ = atoi(a_[i_ + 5].c_str());
			int count = 0;
			int drop_fish = 0;
			if (items[id_].blockType == BlockTypes::FISH) {
				for (int i_ = 0, remove = 0; i_ < pInfo(p_)->inv.size(); i_++) if (pInfo(p_)->inv[i_].id == id_) drop_fish = pInfo(p_)->inv[i_].count, c_ = pInfo(p_)->inv[i_].count;
			}
			if (id_ >= items.size() or id_ == 18 or id_ == 32 or id_ == 6336) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				c_ = c_ * -1;
				if (a_[i_] == "trash_item" or a_[i_] == "trash_item2") {
					if (a_[i_] == "trash_item" and items[id_].untradeable) {
						int has_ = 0;
						modify_inventory(p_, id_, has_);
						if (has_ < c_) break;
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Recycle`` " + to_string(c_ * -1) + " `w" + items[id_].name + "``|left|" + to_string(id_) + "|\nembed_data|itemID|" + to_string(id_) + "\nembed_data|count|" + to_string(c_ * -1) + "\nadd_textbox|You are recycling an `9UNTRADEABLE`` item. Are you absolutely sure you want to do this? There is no way to get the item back if you select yes.|left|\nend_dialog|trash_item2|NO!|Yes, I am sure|");
						p.CreatePacket(p_);
						break;
					}
					if (modify_inventory(p_, id_, c_) == 0) {
						packet_(p_, "action|play_sfx\nfile|audio/trash.wav\ndelayMS|0");
						a_[i_ + 5].erase(0, min(a_[i_ + 5].find_first_not_of('0'), a_[i_ + 5].size() - 1));
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						if (pInfo(p_)->supp != 0) {
							int item = id_, maxgems = 0, receivegems = 0;
							int count = atoi(a_[i_ + 5].c_str());
							if (id_ % 2 != 0) item -= 1;
							maxgems = items[item].max_gems2;
							if (items[item].max_gems2 != 0) if (maxgems != 0) for (int i = 0; i < count; i++) receivegems += rand() % maxgems;
							if (items[item].max_gems3 != 0) receivegems = count * items[item].max_gems3;
							if (receivegems != 0) {
								pInfo(p_)->gems += receivegems;
								gamepacket_t p;
								p.Insert("OnSetBux");
								p.Insert(pInfo(p_)->gems);
								p.Insert(0);
								p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
								if (pInfo(p_)->supp >= 2) {
									p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
								}
								p.CreatePacket(p_);
							}
							p.Insert((items[id_].blockType == BlockTypes::FISH ? (to_string(abs(c_))) + "lb." : a_[i_ + 5]) + " `w" + items[id_].ori_name + "`` recycled, `0" + setGems(receivegems) + "`` gems earned.");
						}
						else p.Insert((items[id_].blockType == BlockTypes::FISH ? (to_string(abs(c_))) + "lb." : a_[i_ + 5]) + " `w" + items[id_].ori_name + "`` trashed.");
						p.CreatePacket(p_);
						break;
					}
					break;
				}
				if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 4758) != world_->active_jammers.end()) {
					if (world_->owner_name != pInfo(p_)->tankIDName and not pInfo(p_)->admin and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end()) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("The Mini-Mod says no dropping items in this world!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
				}
				if ((items[id_].untradeable and not pInfo(p_)->dev) or id_ == 18 or id_ == 32 or id_ == 1424 or id_ == 5816) {
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("You can't drop that.");
					p.CreatePacket(p_);
					break;
				}
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldDrop drop_{};
					drop_.id = id_;
					if (drop_fish == 0) drop_.count = atoi(a_[i_ + 5].c_str());
					else drop_.count = drop_fish;
					drop_.uid = uint16_t(world_->drop.size()) + 1;
					int a_ = rand() % 12;
					drop_.x = (pInfo(p_)->state == 16 ? pInfo(p_)->x - (a_ + 20) : (pInfo(p_)->x + 20) + a_);
					drop_.y = pInfo(p_)->y + rand() % 16;
					if (drop_.x / 32 < 0 or drop_.x / 32 >= world_->width or drop_.y / 32 < 0 or drop_.y / 32 >= world_->height) {
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("You can't drop that here, face somewhere with open space.");
						p.CreatePacket(p_);
						break;
					}
					BlockTypes type_ = FOREGROUND;
					WorldBlock* block_ = &world_->blocks[(pInfo(p_)->state == 16 ? drop_.x / 32 : round((double)drop_.x / 32)) + (drop_.y / 32 * world_->width)];
					if (items[block_->fg].collisionType == 1 || block_->fg == 6 || items[block_->fg].entrance || items[block_->fg].toggleable and is_false_state(world_->blocks[(pInfo(p_)->state == 16 ? drop_.x / 32 : round((double)drop_.x / 32)) + (drop_.y / 32 * world_->width)], 0x00400000)) {
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert(items[block_->fg].blockType == BlockTypes::MAIN_DOOR ? "You can't drop items on the white door." : "You can't drop that here, face somewhere with open space.");
						p.CreatePacket(p_);
						break;
					}
					int count_ = 0;
					bool dublicated = false;
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16) {
							count_ += 1;
						}
						if (world_->drop[i_].id == id_) if (world_->drop[i_].count + drop_.count < 200) dublicated = true;
					}
					if (!dublicated) {
						if (count_ > 20) {
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("You can't drop that here, find an emptier spot!");
							p.CreatePacket(p_);
							break;
						}
					}
					int dropped = c_; bool Growganoth = false;
					if (modify_inventory(p_, id_, c_) == 0) {
						Algorithm::log_text("DropLog", pInfo(p_)->tankIDName + " (#" + to_string(pInfo(p_)->id) + ") dropped " + to_string(drop_.count) + " " + items[id_].ori_name + " in world " + pInfo(p_)->world);
						if (pInfo(p_)->level < 125) {
							if (id_ == 7188) send_user_logs(pInfo(p_)->tankIDName, "Suspiciously dropped " + to_string(drop_.count) + " Blue Gem Lock in World: " + pInfo(p_)->world + ".");
							if (id_ == 1796 and drop_.count > 10) send_user_logs(pInfo(p_)->tankIDName, "Suspiciously dropped " + to_string(drop_.count) + " Diamond Lock in World: " + pInfo(p_)->world + ".");
							if (id_ == 242 and drop_.count == 200) send_user_logs(pInfo(p_)->tankIDName, "Suspiciously dropped " + to_string(drop_.count) + " World Lock in World: " + pInfo(p_)->world + ".");
						}
						/*
						

						*/
						if (world_->name == "GROWGANOTH" && Halloween) {
							if (drop_.x / 32 >= 47 and drop_.x / 32 <= 52 and drop_.y / 32 == 15) {
								vector<int> Maw_Prize{};
								bool Guaranteed_Drops = false, Consumable = false;
								int Reward = 0, Give = 1, Give_Back = abs(dropped);
								if (items[id_].consume_prize != 0 && items[id_].consume_needed != 0) Growganoth = true, Consumable = true;
								if (items[id_].rarity != 0 && items[id_].rarity < 367) {
									if (items[id_].rarity >= 1) Maw_Prize.push_back(1208);
									if (items[id_].rarity >= 5) Maw_Prize.insert(Maw_Prize.end(), { 1992,5256,11348 });
									if (items[id_].rarity >= 10) Maw_Prize.insert(Maw_Prize.end(), { 1222,11342,1198,12786 });
									if (items[id_].rarity >= 15) Maw_Prize.insert(Maw_Prize.end(), { 1982,1200 });
									if (items[id_].rarity >= 20) Maw_Prize.insert(Maw_Prize.end(), { 4160,1220,10198 });
									if (items[id_].rarity >= 25) Maw_Prize.insert(Maw_Prize.end(), { 5240,1202 });
									if (items[id_].rarity >= 30) Maw_Prize.insert(Maw_Prize.end(), { 1238,5238,4162,10316,10196,10196 });
									if (items[id_].rarity >= 35) Maw_Prize.insert(Maw_Prize.end(), { 9044,1168 });
									if (items[id_].rarity >= 40) Maw_Prize.insert(Maw_Prize.end(), { 3116,4164,1172,12788 });
									if (items[id_].rarity >= 45) Maw_Prize.push_back(1230);
									if (items[id_].rarity >= 50) Maw_Prize.insert(Maw_Prize.end(), { 1192,11340,1194,10202 });
									if (items[id_].rarity >= 55) Maw_Prize.insert(Maw_Prize.end(), { 1226,7108 });
									if (items[id_].rarity >= 60) Maw_Prize.insert(Maw_Prize.end(), { 1196,12784 });
									if (items[id_].rarity >= 65) Maw_Prize.insert(Maw_Prize.end(), { 1236,9046 });
									if (items[id_].rarity >= 70) Maw_Prize.insert(Maw_Prize.end(), { 1980,1972,7110,1182,1994,1184,1186,1188,11330 });
									if (items[id_].rarity >= 73) Maw_Prize.insert(Maw_Prize.end(), { 10204,3102,4154,5232,5224,5222 });
									if (items[id_].rarity >= 75) Maw_Prize.push_back(1988);
									if (items[id_].rarity >= 80) Maw_Prize.insert(Maw_Prize.end(), { 4158,7128,1170,12790 });
									if (items[id_].rarity >= 85) Maw_Prize.push_back(1984);
									if (items[id_].rarity >= 90) Maw_Prize.insert(Maw_Prize.end(), { 1216,1218,5248,7114,10322,7112 });
									if (items[id_].rarity >= 97) Maw_Prize.push_back(3106);
									if (items[id_].rarity >= 100) Maw_Prize.push_back(7130);
									if (items[id_].rarity >= 101) Maw_Prize.push_back(3110);
									Reward = Maw_Prize[rand() % Maw_Prize.size()];
									Growganoth = true;
								}
								if (id_ == 10328) {
									gamepacket_t p;
									//p.Insert("OnProgressUIUpdateValue"); p.Insert(pInfo(p_)->Darking_Sacrifice); p.Insert(0); p.CreatePacket(p_);
									Maw_Prize = { 12772, 12416, 12396, 12418, 12420, 12780, 10236  ,  4152  , 3114  , 1250  , 11314  , 3108  , 1956  , 11332  , 11336  , 11334  , 9042  ,9048  , 3126  , 10186  , 1990  , 1968  , 4166  , 5208  , 9056  , 7122  , 4172  , 4156  , 1234  , 5250  , 5254  , 5252  , 4138  , 4146  , 4140  , 4142  , 4148  , 4144  , 2000  , 1960  , 5210  , 1948  , 1214  , 7100  , 1966  , 1962  , 4188  , 4186  , 4190  , 10192  , 4136  , 10212  , 5236  , 5216  , 5218  , 5220  , 5214  , 4248  , 4182  , 4246  , 3098  , 5244  , 5256  , 10232  , 3118  , 10194  , 4192  , 1178  , 11316  , 1232  , 3124  , 11312  , 9040  , 10190  , 9034  , 3122  , 9050  , 9054  , 9052  , 7126  , 10200  , 10234  , 7124  , 11320  , 1210, 9018 };
									if (rand() % 1000 < 1 or pInfo(p_)->tankIDName == "iDems" and pInfo(p_)->hand == 5176) Maw_Prize = { 5176, 1970, 12414, 9114, 11322, 7104, 10206, 11318, 10184, 3100, 7102 };
									Reward = Maw_Prize[rand() % Maw_Prize.size()];
									Growganoth = true;
									int Give_Again = Give_Back - 1;
									if (abs(dropped) > 1) modify_inventory(p_, id_, Give_Again);
									dropped = 1;
								}
								if (id_ == 1950) Growganoth = true, Guaranteed_Drops = true, Reward = 4152;
								if (id_ == 2722) Growganoth = true, Guaranteed_Drops = true, Reward = 3114;
								if (id_ == 910) Growganoth = true, Guaranteed_Drops = true, Reward = 1250;
								if (id_ == 11046) Growganoth = true, Guaranteed_Drops = true, Reward = 11314;
								if (id_ == 94 or id_ == 2636 or id_ == 604 or id_ == 1956) Growganoth = true, Guaranteed_Drops = true, Reward = 3108;
								if (id_ == 276 or id_ == 274) Growganoth = true, Guaranteed_Drops = true, Reward = 1956;
								if (id_ == 6300) Growganoth = true, Guaranteed_Drops = true, Reward = 7102;
								if (id_ == 10730) Growganoth = true, Guaranteed_Drops = true, Reward = 11332;
								if (id_ == 10734) Growganoth = true, Guaranteed_Drops = true, Reward = 11350;
								if (id_ == 10732) Growganoth = true, Guaranteed_Drops = true, Reward = 11334;
								if (id_ == 6176) Growganoth = true, Guaranteed_Drops = true, Reward = 9042;
								if (id_ == 3040) Growganoth = true, Guaranteed_Drops = true, Reward = 3100;
								if (id_ == 6144) Growganoth = true, Guaranteed_Drops = true, Reward = 7104;
								if (id_ == 7998) Growganoth = true, Guaranteed_Drops = true, Reward = 9048;
								if (id_ == 1162) Growganoth = true, Guaranteed_Drops = true, Reward = 3126;
								if (id_ == 9322) Growganoth = true, Guaranteed_Drops = true, Reward = 10184;
								if (id_ == 7696) Growganoth = true, Guaranteed_Drops = true, Reward = 10186;
								if (id_ == 1474) Growganoth = true, Guaranteed_Drops = true, Reward = 1990;
								if (id_ == 1506) Growganoth = true, Guaranteed_Drops = true, Reward = 1968;
								if (id_ == 2386) Growganoth = true, Guaranteed_Drops = true, Reward = 4166;
								if (id_ == 9364) Growganoth = true, Guaranteed_Drops = true, Reward = 10206;
								if (id_ == 10576) Growganoth = true, Guaranteed_Drops = true, Reward = 11322;
								if (id_ == 4960) Growganoth = true, Guaranteed_Drops = true, Reward = 5208;
								if (id_ == 6196) Growganoth = true, Guaranteed_Drops = true, Reward = 9056;
								if (id_ == 4326) Growganoth = true, Guaranteed_Drops = true, Reward = 7122;
								if (id_ == 2860 or id_ == 2268) Growganoth = true, Guaranteed_Drops = true, Reward = 4172;
								if (id_ == 1114) Growganoth = true, Guaranteed_Drops = true, Reward = 4156;
								if (id_ == 362) Growganoth = true, Guaranteed_Drops = true, Reward = 1234;
								if (id_ == 11574) Growganoth = true, Guaranteed_Drops = true, Reward = 12772;
								if (id_ == 4334) Growganoth = true, Guaranteed_Drops = true, Reward = 5250;
								if (id_ == 4338) Growganoth = true, Guaranteed_Drops = true, Reward = 5252;
								if (id_ == 1408) Growganoth = true, Guaranteed_Drops = true, Reward = 5254;
								if (id_ == 3288) Growganoth = true, Guaranteed_Drops = true, Reward = 4138;
								if (id_ == 3290) Growganoth = true, Guaranteed_Drops = true, Reward = 4140;
								if (id_ == 3292) Growganoth = true, Guaranteed_Drops = true, Reward = 4142;
								if (id_ == 3294) Growganoth = true, Guaranteed_Drops = true, Reward = 4144;
								if (id_ == 3296) Growganoth = true, Guaranteed_Drops = true, Reward = 4146;
								if (id_ == 3298) Growganoth = true, Guaranteed_Drops = true, Reward = 4148;
								if (id_ == 900 or id_ == 7752 or id_ == 7754 or id_ == 7136 or id_ == 1576 or id_ == 1378 or id_ == 7758 or id_ == 7760 or id_ == 7748) Growganoth = true, Guaranteed_Drops = true, Reward = 2000;
								if (id_ == 1746) Growganoth = true, Guaranteed_Drops = true, Reward = 1960;
								if (id_ == 5018) Growganoth = true, Guaranteed_Drops = true, Reward = 5210;
								if (id_ == 1252) Growganoth = true, Guaranteed_Drops = true, Reward = 1948;
								if (id_ == 1190) Growganoth = true, Guaranteed_Drops = true, Reward = 1214;
								if (id_ == 2868) Growganoth = true, Guaranteed_Drops = true, Reward = 7100;
								if (id_ == 11638) Growganoth = true, Guaranteed_Drops = true, Reward = 12780;
								if (id_ == 11534) Growganoth = true, Guaranteed_Drops = true, Reward = 12416;
								if (id_ == 1830) Growganoth = true, Guaranteed_Drops = true, Reward = 1966;
								if (items[id_].name.find("Chemical") != string::npos and id_ != 1962) Growganoth = true, Guaranteed_Drops = true, Reward = 1962;
								if (id_ == 3556) {
									Maw_Prize.insert(Maw_Prize.end(), { 4186, 4188 });
									Growganoth = true, Guaranteed_Drops = true, Reward = Maw_Prize[rand() % Maw_Prize.size()];
								}
								if (id_ == 762) Growganoth = true, Guaranteed_Drops = true, Reward = 4190;
								if (id_ == 3818) Growganoth = true, Guaranteed_Drops = true, Reward = 10192;
								if (id_ == 366) Growganoth = true, Guaranteed_Drops = true, Reward = 4136;
								if (id_ == 9262) Growganoth = true, Guaranteed_Drops = true, Reward = 10212;
								if (id_ == 5236) Growganoth = true, Guaranteed_Drops = true, Reward = 1294;
								if (id_ == 1246) Growganoth = true, Guaranteed_Drops = true, Reward = 5214;
								if (id_ == 1242) Growganoth = true, Guaranteed_Drops = true, Reward = 5216;
								if (id_ == 1244) Growganoth = true, Guaranteed_Drops = true, Reward = 5218;
								if (id_ == 1248) Growganoth = true, Guaranteed_Drops = true, Reward = 5220;
								if (id_ == 7026 or id_ == 7028 or id_ == 7030) Growganoth = true, Guaranteed_Drops = true, Reward = 12396;
								if (id_ == 3016 or id_ == 3018 or id_ == 5526 or id_ == 5528) Growganoth = true, Guaranteed_Drops = true, Reward = 4248;
								if (id_ == 3012 or id_ == 3014 or id_ == 2914) Growganoth = true, Guaranteed_Drops = true, Reward = 4246;
								if (id_ == 242) Growganoth = true, Guaranteed_Drops = true, Reward = 1212;
								if (id_ == 2972) Growganoth = true, Guaranteed_Drops = true, Reward = 4182;
								if (id_ == 1460) Growganoth = true, Guaranteed_Drops = true, Reward = 1970;
								if (id_ == 2392) Growganoth = true, Guaranteed_Drops = true, Reward = 9114;
								if (id_ == 3218 or id_ == 3020) Growganoth = true, Guaranteed_Drops = true, Reward = 3098;
								if (id_ == 3792) Growganoth = true, Guaranteed_Drops = true, Reward = 5244;
								if (id_ == 10634) Growganoth = true, Guaranteed_Drops = true, Reward = 11318;
								if (id_ == 1198) Growganoth = true, Guaranteed_Drops = true, Reward = 5256;
								if (id_ == 8468) Growganoth = true, Guaranteed_Drops = true, Reward = 10232;
								if (id_ == 2984) Growganoth = true, Guaranteed_Drops = true, Reward = 3118;
								if (id_ == 4360) Growganoth = true, Guaranteed_Drops = true, Reward = 10194;
								if (id_ == 10148) Growganoth = true, Guaranteed_Drops = true, Reward = 12418;
								if (items[id_].name.find("Sheet Music: ") != string::npos and id_ != 4192 or id_ == 412) Growganoth = true, Guaranteed_Drops = true, Reward = 4192;
								if (id_ == 5012 or id_ == 1018 or id_ == 592) Growganoth = true, Guaranteed_Drops = true, Reward = 1178;
								if (id_ == 10406) Growganoth = true, Guaranteed_Drops = true, Reward = 11316;
								if (id_ == 10652) Growganoth = true, Guaranteed_Drops = true, Reward = 12420;
								if (id_ == 882) Growganoth = true, Guaranteed_Drops = true, Reward = 1232;
								if (id_ == 1934) Growganoth = true, Guaranteed_Drops = true, Reward = 3124;
								if (id_ == 10626) Growganoth = true, Guaranteed_Drops = true, Reward = 11312;
								if (id_ == 6160) Growganoth = true, Guaranteed_Drops = true, Reward = 9040;
								if (id_ == 3794) Growganoth = true, Guaranteed_Drops = true, Reward = 10190;
								if (id_ == 8018) Growganoth = true, Guaranteed_Drops = true, Reward = 9034;
								if (id_ == 2390) Growganoth = true, Guaranteed_Drops = true, Reward = 3122;
								if (id_ == 9050) Growganoth = true, Guaranteed_Drops = true, Reward = 5246;
								if (id_ == 9052) Growganoth = true, Guaranteed_Drops = true, Reward = 5246;
								if (id_ == 9054) Growganoth = true, Guaranteed_Drops = true, Reward = 5246;
								if (id_ == 6798) Growganoth = true, Guaranteed_Drops = true, Reward = 7126;
								if (id_ == 9722 or id_ == 9724) Growganoth = true, Guaranteed_Drops = true, Reward = 10200;
								if (id_ == 9388) Growganoth = true, Guaranteed_Drops = true, Reward = 10234;
								if (id_ == 4732) Growganoth = true, Guaranteed_Drops = true, Reward = 7124;
								if (id_ == 10804) Growganoth = true, Guaranteed_Drops = true, Reward = 11320;
								if (id_ == 11666) Growganoth = true, Guaranteed_Drops = true, Reward = 12414;
								if (items[id_].name.find("Weather Machine - ") != string::npos and id_ != 932 or id_ == 8836 or id_ == 1210) Growganoth = true, Guaranteed_Drops = true, Reward = 1210;
								if (id_ != 0 and Reward == 0) Growganoth = true;
								if (Growganoth) {
									gamepacket_t a, b;
									a.Insert("OnTalkBubble"), a.Insert(pInfo(p_)->netID);
									b.Insert("OnConsoleMessage");
									if (Reward != 0) {
										gamepacket_t p, p2;
										if (Consumable) a.Insert("`4Growganoth turns your " + items[id_].ori_name + " into an " + items[items[id_].consume_prize].ori_name + " and hatches it with evil!``"), b.Insert("`4Growganoth turns your " + items[id_].ori_name + " into an " + items[items[id_].consume_prize].ori_name + " and hatches it with evil!``"), b.CreatePacket(p_);
										else a.Insert("`4Growganoth is pleased by your offering and grants a reward! Also, he eats you.``"), b.Insert("`4Growganoth is pleased by your offering and grants a reward! Also, he eats you.``"), b.CreatePacket(p_);
										p.Insert("OnConsoleMessage"), p.Insert("" + (string(abs(dropped) != 1 ? to_string(abs(dropped)) + " " : "")) + "`2" + items[id_].ori_name + "`` was devoured by Growganoth!"), p.CreatePacket(p_);
										p2.Insert("OnConsoleMessage");
										if (Guaranteed_Drops) {
											if (modify_inventory(p_, Reward, Give_Back) == 0) {
												p2.Insert((string(abs(dropped) != 1 ? to_string(abs(dropped)) : "A")) + " `2" + items[Reward].ori_name + "`` was bestowed upon you!");
												p2.CreatePacket(p_);
											}
											else {
												modify_inventory(p_, id_, Give_Back);
												p2.Insert("Nothing was upon to you! you didn't have enough inventory!");
												p2.CreatePacket(p_);
											}
										}
										else {
											if (modify_inventory(p_, Reward, Give) == 0) {
												p2.Insert("A `2" + items[Reward].ori_name + "`` was bestowed upon you!");
												p2.CreatePacket(p_);
											}
											else {
												if (id_ == 10328) Give_Back = 1;
												modify_inventory(p_, id_, Give_Back);
												p2.Insert("Nothing was upon to you! you didn't have enough inventory!");
												p2.CreatePacket(p_);
											}
										}
										if (Guaranteed_Drops) {
											gamepacket_t a, b;
											a.Insert("OnTalkBubble"), a.Insert(pInfo(p_)->netID);
											b.Insert("OnConsoleMessage"); a.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), b.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), b.CreatePacket(p_);
											a.Insert(0), a.Insert(0), a.CreatePacket(p_);
										}
										if (Reward == 9488 || Reward == 1970 || Reward == 12414 || Reward == 9114 || Reward == 11322 || Reward == 7104 || Reward == 10206 || Reward == 11318 || Reward == 10184 || Reward == 3100 || Reward == 7102) {
											if (id_ == 10328) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage"), p.Insert("`4Growganoth`` honors " + (pInfo(p_)->mod && pInfo(p_)->d_name.empty() ? pInfo(p_)->name_color : "`0") + "" + (pInfo(p_)->d_name.empty() ? pInfo(p_)->tankIDName : pInfo(p_)->d_name) + "`` with a `5Rare " + items[Reward].name + "`` for their Dark King's Offering!");
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													p.CreatePacket(currentPeer);
												}
												lastsbworld = pInfo(p_)->world;
											}
										}
									}
									else {
										a.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), b.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), b.CreatePacket(p_);
										modify_inventory(p_, id_, Give_Back);
									}
									a.Insert(0), a.Insert(0), a.CreatePacket(p_);
									SendRespawn(p_, true, 0, 1);
								}
							}
							else {
								int Give_Back = abs(dropped);
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("Not close enough to the maw!");
								p.CreatePacket(p_);
								modify_inventory(p_, id_, Give_Back);
								break;
							}
						}

						add_cctv(p_, "dropped", to_string(abs(dropped)) + " " + items[id_].name);
						if (!Growganoth) dropas_(world_, drop_, pInfo(p_)->netID);
					}
				}
			}
			break;
		}
		else if (a_[i_] == "growid_apply") {
			if (a_.size() != 13) break;
			if (pInfo(p_)->tankIDName != "" || pInfo(p_)->isIn == false) continue;
			try {
				string user_ = a_[i_ + 2], pass_ = a_[i_ + 4], pass_verify_ = a_[i_ + 6], email_ = a_[i_ + 8];
				if (pInfo(p_)->tankIDName != "") continue;
				char IPAddress[16];
				enet_address_get_host_ip(&p_->address, IPAddress, 16);
				string ip;
				ip = IPAddress;
				auto path = "./database/registered/" + ip + ".json";
				bool udahAda = std::filesystem::exists(path);
				if (not udahAda) {
					vector<string> accounts = {};
					accounts.push_back(user_);
					ofstream newRegister(path, std::ios_base::trunc | std::ios_base::out);
					json j;
					j["Accounts"] = accounts;
					j["totalAccount"] = 1;
					newRegister << j << endl;
					newRegister.close();
				}
				else {
					int accountCreated;
					vector<string> addAccount;
					ifstream ifs("database/registered/" + ip + ".json");
					if (ifs.is_open()) {
						json j;
						ifs >> j;
						vector<string> accounts = j["Accounts"];
						accountCreated = j["totalAccount"].get<int>();
						addAccount = accounts;
					}
					if (accountCreated >= 3 or addAccount.size() >= 3) {
						tayo_info("Too many account created for IP: " + ip);
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`4Unable to create new TayoPs account for guest " + pInfo(p_)->requestedName + " `oToo many accounts created from this IP address. (" + ip + ")"), p.CreatePacket(p_);
						return;
					}
					addAccount.push_back(user_);
					accountCreated++;
					ofstream o("database/registered/" + ip + ".json");
					if (!o.is_open()) break;
					json j;
					j["Accounts"] = addAccount;
					j["totalAccount"] = accountCreated;
					o << j << endl;
				}
				string path_ = "database/players/" + user_ + "_.json";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				bool bad_name = false;
				string check_user = user_;
				transform(check_user.begin(), check_user.end(), check_user.begin(), ::toupper);
				for (int i = 0; i < swear_words.size(); i++) {
					if (check_user.find(swear_words.at(i)) != string::npos) {
						bad_name = true;
						break;
					}
				}
				bool alreadyhas = false;
				if (pInfo(p_)->tankIDName != "") alreadyhas = true;
				if (alreadyhas)
					p.Insert(Algorithm::r_dialog("`4Oops!``  You already own account!", user_, pass_, pass_verify_, email_));
				else if (bad_name)
					p.Insert(Algorithm::r_dialog("`4Oops!``  Your `wGrowID`` cannot contain `$swear words``.", user_, pass_, pass_verify_, email_));
				else if (not email(email_))
					p.Insert(Algorithm::r_dialog("`4Oops!``  Look, if you'd like to be able try retrieve your password if you lose it, you'd better enter a real email.  We promise to keep your data 100% private and never spam you.", user_, pass_, pass_verify_, email_));
				else if (user_.size() < 3 or user_.size() > 18)
					p.Insert(Algorithm::r_dialog("`4Oops!``  Your `wGrowID`` must be between `$3`` and `$18`` characters long.", user_, pass_, pass_verify_, email_));
				else if (pass_.size() < 8 or pass_.size() > 18)
					p.Insert(Algorithm::r_dialog("`4Oops!``  Your password must be between `$8`` and `$18`` characters long.", user_, pass_, pass_verify_, email_));
				else if (pass_ != pass_verify_)
					p.Insert(Algorithm::r_dialog("`4Oops!``  Passwords don't match.  Try again.", user_, pass_, pass_verify_, email_));
				else if (special_char(user_))
					p.Insert(Algorithm::r_dialog("`4Oops!`` You can only use letters and numbers in your GrowID.", user_, pass_, pass_verify_, email_));
				else if (_access_s(path_.c_str(), 0) == 0)
					p.Insert(Algorithm::r_dialog("`4Oops!`` The name `w" + user_ + "`` is so cool someone else has already taken it.  Please choose a different name.", user_, pass_, pass_verify_, email_));
				else {
					time_t s__;
					s__ = time(NULL);
					int days_ = int(s__) / (60 * 60 * 24);
					pInfo(p_)->account_created = days_;
					pInfo(p_)->playtime = s__;
					pInfo(p_)->inv.push_back({ 18, 1 }), pInfo(p_)->inv.push_back({ 32, 1 });
					for (int i_ = 3; i_ <= 16; i_++) {
						Items itm_{};
						itm_.id = 0, itm_.count = 0;
						pInfo(p_)->inv.push_back(itm_);
					}
					int count = 200;
					// new player kit
					modify_inventory(p_, 1796, count = 15);
					//modify_inventory(p_, 2952, count = 1);
					modify_inventory(p_, 4956, count = 1);
					modify_inventory(p_, 2912, count = 1);
					modify_inventory(p_, 13018, count = 1);
					vector<int> list{ 954, 454, 682, 3004, 1154,4584, 526, 5666, 340, 3838, 5990 };
					modify_inventory(p_, list[rand() % list.size()], count = 100);
					modify_inventory(p_, 224, count = 5);
					modify_inventory(p_, 866, count = 1);
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTayoPsID GET!``|left|206|\nadd_textbox|A `wTayoPsID`` with the log on of `w" + user_ + "`` created.  Write it and your password down as they will be required to log on from now on!|left|\nend_dialog|TayoPsID_apply|Continue||");
					pInfo(p_)->tankIDName = user_, pInfo(p_)->tankIDPass = pass_, pInfo(p_)->email = email_, pInfo(p_)->uid = GlobalStats.totalUserIDGenerated, pInfo(p_)->lastReqName = pInfo(p_)->requestedName;
					InsertUIDData(pInfo(p_)); 
					GlobalStats.totalUserIDGenerated++;
					ifstream in("database/server_statistic.json");
					json infile = json::parse(in);
					infile["totalUserIDGenerated"] = GlobalStats.totalUserIDGenerated;
					ofstream out("database/server_statistic.json");
					out << setw(4) << infile << endl;
					in.close();
					out.close();
					{
						gamepacket_t p;
						p.Insert("SetHasGrowID");
						p.Insert(1);
						p.Insert(user_);
						p.Insert(pass_);
						p.CreatePacket(p_);
					}
					packet_(p_, "action|log\nmsg|`2Account succesfully created`7, re-connecting for authentication.");
					save_player(pInfo(p_), false);
					enet_peer_disconnect_later(p_, 0);
				}
				p.CreatePacket(p_);
			}
			catch (exception) {
				tayo_warn("Error while writing database");
				gnettoken_db_logs("Something went wrong when creating new GrowID");
			}
			break;
		}
	}
}

bool is_number(const std::string& s)
{
	char* end = nullptr;
	double val = strtod(s.c_str(), &end);
	return end != s.c_str() && *end == '\0' && val != HUGE_VAL;
}
void failed_login(ENetPeer* peer, string message, bool mt = false) {
	packet_(peer, "action|log\nmsg|" + message);
	if (mt) packet_(peer, "action|set_url\nurl|https://discord.gg/Hz3Kq5xCs8\nlabel|View Discord");
	packet_(peer, "action|logon_fail");
	enet_peer_disconnect_later(peer, 0);
}
vector<vector<string>> failed_logins{};
bool player_login(ENetPeer* peer, string cch) {
	if (pInfo(peer)->tankIDName == "") {
		for (int i = 0; i < ipbans.size(); i++) if (pInfo(peer)->ip == ipbans[i]) failed_login(peer, "CT:[S]_ `4Sorry, you are not allowed to enter the game from this device or location. Contact `1TayoPs `5Discord Staff Team `4if you have any questions.``", true);
		for (int i = 0; i < ridbans.size(); i++) if (pInfo(peer)->rid == ridbans[i]) failed_login(peer, "CT:[S]_ `4Sorry, you are not allowed to enter the game from this device or location. Contact `1TayoPs `5Discord Staff Team `4if you have any questions.``", true);
		vector<string> a_ = explode("|", replace_str(cch, "\n", "|"));
		for (int i_ = 0; i_ < a_.size(); i_++) {
			if (a_[i_] == "requestedName") {
				pInfo(peer)->requestedName = a_[i_ + 1];
			}
			else if (a_[i_] == "tankIDName") {
				pInfo(peer)->tankIDName = a_[i_ + 1];
			}
			else if (a_[i_] == "tankIDPass") {
				pInfo(peer)->tankIDPass = a_[i_ + 1];
			}
			else if (a_[i_] == "f") {
			}
			else if (a_[i_] == "protocol") {
				pInfo(peer)->proto = atoi(a_[i_ + 1].c_str());
				
				if (atoi(a_[i_ + 1].c_str()) <= 205) {
					packet_(peer, "action|log\nmsg|`4Outdated Client:`` Your growtopia version doesn't fulfill the criteria. Make sure you are using latest version of Growtopia.");
					packet_(peer, "action|logon_fail");
					enet_peer_disconnect_later(peer, 0);
					return false;
				}
				
			}
			else if (a_[i_] == "game_version") {
				pInfo(peer)->game_temp = stod(a_[i_ + 1]);
			}
			else if (a_[i_] == "fz") {
			}
			else if (a_[i_] == "lmode") {
			}
			else if (a_[i_] == "cbits") {
			}
			else if (a_[i_] == "player_age") {
			}
			else if (a_[i_] == "GDPR") {
			}
			else if (a_[i_] == "meta") {
				vector<string> ex = explode("_", a_[i_ + 1]);
				if (ex.size() == 2) {
					pInfo(peer)->meta = ex[0];
				}
				else {
					pInfo(peer)->meta = a_[i_ + 1];
				}
			}
			else if (a_[i_] == "fhash") {
			}
			else if (a_[i_] == "UUIDToken") {
				pInfo(peer)->uuid = a_[i_ + 1];
				/*
				if (find(uuidbans.begin(), uuidbans.end(), pInfo(peer)->uuid) != uuidbans.end()) {
					//if (pInfo(peer)->rid.substr(0, 2) != "01") banned_ip_temporary.push_back(make_pair(pInfo(peer)->ip, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					failed_login(peer, "CT:[S]_ `4Sorry, you are not allowed to enter the game from this location. Contact `5Discord Staff Team `4if you have any questions.");
					return false;
				}
				*/
			}
			else if (a_[i_] == "rid") {
				pInfo(peer)->rid = a_[i_ + 1];
				if (find(ridbans.begin(), ridbans.end(), pInfo(peer)->rid) != ridbans.end()) {
					failed_login(peer, "CT:[S]_ `4Sorry, you are not allowed to enter the game from this location. Contact `5Discord Staff Team `4if you have any questions.");
					return false;
				}
			}
			else if (a_[i_] == "platformID") {
				pInfo(peer)->platformid = a_[i_ + 1];
			}
			else if (a_[i_] == "deviceVersion") {
			}
			else if (a_[i_] == "country") {
				vector<string> validCountry{ "ad", "ae", "af", "ag", "ai", "al", "am", "an", "ao", "ar", "as", "at", "au", "aw", "ax", "az", "ba", "bb", "bd", "be", "bf", "bg", "bh", "bi", "bj", "bm", "bn", "bo", "br", "bs", "bt", "bv", "bw", "by", "bz", "ca", "catalonia", "cc", "cd", "cf", "cg", "ch", "ci", "ck", "cl", "cm", "cn", "co", "cr", "cs", "cu", "cv", "cx", "cy", "cz", "de", "dj", "dk", "dm", "do", "dz", "ec", "ee", "eg", "eh", "england", "er", "es", "et", "europeanunion", "fam", "fi", "fi", "fj", "fk", "fm", "fo", "fr", "ga", "gb", "gd", "ge", "gf", "gh", "gi", "gl", "gm", "gn", "gp", "gq", "gr", "gs", "gt", "gu", "gw", "gy", "hk", "hm", "hn", "hr", "ht", "hu", "id", "ie", "il", "in", "io", "iq", "ir", "is", "jp", "np", "kr", "kh", "km", "kn", "kz", "sa", "us", "za", "uy" };
				if (find(validCountry.begin(), validCountry.end(), to_lower(a_[i_ + 1])) != validCountry.end()) pInfo(peer)->country = a_[i_ + 1];
				else (pInfo(peer)->country = "sg");
			}
			else if (a_[i_] == "hash") {
			}
			else if (a_[i_] == "vid") {
				pInfo(peer)->vid = a_[i_ + 1];
			}
			else if (a_[i_] == "mac") {
				pInfo(peer)->mac = a_[i_ + 1];
			}
			else if (a_[i_] == "wk") {
				pInfo(peer)->wk = a_[i_ + 1];
			}
			else if (a_[i_] == "zf") {
			}
		}
		if (not pInfo(peer)->tankIDName.empty()) {
			switch (auth_(peer)) {
			case -1:
			{
				packet_(peer, "`4Unable to log on: `oThat `wTayoPsID`` doesn't seem valid, or the password is wrong. If you don't have one, press `wCancel``, un-check `w'I have a TayoPsID'``, then click `wConnect``.", "Retrieve lost password");
				packet_(peer, "action|logon_fail");
				enet_peer_disconnect_later(peer, 0);
				return false;
			}
			case 2: return false;
			default:
			{
				break;
			}
			}
			if (pInfo(peer)->gp) {
				if (not has_playmod(pInfo(peer), "Royal GrowPass")) {
					pInfo(peer)->gp = 0;
					pInfo(peer)->master = false;
					pInfo(peer)->donor = false;
				}
			}
			if (!pInfo(peer)->mod || !pInfo(peer)->admin && pInfo(peer)->ghost) pInfo(peer)->ghost = false;
			if (has_playmod(pInfo(peer), "Royal GrowPass") and not pInfo(peer)->gp) pInfo(peer)->gp = 1;
			if (pInfo(peer)->b_t + pInfo(peer)->b_s < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (not pInfo(peer)->b_r.empty() or not pInfo(peer)->b_b.empty()) {
					packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`oYou are no longer banned. Now be good! (`$Ban`` mod removed)");
					p.CreatePacket(peer);
				}
				if (pInfo(peer)->Warning >= 5) {
					pInfo(peer)->Warning = 0;
					pInfo(peer)->Warning_Message = {};
				}
				pInfo(peer)->b_t = 0;
				pInfo(peer)->b_s = 0;
				pInfo(peer)->b_b = "";
				pInfo(peer)->b_r = "";
			}
			else {
				pInfo(peer)->name_color = (pInfo(peer)->dev == 1 ? "`6@" : pInfo(peer)->admin == 1 ? "`8@" : pInfo(peer)->supermod == 1 ? "`b@" : (pInfo(peer)->tmod == 1) ? "`#@" :
					pInfo(peer)->glory == 1 ? "`c[GLORY] " : pInfo(peer)->vvip == 1 ? "`9[VVIP] " : pInfo(peer)->vip == 1 ? "`1[VIP] " : "`0");
				pInfo(peer)->modName = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
				if (is_reseller(peer) and not pInfo(peer)->hide_reseller) pInfo(peer)->modName += " `b[Atomic ĭ]``";
				long long int time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				int actualseconds = (pInfo(peer)->b_t + pInfo(peer)->b_s - time) / 1000;
				string time_counted = "";
				if (actualseconds / 86400 >= 1) {
					time_counted += "" + to_string(actualseconds / (24 * 3600)) + " days, ";
					actualseconds = actualseconds % (24 * 3600);
				}
				if (actualseconds / 3600 >= 1) {
					time_counted += "" + to_string(actualseconds / 3600) + " hours, ";
					actualseconds %= 3600;
				}
				if (actualseconds / 60 >= 1) {
					time_counted += "" + to_string(actualseconds / 60) + " mins, ";
					actualseconds %= 60;
				}
				time_counted += "" + to_string(actualseconds) + " secs";
				packet_(peer, "action|log\nmsg|CT:[S]_ `4Sorry, this account, device or location has been temporarily suspended.``", "");
				if (pInfo(peer)->b_r != "No reason") packet_(peer, "action|log\nmsg|CT:[S]_ `4Ban Reason: " + pInfo(peer)->b_r + "``", "");
				packet_(peer, "action|log\nmsg|CT:[S]_ If you didn't do anything wrong, it could be because you're playing from the same place or on the same device as someone who did. Contact support at `5TayoPs Discord Server`` if you have any questions.", "");
				packet_(peer, "action|log\nmsg|CT:[S]_ This is a temporary ban caused by " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` and will be removed in `0" + time_counted + "``. If that's not your name, try playing from another location or device to fix it.", "");
				packet_(peer, "action|logon_fail");
				enet_peer_disconnect_later(peer, 0);
			}
		}
		//if (pInfo(peer)->requestedName != "Bypassing") failed_login(peer, "CT:[S]_ `5The game is currently undergoing maintenance. We will be back soon :D``", true);

		read_maintenance(maintenance);
		if (maintenance and (to_lower(pInfo(peer)->tankIDName) != "iEnzo" or to_lower(pInfo(peer)->tankIDName) != "Ayano" or to_lower(pInfo(peer)->tankIDName) != "iDems")) failed_login(peer, "CT:[S]_ `5The game is currently undergoing maintenance. We will be back soon :D``", true);
		pInfo(peer)->isIn = true;
		Algorithm::OnSuperMain(peer, item_hash);
		return true;
	}
	return false;
}

int choose_random(const int id_) {
	vector<int> ids_;
	int a_ = 0;
	while (items[id_ + a_].properties & Property_RandomGrow) {
		if (items[id_ + a_].blockType != BlockTypes::SEED) ids_.push_back(id_ + a_);
		a_++;
	}
	a_ = 0;
	while (items[id_ - a_].properties & Property_RandomGrow) {
		if (items[id_ - a_].blockType != BlockTypes::SEED) ids_.push_back(id_ - a_);
		a_++;
	}
	return ids_[rand() % ids_.size()];
}
bool use_mag(World* world_, WorldDrop drop_, int x_, int y_) {
	if (drop_.id == 5136 or drop_.id == 9148) return false;
	int lock = 0;
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or not pInfo(currentPeer)->isIn) continue;
		if (pInfo(currentPeer)->world != world_->name) continue;
		if (pInfo(currentPeer)->world == world_->name) {
			lock = pInfo(currentPeer)->lock;
		}
	}
	for (int i_ = 0; i_ < world_->machines.size(); i_++) {
		WorldMachines machine_ = world_->machines[i_];
		if (machine_.target_item == drop_.id and machine_.enabled) {
			if (machine_.id == 6948 or machine_.id == 5638 or machine_.id == 6946) {
				WorldBlock* itemas = &world_->blocks[machine_.x + (machine_.y * world_->width)];
				if (itemas->pr < (machine_.id == 6948 or machine_.id == 6946 ? (get_mag_size(lock)) : (get_mag_size(lock)))) {
					PlayerMoving data_{};
					data_.packetType = 19, data_.netID = -1, data_.plantingTree = 0;
					data_.x = machine_.x * 32 + 16, data_.y = machine_.y * 32 + 16;
					data_.XSpeed = x_ * 32 + 16, data_.YSpeed = y_ * 32 + 16;
					data_.punchX = drop_.id;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 6;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[]raw;
					itemas->pr += drop_.count;
					if (itemas->pr >= (machine_.id == 6948 or machine_.id == 6946 ? (get_mag_size(lock)) : (get_mag_size(lock))) or itemas->pr == drop_.count) {
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = machine_.x, data_.punchY = machine_.y, data_.characterState = 0x8;
						int alloc = alloc_(world_, itemas);
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
						BYTE* blc = raw + 56;
						form_visual(blc, *itemas, *world_, NULL, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (itemas->locked) {
							upd_lock(*itemas, *world_, NULL);
						}
					}
					return true;
				}
			}
		}
	}
	return false;
}

void drop_rare_item(World* world_, ENetPeer* peer, int i, int x, int y, bool seed) {
	int giveitem = 0, count = 1, got = 0, remove = -1;
	if (peer != NULL and pInfo(peer)->necklace == 11406 and seed and rand() % 750 < 1) {
		giveitem = items[11406].randomitem[rand() % items[11406].randomitem.size()];
		if (rand() % 25 < 1) giveitem = 11398; // rare 11398
		if (rand() % 2 < 1) modify_inventory(peer, 11406, remove = -1); // 50% chance
	}
	if (rand() % 10000 < 1) giveitem = 3918;
	if (rand() % 282 < 1) giveitem = 2914;
	if (rand() % 10000 < 1) giveitem = 12600;
	//if (rand() % 10000 < 1) giveitem = 9502;
	//if (rand() % 5000 < 1) giveitem = 9500;
	if (rand() % 1000 < 1) giveitem = 1898;
	if (rand() % 282 < 1) giveitem = theitemtoday;
	//if (items[i].chi == 0 || items[i].chi == 1 || items[i].chi == 2 || items[i].chi == 3) if (rand() % 28 < 1) giveitem = items[i].chi == 0 ? 5028 : items[i].chi == 1 ? 5024 : items[i].chi == 2 ? 5030 : items[i].chi == 3 ? 5026 : 0;
	if (items[i].chance != 0) if (rand() % items[i].chance < 1) giveitem = items[i].randomitem[rand() % items[i].randomitem.size()];
	int chance = 20000;
	// guild chest chance
	if (rand() % chance < 1 and items[i].rarity == 420) giveitem = 9538;
	if (rand() % (chance / 100) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 7954;
	if (rand() % (chance / 100) == 1 and items[i].farmable and items[i].rarity >= 25) giveitem = 9492;
	if (rand() % (chance / 100) == 1 and items[i].farmable and items[i].rarity >= 26) giveitem = 9169;
	if (rand() % (chance / 100) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 7484;
	if (rand() % (chance / 100) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 5948;
	//if (rand() % (chance / 200) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 9380;
	if (rand() % (chance / 50) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 11038; //summer artifact drop

	if (i == 8566 || i == 8562 || i == 8564 || i == 8560 && rand() % 72 < 1) giveitem = 8534;
	if (peer != NULL and pInfo(peer)->hand == 8554) {
		if (rand() % 200 < 1) {
			giveitem = 8534;
			count = rand() % 10 + 1;
			if (rand() % 1000 < 1) modify_inventory(peer, 8554, remove);
		}
	}
	/*
	if (seed && rand() % 200 - items[i].rarity < 1) {
		vector<int> harvest{ 1058, 1094, 1096, 1098 };
		giveitem = harvest[rand() % harvest.size()];
		if (rand() % 40 < 1) giveitem = 1828;
		if (pInfo(peer)->necklace == 10158 && giveitem == 1828) {
			count = rand() % 3 + 1;
			if (count >= 2) {
				modify_inventory(peer, 10158, got = -1);
				WorldDrop drop_block_{};
				drop_block_.id = 10228, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x * 32) + rand() % 17, drop_block_.y = (y * 32) + rand() % 17;
				if (not use_mag(world_, drop_block_, x, y)) dropas_(world_, drop_block_);
			}
		}
	}
	*/
	if (giveitem != 0) {
		WorldDrop drop_block_{};
		drop_block_.id = giveitem, drop_block_.count = count, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x * 32) + rand() % 17, drop_block_.y = (y * 32) + rand() % 17;
		if (not use_mag(world_, drop_block_, x, y)) dropas_(world_, drop_block_);
	}
}
bool harvest_seed(World* world_, WorldBlock* block_, int x_, int y_, int drop_count, int net_id = -1, ENetPeer* p_ = NULL) {
	bool seed_drop = false;
	if (block_->fg == 8533) block_->fg = 3;
	if (drop_count != 0) {
		if (items[block_->fg - 1].rarity != 999 and items[block_->fg - 1].blockType != BlockTypes::CLOTHING and rand() % 100 < 30) {
			seed_drop = true;
			WorldDrop drop_seed_{};
			drop_seed_.id = block_->fg;
			drop_seed_.count = 1;
			drop_seed_.uid = uint16_t(world_->drop.size()) + 1;
			drop_seed_.x = (x_ * 32) + rand() % 17;
			drop_seed_.y = (y_ * 32) + rand() % 17;
			if (pInfo(p_)->back == 8908 && modify_inventory(p_, drop_seed_.id, drop_seed_.count) == 0) {
				PlayerMoving data_{};
				data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
				data_.punchX = drop_seed_.id, data_.punchY = pInfo(p_)->netID;
				BYTE* raw;
				data_.x = (pInfo(p_)->lastwrenchx * 32) + 10, data_.y = (pInfo(p_)->lastwrenchy * 32) + 16;
				raw = packPlayerMoving(&data_);
				int32_t to_netid = pInfo(p_)->netID;
				raw[3] = 5;
				memcpy(raw + 8, &to_netid, 4);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
				int got = 0;
				if (rand() % 250 < 1) {
					modify_inventory(p_, 8908, got = -1);
					modify_inventory(p_, 8940, got = 1);
				}
			}
			else {
				if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
			}
		}
		WorldDrop drop_block_{};
		if (items[block_->fg].properties & Property_RandomGrow) {
			drop_block_.id = choose_random(block_->fg);
		}
		else
			drop_block_.id = block_->fg - 1;
		drop_block_.count = drop_count;
		drop_block_.uid = uint16_t(world_->drop.size()) + 1;
		drop_block_.x = (x_ * 32) + rand() % 17;
		drop_block_.y = (y_ * 32) + rand() % 17;
		if (pInfo(p_)->back == 8908 && modify_inventory(p_, drop_block_.id, drop_block_.count) == 0) {
			PlayerMoving data_{};
			data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
			data_.punchX = drop_block_.id, data_.punchY = pInfo(p_)->netID;
			BYTE* raw;
			data_.x = (pInfo(p_)->lastwrenchx * 32) + 10, data_.y = (pInfo(p_)->lastwrenchy * 32) + 16;
			raw = packPlayerMoving(&data_);
			int32_t to_netid = pInfo(p_)->netID;
			raw[3] = 5;
			memcpy(raw + 8, &to_netid, 4);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world) continue;
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
			int got = 0;
			if (rand() % 250 < 1) {
				modify_inventory(p_, 8908, got = -1);
				modify_inventory(p_, 8940, got = 1);
			}
		}
		else {
			if (not use_mag(world_, drop_block_, x_, y_)) dropas_(world_, drop_block_);
		}
	}
	if (items[block_->fg - 1].max_gems != 0) {
		if (p_ != NULL) {
			add_peer_xp(p_, (items[block_->fg].rarity / 5 > 0 ? items[block_->fg].rarity / 5 : 1));
		}
		int c_ = rand() % (items[block_->fg - 1].max_gems + 1);
		if (p_ != NULL) {
			if ((has_playmod(pInfo(p_), "Lucky") and ((rand() % 100) + 1) <= 30) || pInfo(p_)->affinity_level == 4) {
				PlayerMoving data_{};
				data_.packetType = 17;
				data_.netID = 125;
				data_.YSpeed = 125;
				data_.x = x_ * 32 + 16;
				data_.y = y_ * 32 + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw;
				c_ += (rand() % 5) + 1;
			}
		}
		if (c_ != 0) {
			gems_(p_, world_, c_, x_ * 32, y_ * 32, block_->fg);
		}
	}
	PlayerMoving data_{};
	data_.packetType = 12, data_.netID = net_id, data_.plantingTree = block_->fg;
	data_.punchX = x_, data_.punchY = y_;
	int32_t item = -1;
	BYTE* raw = packPlayerMoving(&data_);
	memcpy(raw + 8, &item, 4);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name) {
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	delete[]raw;
	reset_(block_, x_, y_, world_);
	return seed_drop;
}

void DoorMove(ENetPeer* peer, int x1, int y1) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (world_->blocks[i_].fg == 6) world_->blocks[i_].fg = 0, update_tile(peer, i_ % world_->width, i_ / world_->width, 0, false, true);
			if (i_ < ((world_->width * world_->height) - ((world_->width) * (6 * (world_->width / 100)))) && world_->blocks[i_].fg == 8) world_->blocks[i_].fg = 0, update_tile(peer, i_ % world_->width, i_ / world_->width, 0, false, true);
		}
		world_->blocks[x1 + (y1 * world_->width)].fg = 6;
		world_->blocks[x1 + (y1 + 1) * world_->width].fg = 8;
		update_tile(peer, x1, y1, 6, false, true);
		update_tile(peer, x1, y1 + 1, 8, false, true);
	}
}

bool LockMove(ENetPeer* peer, int wx1, int wy1) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		int lock = -1;
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (world_->blocks[i_].fg == 202 || world_->blocks[i_].fg == 204 || world_->blocks[i_].fg == 206 || world_->blocks[i_].fg == 4994) continue;
			if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
				lock = world_->blocks[i_].fg, world_->blocks[i_].fg = 0, update_tile(peer, i_ % world_->width, i_ / world_->width, 0, false, true);
				break;
			}
		}
		if (lock != -1) {
			world_->blocks[wx1 + (wy1) * world_->width].fg = lock;
			update_tile(peer, wx1, wy1, lock, false, true);
			return true;
		}
	}
	return false;
}
void ChangeName(ENetPeer* peer, string name) {
	gamepacket_t p2(0, pInfo(peer)->netID);
	p2.Insert("OnNameChanged");
	p2.Insert(name + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend``" : ""));
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
		p2.CreatePacket(currentPeer);
	}
}
void plant_(World* world_, ENetPeer* peer, WorldBlock* block_, int x_, int y_, int p_, bool upd_visual = true, bool mag_place = false) {
	block_->fruit = items[block_->fg].rarity == 999 ? 1 : (rand() % 4) + 1;
	if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 3 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
		pInfo(peer)->C_QuestProgress += items[block_->fg].rarity;
		if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
	}
	// LEGEND QUEST PLANT RARITY
	if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 5 && pInfo(peer)->quest_progress < 100000) {
		pInfo(peer)->quest_progress += items[block_->fg].rarity;
		if (pInfo(peer)->quest_progress >= 100000) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
	}
	if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 5 && pInfo(peer)->quest_progress < 40000) {
		pInfo(peer)->quest_progress += items[block_->fg].rarity;
		if (pInfo(peer)->quest_progress >= 40000) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
	}

	if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 2 && pInfo(peer)->quest_progress < 50000) {
		pInfo(peer)->quest_progress += items[block_->fg].rarity;
		if (pInfo(peer)->quest_progress >= 50000) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
	}
	if (upd_visual)
		punch_tile(peer, x_, y_, 0x3, p_, mag_place ? -1 : pInfo(peer)->netID, 0x0, 1, block_->fruit);
	int timed = items[p_].growTime / 4;
	// clothing growtime effects
	if (pInfo(peer)->ances == 5082) timed *= 1.10;
	if (pInfo(peer)->ances == 5162) timed = (timed * 1.20);
	if (pInfo(peer)->ances == 5164) timed = (timed * 1.30);
	if (pInfo(peer)->ances == 5166) timed = (timed * 1.40);
	if (pInfo(peer)->ances == 5168 || pInfo(peer)->affinity_level == 2) timed = (timed * 1.50);
	if (pInfo(peer)->ances == 5170) timed = (timed * 1.60);
	if (pInfo(peer)->hand == 6846) timed = (timed * 1.15);
	block_->planted = time(nullptr) - (timed);
	PlayerMoving data_{};
	data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
	BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
	BYTE* blc = raw + 56;
	WorldBlock* block_s = &world_->blocks[x_ + (y_ * world_->width)];
	form_visual(blc, *block_s, *world_, peer, false);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name) {
			send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
		}
	}
	delete[] raw, blc;
	if (block_->locked) {
		upd_lock(*block_, *world_, peer);
	}
}

Position2D track_steam(World* world_, WorldBlock* start_from, int x, int y) {
	if (x <= 0 || y <= 0) return { -1, -1 };
	Position2D new_pos{ -1, -1 };
	vector<int> new_tiles{};
	new_tiles.push_back((int)x + ((int)y * world_->width));
	int ySize = world_->blocks.size() / world_->width, xSize = world_->blocks.size() / ySize;
	vector<WorldBlock> shadow_copy = world_->blocks;
	for (int i2 = 0; i2 < new_tiles.size(); i2++) {
		int x_ = new_tiles[i2] % world_->width, y_ = new_tiles[i2] / world_->width;
		if (world_->blocks[x_ + (y_ * world_->width)].fg == 3724 or world_->blocks[x_ + (y_ * world_->width)].fg == 3286) {
			new_pos.x = x_, new_pos.y = y_;
			return new_pos;
		}
		else if (world_->blocks[x_ + 1 + (y_ * world_->width)].fg == 3724 or world_->blocks[x_ + 1 + (y_ * world_->width)].fg == 3286) {
			new_pos.x = x_ + 1, new_pos.y = y_;
			return new_pos;
		}
		else if (world_->blocks[x_ - 1 + (y_ * world_->width)].fg == 3724 or world_->blocks[x_ - 1 + (y_ * world_->width)].fg == 3286) {
			new_pos.x = x_ - 1, new_pos.y = y_;
			return new_pos;
		}
		else if (world_->blocks[x_ + ((y_ + 1) * world_->width)].fg == 3724 or world_->blocks[x_ + ((y_ + 1) * world_->width)].fg == 3286) {
			new_pos.x = x_, new_pos.y = y_ + 1;
			return new_pos;
		}
		else if (world_->blocks[x_ + ((y_ - 1) * world_->width)].fg == 3724 or world_->blocks[x_ + ((y_ - 1) * world_->width)].fg == 3286) {
			new_pos.x = x_, new_pos.y = y_ - 1;
			return new_pos;
		}

		if (x_ < (world_->width - 1) and shadow_copy[x_ + 1 + (y_ * world_->width)].fg == 3260) {
			if (not shadow_copy[x_ + 1 + (y_ * world_->width)].scanned) {
				shadow_copy[x_ + 1 + (y_ * world_->width)].scanned = true;
				new_tiles.push_back(x_ + 1 + (y_ * world_->width));
			}
		} if (x_ > 0 and shadow_copy[x_ - 1 + (y_ * world_->width)].fg == 3260) {
			if (not shadow_copy[x_ - 1 + (y_ * world_->width)].scanned) {
				shadow_copy[x_ - 1 + (y_ * world_->width)].scanned = true;
				new_tiles.push_back(x_ - 1 + (y_ * world_->width));
			}
		} if (y_ < (world_->height - 1) and shadow_copy[x_ + ((y_ + 1) * world_->width)].fg == 3260) {
			if (not shadow_copy[x_ + ((y_ + 1) * world_->width)].scanned) {
				shadow_copy[x_ + ((y_ + 1) * world_->width)].scanned = true;
				new_tiles.push_back(x_ + ((y_ + 1) * world_->width));
			}
		} if (y_ > 0 and shadow_copy[x_ + ((y_ - 1) * world_->width)].fg == 3260) {
			if (not shadow_copy[x_ + ((y_ - 1) * world_->width)].scanned) {
				shadow_copy[x_ + ((y_ - 1) * world_->width)].scanned = true;
				new_tiles.push_back(x_ + ((y_ - 1) * world_->width));
			}
		}
	}
	return new_pos;
}

void load_storagebox(ENetPeer* peer, World* world_, WorldBlock* block_) {
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	int got = 0, got2 = 0;
	modify_inventory(peer, 1424, got);
	modify_inventory(peer, 1424, got *= -1);
	modify_inventory(peer, 5816, got2);
	modify_inventory(peer, 5816, got2 *= -1);
	string dbox_item = "\nadd_spacer|small|\ntext_scaling_string|aaaaaaaaaaaaaaa|";
	int itemcount = 0;
	for (int i_ = 0; i_ < world_->sbox1.size(); i_++) if (world_->sbox1[i_].x == pInfo(peer)->lastwrenchx and world_->sbox1[i_].y == pInfo(peer)->lastwrenchy) itemcount++, dbox_item += "\nadd_button_with_icon|itm" + to_string(itemcount) + "|" + items[world_->sbox1[i_].id].name + "|frame|" + to_string(world_->sbox1[i_].id) + "|" + to_string(world_->sbox1[i_].count) + "|";
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[pInfo(peer)->lastwrenchb].name + "``|left|" + to_string(pInfo(peer)->lastwrenchb) + "|" + (dbox_item.size() > 56 ? dbox_item + "\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nadd_textbox|`w" + to_string(itemcount) + "/" + to_string(items[pInfo(peer)->lastwrenchb].box_size) + "`` items stored.|left|" + (itemcount >= items[pInfo(peer)->lastwrenchb].box_size ? "" : "\nadd_spacer|small|\nadd_item_picker|itemid|`wDeposit Item``|Choose an item to store|") + (pInfo(peer)->lastwrenchb == 8878 ? "\nadd_textbox|This Safe Vault is " + a + (block_->door_destination == "" ? "not `4" : "`2") + "password protected``!|left|\nadd_spacer|small|\nadd_textbox|Change your password.|left|\nadd_button|change_password|`wUpdate Password``|noflags|0|0|" : "") + "\nend_dialog|storageboxxtreme|Exit||\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}

void apply_dye(ENetPeer* peer, World* world_, WorldBlock* block_, int p_, int x_, int y_, uint32_t color, int r, int g, int b, bool shampoo)
{
	if (x_ != pInfo(peer)->x / 32 or y_ != pInfo(peer)->y / 32) {
		gamepacket_t p;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		p.Insert("(Must be used on yourself)");
		p.Insert(0);
		p.Insert(1);
		p.CreatePacket(peer);
		return;
	}
	int got = 0;
	modify_inventory(peer, p_, got);
	if (got == 0) return;
	string based_on = (p_ == 3822 || p_ == 3824 || p_ == 3826 || p_ == 3828 || p_ == 3830 ? "hair" : (p_ == 5458 || p_ == 5460 || p_ == 5462 || p_ == 5464 || p_ == 5466 ? "drops" : "lenses"));
	if (based_on == "lenses" && shampoo == false) {
		if (pInfo(peer)->eye_lenses == 0xFFFFFFFF) r *= 9, g *= 9, b *= 9;
	}
	if (((block_->fg != 230 && block_->fg != 6158) && based_on == "hair") or ((block_->fg != 5468 && block_->fg != 7740) && based_on == "drops") or ((block_->fg != 5468 && block_->fg != 7740) && based_on == "lenses")) {
		gamepacket_t p;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		if (based_on == "hair") p.Insert("You'll make a huge mess if you do that outside the Bathtub!");
		else p.Insert("You'd better do that in front of a bathroom mirror or you'll poke your eye out!");
		p.Insert(0);
		p.Insert(1);
		p.CreatePacket(peer);
		return;
	}
	if ((based_on == "hair" && pInfo(peer)->hair_color == color) or (based_on == "drops" && pInfo(peer)->eye_drop == color) or (based_on == "lenses" && pInfo(peer)->eye_lenses == color)) {
		gamepacket_t p;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		if (based_on == "hair") {
			if (shampoo) p.Insert("Your hair is already clean!");
			else p.Insert("Your hair is already that color!");
		}
		else if (based_on == "drops") {
			if (shampoo) p.Insert("Your eyes are already clean!");
			else p.Insert("Your eyes are already that color!");
		}
		else if (based_on == "lenses") {
			if (shampoo) p.Insert("Your lenses are already clean!");
			else p.Insert("Your pupils are already that color!");
		}
		p.Insert(0);
		p.Insert(1);
		p.CreatePacket(peer);
		return;
	}

	uint8_t* cancer = (uint8_t*)(&(based_on == "hair" ? pInfo(peer)->hair_color : (based_on == "drops" ? pInfo(peer)->eye_drop : pInfo(peer)->eye_lenses)));
	cancer[1] = std::clamp(cancer[1] + r, 0, 255);
	cancer[2] = std::clamp(cancer[2] + g, 0, 255);
	cancer[3] = std::clamp(cancer[3] + b, 0, 255);

	if (rand() % 100 < (items[p_].newdropchance + 5)) {
		WorldDrop drop_seed_{};
		drop_seed_.id = p_ + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
		if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
	}
	else if (rand() % 10 < 4) gems_(peer, world_, rand() % (items[p_].max_gems + 1), x_ * 32, y_ * 32, p_);
	gamepacket_t p;
	p.Insert("OnTalkBubble");
	p.Insert(pInfo(peer)->netID);
	if (based_on == "hair") {
		if (shampoo) {
			if (rand() % 250 < 1) {
				WorldDrop drop_seed_{};
				drop_seed_.id = 12510, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
				if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
			}
			p.Insert("Your hair got cleaner!");
		}
		else p.Insert("You dyed your hair!");
	}
	else if (based_on == "drops") {
		if (shampoo) p.Insert("Your eyes got cleaner!");
		else p.Insert("You used eye drops!");
	}
	else {
		if (shampoo) p.Insert("Your lenses got cleaner!");
		else p.Insert("You put in some contact lenses!");
	}
	if (based_on == "hair") {
		gamepacket_t p2(0, pInfo(peer)->netID);
		p2.Insert("OnAction");
		p2.Insert("/shower");
		p.CreatePacket(peer);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == pInfo(peer)->world) p2.CreatePacket(currentPeer);
		}
	}
	modify_inventory(peer, p_, got = -1);
	update_clothes(peer);
}
/*
bool patchPath(World* world_, int x, int y, int fg, ENetPeer* p_) {
	if (world_->blocks[fg].fg == 8676) return false;
	if (x < 0 || x > world_->width * 32 || y < 0 || y > world_->height * 32) return false;
	vector<int> new_tiles{};
	if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].collisionType != 1 or items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance or items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].toggleable or items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance) {
		if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance and not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].admins.begin(), world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].admins.end(), pInfo(p_)->tankIDName) == world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].admins.end()) {
		}
		else if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].toggleable and is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00400000)) {
		}
		else {
			new_tiles.push_back((int)x / 32 + ((int)y / 32 * world_->width));
		}
	} int ySize = world_->blocks.size() / world_->width, xSize = world_->blocks.size() / ySize;
	vector<WorldBlock> shadow_copy = world_->blocks;
	for (int i2 = 0; i2 < new_tiles.size(); i2++) {
		int x_ = new_tiles[i2] % world_->width, y_ = new_tiles[i2] / world_->width;
		if (&world_->blocks[x_ + (y_ * world_->width)] == &world_->blocks[fg] and items[shadow_copy[x_ + (y_ * world_->width)].fg].collisionType != 1) {
			return false;
		}
		if (x_ < (world_->width - 1) and items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].collisionType != 1 or x_ < (world_->width - 1) and items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance or x_ < (world_->width - 1) and items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].toggleable) {
			if (items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].vipentrance and not shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ + 1 + (y_ * world_->width)].admins.begin(), shadow_copy[x_ + 1 + (y_ * world_->width)].admins.end(), pInfo(p_)->tankIDName) == shadow_copy[x_ + 1 + (y_ * world_->width)].admins.end()) {
			}
			else if (items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not world_->owner_name.empty() and /*!guild_access(p_, world_->guild_id) and * find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
			}
			else if (items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + 1 + (y_ * world_->width)].scanned) {
					shadow_copy[x_ + 1 + (y_ * world_->width)].scanned = true;
					new_tiles.push_back(x_ + 1 + (y_ * world_->width));
				}
				}
				} if (x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].collisionType != 1 or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].toggleable) {
					if (items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].vipentrance and not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ - 1 + (y_ * world_->width)].admins.begin(), shadow_copy[x_ - 1 + (y_ * world_->width)].admins.end(), pInfo(p_)->tankIDName) == shadow_copy[x_ - 1 + (y_ * world_->width)].admins.end()) {
					}
					else if (items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not world_->owner_name.empty() and /*!guild_access(p_, world_->guild_id) and * find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
					}
					else if (items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)], 0x00400000)) {
					}
					else {
						if (not shadow_copy[x_ - 1 + (y_ * world_->width)].scanned) {
							shadow_copy[x_ - 1 + (y_ * world_->width)].scanned = true;
							new_tiles.push_back(x_ - 1 + (y_ * world_->width));
						}
					}
				} if (y_ < (world_->height - 1) and items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].collisionType != 1 or y_ < (world_->height - 1) and items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance or y_ < (world_->height - 1) and items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].toggleable) {
					if (items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].vipentrance and not shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ + ((y_ + 1) * world_->width)].admins.begin(), shadow_copy[x_ + ((y_ + 1) * world_->width)].admins.end(), pInfo(p_)->tankIDName) == shadow_copy[x_ + ((y_ + 1) * world_->width)].admins.end()) {
					}
					else if (items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not world_->owner_name.empty() and /*!guild_access(p_, world_->guild_id) and  find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
					}
					else if (items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)], 0x00400000)) {
					}
					else {
						if (not shadow_copy[x_ + ((y_ + 1) * world_->width)].scanned) {
							shadow_copy[x_ + ((y_ + 1) * world_->width)].scanned = true;
							new_tiles.push_back(x_ + ((y_ + 1) * world_->width));
						}
					}
				} if (y_ > 0 and items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].collisionType != 1 or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * world_->width)].fg].entrance or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * world_->width)].fg].toggleable) {
					if (items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].vipentrance and not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ + ((y_ - 1) * world_->width)].admins.begin(), shadow_copy[x_ + ((y_ - 1) * world_->width)].admins.end(), pInfo(p_)->tankIDName) == shadow_copy[x_ + ((y_ - 1) * world_->width)].admins.end()) {
					}
					else if (items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not world_->owner_name.empty() and /*!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
					}
					else if (items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)], 0x00400000)) {
					}
					else {
						if (not shadow_copy[x_ + ((y_ - 1) * world_->width)].scanned) {
							shadow_copy[x_ + ((y_ - 1) * world_->width)].scanned = true;
							new_tiles.push_back(x_ + ((y_ - 1) * world_->width));
						}
					}
				}
	}
	return true;
}
*/
/*
bool AbleToCollect(World* world, WorldBlock* target, ENetPeer* peer) {
	if ((items[target->fg].entrance and is_false_state(*target, 0x00800000) and not is_block_owner(peer, world, target) and not has_access(peer, world, target))
		|| (items[target->fg].entrance and is_false_state(*target, 0x00800000) and
			(world->owner_name.empty() and world->owner_name != pInfo(peer)->tankIDName and find(world->admins.begin(), world->admins.end(), pInfo(peer)->tankIDName) == world->admins.end() and not has_access(peer, world, target))))
		return false;
	else if (items[target->fg].toggleable and is_false_state(*target, 0x00400000))
		return false;

	return true;
}
*/

bool IsObstacle(World* world, Player* player, CL_Vec2i position) {
	if (position.x >= world->width || position.y >= world->height) return true;
	if (position.x < 0 || position.y < 0) return true;
	if (player->ghost)
		return false;
 	WorldBlock* tile = GetTile(position.x, position.y, world);
	if (!tile) return true;
	auto def = items[tile->fg ? tile->fg : tile->bg];
	if (tile->fg == 0 || def.collisionType != 1 || def.blockType == PLATFORM)
		return false;
	if (def.entrance) {
		if (player->dev)
			return false;
		if (tile->locked) {
			WorldBlock* parent = GetParentTile(tile, world);
			if (!parent)
				return true;
			if (find(parent->admins.begin(), parent->admins.end(), player->uid) != parent->admins.end()
				|| HasFlag(parent, TILEFLAG_PUBLIC) || HasFlag(tile, TILEFLAG_PUBLIC) || parent->owner_name == player->tankIDName)
				return false;
		}
		else {
			if (world->owner_name.empty() || world->owner_name == player->tankIDName)
				return false;
			/*
			auto main_lock = GetTile(player->lock, world);
			if (!main_lock)
				return true;
			auto access_list = main_lock->admins;
			*/
			auto access_list = world->admins;
			if (find(access_list.begin(), access_list.end(), player->uid) != access_list.end()
				|| /*HasFlag(main_lock, TILEFLAG_PUBLIC)*/ world->open_to_public || guild_access(player) || HasFlag(tile, TILEFLAG_PUBLIC))
				return false;
		}
		return true;
	}
	else if (def.toggleable) {
		if (player->dev)
			return false;
		if (HasFlag(tile, TILEFLAG_OPEN))
			return false;

		return true;
	}
	else if (def.vipentrance) {
		if (player->dev)
			return false;
		if (world->owner_name.empty() || world->owner_name == player->tankIDName)
			return false;
		auto access_list = tile->admins;
		if (find(access_list.begin(), access_list.end(), player->uid) != access_list.end()
			|| HasFlag(tile, TILEFLAG_PUBLIC) || tile->owner_name == player->tankIDName || tile->limit_admins)
			return false;
		return true;
	}
	return true;
}
bool AllowedPath(World* world, Player* player, int x, int y) {
	enum { UP, DOWN, LEFT, RIGHT };

	std::vector<int> layer = { 0, 0, 0, 0 }; // all checked sides
	if (!player || !world)
		return false;

	if (x > world->width || x < 0 || y > world->height || y < 0)
		return false;

	if (world->blocks.at((x + 1) + (y * world->width)).fg != 0) {
		if (items.at(world->blocks.at((x + 1) + (y * world->width)).fg).toggleable) {
			bool open = HasFlag(&world->blocks.at((x + 1) + (y * world->width)), TILEFLAG_OPEN);
			if (!open)
				layer[RIGHT] += 1;
		}
		else if (items.at(world->blocks.at((x + 1) + (y * world->width)).fg).entrance) {
			//if (world->blocks.at((x + 1) + (y * world->width)).locked)
			{
				bool open = HasFlag(&world->blocks.at((x + 1) + (y * world->width)), TILEFLAG_PUBLIC);
				bool public_ = world->open_to_public;
				bool owner = (world->blocks.at((x + 1) + (y * world->width)).owner_name == player->tankIDName);
				bool admin = (find(world->blocks.at((x + 1) + (y * world->width)).admins.begin(), world->blocks.at((x + 1) + (y * world->width)).admins.end(), player->uid) != world->blocks.at((x + 1) + (y * world->width)).admins.end());
				if (!open && !owner && !public_ && !admin && world->owner_name != player->tankIDName
					&& find(world->admins.begin(), world->admins.end(), player->uid) == world->admins.end())
					layer[RIGHT] += 1;
			}
		}
		else if (items.at(world->blocks.at((x + 1) + (y * world->width)).fg).vipentrance) {
			auto access_list = world->blocks.at((x + 1) + (y * world->width)).admins;
			if (find(access_list.begin(), access_list.end(), player->uid) != access_list.end()
				|| HasFlag(&world->blocks.at((x + 1) + (y * world->width)), TILEFLAG_PUBLIC) || world->blocks.at((x + 1) + (y * world->width)).owner_name == player->tankIDName || world->blocks.at((x + 1) + (y * world->width)).limit_admins)
				layer[RIGHT] += 1;
		}
		else {
			if (items.at(world->blocks.at((x + 1) + (y * world->width)).fg).collisionType != 0) {
				layer[RIGHT] += 1;
			}
		}
	}
	if (world->blocks.at((x - 1) + (y * world->width)).fg != 0) {
		if (items.at(world->blocks.at((x - 1) + (y * world->width)).fg).toggleable) {
			bool open = HasFlag(&world->blocks.at((x - 1) + (y * world->width)), TILEFLAG_OPEN);
			if (!open)
				layer[LEFT] += 1;
		}
		else if (items.at(world->blocks.at((x - 1) + (y * world->width)).fg).entrance) {
			//if (world->blocks.at((x - 1) + (y * world->width)).locked)
			{
				bool open = HasFlag(&world->blocks.at((x - 1) + (y * world->width)), TILEFLAG_PUBLIC);
				bool public_ = world->open_to_public;
				bool owner = (world->blocks.at((x - 1) + (y * world->width)).owner_name == player->tankIDName);
				bool admin = (find(world->blocks.at((x - 1) + (y * world->width)).admins.begin(), world->blocks.at((x - 1) + (y * world->width)).admins.end(), player->uid) != world->blocks.at((x - 1) + (y * world->width)).admins.end());
				if (!open && !owner && !public_ && !admin && world->owner_name != player->tankIDName
					&& find(world->admins.begin(), world->admins.end(), player->uid) == world->admins.end())
					layer[LEFT] += 1;
			}
		}
		else if (items.at(world->blocks.at((x - 1) + (y * world->width)).fg).vipentrance) {
			auto access_list = world->blocks.at((x - 1) + (y * world->width)).admins;
			if (find(access_list.begin(), access_list.end(), player->uid) != access_list.end()
				|| HasFlag(&world->blocks.at((x - 1) + (y * world->width)), TILEFLAG_PUBLIC) || world->blocks.at((x - 1) + (y * world->width)).owner_name == player->tankIDName || world->blocks.at((x - 1) + (y * world->width)).limit_admins)
				layer[LEFT] += 1;
		}
		else {
			if (items.at(world->blocks.at((x - 1) + (y * world->width)).fg).collisionType != 0) {
				layer[LEFT] += 1;
			}
		}
	}
	if (world->blocks.at(x + ((y + 1) * world->width)).fg != 0) {
		if (items.at(world->blocks.at(x + ((y + 1) * world->width)).fg).toggleable) {
			bool open = HasFlag(&world->blocks.at(x + ((y + 1) * world->width)), TILEFLAG_OPEN);
			if (!open)
				layer[UP] += 1;
		}
		else if (items.at(world->blocks.at(x + ((y + 1) * world->width)).fg).entrance) {
			//if (world->blocks.at(x + ((y + 1) * world->width)).locked)
			{
				bool open = HasFlag(&world->blocks.at(x + ((y + 1) * world->width)), TILEFLAG_PUBLIC);
				bool public_ = world->open_to_public;
				bool owner = (world->blocks.at(x + ((y + 1) * world->width)).owner_name == player->tankIDName);
				bool admin = (find(world->blocks.at(x + ((y + 1) * world->width)).admins.begin(), world->blocks.at(x + ((y + 1) * world->width)).admins.end(), player->uid) != world->blocks.at(x + ((y + 1) * world->width)).admins.end());
				if (!open && !owner && !public_ && !admin && world->owner_name != player->tankIDName
					&& find(world->admins.begin(), world->admins.end(), player->uid) == world->admins.end())
					layer[UP] += 1;
			}
		}
		else if (items.at(world->blocks.at(x + ((y + 1) * world->width)).fg).vipentrance) {
			auto access_list = world->blocks.at(x + ((y + 1) * world->width)).admins;
			if (find(access_list.begin(), access_list.end(), player->uid) != access_list.end()
				|| HasFlag(&world->blocks.at(x + ((y + 1) * world->width)), TILEFLAG_PUBLIC) || world->blocks.at(x + ((y + 1) * world->width)).owner_name == player->tankIDName || world->blocks.at(x + ((y + 1) * world->width)).limit_admins)
					layer[UP] += 1;
		}
		else {
			if (items.at(world->blocks.at(x + ((y + 1) * world->width)).fg).collisionType != 0) {
				layer[UP] += 1;
			}
		}
	}
	if (world->blocks.at(x + ((y - 1) * world->width)).fg != 0) {
		if (items.at(world->blocks.at(x + ((y - 1) * world->width)).fg).toggleable) {
			bool open = HasFlag(&world->blocks.at(x + ((y - 1) * world->width)), TILEFLAG_OPEN);
			if (!open)
				layer[DOWN] += 1;
		}
		else if (items.at(world->blocks.at(x + ((y - 1) * world->width)).fg).entrance) {
			//if (world->blocks.at(x + ((y - 1) * world->width)).locked)
			{
				bool open = HasFlag(&world->blocks.at(x + ((y - 1) * world->width)), TILEFLAG_PUBLIC);
				bool public_ = world->open_to_public;
				bool owner = (world->blocks.at(x + ((y - 1) * world->width)).owner_name == player->tankIDName);
				bool admin = (find(world->blocks.at(x + ((y - 1) * world->width)).admins.begin(), world->blocks.at(x + ((y - 1) * world->width)).admins.end(), player->uid) != world->blocks.at(x + ((y - 1) * world->width)).admins.end());
				if (!open && !owner && !public_ && !admin && world->owner_name != player->tankIDName
					&& find(world->admins.begin(), world->admins.end(), player->uid) == world->admins.end())
					layer[DOWN] += 1;
			}
		}
		else if (items.at(world->blocks.at(x + ((y - 1) * world->width)).fg).vipentrance) {
			auto access_list = world->blocks.at(x + ((y - 1) * world->width)).admins;
			if (find(access_list.begin(), access_list.end(), player->uid) != access_list.end()
				|| HasFlag(&world->blocks.at(x + ((y - 1) * world->width)), TILEFLAG_PUBLIC) || world->blocks.at(x + ((y - 1) * world->width)).owner_name == player->tankIDName || world->blocks.at(x + ((y - 1) * world->width)).limit_admins)
				layer[DOWN] += 1;
		}
		else {
			if (items.at(world->blocks.at(x + ((y - 1) * world->width)).fg).collisionType != 0) {
				layer[DOWN] += 1;
			}
		}
	}

	if (layer[UP] > 0 && layer[DOWN] > 0 && layer[LEFT] > 0 && layer[RIGHT] > 0)
		return false;

	return true;
}
bool NotCollectable(World* world, WorldBlock* block_, Player* player) {
	auto block = GetTile(GetTilePos(block_->fg, world), world);
	if (!block)
		return true;
	if (block->fg == 0 || items[block->fg].collisionType == 0)
		return false;

	if (items[block->fg].entrance) {
		if (block->locked) {
			WorldBlock* parent = GetParentTile(block, world);
			if (!parent)
				return true;
			if (find(parent->admins.begin(), parent->admins.end(), player->uid) != parent->admins.end()
				|| HasFlag(parent, TILEFLAG_PUBLIC) || HasFlag(block, TILEFLAG_PUBLIC) || parent->owner_name == player->tankIDName)
				return false;
		}
		else {
			if (world->owner_name.empty() or world->owner_name == player->tankIDName)
				return false;
			vector<int> access_list = world->admins;
			if (find(access_list.begin(), access_list.end(), player->uid) != access_list.end()
				|| world->open_to_public || HasFlag(block, TILEFLAG_PUBLIC))
				return false;
		}
		return true;
	}
	else if (items[block->fg].vipentrance) {
		vector<int> access_list = block->admins;
		if (find(access_list.begin(), access_list.end(), player->uid) != access_list.end()
			|| HasFlag(block, TILEFLAG_PUBLIC) || block->owner_name == player->tankIDName || block->limit_admins)
			return false;

		return true;
	}
	else if (items[block->fg].toggleable) {
		if (HasFlag(block, TILEFLAG_OPEN))
			return false;

		return true;
	}
	else if (!AllowedPath(world, player, player->x / 32, player->y / 32)) {
		return true;
	}

	return true;
}
bool OnFindPath(Player* player, World* world, const CL_Vec2i& current_pos, const CL_Vec2i& future_pos) {
	int start = current_pos.x + current_pos.y * world->width;
	int end = future_pos.x + future_pos.y * world->width;

	if (player->ghost)
		return true;

	if (current_pos.x < 0 || current_pos.x >= world->width)
		return false;
	if (future_pos.x < 0 || future_pos.x >= world->width)
		return false;

	if (current_pos.y < 0 || current_pos.y >= world->height)
		return false;
	if (future_pos.y < 0 || future_pos.y >= world->height)
		return false;

	if (IsObstacle(world, player, current_pos) || IsObstacle(world, player, future_pos))
		return false;
	//if (AllowedPath(world, player, current_pos.x, current_pos.y)) return true;
	if (start == end)
		return true;

	for (auto& tile : world->blocks) {
		tile.path_parent = -1;
		tile.visited = false;
		tile.local = INFINITY;
		tile.global = INFINITY;
	}

	auto get_distance = [&](int32_t a, int32_t b) {
		return sqrtf(
			(GetTilePos(GetTile(a, world)->fg, world).x - GetTilePos(GetTile(b, world)->fg, world).x) * 
			(GetTilePos(GetTile(a, world)->fg, world).x - GetTilePos(GetTile(b, world)->fg, world).x) +
			(GetTilePos(GetTile(a, world)->fg, world).x - GetTilePos(GetTile(b, world)->fg, world).x) *
			(GetTilePos(GetTile(a, world)->fg, world).x - GetTilePos(GetTile(b, world)->fg, world).x)
		);
	};

	int current = start;
	GetTile(start, world)->local = 0.0f;
	GetTile(start, world)->global = get_distance(start, end);

	list<int> not_tested;
	not_tested.emplace_back(start);
	while (!not_tested.empty() && current != end) {
		not_tested.sort([&](const int lhs, const int rhs) {
			return GetTile(lhs, world)->global < GetTile(rhs, world)->global;
		});

		while (!not_tested.empty() && GetTile(not_tested.front(), world)->visited)
			not_tested.pop_front();
		if (not_tested.empty())
			break;

		current = not_tested.front();
		GetTile(current, world)->visited = true;
		int x = GetTilePos(GetTile(current, world)->fg, world).x, y = GetTilePos(GetTile(current, world)->fg, world).y;
		if (y + 1 < world->height) {
			int index = GetTilePos(GetTile(x + (y + 1) * world->width, world)->fg, world).x + GetTilePos(GetTile(x + (y + 1) * world->width, world)->fg, world).y * world->width;

			if (!GetTile(index, world)->visited && IsObstacle(world, player, { GetTilePos(GetTile(index, world)->fg, world).x, GetTilePos(GetTile(index, world)->fg, world).y }) == false)
				not_tested.emplace_back(index);

			float distance = GetTile(current, world)->local + get_distance(current, index);
			if (distance < GetTile(index, world)->local) {
				GetTile(index, world)->path_parent = current;
				GetTile(index, world)->local = distance;
				GetTile(index, world)->global = GetTile(index, world)->local + get_distance(index, end);
			}
		}
		if (x + 1 < world->width) {
			int index = GetTilePos(GetTile((x + 1) + y * world->width, world)->fg, world).x + GetTilePos(GetTile((x + 1) + y * world->width, world)->fg, world).y * world->width;
			if (!GetTile(index, world)->visited && IsObstacle(world, player, { GetTilePos(GetTile(index, world)->fg, world).x, GetTilePos(GetTile(index, world)->fg, world).y }) == false)
				not_tested.emplace_back(index);

			float distance = GetTile(current, world)->local + get_distance(current, index);
			if (distance < GetTile(index, world)->local) {
				GetTile(index, world)->path_parent = current;
				GetTile(index, world)->local = distance;
				GetTile(index, world)->global = GetTile(index, world)->local + get_distance(index, end);
			}
		}
		if (y - 1 >= 0) {
			int index = GetTilePos(GetTile(x + (y - 1) * world->width, world)->fg, world).x + GetTilePos(GetTile(x + (y - 1) * world->width, world)->fg, world).y * world->width;
			if (!GetTile(index, world)->visited && IsObstacle(world, player, { GetTilePos(GetTile(index, world)->fg, world).x, GetTilePos(GetTile(index, world)->fg, world).y }) == false)
				not_tested.emplace_back(index);

			float distance = GetTile(current, world)->local + get_distance(current, index);
			if (distance < GetTile(index, world)->local) {
				GetTile(index, world)->path_parent = current;
				GetTile(index, world)->local = distance;
				GetTile(index, world)->global = GetTile(index, world)->local + get_distance(index, end);
			}
		}
		if (x - 1 >= 0) {
			int index = GetTilePos(GetTile((x - 1) + y * world->width, world)->fg, world).x + GetTilePos(GetTile((x - 1) + y * world->width, world)->fg, world).y * world->width;
			if (!GetTile(index, world)->visited && IsObstacle(world, player, { GetTilePos(GetTile(index, world)->fg, world).x, GetTilePos(GetTile(index, world)->fg, world).y }) == false)
				not_tested.emplace_back(index);

			float distance = GetTile(current, world)->local + get_distance(current, index);
			if (distance < GetTile(index, world)->local) {
				GetTile(index, world)->path_parent = current;
				GetTile(index, world)->local = distance;
				GetTile(index, world)->global = GetTile(index, world)->local + get_distance(index, end);
			}
		}
	}

	if (end != -1) {
		int p = end;
		if (p < 0 || p >= world->width * world->height)
			return false;

		while (GetTile(p, world)->path_parent != -1) {
			if (GetTile(p, world)->path_parent == p)
				return false;
			if (p < 0 || p >= world->width * world->height)
				return false;

			p = GetTile(p, world)->path_parent;
		}
		if (p == start)
			return true;
	}

	return false;
}
bool patchNoClip(World* world_, int x, int y, WorldBlock* target_, ENetPeer* p_) { // this is shit lol
	vector<int> new_tiles{};
	if (x > world_->width || y > world_->height) return false;
	if (x < 0 || y < 0) return false;

	if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].collisionType != 1 or
		items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance or
		items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].toggleable or
		items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance) {
		if ((items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance and
			not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and
			world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty()
			and not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
			not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]))
			|| (//world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].locked and 
				items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance and
			not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and
			not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
			not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)])) ||
			(//world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].locked and
				items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance and
				not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and
				not world_->owner_name.empty() and
				find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
				world_->owner_name != pInfo(p_)->tankIDName and
				not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
				not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]))) {
		}
		/*
		else if (world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].locked and 
			items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance and
			is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00800000) and 
			not world_->open_to_public or !(is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)])
				and not block_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], false, true))) {
		}
		*/
		else if ((items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance and
			is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00800000)
			and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and
			not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(),
				world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and 
			not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
			not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)])) ||
			(//world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].locked and 
				items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance and
					//not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and 
				is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00800000) and
				    not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
					not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)])) ||
			(//world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].locked and
				items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance and
				//not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and
				is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00800000) and
				not world_->owner_name.empty() and
				find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
				world_->owner_name != pInfo(p_)->tankIDName and
				not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
				not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]))) {
		}
		else if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].toggleable and
			is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00400000)) {
		}
		else {
			new_tiles.push_back((int)x / 32 + ((int)y / 32 * world_->width));
		}
	} int ySize = world_->blocks.size() / world_->width, xSize = world_->blocks.size() / ySize;
	vector<WorldBlock> shadow_copy = world_->blocks;
	for (int i2 = 0; i2 < new_tiles.size(); i2++) {
		int x_ = new_tiles[i2] % world_->width, y_ = new_tiles[i2] / world_->width;

		if (&world_->blocks[x_ + (y_ * world_->width)] == target_ and items[shadow_copy[x_ + (y_ * world_->width)].fg].collisionType != 1) {
			return false;
		} if (x_ < (world_->width - 1) and items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].collisionType != 1 or x_ < (world_->width - 1) and
			items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance or x_ < (world_->width - 1) and
			items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].toggleable) {
			if ((items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].vipentrance and not
				shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and
				not world_->owner_name.empty() and not 
				is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)], false) and
				not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)])) ||
				(//shadow_copy[x_ + 1 + (y_ * world_->width)].locked and
					items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].vipentrance and
					not shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and
					not is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)], false) and 
				    not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)])) ||
				(//shadow_copy[x_ + 1 + (y_ * world_->width)].locked and
					items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].vipentrance and
					not shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and
					not world_->owner_name.empty() and
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					world_->owner_name != pInfo(p_)->tankIDName and
					not is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)], false) and
					not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]))) {
			}
			/*
			else if (shadow_copy[x_ + 1 + (y_ * world_->width)].locked and
				items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance and
				is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)], 0x00800000) and
				not world_->open_to_public or !(is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)])
					and not block_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)], false, true))) {
			}
			*/
			else if ((items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)],
				0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not
				world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(),
					world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and not
				is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)], false) and
				not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]))
				||
				(//shadow_copy[x_ + 1 + (y_ * world_->width)].locked and 
					items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)],
					0x00800000) and
					//not shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and
					not is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]))
				||
				(//shadow_copy[x_ + 1 + (y_ * world_->width)].locked and
					items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)],
						0x00800000) and
					//not shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and
					not world_->owner_name.empty() and
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					world_->owner_name != pInfo(p_)->tankIDName and
					not is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]))) {
			}
			else if (items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].toggleable and
				is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + 1 + (y_ * world_->width)].scanned) {
					shadow_copy[x_ + 1 + (y_ * world_->width)].scanned = true;
					new_tiles.push_back(x_ + 1 + (y_ * world_->width));
				}
			}
		} if (x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].collisionType != 1 or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].toggleable) {
			if ((items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].vipentrance and not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins
				and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and
				not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
				not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]))
				|| (//shadow_copy[x_ - 1 + (y_ * world_->width)].locked and 
					items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].vipentrance and
					not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins and
					not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]))
				|| (//shadow_copy[x_ - 1 + (y_ * world_->width)].locked and
					items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].vipentrance and
					not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins and
					not world_->owner_name.empty() and
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					world_->owner_name != pInfo(p_)->tankIDName and
					not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]))) {
			}
			/*
			else if (shadow_copy[x_ - 1 + (y_ * world_->width)].locked and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)], 0x00800000) and shadow_copy[x_ - 1 + (y_ * world_->width)].owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and find(shadow_copy[x_ - 1 + (y_ * world_->width)].admins.begin(), shadow_copy[x_ - 1 + (y_ * world_->width)].admins.end(), pInfo(p_)->tankIDName) == shadow_copy[x_ - 1 + (y_ * world_->width)].admins.end()) {
			}
			*/
			/*
			else if (shadow_copy[x_ - 1 + (y_ * world_->width)].locked and
				items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance and
				is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)], 0x00800000) and
				not world_->open_to_public or !(is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)])
					and not block_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)], false, true))) {
			}
			*/
			else if ((items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)],
				0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not
				world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(),
					world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
				not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
				not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)])) ||
				(//shadow_copy[x_ - 1 + (y_ * world_->width)].locked and 
					items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)],
					0x00800000) and 
					//not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins and
					not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)])) ||
				(//shadow_copy[x_ - 1 + (y_ * world_->width)].locked and
					items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)],
						0x00800000) and
					//not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins and
					not world_->owner_name.empty() and
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					world_->owner_name != pInfo(p_)->tankIDName and
					not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]))) {
			}
			else if (items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)],
				0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ - 1 + (y_ * world_->width)].scanned) {
					shadow_copy[x_ - 1 + (y_ * world_->width)].scanned = true;
					new_tiles.push_back(x_ - 1 + (y_ * world_->width));
				}
			}
		} if (y_ < (world_->height - 1) and items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].collisionType != 1 or y_ < 59 and items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance or y_ < 59 and items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].toggleable) {
			if ((items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].vipentrance and not
				shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and world_->owner_name !=
				pInfo(p_)->tankIDName and not world_->owner_name.empty() and
				not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
				not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))
				|| (//shadow_copy[x_ + ((y_ + 1) * world_->width)].locked and 
					items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].vipentrance and
					not shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)])) ||
				(//shadow_copy[x_ + ((y_ + 1) * world_->width)].locked and
					items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].vipentrance and
					not shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and
					not world_->owner_name.empty() and 
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					world_->owner_name != pInfo(p_)->tankIDName and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))) {
			}
			/*
			else if (shadow_copy[x_ + ((y_ + 1) * world_->width)].locked and
				items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance and
				is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)], 0x00800000) and
				not world_->open_to_public or !(is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)])
					and not block_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)], false, true))) {
			}
			*/
			else if ((items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance and
				is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)], 0x00800000) and
				world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and
				not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and
				find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
				not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
				not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))
				||
				(//shadow_copy[x_ + ((y_ + 1) * world_->width)].locked and 
					items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance and 
					is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)],
					0x00800000) and 
					//not shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))
				|| (//shadow_copy[x_ + ((y_ + 1) * world_->width)].locked and
					items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance and
					is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)],
						0x00800000) and 
					//not shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and
					not world_->owner_name.empty() and
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					world_->owner_name != pInfo(p_)->tankIDName and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))) {
			}
			else if (items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + ((y_ + 1) * world_->width)].scanned) {
					shadow_copy[x_ + ((y_ + 1) * world_->width)].scanned = true;
					new_tiles.push_back(x_ + ((y_ + 1) * world_->width));
				}
			}
		} if (y_ > 0 and items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].collisionType != 1 or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * world_->width)].fg].entrance or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * world_->width)].fg].toggleable) {
			if ((items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].vipentrance and
				not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not
				world_->owner_name.empty() and not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
				not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)])) ||
				(//shadow_copy[x_ + ((y_ - 1) * world_->width)].locked and
					items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].vipentrance and
					not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)])) || 
				(//shadow_copy[x_ + ((y_ - 1) * world_->width)].locked and
					items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].vipentrance and
					not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and
					not world_->owner_name.empty() and
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					world_->owner_name != pInfo(p_)->tankIDName and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]))) {
			}
			else if ((items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].entrance and
				is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)], 0x00800000) and
				world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and
				not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and
				find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and 
				not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
				not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)])) ||
				(//shadow_copy[x_ + ((y_ - 1) * world_->width)].locked and
					items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)],
						0x00800000) and 
					//not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)])) ||
				(//shadow_copy[x_ + ((y_ - 1) * world_->width)].locked and
					items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)],
						0x00800000) and 
					//not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and
					not world_->owner_name.empty() and
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					world_->owner_name != pInfo(p_)->tankIDName and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]))) {
			}
			else if (items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + ((y_ - 1) * world_->width)].scanned) {
					shadow_copy[x_ + ((y_ - 1) * world_->width)].scanned = true;
					new_tiles.push_back(x_ + ((y_ - 1) * world_->width));
				}
			}
		}
	}
	return true;
}

bool ar_turi_noclipa2(World* world_, int x = -1, int y = -1, int fg = -1, ENetPeer* p_ = NULL) {
	//if (world_->blocks[fg].fg == 8676) return false;
	if (fg == -1 or x == -1 or y == -1 or p_ == NULL or world_ == nullptr) return true;
	if (x < 0 || x > world_->width * 32 || y < 0 || y > world_->height * 32) return true;
	if (world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg < 0 or world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg > items.size()) return true;
	vector<int> new_tiles{};
	if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].collisionType != 1 or items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance or items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].toggleable or items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance) {
		if ((items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance and
			not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and
			world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty()
			and not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
			not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]))
			|| (//world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].locked and 
				items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance and
				not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and
				not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
				not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)])) ||
			(//world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].locked and
				items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].vipentrance and
				not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and
				not world_->owner_name.empty() and
				find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
				world_->owner_name != pInfo(p_)->tankIDName and
				not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
				not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]))) {

		}
		else if ((items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance and
			is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00800000)
			and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and
			not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(),
				world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
			not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
			not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)])) ||
			(//world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].locked and 
				items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance and
				//not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and 
				is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00800000) and
				not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
				not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)])) ||
			(//world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].locked and
				items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].entrance and
				//not world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].limit_admins and
				is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00800000) and
				not world_->owner_name.empty() and
				find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
				world_->owner_name != pInfo(p_)->tankIDName and
				not is_block_owner(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]) and
				not has_access(p_, world_, &world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)]))) {
		}
		else if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)].fg].toggleable and is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * world_->width)], 0x00400000)) {
		}
		else {
			new_tiles.push_back((int)x / 32 + ((int)y / 32 * world_->width));
		}
	}
	if (new_tiles.size() <= 0) {
		new_tiles.clear();
		return true;
	}
	else {
		int ySize = world_->blocks.size() / world_->width, xSize = world_->blocks.size() / ySize;
		vector<WorldBlock> shadow_copy = world_->blocks;
		for (int i2 = 0; i2 < new_tiles.size(); i2++) {
			int x_ = new_tiles[i2] % world_->width, y_ = new_tiles[i2] / world_->width;
			if (x_ < -1 or y_ < -1 or x_ > world_->width or y_ > (world_->height - 1)) return true;
			if (&world_->blocks[x_ + (y_ * world_->width)] == &world_->blocks[fg] and items[shadow_copy[x_ + (y_ * world_->width)].fg].collisionType != 1) {
				return false;
			}
			if (x_ < 99 and items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].collisionType != 1 or x_ < 99 and items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance or x_ < 99 and items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].toggleable) {
				if ((items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].vipentrance and not
					shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and
					not world_->owner_name.empty() and not
					is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)], false) and
					not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)])) ||
					(//shadow_copy[x_ + 1 + (y_ * world_->width)].locked and
						items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].vipentrance and
						not shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and
						not is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)], false) and
						not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)])) ||
					(//shadow_copy[x_ + 1 + (y_ * world_->width)].locked and
						items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].vipentrance and
						not shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and
						not world_->owner_name.empty() and
						find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
						world_->owner_name != pInfo(p_)->tankIDName and
						not is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)], false) and
						not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]))) {

				}
				else if ((items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)],
					0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not
					world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(),
						world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and not
					is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)], false) and
					not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]))
					||
					(//shadow_copy[x_ + 1 + (y_ * world_->width)].locked and 
						items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)],
							0x00800000) and
						//not shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and
						not is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]))
					||
					(//shadow_copy[x_ + 1 + (y_ * world_->width)].locked and
						items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)],
							0x00800000) and
						//not shadow_copy[x_ + 1 + (y_ * world_->width)].limit_admins and
						not world_->owner_name.empty() and
						find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
						world_->owner_name != pInfo(p_)->tankIDName and
						not is_block_owner(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + 1 + (y_ * world_->width)]))) {
				}
				else if (items[shadow_copy[x_ + 1 + (y_ * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ + 1 + (y_ * world_->width)], 0x00400000)) {
				}
				else {
					if (not shadow_copy[x_ + 1 + (y_ * world_->width)].scanned) {
						shadow_copy[x_ + 1 + (y_ * world_->width)].scanned = true;
						new_tiles.push_back(x_ + 1 + (y_ * world_->width));
					}
				}
			} if (x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].collisionType != 1 or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].toggleable) {
				if ((items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].vipentrance and not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins
					and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and
					not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]))
					|| (//shadow_copy[x_ - 1 + (y_ * world_->width)].locked and 
						items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].vipentrance and
						not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins and
						not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]))
					|| (//shadow_copy[x_ - 1 + (y_ * world_->width)].locked and
						items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].vipentrance and
						not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins and
						not world_->owner_name.empty() and
						find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
						world_->owner_name != pInfo(p_)->tankIDName and
						not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]))) {

				}
				else if ((items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)],
					0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not
					world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(),
						world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)])) ||
					(//shadow_copy[x_ - 1 + (y_ * world_->width)].locked and 
						items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)],
							0x00800000) and
						//not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins and
						not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)])) ||
					(//shadow_copy[x_ - 1 + (y_ * world_->width)].locked and
						items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)],
							0x00800000) and
						//not shadow_copy[x_ - 1 + (y_ * world_->width)].limit_admins and
						not world_->owner_name.empty() and
						find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
						world_->owner_name != pInfo(p_)->tankIDName and
						not is_block_owner(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ - 1 + (y_ * world_->width)]))) {
				}
				else if (items[shadow_copy[x_ - 1 + (y_ * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ - 1 + (y_ * world_->width)], 0x00400000)) {
				}
				else {
					if (not shadow_copy[x_ - 1 + (y_ * world_->width)].scanned) {
						shadow_copy[x_ - 1 + (y_ * world_->width)].scanned = true;
						new_tiles.push_back(x_ - 1 + (y_ * world_->width));
					}
				}
			} if (y_ < 59 and items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].collisionType != 1 or y_ < 59 and items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance or y_ < 59 and items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].toggleable) {
				if ((items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].vipentrance and not
					shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and world_->owner_name !=
					pInfo(p_)->tankIDName and not world_->owner_name.empty() and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))
					|| (//shadow_copy[x_ + ((y_ + 1) * world_->width)].locked and 
						items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].vipentrance and
						not shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and
						not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)])) ||
					(//shadow_copy[x_ + ((y_ + 1) * world_->width)].locked and
						items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].vipentrance and
						not shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and
						not world_->owner_name.empty() and
						find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
						world_->owner_name != pInfo(p_)->tankIDName and
						not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))) {

				}
				else if ((items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance and
					is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)], 0x00800000) and
					world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and
					not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))
					||
					(//shadow_copy[x_ + ((y_ + 1) * world_->width)].locked and 
						items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance and
						is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)],
							0x00800000) and
						//not shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and
						not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))
					|| (//shadow_copy[x_ + ((y_ + 1) * world_->width)].locked and
						items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].entrance and
						is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)],
							0x00800000) and
						//not shadow_copy[x_ + ((y_ + 1) * world_->width)].limit_admins and
						not world_->owner_name.empty() and
						find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
						world_->owner_name != pInfo(p_)->tankIDName and
						not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + ((y_ + 1) * world_->width)]))) {
				}
				else if (items[shadow_copy[x_ + ((y_ + 1) * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ + 1) * world_->width)], 0x00400000)) {
				}
				else {
					if (not shadow_copy[x_ + ((y_ + 1) * world_->width)].scanned) {
						shadow_copy[x_ + ((y_ + 1) * world_->width)].scanned = true;
						new_tiles.push_back(x_ + ((y_ + 1) * world_->width));
					}
				}
			} if (y_ > 0 and items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].collisionType != 1 or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * world_->width)].fg].entrance or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * world_->width)].fg].toggleable) {
				if ((items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].vipentrance and
					not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not
					world_->owner_name.empty() and not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)])) ||
					(//shadow_copy[x_ + ((y_ - 1) * world_->width)].locked and
						items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].vipentrance and
						not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and
						not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)])) ||
					(//shadow_copy[x_ + ((y_ - 1) * world_->width)].locked and
						items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].vipentrance and
						not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and
						not world_->owner_name.empty() and
						find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
						world_->owner_name != pInfo(p_)->tankIDName and
						not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]))) {

				}
				else if ((items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].entrance and
					is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)], 0x00800000) and
					world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and
					not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and
					find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
					not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
					not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)])) ||
					(//shadow_copy[x_ + ((y_ - 1) * world_->width)].locked and
						items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)],
							0x00800000) and
						//not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and
						not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)])) ||
					(//shadow_copy[x_ + ((y_ - 1) * world_->width)].locked and
						items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].entrance and is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)],
							0x00800000) and
						//not shadow_copy[x_ + ((y_ - 1) * world_->width)].limit_admins and
						not world_->owner_name.empty() and
						find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->uid) == world_->admins.end() and
						world_->owner_name != pInfo(p_)->tankIDName and
						not is_block_owner(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]) and
						not has_access(p_, world_, &shadow_copy[x_ + ((y_ - 1) * world_->width)]))) {
				}
				else if (items[shadow_copy[x_ + ((y_ - 1) * world_->width)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ - 1) * world_->width)], 0x00400000)) {
				}
				else {
					if (not shadow_copy[x_ + ((y_ - 1) * world_->width)].scanned) {
						shadow_copy[x_ + ((y_ - 1) * world_->width)].scanned = true;
						new_tiles.push_back(x_ + ((y_ - 1) * world_->width));
					}
				}
			}
		}
		new_tiles.clear();
		shadow_copy.clear();
		return true;
	}
}

void add_playmod(ENetPeer* peer, int id, int time_ = -1) {
	PlayMods mod;
	mod.id = id;
	mod.time = time(nullptr) + (time_ == -1 ? atoi(explode("_", info_about_playmods[id].consumableid_time)[1].c_str()) : time_);
	mod.user = pInfo(peer)->tankIDName;
	pInfo(peer)->playmods.push_back(mod);

	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert(info_about_playmods[id].onUsed + " (`$" + info_about_playmods[id].name + "`` mod added, `$" + Algorithm::to_playmod_time(time_ != -1 ? time_ : atoi(explode("_", info_about_playmods[id].consumableid_time)[1].c_str())) + "``left)");
	p.CreatePacket(peer);
	update_clothes(peer);
}

bool edit_tile(ENetPeer* peer, int x_, int y_, int p_, bool mag_place = false) {
	if (items[p_].blocked_place) return false;
	string name_ = pInfo(peer)->world;
	if (pInfo(peer)->lastwrenchx != x_ || pInfo(peer)->lastwrenchy != y_) pInfo(peer)->random_fossil = rand() % 3 + 4;
	pInfo(peer)->lastwrenchx = x_;
	pInfo(peer)->lastwrenchy = y_;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (x_ < 0 or x_ >= world_->width or y_ < 0 or y_ >= world_->height or p_ < 0 or p_ >= items.size()) return false;
		WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
		if (block_->bg >= items.size()) block_->bg = 0;
		uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
		if (p_ == 3002 and t_ != 3004) return false;
		switch (p_) {
		case 18:
		{
			if (pInfo(peer)->hideseek.InGame && pInfo(peer)->hideseek.Seekers) {
				ENetPeer* target = get_clicked_on(world_, x_, y_);

				if (target != nullptr && pInfo(target)->hideseek.InGame) {
					if (pInfo(target)->hideseek.Hiders && pInfo(peer)->hideseek.Seekers && global::algorithm::hideseek.GameStarted) {
						pInfo(target)->hideseek.Hiders = false;
						pInfo(target)->hideseek.InGame = false;
						pInfo(target)->hideseek.Seekers = false;

						if (pInfo(target)->world != "EXIT") global::algorithm::hideseek.Hiders--;

						exit_(target);

						std::string message = global::algorithm::hideseek.Hiders >= 1 ? "`oThere's `w" + setGems(global::algorithm::hideseek.Hiders) + " `oothers more hiders!" : "`oThere's no more `whiders `oanymore!";

						enet_peer_send(peer, 0, Variant{ "OnConsoleMessage" }.push("`oYou just caught the `2Hiders `ogood job. " + message).pack());
						enet_peer_send(target, 0, Variant{ "OnConsoleMessage" }.push("`oYou've been caughted by the `2Seekers`o. Try again with the luckiest one!").pack());

						if (global::algorithm::hideseek.Hiders <= 0) {
							global::algorithm::hideseek.SeekersWon = true;
							global::algorithm::hideseek.Timers = 0;

							pInfo(peer)->hideseek.Hiders = 0;
							pInfo(peer)->hideseek.Seekers = 0;
						}
						else {
							player::algorithm::loop_world(pInfo(peer)->world, [&](ENetPeer* currentPeer) {
								if (currentPeer != nullptr && pInfo(currentPeer)->hideseek.InGame) {
									enet_peer_send(currentPeer, 0, Variant{ "OnConsoleMessage" }.push(std::format("`1HIDE-SEEK: `w{} `ohas been caught! [`w{}/{} `opeople hiders left]", pInfo(target)->tankIDName, setGems(global::algorithm::hideseek.Hiders), setGems(global::algorithm::hideseek.Players - 1))).pack());
								}
								});
						}
					}
				}
			}
			if (pInfo(peer)->hand == 3066) {
				if (block_->flags & 0x10000000) {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						packet_(currentPeer, "action|play_sfx\nfile|audio/burn.wav\ndelayMS|0");
					}
					pInfo(peer)->fires++;
					if (pInfo(peer)->fires >= 100) {
						pInfo(peer)->fires = 0;
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("I'm so good at fighting fires, I rescued this `2Highly Combustible Box``!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						PlayerMoving data_{};
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data_.packetType = 19, data_.plantingTree = 500;
						data_.punchX = 3090, data_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						memcpy(raw + 8, &to_netid, 4);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == pInfo(peer)->world) send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
						int give_ = 1;
						if (modify_inventory(peer, 3090, give_) == 0) {
						}
						else {
							WorldDrop drop_block_{};
							drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17, drop_block_.id = 3090, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
							dropas_(world_, drop_block_);
						}
					}
					block_->flags ^= 0x10000000;
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					int alloc = alloc_(world_, block_);
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw, blc;
					if (block_->locked) upd_lock(*block_, *world_, peer);
				}
				if (t_ != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(""), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					break;
				}
			}
			if (t_ == 0) {
				break;
			}
			if (items[t_].properties & Property_Mod and not pInfo(peer)->admin and items[t_].blockType != BEDROCK and t_ != 12258) {
				packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert(items[t_].blockType == BlockTypes::MAIN_DOOR ? "(stand over and punch to use)" : "It's too strong to break.");
				p.Insert(0);
				p.Insert(1);
				p.CreatePacket(peer);
				break;
			}
			else if (items[t_].blockType == BEDROCK and not pInfo(peer)->supermod) {
				packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("It's too strong to break.");
				p.Insert(0);
				p.Insert(1);
				p.CreatePacket(peer);
				break;
			}
			else if (t_ == 3470) { // cutting board
				if (pInfo(peer)->hand == 3466 || pInfo(peer)->hand == 4506) {
					WorldDrop drop_block_{};
					drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					PlayerMoving data_{};
					data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0;
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == world_->drop[i_].x / 32 && y_ == world_->drop[i_].y / 32) {
							if (items[world_->drop[i_].id].blockType == BlockTypes::FISH || world_->drop[i_].id == 866 || world_->drop[i_].id == 872 || world_->drop[i_].id == 7050) {
								if (world_->drop[i_].id == 3032 && world_->drop[i_].count == 90 && rand() % 100 < 5) {
									drop_block_.id = 5486, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
									dropas_(world_, drop_block_);
								}
								else if (world_->drop[i_].id == 5450 && world_->drop[i_].count == 50 && rand() % 100 < 10) {
									drop_block_.id = 6806, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
									dropas_(world_, drop_block_);
								}
								data_.plantingTree = world_->drop[i_].uid;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
								if (items[world_->drop[i_].id].blockType == BlockTypes::FISH && world_->drop[i_].count < 10 && rand() % 100 < 40) {
									PlayerMoving data_{};
									data_.packetType = 17, data_.netID = 45, data_.YSpeed = 45, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
									BYTE* raw = packPlayerMoving(&data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
									world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
									break;
								}
								int drop_count = 1;
								if (items[world_->drop[i_].id].blockType == BlockTypes::FISH && world_->drop[i_].count >= 10) drop_count = world_->drop[i_].count / 10;
								if (world_->drop[i_].id == 866 || world_->drop[i_].id == 872 || world_->drop[i_].id == 7050) drop_count = world_->drop[i_].count;
								drop_block_.id = world_->drop[i_].id == 866 ? 4578 : world_->drop[i_].id == 872 ? 4588 : world_->drop[i_].id == 7050 ? 7052 : 3468, drop_block_.count = drop_count, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
								dropas_(world_, drop_block_);
								world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
							}
						}
					}
				}
			}
			else if (t_ == 758 || t_ == 756) {
				if (pInfo(peer)->i758 + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
					pInfo(peer)->i758 = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					int get37 = 0;
					string wheel = "";
					string reme = "";
					string qeme = "";
					gamepacket_t p(2000), p2(2000), p3(2000);
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					p2.Insert("OnConsoleMessage");
					PlayerMoving data_{};
					BYTE* raw = packPlayerMoving(&data_);
					if (t_ == 758) {
						get37 = rand() % 37;
						
						string color = "";
						int get37 = rand() % 37;
						int numReme, rNumReme, num1, num2;
						num1 = get37 / 10;
						num2 = get37 % 10;
						numReme = num1 + num2;
						if (numReme == 10) {
							rNumReme = 0;
						}
						else {
							rNumReme = numReme;
						}
						int qemeValue = get37 % 10;

						if (pInfo(peer)->reme_spin) {
							reme = "`9Reme: " + to_string(rNumReme) + " ";
						}

						if (pInfo(peer)->qeme_spin) {
							qeme = "`6Qeme: " + to_string(qemeValue) + " ";
						}
						if (pInfo(peer)->csn != -1 && pInfo(peer)->csn < 37) get37 = pInfo(peer)->csn;
						if (get37 == 999 || get37 == 37 || get37 == 36 || get37 == 34 || get37 == 32 || get37 == 27 || get37 == 25 || get37 == 23 || get37 == 18 || get37 == 16 || get37 == 9 || get37 == 7 || get37 == 5) color = "`4";
						else if (get37 == 0 || get37 == 28 || get37 == 19) color = "`2";
						else if (get37 == 1 || get37 == 10 || get37 == 2 || get37 == 20 || get37 == 21 || get37 == 3 || get37 == 30 || get37 == 12 || get37 == 11 || get37 == 29) color = "`8";
						else color = "`b";
						wheel = "`7[``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` spun the wheel and got " + color + to_string(get37) + "``! ";
						if (pInfo(peer)->reme_spin) {
							wheel += reme;
						}
						if (pInfo(peer)->qeme_spin) {
							wheel += qeme;
						}
						wheel += "`7] `2[REAL SPIN]``";
					}
					else {
						get37 = rand() % 10;
						if (get37 == 1) data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
						wheel = "`7[``" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` " + (get37 == 1 ? "`2wins at slots!`" : "`4loses at slots.`") + "``7]``";
						p3.Insert("OnPlayPositioned");
						p3.Insert(get37 == 1 ? "audio/slot_win.wav" : "audio/slot_lose.wav");
					}
					p.Insert(wheel);
					p.Insert(0), p.Insert(0);
					p2.Insert(wheel);
					p2.Insert(reme);
					p2.Insert(qeme);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							if (pInfo(peer)->csn != -1) pInfo(peer)->csn = -1;
							p.CreatePacket(currentPeer);
							p2.CreatePacket(currentPeer);
							if (t_ == 756) {
								p3.CreatePacket(currentPeer);
								if (get37 == 1) send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
					}
					if (get37 == 1) delete[] raw;
					punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 0x0);
				}
			}

			else if (t_ == 1482 || t_ == 2252 || t_ == 7864 || t_ == 11434) {
				struct tm newtime;
				time_t now = time(0);
				localtime_s(&newtime, &now);
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("It's " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min) + "") + " " + (newtime.tm_hour >= 12 ? "PM" : "AM") + " on " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + "");
				p.Insert(0);
				p.Insert(1);
				p.CreatePacket(peer);
			}
			if (items[t_].toggleable or items[t_].blockType == BlockTypes::CHEMICAL_COMBINER) {
				if (block_->flags & 0x00800000 or world_->owner_name == pInfo(peer)->tankIDName or guild_access(peer, world_->guild_id) or find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) != world_->admins.end() or world_->open_to_public or pInfo(peer)->admin) {
					if (block_->fg == 1908) {
						if ((carnival[1].player_ != pInfo(peer)->tankIDName and carnival[2].player_ != pInfo(peer)->tankIDName)) {
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							if (not pInfo(peer)->invis) {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										p.CreatePacket(currentPeer);
									}
								}
							}
							else {
								p.CreatePacket(peer);
							}
							return true;
						}
						else if ((carnival[1].player_ == pInfo(peer)->tankIDName or carnival[2].player_ == pInfo(peer)->tankIDName)) {
							if (block_->flags & 0x00400000) {
								block_->flags = (block_->flags & 0x00400000 ? block_->flags ^ 0x00400000 : block_->flags | 0x00400000);
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, peer, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
								if (block_->locked) {
									upd_lock(*block_, *world_, peer);
								}
								if (block_->fg == 1908 and pInfo(peer)->world == "CARNIVAL") {
									gamepacket_t p2(0, pInfo(peer)->netID);
									p2.Insert("OnCountdownStart");
									long long int time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									if (carnival[1].player_ == pInfo(peer)->tankIDName) {
										int s_ = (carnival[1].when_ + carnival[1].until_ - time) / 1000;
										if (carnival[1].punch_c == 0) break;
										carnival[1].punch_c -= 1, carnival[1].score_ += 1;
										p2.Insert(s_), p2.Insert(carnival[1].score_);
										p2.CreatePacket(peer);
									}
									if (carnival[2].player_ == pInfo(peer)->tankIDName) {
										int s_ = (carnival[2].when_ + carnival[2].until_ - time) / 1000;
										if (carnival[2].punch_c == 0) break;
										carnival[2].punch_c -= 1, carnival[2].score_ += 1;
										p2.Insert(s_), p2.Insert(carnival[2].score_);
										p2.CreatePacket(peer);
									}
								}
							}
							else {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
								return true;
							}
						}
					}
					else {
						block_->flags = (block_->flags & 0x00400000 ? block_->flags ^ 0x00400000 : block_->flags | 0x00400000);
					}
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					if (t_ == 226) {
						if (block_->flags & 0x00400000) p.Insert("Signal jammer enabled. This world is now `4hidden`` from the universe.");
						else p.Insert("Signal jammer disabled. This world is `2visible`` to the universe.");
					}
					if (t_ == 4992) {
						if (block_->flags & 0x00400000) p.Insert("`3Antigravity was enabled.``");
						else p.Insert("`4Antigravity was disabled.``");
					}
					if (t_ == 4992 || t_ == 226) p.CreatePacket(peer);
					if (t_ == 226 or t_ == 3616 or t_ == 1276 or t_ == 1278 or t_ == 4758 or t_ == 3750 or t_ == 4992 or t_ == 3072 or t_ == 4884) {
						if (block_->flags & 0x00400000) world_->active_jammers.push_back(t_);
						else world_->active_jammers.erase(remove(world_->active_jammers.begin(), world_->active_jammers.end(), t_), world_->active_jammers.end());
					}
				}
			}
			// nuo cia non access negales nieko padaryt:
			if (items[t_].toggleable) {
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (block_->flags & 0x00800000 and not world_->owner_name.empty() and owner_name != user_name and !guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end() and not pInfo(peer)->dev) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnPlayPositioned");
					p.Insert("audio/punch_locked.wav");
					if (not pInfo(peer)->invis) {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								p.CreatePacket(currentPeer);
							}
						}
					}
					else {
						p.CreatePacket(peer);
					}
					punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 16);
					return true;
				}
			}
			if (items[t_].properties & Property_Public) { /*cout << "public block break" << endl;*/ }
			else {
				if (block_access(peer, world_, block_) and block_->fg == 3918 || block_->fg == 3922 || block_->fg == 3928) {
					if (block_access(peer, world_, block_)) {
						if (pInfo(peer)->hand == 3932) {
							pInfo(peer)->random_fossil -= 1;
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							bool broken_fossil = false;
							if (pInfo(peer)->random_fossil < 0 or block_->fossil) {
								pInfo(peer)->random_fossil = rand() % 3 + 4;
								p.Insert("`4I smashed a Fossil!``");
								block_->flags = 0;
								block_->fossil = false;
								block_->fg = 10;
								update_tile(peer, x_, y_, 10, false, true);
							}
							else {
								if (pInfo(peer)->random_fossil == 0) {
									block_->fossil = true;
									p.Insert("`2I unearthed a Fossil!`` I better be careful getting it out...");
									PlayerMoving data_{};
									block_->flags = 4194304;
									int alloc = alloc_(world_, block_);
									data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
									BYTE* blc = raw + 56;

									form_visual(blc, *block_, *world_, peer, false, true);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw, blc;
								}
							}
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
					}
				}
				
				else if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
					block_->owner_name = GetNameByUid(block_->owner_id);
					if (block_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev) {
						if (items[t_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							string owner_name = block_->owner_name;
							if (world_->owner_named != "") {
								if (world_->owner_named.substr(0, 2) == "`o") owner_name = "`w" + world_->owner_name;
								else owner_name = world_->owner_named;
							}
							if (owner_name == "") owner_name = "`w" + world_->owner_name;
							if (block_->open_to_public)
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wOpen to public``)");
							else if (find(block_->admins.begin(), block_->admins.end(), pInfo(peer)->uid) != block_->admins.end())
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wAccess granted``)");
							else
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`4No access``)");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
							if (not pInfo(peer)->dev) {
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
								}
								return true;
							}
						}
					}
				}
				else if (block_->locked) {
					WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
					string owner_name = block2_->owner_name, user_name = pInfo(peer)->tankIDName;
					if (owner_name != user_name and not pInfo(peer)->dev) {
						if (block2_->fg == 4994 or not block2_->open_to_public and find(block2_->admins.begin(), block2_->admins.end(), pInfo(peer)->uid) == block2_->admins.end()) {
							if (block2_->fg == 4994) {
								if (not block2_->open_to_public) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
									return true;
								}
								if (block2_->build_only and block2_->open_to_public) {
									if (not pInfo(peer)->dev) {
										gamepacket_t p(0, pInfo(peer)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/punch_locked.wav");
										if (not pInfo(peer)->invis) {
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == name_) {
													p.CreatePacket(currentPeer);
												}
											}
										}
										else {
											p.CreatePacket(peer);
										}
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("This lock allows building only!");
											p.Insert(0);
											p.Insert(1);
											p.CreatePacket(peer);
										}
										return true;
									}
								}
							}
							else {
								if (not pInfo(peer)->dev) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
									return true;
								}
							}
						}
					}
				}
				else if (not world_->owner_name.empty()) {
					string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
					if (owner_name != user_name and not pInfo(peer)->dev) {
						if (items[t_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							string owner_name = "";
							if (world_->owner_named.substr(0, 2) == "`o") owner_name = "`w" + world_->owner_name;
							else owner_name = world_->owner_named;
							if (owner_name == "") owner_name = "`w" + world_->owner_name;
							string verifSince = (world_->verified ? "`0[`^Verified Since: " + world_->verifiedTime + "`0]" : "");
							if (world_->open_to_public)
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wOpen to public``)\n" + verifSince);
							else if (guild_access(peer, world_->guild_id) or find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) != world_->admins.end())
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wAccess granted``)\n" + verifSince);
							else
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`4No access``)\n" + verifSince);
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
							{
								if (not pInfo(peer)->dev)
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
								}
								return true;
							}
						}
						if (not world_->open_to_public and !guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end()) {
							if (not pInfo(peer)->dev) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
								return true;
							}
						}
					}
				}
				if (world_->owner_name != pInfo(peer)->tankIDName) {
					if (items[t_].magplant) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Only the `9World Owner`` can activate this!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
			}
			if (items[t_].magplant) {
				switch (t_) {
				case 6950: case 6952:
				{
					if (block_->id != 0) {
						block_->enabled = (block_->enabled ? false : true);
						for (int i_ = 0; i_ < world_->machines.size(); i_++) {
							WorldMachines* machine_ = &world_->machines[i_];
							if (machine_->x == x_ and machine_->y == y_) {
								machine_->enabled = block_->enabled;
								break;
							}
						}
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					break;
				}
				}
			}
			if (items[t_].blockType == BlockTypes::CHEMICAL_COMBINER) {
				if (block_->flags & 0x00400000) {
				}
				else {
					vector<vector<int>> comb;
					bool combined = false;
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32)) {
							comb.push_back({ world_->drop[i_].id, world_->drop[i_].count });
						}
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					if (comb.size() < 3) p.Insert("I need 3 ingredients!");
					if (comb.size() > 3) p.Insert("It won't mix more than 3 items at once!");
					if (comb.size() == 3) {
						for (vector<vector<int>>recipe : receptai) {
							uint32_t result_item_id = recipe[3][0];
							uint32_t result_gives_per_recipe = recipe[3][1];
							vector<int> compare1, compare2;
							vector<vector<vector<int>>> info{ {}, {} };
							for (int i_ = 0; i_ < 3; i_++) {
								compare1.push_back(recipe[i_][0]);
								info[0].push_back({ recipe[i_][0], recipe[i_][1] });
							} for (vector<int>item_id : comb) {
								compare2.push_back(item_id[0]);
								info[1].push_back({ item_id[0], item_id[1] });
							} sort(compare1.begin(), compare1.end()), sort(compare2.begin(), compare2.end());
							if (compare1 == compare2) {
								sort(info[0].begin(), info[0].end()), sort(info[1].begin(), info[1].end());
								bool no = false;
								for (int i_ = 0; i_ < info[0].size(); i_++) {
									if (info[0][i_][1] > info[1][i_][1]) {
										no = true;
										break;
									}
								} if (no) break;
								uint32_t result_item_count = 0;
								uint32_t times_ = 0;
								for (int i_ = 0; i_ < world_->drop.size(); i_++) {
									if (no) break;
									if (world_->drop[i_].id == 0) continue;
									if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32)) {
										for (int i_2 = 0; i_2 < info[0].size(); i_2++) {
											if (info[0][i_2][0] == world_->drop[i_].id) {
												if (info[0][i_2][1] > info[1][i_2][1]) {
													break;
												}
												world_->drop[i_].count -= info[0][i_2][1];
												info[1][i_2][1] = world_->drop[i_].count;
												times_++;
												if (world_->drop[i_].count <= 0) {
													PlayerMoving data_{};
													data_.packetType = 14, data_.netID = -2, data_.plantingTree = world_->drop[i_].uid;
													BYTE* raw = packPlayerMoving(&data_);
													int32_t item = -1;
													memcpy(raw + 8, &item, 4);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == name_) {
															send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
														}
													}
													world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
													delete[] raw;
												}
												else {
													PlayerMoving data_{};
													data_.packetType = 14, data_.netID = -2, data_.plantingTree = world_->drop[i_].uid;
													BYTE* raw = packPlayerMoving(&data_);
													int32_t item = -1;
													memcpy(raw + 8, &item, 4);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == name_) {
															send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
														}
													}
													delete[] raw;
													WorldDrop drop_{};
													drop_.id = world_->drop[i_].id;
													drop_.count = world_->drop[i_].count;
													drop_.uid = uint16_t(world_->drop.size()) + 1;
													drop_.x = world_->drop[i_].x;
													drop_.y = world_->drop[i_].y;
													world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
													dropas_(world_, drop_);
												} if (times_ == 3) {
													times_ = 0;
													result_item_count += result_gives_per_recipe;
													for (int i_ = 0; i_ < info[0].size(); i_++) {
														if (info[0][i_][1] > info[1][i_][1]) {
															no = true;
															break;
														}
													}
												}
												break;
											}
										}
									}
								} if (result_item_count != 0) {
									combined = true;
									WorldDrop drop_block_{};
									drop_block_.id = result_item_id, drop_block_.count = result_item_count, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
									dropas_(world_, drop_block_);
									PlayerMoving data_{};
									data_.packetType = 17, data_.netID = 44, data_.YSpeed = 44, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
									BYTE* raw = packPlayerMoving(&data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]raw;
									p.Insert("SCIENCE!");
								}
								break;
							}
						}
					}
					if (not combined) p.Insert("Those items don't seem to combine!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
			}
			if (items[t_].blockType == BlockTypes::WEATHER) {
				int weather_id_ = (t_ != 5958 ? items.at(t_).base_weather : get_epoch_weather(*block_));
				long long current_time = time(nullptr);
				if (block_->last_punch_weather - current_time <= 0) {
					world_->weather = (weather_id_ != world_->weather ? weather_id_ : 0);
					block_->enabled = (world_->weather != 0 ? true : false);
					block_->last_punch_weather = current_time + 1.5;
					if (t_ == 5958) {
						if (block_->flags & 0x00400000) {
							block_->flags ^= 0x00400000;
						}
						else {
							block_->flags |= 0x00400000;
							block_->epoch_cycle = time(nullptr) + (block_->epoch_state.second * 60);
						}
					}
					if (world_->weather == 0) {
						if (pInfo(peer)->lock == 11550) world_->weather = 54;
						if (pInfo(peer)->lock == 11586) world_->weather = 55;
						if (pInfo(peer)->lock == 10410) world_->weather = 53;
						world_->weather = world_->d_weather;
					}
					gamepacket_t p;
					p.Insert("OnSetCurrentWeather");
					p.Insert(world_->weather == 0 ? 4 : world_->weather);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							p.CreatePacket(currentPeer);
						}
					}
				}
				if (t_ != 5958) {
					for (int i = 0; i < world_->blocks.size(); i++) {
						if (world_->blocks[i].fg == 5958 && world_->blocks[i].flags & 0x00400000) {
							world_->blocks[i].flags ^= 0x00400000;
							int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
							int x = i % xSize, y = i / xSize;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, &world_->blocks[i]));
							BYTE* blc = raw + 56;
							form_visual(blc, world_->blocks[i], *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(peer)->world) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, &world_->blocks[i]), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (world_->blocks[i].locked) {
								upd_lock(world_->blocks[i], *world_, peer);
							}
							i = world_->blocks.size();
						}
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, peer, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, peer);
				}
			}
			if (block_->fg == 5638) {
				if (pInfo(peer)->tankIDName == world_->owner_name or pInfo(peer)->admin or world_->owner_name.empty()) {
					long long current_time = time(nullptr);
					if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
						if (block_->id == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Cannot activate the " + items[block_->fg].name + ", you need to set the item first.");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Cannot activate the " + items[block_->fg].name + ", you need to set the item first.");
								p.CreatePacket(peer);
							}
						}
						else {
							if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and 
								items[block_->id].blockType != SEED and not(items[block_->id].farmable) and
								(items[block_->id].blockType != CONSUMABLE) and items[block_->id].rarity == 999) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Cannot activate the " + items[block_->fg].name + ", the current item cannot be placed."); // something to fix
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("Cannot activate the " + items[block_->fg].name + ", the current item cannot be placed.");
									p.CreatePacket(peer);
								}
							}
							else {
								if (not block_->magnetron) {
									block_->magnetron = true;
									if (pInfo(peer)->magnetron_x != 0 and pInfo(peer)->magnetron_y != 0 and pInfo(peer)->magnetron_x != x_ and pInfo(peer)->magnetron_x != y_) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You received a " + items[5640].name + ".");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You received a " + items[5640].name + ".");
											p.CreatePacket(peer);
										}
										{
											pInfo(peer)->magnetron_id = block_->id;
											pInfo(peer)->magnetron_x = x_;
											pInfo(peer)->magnetron_y = y_;
										}
									}
									else {
										int c_ = 0;
										modify_inventory(peer, 5640, c_);
										if (c_ == 0) {
											{
												int c_ = 1;
												if (modify_inventory(peer, 5640, c_) == 0) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(peer)->netID);
													p.Insert("You received a " + items[5640].name + ".");
													p.Insert(0), p.Insert(0);
													p.CreatePacket(peer);
													{
														gamepacket_t p;
														p.Insert("OnConsoleMessage");
														p.Insert("You received a " + items[5640].name + ".");
														p.CreatePacket(peer);
													}
													{
														pInfo(peer)->magnetron_id = block_->id;
														pInfo(peer)->magnetron_x = x_;
														pInfo(peer)->magnetron_y = y_;
													}
												}
											}
										}
									}
									gamepacket_t p;
									p.Insert("OnPlanterActivated");
									p.Insert(block_->id);
									p.Insert(x_);
									p.Insert(y_);
									p.CreatePacket(peer);
								}
								else {
									block_->magnetron = false;
									gamepacket_t p;
									p.Insert("OnPlanterActivated");
									p.Insert(0);
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(peer);
								}
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, peer, false);
								try {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											//cout << "raw 112 part 1" << endl;
											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
								}
								catch (out_of_range) {
									return false;
								}
								if (block_->locked) {
									upd_lock(*block_, *world_, peer);
								}
							}
						}
					}
				}
			}
			if (items[block_->fg].mannequin) {
				bool s = false;
				int c_ = 1;
				if (block_->mannequin.c_head != 0) {
					if (modify_inventory(peer, block_->mannequin.c_head, c_) == 0) {
						block_->mannequin.c_head = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_shirt != 0) {
					if (modify_inventory(peer, block_->mannequin.c_shirt, c_) == 0) {
						block_->mannequin.c_shirt = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_pants != 0) {
					if (modify_inventory(peer, block_->mannequin.c_pants, c_) == 0) {
						block_->mannequin.c_pants = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_feet != 0) {
					if (modify_inventory(peer, block_->mannequin.c_feet, c_) == 0) {
						block_->mannequin.c_feet = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_mask != 0) {
					if (modify_inventory(peer, block_->mannequin.c_mask, c_) == 0) {
						block_->mannequin.c_mask = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_hand != 0) {
					if (modify_inventory(peer, block_->mannequin.c_hand, c_) == 0) {
						block_->mannequin.c_hand = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_back != 0) {
					if (modify_inventory(peer, block_->mannequin.c_back, c_) == 0) {
						block_->mannequin.c_back = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_hair != 0) {
					if (modify_inventory(peer, block_->mannequin.c_hair, c_) == 0) {
						block_->mannequin.c_hair = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_neck != 0) {
					if (modify_inventory(peer, block_->mannequin.c_neck, c_) == 0) {
						block_->mannequin.c_neck = 0;
					}
					s = true;
				} if (s) {
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, peer);
					}
					return true;
				}
			}
			if (items[block_->fg].fossil_prep) {
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) break;
				if (block_->id != 0) {
					long long current_time = time(nullptr);
					if (block_->planted - current_time > 0) {
						if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("The fossil is not done yet!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					else {
						vector<int> random_id{3948, 3940, 3946, 3942, 3944, 10584, 4236, 10220, 11220, 6800, 4126, 3950};
						int id_got = random_id[rand() % random_id.size()];
						int c_ = 1;
						if (modify_inventory(peer, id_got, c_) == 0) {
							block_->id = 0, block_->planted = 0;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							PlayerMoving data_effect_{};
							data_effect_.packetType = 19;
							data_effect_.punchX = id_got;
							data_effect_.punchY = pInfo(peer)->netID;
							data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
							BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
							raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 5;
							try {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc, raw_effect;
							}
							catch (out_of_range) {
								return false;
							}
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert(format("The fossil turned out to be {} `2{}`w!``", id_got == 3948 || id_got == 3940 || id_got == 3946 || id_got == 4236 ? "an" : "a", items[id_got].name));
							p.CreatePacket(peer);
						}
						else {
							if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("No room to pick it up!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
							}
						}
					}
				}
			}
			if (items[block_->fg].charger) {
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) break;
				if (block_->id != 0) {
					long long current_time = time(nullptr);
					if (block_->planted - current_time > 0) {
						if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("That's not done charging!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					else {
						int c_ = 1;
						if (modify_inventory(peer, 2204, c_) == 0) {
							block_->id = 0, block_->planted = 0;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							PlayerMoving data_effect_{};
							data_effect_.packetType = 19;
							data_effect_.punchX = 2204;
							data_effect_.punchY = pInfo(peer)->netID;
							data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
							BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
							raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 5;
							try {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										//cout << "raw 112 part 2" << endl;
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc, raw_effect;
							}
							catch (out_of_range) {
								return false;
							}
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
						}
						else {
							if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("No room to pick it up!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
							}
						}
					}
				}
			}
			if (t_ == 5814) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("You can't smash a " + items[t_].name + ", the only way to destroy it is to abandon the guild!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
				return true;
			}
			if (items[t_].blockType == BlockTypes::DISPLAY) {
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				if ((owner_name != user_name and not owner_name.empty() and not pInfo(peer)->dev) ||
					(block_->locked and not is_block_owner(peer, world_, block_) and not has_access(peer, world_, block_))) {
					if (block_->id != 0) {
						if (not pInfo(peer)->dev) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Only the block's owner can break it!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(peer);
							return true;
						}
					}
				}
				else {
					//if (pInfo(peer)->admin) writelogd(pInfo(peer)->tankIDName + " stole in (" + pInfo(peer)->world + ")" + items[t_].name);
					int c_ = 0;
					modify_inventory(peer, block_->id, c_);
					int slots_ = get_free_slots(pInfo(peer));
					if (c_ + 1 > 200 or c_ == 0 and slots_ == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("You don't have enough space in your backpack! Free some and try again.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						return true;
					}
				}
			}
			pInfo(peer)->punch_count++;
			long long time_ = time(nullptr);
			uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
			if (items[t_].blockType == BlockTypes::SEED and laikas == items[block_->fg].growTime) {
				if (t_ == 1791) {
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					world_->blocks[x_ + (y_) * world_->width].fg = 1790;
					update_tile(peer, x_, y_, 1790, false, true);
					return false;
				}
				add_role_xp(peer, 1, "farmer");
				if (pInfo(peer)->startedKit && pInfo(peer)->lvlKit < 50) add_role_xp(peer, rand() % 3, "kit");
				// QUEST HARVEST
				if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 2 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
					pInfo(peer)->C_QuestProgress += items[block_->fg].rarity;
					if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
						pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
				if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 15 && pInfo(peer)->quest_progress < 100000) {
					pInfo(peer)->quest_progress += items[block_->fg].rarity;
					if (pInfo(peer)->quest_progress >= 100000) {
						pInfo(peer)->quest_progress = 100000;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
				
				// DROP BLOCK FROM TREES
				int drop_count = items[block_->fg - 1].rarity == 1 ? (items[block_->fg - 1].farmable ? (rand() % 9) + 4 : (rand() % block_->fruit) + 1) : items[block_->fg - 1].farmable ? (rand() % block_->fruit + 1) + rand() % 6 : (rand() % block_->fruit + 1) + rand() % 4;
				if (thedaytoday == 1 and rand() % 50 < 1) drop_count++;
				if (pInfo(peer)->back == 1746 && pInfo(peer)->feet == 1830 || pInfo(peer)->feet == 1966) { // fuel pack
					if (items[block_->fg - 1].rarity < 300) {
						int c1746 = 1746, countofitem = 0, removepack = -1;
						modify_inventory(peer, c1746, countofitem);
						if (countofitem >= 1) {
							if (rand() % 100 < 10) { // real gt 10% chance
								modify_inventory(peer, c1746, removepack);
								drop_count *= 2; // real gt double drop count
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = pInfo(peer)->feet == 1966 ? 106 : 50, data_.YSpeed = pInfo(peer)->feet == 1966 ? 106 : 50, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
							}
						}
					}
				}
				if (rand() % 100 < 10 and pInfo(peer)->hand == 6840) {
					PlayerMoving data_{};
					data_.packetType = 36, data_.netID = 24, data_.YSpeed = 24, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					drop_count += rand() % 4 + 1;
				}
				if (pInfo(peer)->hand == 1068) {
					vector<int> list{ 5090, 3088, 5198 };
					if (rand() % 5 < 1) list = { 3086, 3074, 5200, 8910, 7034, 11248, 10132 };
					if (rand() % 200 + 1 < 2) list = { 12380, 12388, 12390 };
					int item = list[rand() % list.size()], got = 0;
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(items[item].hand_scythe_text), p.CreatePacket(peer);
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = item == 5198 ? 2 : 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					drop_count = 0;
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 50, data_.YSpeed = 50, data_.x = x_ * 32, data_.y = y_ * 32;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					int chance = 0;
					if (has_playmod(pInfo(peer), "Food: Purified Scythe")) chance = 5;
					if (rand() % 100 < (80 - chance)) modify_inventory(peer, 1068, got = -1);
				}
				if (harvest_seed(world_, block_, x_, y_, drop_count, pInfo(peer)->netID, peer)) {
					if (drop_count != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("A `w" + items[t_].name + "`` falls out!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
					}
				}
				else if (Harvest_Festival) {
					vector<int> mooncake_list = random_mooncake;
					int chance = 5000 - items[t_].rarity; 
					bool drop_rare = true;
					//int chance_ = rand() % (int)((2700) + sin(89) / cos(64) + items[t_].rarity);
					if (!items[t_ - 1].farmable)
						chance = 3000 - items[t_].rarity, drop_rare = false;
					mooncake_list.erase(remove(mooncake_list.begin(), mooncake_list.end(), 1828), mooncake_list.end()), mooncake_list.erase(remove(mooncake_list.begin(), mooncake_list.end(), 10140), mooncake_list.end());
					int chance_ = rand() % chance;
					if (drop_rare && chance_ <= ((pInfo(peer)->dateMasterB_title || pInfo(peer)->necklace == 10158 || pInfo(peer)->necklace == 8924) ? 1 : 3)) { mooncake_list = { 1828, 10140 }; }
					if (chance_ <= 20) {
						int item = mooncake_list[rand() % mooncake_list.size()];
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("A `w" + items[item].name + "`` falls out!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						WorldDrop drop_block_{};
						drop_block_.id = item, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = x_ * 32 + rand() % 17, drop_block_.y = y_ * 32 + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (world_->weather == 8 and rand() % 282 < 28) {
					WorldDrop drop_block_{};
					drop_block_.id = 3722, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = x_ * 32 + rand() % 17, drop_block_.y = y_ * 32 + rand() % 17;
					dropas_(world_, drop_block_);
					PlayerMoving data_2{};
					data_2.packetType = 0x11, data_2.x = drop_block_.x, data_2.y = drop_block_.y, data_2.YSpeed = 108;
					BYTE* raw2 = packPlayerMoving(&data_2);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
						send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw2;
				}
				if (drop_count != 0) drop_rare_item(world_, peer, t_ - 1, x_, y_, true);
				return true;
			}
			double increase_ = round((double)items[t_].breakHits / 6 / 6);
			int punch_modifier = ((has_playmod(pInfo(peer), "Dragoscarf") || (has_playmod(pInfo(peer), "Enhanced Digging") || (has_playmod(pInfo(peer), "Death To Blocks!") || (has_playmod(pInfo(peer), "Dragonborn") || (has_playmod(pInfo(peer), "punch damage") || (has_playmod(pInfo(peer), "diggin' it")) ? -increase_ : has_playmod(pInfo(peer), "cupid's firepower") ? increase_ : (has_playmod(pInfo(peer), "eye beam") ? increase_ : 0)))))));
			if (block_->hp == -1 or (items[t_].dropChance) < (time_ - block_->lp)) {
				int punch_ = items[t_].breakHits / 6 + punch_modifier;
				if (punch_ <= 2) punch_ = 3;
				else if (punch_ <= 3 and punch_modifier < 0) punch_ = 4;
				if (pInfo(peer)->hand == 2952) {
					if (t_ == 2 or t_ == 14) {
						punch_ = 1;
					}
				}
				if (pInfo(peer)->hand == 9882) {
					punch_ = 1;
					pInfo(peer)->punch_sword_time++;
					if (pInfo(peer)->punch_sword_time >= 200) {
						Algorithm::send_bubble(peer, pInfo(peer)->netID, "`4Oops, I have broke the sword.``");
						Algorithm::send_console(peer, "`4Oops, I have broke the sword.``");
						pInfo(peer)->punch_sword_time = 0;
						int c_ = -1;
						modify_inventory(peer, 9882, c_);
					}
				}
				if (pInfo(peer)->hand == 5172 || pInfo(peer)->hand == 5174 
					|| pInfo(peer)->hand == 8530 || pInfo(peer)->hand == 13828 || (pInfo(peer)->hand == 8532 && pInfo(peer)->void_ray_1hit)
					) 
					punch_ = 1;
				//if (pInfo(peer)->hair == 8372) punch_ = 1;
				//if (pInfo(peer)->hand == 9716) punch_ = 3;
				if (t_ == 1000 or t_ == 786) {
					punch_ = 1;
				}
				if (pInfo(peer)->hit2) {
					punch_ = 2;
				}
				if (pInfo(peer)->necklace == 9376) {
					if (t_ == 3564 or t_ == 3556 or t_ == 9380 or t_ == 9382) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 221, data_.YSpeed = 221, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
						punch_ = 1;
					}
				}
				if (pInfo(peer)->hit1 or pInfo(peer)->hand == 5196) {
					PlayerMoving data_{};
					data_.packetType = 36, data_.netID = 282, data_.YSpeed = 282, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					punch_ = 1;
				}
				{
					std::ifstream fileitem("./database/config/items.json");
					if (!fileitem.is_open()) {
						std::cerr << "Error opening file." << std::endl;
					}
					json jsonitem;
					fileitem >> jsonitem;
					fileitem.close();
					if (jsonitem.is_array()) {
						for (const auto& obj : jsonitem) {
							if (obj.is_object()) {
								if (obj.contains("ItemId") && obj.contains("BreakHit")) {
									int itemsid = obj["ItemId"];
									int farsg = obj["BreakHit"];
									if (pInfo(peer)->hand == itemsid) punch_ = farsg;
								}
							}
						}
					}
				}
				if (pInfo(peer)->hand == 3932 || pInfo(peer)->hand == 3934) punch_ += 7;
				if (pInfo(peer)->hand == 3932 && pInfo(peer)->hair == 590) punch_ += 20;
				block_->hp = punch_;
				block_->lp = time_;
			}
			block_->hp -= 1;
			if (block_->hp == 0) { /*isgriove*/
				//grow4good(peer, false, "break", 1);
				bool ignore_reset = false;
				if (items[t_].bunny_egg) {
					WorldDrop drop_block_{};
					uint32_t percentage = block_->bunny_egg_progress / 10;
					if (percentage <= 9) {
						{
							uint32_t playmod_effect = 42;
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = playmod_effect, data_.YSpeed = playmod_effect, data_.x = pInfo(peer)->x + rand() % 17, data_.y = pInfo(peer)->y + rand() % 22;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
						}
						PlayMods give_playmod{};
						give_playmod.id = 4;
						give_playmod.time = time(nullptr) + 180;
						pInfo(peer)->playmods.push_back(give_playmod);
						update_clothes(peer);
					}
					else if (percentage <= 19) {
						vector<int> pastel_blocks{
							510,
							512,
							514,
							516,
							518,
							520,
							522
						};
						drop_block_.id = pastel_blocks[rand() % pastel_blocks.size()], drop_block_.count = 5;
					}
					else if (percentage <= 24) 	drop_block_.id = 10760, drop_block_.count = 5;
					else if (percentage <= 29) drop_block_.id = 4624, drop_block_.count = 7;
					else if (percentage <= 39) drop_block_.id = ((rand() % 100) < 50 ? 616 : 618), drop_block_.count = 1;
					else if (percentage <= 49) drop_block_.id = ((rand() % 100) < 50 ? 1548 : 8044), drop_block_.count = 1;
					else if (percentage <= 59) {
						vector<int> easter_set{
							502,
							500,
							498,
							508,
						};
						drop_block_.id = easter_set[rand() % easter_set.size()], drop_block_.count = 1;
					}
					else if (percentage <= 69) {
						vector<int> bunny_set{
							504,
							506,
							524
						};
						drop_block_.id = bunny_set[rand() % bunny_set.size()], drop_block_.count = 1;
					}
					else if (percentage <= 79) drop_block_.id = 8038, drop_block_.count = 1;
					else if (percentage <= 89) drop_block_.id = 2558, drop_block_.count = 1;
					else if (percentage <= 99) drop_block_.id = 1550, drop_block_.count = 1;
					else if (percentage == 100) drop_block_.id = 1552, drop_block_.count = 1;
					else if (percentage <= 119) drop_block_.id = 9452, drop_block_.count = 1;
					else if (percentage <= 159) drop_block_.id = 9468, drop_block_.count = 1;
					else if (percentage <= 179) drop_block_.id = 9454, drop_block_.count = 1;
					else if (percentage <= 199) drop_block_.id = 9442, drop_block_.count = 1;
					else if (percentage == 200)drop_block_.id = 9446, drop_block_.count = 1;
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = x_ * 32 + rand() % 17, drop_block_.y = y_ * 32 + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 392 || t_ == 3402 || t_ == 9350) { // golden booty chest ir hearstone ir super golden booty chest
					WorldDrop drop_block_{};
					/*
					if (t_ == 3402) {
						pInfo(peer)->booty_broken++;
						if (pInfo(peer)->booty_broken >= 100) {
							pInfo(peer)->booty_broken = 0;
							int c_ = 1;
							if (modify_inventory(peer, 9350, c_) != 0) {
								drop_block_.id = 9350, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								dropas_(world_, drop_block_);
							}
							gamepacket_t p, p2;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You received " + items[9350].name + "!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							p2.Insert("OnConsoleMessage"), p2.Insert("You received " + items[9350].name + "!"), p2.CreatePacket(peer);
							PlayerMoving data_{};
							data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0, data_.punchX = 9350, data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							memcpy(raw + 8, &to_netid, 4);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
						}
						//valentine
						{
							gamepacket_t p;d
							p.Insert("OnProgressUISet"), p.Insert(1), p.Insert(3402), p.Insert(pInfo(peer)->booty_broken), p.Insert(100), p.Insert(""), p.Insert(1);
							p.CreatePacket(peer);
						}
						gamepacket_t p;
						p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->booty_broken), p.Insert(0);
						p.CreatePacket(peer);
					}
					*/
					vector<int> list{ 11702, 11696,11692,11690,11688,11686,11684,11682,11680,11678, 386, 386, 11694, 5652, 3398, 386, 4422, 364, 9342, 9340, 9334, 9332, 9336, 9338, 4400, 7808, 7810, 4416, 7818, 7820, 7822, 7824, 5644, 390, 7826, 7830, 9324, 5658, 3396, 2384, 5660, 10654, 3400, 4418, 388, 3408, 1470, 3404, 3406, 10662, 2390, 5656, 5648, 2396, 384, 5664, 4424, 366, 13154, 13122, 13146, 13150, 13152, 13144, 13132, 13130, 13124, 13126, 13128, 13114 }, ghc{ 1458 }, rare_list{ 11668, 11670, 11672, 11664, 362, 362, 362, 2388, 10652, 4412, 10632, 10626, 13118, 13140, 13116 };
					int item = list[rand() % list.size()];
					if ((t_ == 9350 ? rand() % 10000 : rand() % 20000) < 1) item = ghc[rand() % ghc.size()];
					if ((t_ == 9350 ? rand() % 1000 : (has_playmod(pInfo(peer), "Lucky in Love") ? rand() % 1000 : rand() % 10000)) < 2) item = rare_list[rand() % rare_list.size()];
					if (item == 1458) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 73, data_.YSpeed = 73, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
						BYTE* raw = packPlayerMoving(&data_);
						string texts = "`4The Power of Love! `2" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` found a `5" + items[item].ori_name + "`` in a `5" + items[t_].name + "``!";
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` " + texts + "``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
							if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
							p.CreatePacket(currentPeer2);
						}
					}
					drop_block_.id = item, drop_block_.count = (item == 11694 || item == 11696 || item == 7810 || item == 7808 || item == 4400 || item == 390 || item == 3408 || item == 4422 || item == 3404 ? 5 : (item == 4418 || item == 5660 || item == 386 ? 2 : 1)), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 776) { // toxic waste
					vector<int> random_xy{ 1, 0, -1 };
					for (int i = 0; i < 3; i++) {
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()];
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * world_->width)];
						if (dropx->fg == 0) dropx->fg = 778, update_tile(peer, randomx + x_, randomy + y_, 778, false, true);
					}
				}
				else if (t_ == 3918 || t_ == 3928 || t_ == 3922) { // fossil rock broken
					if (pInfo(peer)->hand == 3934 && block_->fossil) {
						WorldDrop drop_block_{};
						drop_block_.id = 3936, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 720) { // pinata
					vector<pair<int, int>> receivingitems;
					vector<int> random_xy{ 2, 1, 0, -1, -2 };
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32)) {
							receivingitems.push_back(make_pair(world_->drop[i_].id, world_->drop[i_].count));
							PlayerMoving data_{};
							data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop[i_].uid;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
							world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
						}
					}
					for (int i = 0; i < receivingitems.size(); i++) {
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()];
						WorldDrop drop_block_{};
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * world_->width)];
						if (dropx->fg != 0) drop_block_.id = receivingitems[i].first, drop_block_.count = receivingitems[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						else drop_block_.id = receivingitems[i].first, drop_block_.count = receivingitems[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 836) { // summer suprise
					vector<int> list{ 6308, 846, 3702, 8602, 8600, 11068, 832, 2860, 6328, 6324, 6330, 834, 2862, 8612, 4810, 6326, 9744, 3700, 9756, 842, 9748, 11066, 11062, 11064, 840, 850, 3704, 8592, 8594, 3698, 3740, 442, 846, 4804, 3742, 8610, 2856, 844, 11058, 2858, 11040, 822, 838, 4812 }, rare_list{ 1680, 11040 }, random_xy{ 1, 0, -1 };
					int item = list[rand() % list.size()];
					for (int i = 0; i < 3; i++) {
						if (rand() % 282 < 1) item = rare_list[rand() % rare_list.size()];
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()], item = list[rand() % list.size()];
						WorldDrop drop_block_{};
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * world_->width)];
						if (dropx->fg != 0) drop_block_.id = item, drop_block_.count = (item == 850 || item == 442 || item == 822 || item == 832 || item == 846 ? 10 : (item == 834 ? 5 : 1)), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						else drop_block_.id = item, drop_block_.count = (item == 850 || item == 442 || item == 822 || item == 832 || item == 846 ? 10 : (item == 834 ? 5 : 1)), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 10836 || t_ == 10838 || t_ == 10840 || t_ == 10834 || t_ == 10842) { // Surgery Supply Crate, Fishing Supply Crate, Cooking Supply Crate, Startopia Supply Crate, Superhero Supply Crate
					WorldDrop drop_block_{};
					for (int i = 0; i < items[t_].noob_item.size(); i++) {
						drop_block_.id = items[t_].noob_item[i].first, drop_block_.count = items[t_].noob_item[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 9380 || t_ == 9538 || t_ == 11156) {
					WorldDrop drop_block_{};
					drop_block_.id = items[t_].randomitem[rand() % items[t_].randomitem.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (t_ == 9380) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
				}
				else if (t_ == 9154) {
					vector<int> rand_prize;
					int c_ = 1;
					bool luck = false;
					if (rand() % 1000 < 99) rand_prize = { 1796, 1738, 10184, 10338, 10424, 10772, 10806, 11016, 11290, 13198, 1342, 13576, 5738, 7084, 2982, 362, 2256, 2257, 2260, 2262, 2264, 2390, 818, 678, 3862, 1672, 1824, 3986, 4534, 3512, 6818, 6842, 7104, 7150, 7196, 7502, 6694, 6334, 7412, 7582, 10440, 11172, 11226, 11228, 11174, 11176, 11178, 11222, 11224, 11340, 11488, 11576, 11570, 11726, 11736, 12062, 12070, 12088, 12112, 12124, 12296, 12260,12492, 12494, 12496, 12498, 12500, 12502, 12504, 12506, 12508, 12510, 2718, 2872, 2972, 4182, 4816, 4182, 4818, 4954, 5266, 5482, 6006, 6008, 6814, 6816,  7092, 7152, 7514, 8480, 8814, 9262, 10082, 10084, 10086, 9334, 9462, 9464 }, luck = true;
					else if (rand() % 300 < 35) rand_prize = { 1796, 1738, 10184, 10338, 10424, 10772, 10806, 11016, 11290, 13198, 1342, 13576, 5738, 7084, 2982, 362, 2256, 2257, 2260, 2262, 2264, 2390, 818, 678, 3862, 1672, 1824, 3986, 4534, 3512, 6818, 6842, 7104, 7150, 7196, 7502, 6694, 6334, 7412, 7582, 10440, 11172, 11226, 11228, 11174, 11176, 11178, 11222, 11224, 11340, 11488, 11576, 11570, 11726, 11736, 12062, 12070, 12088, 12112, 12124, 12296, 12260,12492, 12494, 12496, 12498, 12500, 12502, 12504, 12506, 12508, 12510, 2718, 2872, 2972, 4182, 4816, 4182, 4818, 4954, 5266, 5482, 6006, 6008, 6814, 6816,  7092, 7152, 7514, 8480, 8814, 9262, 10082, 10084, 10086, 9334, 9462, 946411308, 11442, 11508, 11552, 11662, 11706, 11752, 12644, 12836, 12874, 12876, 13460, 13718, 12434, 12346, 12248, 13260, 13024, 13108, 13260 };
					else rand_prize = {
1738, 10184, 10338, 10424, 10772, 10806, 11016, 11290, 13198, 1342, 13576, 5738, 7084, 2982, 362, 2256, 2257, 2260, 2262, 2264, 2390, 818, 678, 3862, 1672, 1824, 3986, 4534, 3512, 6818, 6842, 7104, 7150, 7196, 7502, 6694, 6334, 7412, 7582, 10440, 11172, 11226, 11228, 11174, 11176, 11178, 11222, 11224, 11340, 11488, 11576, 11570, 11726, 11736, 12062, 12070, 12088, 12112, 12124, 12296, 12260,12492, 12494, 12496, 12498, 12500, 12502, 12504, 12506, 12508, 12510, 2718, 2872, 2972, 4182, 4816, 4182, 4818, 4954, 5266, 5482, 6006, 6008, 6814, 6816,  7092, 7152, 7514, 8480, 8814, 9262, 10082, 10084, 10086, 9334, 9462, 9464,11308, 11442, 11508, 11552, 11662, 11706, 11752, 12644, 12836, 12874, 12876, 13460, 13718, 12434, 12346, 12248, 13260, 13024, 13108, 13260 }, c_ = 1;
					int item = rand_prize[rand() % rand_prize.size()];
					WorldDrop drop_block_;
					drop_block_.id = item;
					drop_block_.count = c_;
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (luck) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 73, data_.YSpeed = 73, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
						BYTE* raw = packPlayerMoving(&data_);
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`5** `oA `4TayoPs Custom Box `orewards " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` with a `5Rare " + items[drop_block_.id].ori_name + "``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
							if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
							p.CreatePacket(currentPeer2);
						}
					}
				}
				else if (t_ == 7628 || t_ == 5136 || t_ == 9386 || t_ == 9384) {
					WorldDrop drop_block_{};
					drop_block_.id = items[t_].randomitem[rand() % items[t_].randomitem.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (t_ == 5136 || t_ == 9386 || t_ == 9384) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
				}
				else if (t_ == 8426) { // easter crate
					vector<int> list{ 2544, 2548, 2550, 2552, 2546,2544, 2548, 2550, 2552, 2546, 9460 };
					WorldDrop drop_block_{};
					drop_block_.id = 611, drop_block_.count = rand() % 20 + 20, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (rand() % 100 < 40) {
						drop_block_.id = list[rand() % list.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
					if (rand() % 100 < 80) {
						if (rand() % 500 < 1) list = { 2554 };
						drop_block_.id = list[rand() % list.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 826) { // emerald
					if (rand() % 100 < 1) {
						WorldDrop drop_block_{};
						drop_block_.id = 1486, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
					else gems_(peer, world_, rand() % (150 + 1), x_ * 32, y_ * 32, t_);
				}
				else if (t_ == 542) { // pot o gold // riding
					if (rand() % 200 < 1) {
						WorldDrop drop_block_{};
						drop_block_.id = 2574, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
					else gems_(peer, world_, rand() % (100 + 1), x_ * 32, y_ * 32, t_);
				}
				else if (rand() % 200 > 150 && (!((items[t_].properties & Property_AutoPickup) ||
					(items[t_].properties & Property_Permanent) ||
					(items[t_].properties & Property_WorldLock)) || items[t_].farmable) and not pInfo(peer)->Cheat_AF) {
					Algorithm::send_bubble(peer, pInfo(peer)->netID, "You found a Credit Point!");
					pInfo(peer)->opc++;
					save_player(pInfo(peer), false);
				}
				else if (rand() % 100000 < (pInfo(peer)->hand == 11118 ? 10 : 5) and (!(t_ == 2 || t_ == 14 ||
					(items[t_].properties & Property_AutoPickup) ||
					(items[t_].properties & Property_Permanent) ||
					(items[t_].properties & Property_WorldLock)) || items[t_].farmable) and pInfo(peer)->lock == 8470) {
						vector<int> random_item_{ 9384, 9386 };
						int item = random_item_[rand() % random_item_.size()];
						Algorithm::send_bubble(peer, pInfo(peer)->netID, format("You found a {}!", items[item].name));
						WorldDrop drop_block_{};
						drop_block_.id = item, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
				}
				else if (t_ == 3604) { // gold treasure
					vector<int> list{ 112, 3582, 262, 826, 828, 2812, 3606, 3574, 10102, 11228 };
					vector<int> rare{ 2002, 3604, 2002, 2002 };
					if (rand() % 25 < 1) list = { 2002, 3604, 2002, 2002 };
					int item = list[rand() % list.size()];
					if (item == 112) gems_(peer, world_, rand() % (500 + 100), x_ * 32, y_ * 32, t_);
					else {
						WorldDrop drop_block_{};
						drop_block_.id = item, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				/*
				else if (t_ == 5140 || t_ == 5138) { // mystery box
					if (rand() % 100 < (items[t_].newdropchance + 5)) {
					WorldDrop drop_seed_{};
					drop_seed_.id = t_ + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
					if (not use_mag(world_, drop_seed_, x_, y_)) {
						dropas_(world_, drop_seed_);
					}
					}
					else if (rand() % 100 < 7) {
						WorldDrop drop_seed_{};
						drop_seed_.id = t_, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
						if (not use_mag(world_, drop_seed_, x_, y_)) {
							dropas_(world_, drop_seed_);
						}
					}
					else if (rand() % 10 < 8) {
						gems_(peer, world_, rand() % 110 + 1, x_ * 32, y_ * 32, t_);
					}
				}
				*/
				else if (t_ == 10004) { // super summer suprise
					vector<int> list{ 3704, 3698, 9754, 842, 3700, 9750, 3702, 3702, 9750, 9746, 3700, 842, 9754, 3698, 1670, 3704, 3764, 4822, 2874, 8614 }, rare_list{ 9758, 11012, 12188, 1680 };
					WorldDrop drop_block_{};
					int item = list[rand() % list.size()];
					drop_block_.id = item;
					if (rand() % 1000 < 1) item = rare_list[rand() % rare_list.size()];
					if (find(rare_list.begin(), rare_list.end(), item) != rare_list.end()) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 73, data_.YSpeed = 73, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
						BYTE* raw = packPlayerMoving(&data_);
						drop_block_.id = item;
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`5** `oA `4Super Summer Surprise `orewards " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` with a `5Rare " + items[drop_block_.id].ori_name + "``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
							if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
							p.CreatePacket(currentPeer2);
						}
					}
					drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 11038) { //summer artifacts
					vector<int> list{ 442, 3764, 3702, 9740, 9746, 9750, 3700, 842, 9754, 2874, 8614, 3698, 1670, 11040, 11042, 8616, 8618, 1676, 8590, 9732, 9732, 2868, 4822, 1668, 11046, 1678, 1664, 844, 2864, 3764, 6308, 6310, 6306, 6322, 1670, 4816, 4818, 2870, 2874, 2802, 1666, 4814 };
					if (rand() % 2288 < 1) list = { 11044, 12352, 11048, 11166, 2872 };
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()];
					if (drop_block_.id == 11044 || drop_block_.id == 12352) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 73, data_.YSpeed = 73, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
						BYTE* raw = packPlayerMoving(&data_);
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`5** `oA `4Summer Artifact Chest `orewards " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` with a `5Rare " + items[drop_block_.id].ori_name + "``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
							if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
							p.CreatePacket(currentPeer2);
						}
					}
					drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 10826) { // lava pinata
					vector<int> list{ 6042, 10818, 2640, 9610, 2638, 9634, 9632, 10800, 10804, 1570, 9608, 11876 };
					if (rand() % 140 < 1) {
						list = { 10168 , 11288 }; // chance of receiving rare item
						if (volcanic_wings < 48) list.push_back(11870);
						if (volcanic_cape < 48) list.push_back(10806);
					}
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()], drop_block_.count = (drop_block_.id == 10818 ? 20 : 1), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (drop_block_.id == 10168 || drop_block_.id == 11288 || drop_block_.id == 10806 || drop_block_.id == 11870) {
						if (drop_block_.id == 11870) volcanic_wings++;
						if (drop_block_.id == 10806) volcanic_cape++;
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("The `4Lava Pinata`` rewards " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` with a `5Rare " + items[drop_block_.id].ori_name + ".``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							p.CreatePacket(currentPeer);
						}
					}
				}
				else if (t_ == 718) { // ultra pinata
					if (pInfo(peer)->pinata_claimed == false && pInfo(peer)->pinata_prize == false) {
						pInfo(peer)->pinata_claimed = true;
						//gamepacket_t p;
						//p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->pinata_claimed ? 1 : 0), p.Insert(pInfo(peer)->pinata_prize ? 1 : 0), p.CreatePacket(peer);
					}
					vector<int> list{ 11900, 4672, 9614 , 10812 , 9634 , 9632 , 9608 , 704 , 6058 , 3598 , 9624 , 9626 , 706 , 10818 , 6052 , 712 , 708, 1568, 4724, 4728, 4726, 2634, 714, 10816, 720, 2632, 702, 8316, 8320, 8322, 8318, 10828, 700, 700, 2630, 11892, 11898, 11896 };
					if (pInfo(peer)->hair == 1568) list.insert(list.end(), { 1580, 8324, 6042, 2638,9622,9630, 8326, 10808, 10802, 2640, 10882 });
					if (rand() % 1000 < 1) {
						list = { 10826,  8314 }; // chance of receiving rare item
						if (pInfo(peer)->hair == 1568)  list.insert(list.end(), { 8310,4664,3594, 1570, 9610,10814, 1584, 11874 });
					}
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()];
					if (drop_block_.id == 3598) drop_block_.count = rand() % 2 + 3;
					else if (drop_block_.id == 9624) drop_block_.count = rand() % 3 + 1;
					else if (drop_block_.id == 2632 || drop_block_.id == 8322) drop_block_.count = rand() % 3 + 2;
					else if (drop_block_.id == 8316) drop_block_.count = rand() % 2 + 2;
					else if (drop_block_.id == 8320) drop_block_.count = 2;
					else if (drop_block_.id == 8318) drop_block_.count = rand() % 4 + 1;
					else if (drop_block_.id == 10828) drop_block_.count = 10;
					else if (drop_block_.id == 2630) drop_block_.count = rand() % 2 + 1;
					else if (drop_block_.id == 11892) drop_block_.count = 4;
					else if (drop_block_.id == 11896) drop_block_.count = 3;
					else drop_block_.count = 1;
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 9616) { // block de mayo
					vector<int> list{ 11900, 11900, 716, 11890,9628,6054, 10804, 716, 11890,9628,6054, 10804,  704, 6058, 1568, 1572 , 1580, 10822 };
					if (rand() % 1000 < 1) list = { 9618,  8314, 9612 }; // chance of receiving rare item
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()];
					if (drop_block_.id == 716 || drop_block_.id == 1572) drop_block_.count = 6;
					else if (drop_block_.id == 11890) drop_block_.count = 3;
					else drop_block_.count = 1;
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 1584) { // mystery pinata
					vector<pair<int, int>> receivingitems;
					vector<int> random_xy{ 2, 1, 0, -1, -2 };
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32)) {
							receivingitems.push_back(make_pair(world_->drop[i_].id, world_->drop[i_].count));
							PlayerMoving data_{};
							data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop[i_].uid;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
							world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
						}
					}
					for (int i = 0; i < receivingitems.size(); i++) {
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()], item = receivingitems[i].first;
						if (item == 1584) item = 3596;
						if (item == 2634) item = 3602;
						if (item == 1580) item = 1586;
						if (item == 3274) item = 4660;
						if (item == 1568) item = 710;
						if (item == 678) item = 1574;
						if (item == 330) item = 1578;
						if (item == 604 || item == 802 || item == 804 || item == 806 || item == 808 || item == 810 || item == 812) item = 2636;
						if (item == 900 || item == 1378) item = 1576;
						if (item == 2160 || item == 2164 || item == 2162 || item == 2158 || item == 2168 || item == 2166) item = 2642;
						if (item == 2614 || item == 2616 || item == 2618) item = 2620;
						if (item == 2606 || item == 2608 || item == 2610) item = 2612;
						if (item == 2598 || item == 2600 || item == 2602) item = 2604;
						if (item == 1570) item = 6044;
						if (item == 414) item = 6030;
						if (item == 2624) item = 6056;
						if (item == 8310) item = 8312;
						WorldDrop drop_block_{};
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * world_->width)];
						if (dropx->fg != 0) drop_block_.id = item, drop_block_.count = receivingitems[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						else drop_block_.id = item, drop_block_.count = receivingitems[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 2478) { // locke mystery box
					vector<int> list{ 2472,2470,2474,2466,2468,10116,3758,11222 };
					vector<int> clothes{ 370, 372, 374, 42, 68, 40, 130, 270, 234, 142, 694, 10034, 140, 76, 48, 44, 34, 36, 122, 238, 66, 38, 90, 208, 272, 144, 2938, 354, 138, 214, 11202, 342, 1846, 210, 234, 250, 1716, 82, 78, 94, 662, 754, 146, 356, 72, 46, 124, 1720, 92, 1122, 212, 84, 1722, 1844, 2718, 70, 4966, 288, 232, 788, 148, 96, 3932, 448, 98, 134, 50, 74, 1504, 494, 266, 852, 132, 2954, 3934, 3060, 3056, 1800, 88, 2960, 1022, 2578, 3164, 86, 302, 1332, 304, 1116, 6788, 894, 492, 1690, 316, 1850, 1718, 1838, 1032, 1860, 1026, 3048, 352, 724, 1590, 798, 488, 1342, 794, 268, 1502, 8884, 1858, 594, 3466, 1314, 1688, 1312, 3590, 446, 1856, 1854, 1516, 1316, 2700, 4968, 4964, 6796, 1862, 310, 290, 296, 6674, 1864, 4954, 1476, 896, 1848, 496, 136, 158, 2958, 2576, 1954, 152, 1126, 796, 1524, 2928, 80, 2934, 150, 1120, 1142, 1478, 154, 9356, 452, 258, 2882, 156, 1140, 3530, 312, 1124, 890, 1330, 3052, 294, 1650, 1652, 348, 1736, 576, 5016, 1708, 292, 1146, 1028, 1762, 600, 11204 };
					vector<int> block{ 231,487,483,2019,427,1757,2009,281,781,329,459,1041,421,2787,2789,1043,2797,181,613,65,4983,283,553,425,4635,987,627,2017,989,61,4639,973,3523,331,265,859,433,253,339,1105,439,4567,333,677,5673,1427,5603,183,10533,5731,7223,10833,6035,6813,1113,1047,653,2811,4703,1429,847,665,485,1613,833,2025,1775,3931,429,3831,423,437,1773,4767,1299,361,667,2815,3473,301,4637,5683,2709,415,955,461,861,9389,5467,2791,2815,1803,419,2027,685,555,741,10531,5729,7221,10831,6033,6811,621,6401,1107,359,3471,855,309,1685,1449,1309,441,1111,221,1431,3065,9307,1257,1501,1109,4641,3587,1103,417,743,431,3823,2949,1131,3825,727,5379,729,187,787,5459,4785,3261,3521,2293,2309,2321,2333,5461,3721,327,247,63,3479,445,4783,299,863,8935,1451,261,1871,1499,455,9391,683,1159,551,1745,411,3005,557,687,4799,559,4643,3899,1605,9309,567,565,1155,3827,1327,1767,993,1157,563,4721,115,1423,10515,1329,6545,287,669,777,5463,1655,1599,561,4585,3413,4745,1771,2011,1161,1729,3757,3753,321,3265,3263,623,775,6397,129,4667,759,3767,1529,6543,4707,3835,1435,651,8929,569,527,3287,1595,6063,2795,1003,1731,4943,4963,597,4669,1531,1523,625,4297,599,657,571,873,3755,2969,1725,4603,1447,3267,5375,1683,3567, 13, 57, 17, 381, 1139, 21, 101, 379, 117, 27, 23, 581, 195, 105, 191, 377, 1307, 697, 881, 167, 185, 1323, 165, 3783, 369, 25, 171, 53, 103, 179, 29, 249, 177, 1325, 337, 189, 169, 55, 223, 175, 885, 119, 3573, 199, 549, 681, 655, 107, 163, 31, 671, 889, 887, 193, 127, 1433, 173, 7631, 413, 3571, 3569, 2809, 9393, 225, 111, 109, 201, 59, 607, 285, 2029, 2013, 2015, 1611, 995, 997, 963, 1481, 219, 197, 2023, 2021, 9331, 1305, 823, 1039, 231, 487, 483, 2019, 427, 1757, 2009, 281, 781, 329, 459, 1041, 421, 2787, 2789, 1043, 2797, 181, 613, 65, 4983, 283, 553, 425, 4635, 987, 627, 2017, 989, 61, 4639, 973, 3523, 331, 265, 859, 433, 253, 339, 1105, 439, 4567, 333, 677, 5673, 1427, 5603, 183, 10533, 5731, 7223, 10833, 6035, 6813, 1113, 1047, 653, 2811, 4703, 1429, 847, 665 };
					int item = block[rand() % block.size()];
					if ((rand() % 2) + 1 == 2) item = clothes[rand() % clothes.size()];
					else {
						if ((rand() % 2) + 1 == 2) item = block[rand() % block.size()] - 1;
						else item = block[rand() % block.size()];
					}
					if (rand() % 25 < 1) item = list[rand() % list.size()];
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (items[t_].blockType == BlockTypes::VENDING) {
					if (block_->c_ != 0 or block_->wl != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Empty the machine before smashing!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
				else if (items[t_].blockType == BlockTypes::DONATION) {
					if (block_->donates.size() != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Empty the " + items[t_].name + " before breaking it!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
				else if (items[t_].blockType == BlockTypes::STORAGE) {
					int itemcount = 0;
					for (int i_ = 0; i_ < world_->sbox1.size(); i_++) if (world_->sbox1[i_].x == x_ and world_->sbox1[i_].y == y_) itemcount++;
					if (itemcount != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Empty the box before breaking it!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
				else if (items[t_].item_sucker) {
					if (block_->pr > 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Empty this " + items[t_].name + " before breaking!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
				else if (items[t_].magplant) {
					switch (t_) {
					case 6950: case 6952:
					{
						if (block_->pr > 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`4Be careful``, if you return this to your backpack you will `4lose ALL`` Gems stored within! Use them up first!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(peer);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`4Be careful``, if you return this to your backpack you will `4lose ALL`` Gems stored within! Use them up first!");
								p.CreatePacket(peer);
							}
							return true;
						}
						break;
					}
					}
				}
				if (items[t_].properties & Property_AutoPickup) {
					int c_ = 1;
					if (items[t_].blockType == BlockTypes::LOCK and t_ != 202 && t_ != 204 && t_ != 206 && t_ != 4994) {
						if (world_->owner_name != pInfo(peer)->tankIDName && pInfo(peer)->dev == 0) return true;
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
							if (world_->blocks[i_].fg == 4516) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("`4Remove Untrade-a-Box before removing lock!``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
								return true;
							}
						}
					}

					if (get_free_slots(pInfo(peer)) > 1) {
						if (modify_inventory(peer, t_, c_, false) == 0) {
							PlayerMoving data_{};
							data_.packetType = 14, data_.netID = -1, data_.plantingTree = t_;
							data_.x = float(x_) * 32, data_.y = float(y_) * 32;
							int32_t item = -1;
							float val = 1.00;
							BYTE* raw = packPlayerMoving(&data_);
							memcpy(raw + 8, &item, 4);
							memcpy(raw + 16, &val, 4);
							data_.netID = pInfo(peer)->netID;
							WorldDrop n_{};
							n_.id = 0, n_.count = 0, n_.uid = uint16_t(world_->drop.size()) + 1, n_.x = x_ * 32, n_.y = y_ * 32;
							world_->drop.push_back(n_);
							data_.plantingTree = int(world_->drop.size());
							data_.x = 0, data_.y = 0;
							BYTE* raw2 = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[]raw, raw2;
							gamepacket_t p(1);
							p.Insert("OnConsoleMessage");
							p.Insert("Collected `w1 " + items[t_].name + "``.``");
							p.CreatePacket(peer);
							if (items[t_].xeno) {
								world_->xenonite = false;
								world_->X_1 = false, world_->X_2 = false, world_->X_3 = false, world_->X_4 = false, world_->X_5 = false, world_->X_6 = false, world_->X_7 = false, world_->X_8 = false, world_->X_9 = false, world_->X_10 = false, world_->X_11 = false, world_->X_12 = false, world_->X_13 = false, world_->X_14 = false, world_->X_15 = false, world_->X_16 = false, world_->X_17 = false, world_->X_18 = false, world_->X_19 = false;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										pInfo(currentPeer)->xenonite_effect = false;
										update_clothes(currentPeer);
										packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
									}
								}
							}
						}
						else {
							Algorithm::send_bubble(peer, pInfo(peer)->netID, "`wYou don't have enough room in your backpack.");
							return true;
						}
					}
					else {
						Algorithm::send_bubble(peer, pInfo(peer)->netID, "`wYou don't have enough room in your backpack.");
						return true;
					}
				}
				else if (items[t_].max_gems != 0) {
					// BREAK BLOCK
					if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 4 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
						pInfo(peer)->C_QuestProgress++;
						if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 3 && pInfo(peer)->quest_progress < 5000) {
						pInfo(peer)->quest_progress++;
						if (pInfo(peer)->quest_progress >= 5000) {
							pInfo(peer)->quest_progress = 5000;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 4 && pInfo(peer)->quest_progress < 100000) {
						pInfo(peer)->quest_progress++;
						if (pInfo(peer)->quest_progress >= 100000) {
							pInfo(peer)->quest_progress = 100000;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					// BREAK BLOCK RARITY
					if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 5 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
						pInfo(peer)->C_QuestProgress += items[t_].rarity;
						if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 1 && pInfo(peer)->quest_progress < 50000) {
						pInfo(peer)->quest_progress += items[t_].rarity;
						if (pInfo(peer)->quest_progress >= 50000) {
							pInfo(peer)->quest_progress = 50000;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`9Kamish Quest step complete! I'm off to see a Wizard!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 4 && pInfo(peer)->quest_progress < 100000) {
						pInfo(peer)->quest_progress += items[t_].rarity;
						if (pInfo(peer)->quest_progress >= 100000) {
							pInfo(peer)->quest_progress = 100000;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					if (pInfo(peer)->quest_active &&   pInfo(peer)->quest_step == 11 && pInfo(peer)->quest_progress < 100000) {
						pInfo(peer)->quest_progress += items[t_].rarity;
						if (pInfo(peer)->quest_progress >= 100000) {
							pInfo(peer)->quest_progress = 100000;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					add_peer_xp(peer, (items[t_].rarity / 5 > 0 ? items[t_].rarity / 5 : 1));
					int maxgems = items[t_].max_gems;
					if (t_ == 120) maxgems = 50;
					int c_ = rand() % (maxgems + 1);
					if (c_ != 0) {
						bool no_seed = false, no_gems = false, no_block = false;
						if (t_ == 2242 or t_ == 2244 or t_ == 2246 or t_ == 2248 or t_ == 2250 or t_ == 542) no_seed = true, no_block = true;
						else {
							for (int i_ = 0; i_ < world_->drop.size(); i_++) {
								if (abs(world_->drop[i_].y - y_ * 32) <= 16 and abs(world_->drop[i_].x - x_ * 32) <= 16) {
									if (world_->drop[i_].id == 112 and items[t_].rarity < 8) {
										no_gems = true;
									}
									else {
										no_seed = true, no_block = true;
									}
								}
							}
						}
						if (items[t_].bunny_egg) no_seed = true, no_block = true, no_gems = true;
						int chanced = 0;
						if (thedaytoday == 2) chanced = 5;
						if (rand() % 100 < 7) {
							if (t_ == 8 || t_ == 6 || t_ == 7372) break;
							if ((pInfo(peer)->mask == 8192 || pInfo(peer)->ances == 5144 || pInfo(peer)->ances == 5146 ||
								pInfo(peer)->ances == 5148 || pInfo(peer)->ances == 5150 || pInfo(peer)->ances == 5152 ||
								pInfo(peer)->ances == 5080 &&
								rand() % 250 - (items[pInfo(peer)->ances].chance * items[pInfo(peer)->ances].chance) < 1) || (pInfo(peer)->affinity_level == 4 && rand() % 100 < 1)) {
								WorldDrop drop_block_{};
								drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17, drop_block_.id = t_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
								PlayerMoving data_{};
								data_.packetType = 36, data_.netID = 24, data_.YSpeed = 24, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
								if (not use_mag(world_, drop_block_, x_, y_) and not no_block) {
									dropas_(world_, drop_block_);
								}
							}
							WorldDrop drop_block_{};
							drop_block_.id = t_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
							if (not use_mag(world_, drop_block_, x_, y_) and not no_block) {
								dropas_(world_, drop_block_);
							}
						}
						else if (rand() % 100 < (items[t_].newdropchance + chanced)) {
							if (t_ == 8 || t_ == 6 || t_ == 7372) break;
							WorldDrop drop_seed_{};
							drop_seed_.id = t_ + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
							if (not use_mag(world_, drop_seed_, x_, y_) and not no_seed) {
								dropas_(world_, drop_seed_);
							}
						}
						else if (not no_gems) {
							if (t_ == 8 || t_ == 6 || t_ == 7372) break;
							if (has_playmod(pInfo(peer), "Lucky") and ((rand() % 100) + 1) <= 30) {
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = 125, data_.YSpeed = 125, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw;
								c_ += (rand() % 5) + 1;
							}
							drop_rare_item(world_, peer, t_, x_, y_, false);
							gems_(peer, world_, c_, x_ * 32, y_ * 32, t_);
						}
					}
				}
				if (block_->fg == 5638 and pInfo(peer)->magnetron_id != 0 and pInfo(peer)->magnetron_x == x_ and pInfo(peer)->magnetron_y == y_) {
					int c_ = 0;
					modify_inventory(peer, 5640, c_);
					if (c_ != 0) {
						c_ *= -1;
						modify_inventory(peer, 5640, c_);
						pInfo(peer)->magnetron_id = 0;
						pInfo(peer)->magnetron_x = 0;
						pInfo(peer)->magnetron_y = 0;
					}
				}
				if (items[block_->fg].charger and block_->id != 0) {
					if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) break;
					WorldDrop drop_block_{};
					drop_block_.id = 2286, drop_block_.count = 1;
					if (block_->planted - time(nullptr) <= 0) {
						drop_block_.id = 2204;
					}
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				// fossil prep prize! to-do edit later
				if (items[block_->fg].fossil_prep and block_->id != 0) {
					if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) break;
					WorldDrop drop_block_{};
					drop_block_.id = 4134, drop_block_.count = 1;
					if (block_->planted - time(nullptr) <= 0) {
						drop_block_.id = 2;
					}
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				switch (items[block_->fg].blockType) {
				case BlockTypes::WEATHER:
				{
					if (world_->weather != 0) {
						world_->weather = 0;
						if (pInfo(peer)->lock == 11902) world_->weather = 58;
						if (pInfo(peer)->lock == 11550) world_->weather = 54;
						if (pInfo(peer)->lock == 11586) world_->weather = 55;
						if (pInfo(peer)->lock == 10410) world_->weather = 53;
						if (world_->d_weather != 0) world_->weather = world_->d_weather;
						gamepacket_t p;
						p.Insert("OnSetCurrentWeather");
						p.Insert(world_->weather == 0 ? 80 : world_->weather);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								p.CreatePacket(currentPeer);
							}
						}
					}
					break;
				}
				case BlockTypes::DISPLAY:
				{
					if (block_->id != 0) {
						int c_ = 1;
						modify_inventory(peer, block_->id, c_);
						PlayerMoving data_effect_{};
						data_effect_.packetType = 19;
						data_effect_.punchX = block_->id;
						data_effect_.punchY = pInfo(peer)->netID;
						data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
						BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
						raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 5;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw_effect;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("You picked up 1 " + items[block_->id].ori_name + ".");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You picked up 1 " + items[block_->id].ori_name + ".");
							p.CreatePacket(peer);
						}
					}
					break;
				}
				case BlockTypes::LOCK:
				{
					// reset world settings
					if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) pInfo(currentPeer)->ac_.clear();
						}
						vector<int> new_tiles{};
						vector<WorldBlock> shadow_copy_2 = world_->blocks;
						new_tiles.push_back(x_ + (y_ * world_->width));
						int ySize = world_->blocks.size() / world_->width, xSize = world_->blocks.size() / ySize;
						for (int i2 = 0; i2 < new_tiles.size(); i2++) {
							int s_x_ = new_tiles[i2] % world_->width, s_y_ = new_tiles[i2] / world_->width;
							if (s_x_ < (world_->width - 1) and shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].lock_origin == (x_ + (y_ * world_->width))) {
								if (not shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].scanned) {
									shadow_copy_2[s_x_ + 1 + (s_y_ * world_->width)].scanned = true;
									new_tiles.push_back(s_x_ + 1 + (s_y_ * world_->width));
									world_->blocks[s_x_ + 1 + (s_y_ * world_->width)].locked = false;
									world_->blocks[s_x_ + 1 + (s_y_ * world_->width)].lock_origin = -1;
								}
							} if (s_x_ > 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].lock_origin == (x_ + (y_ * world_->width))) {
								if (not shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].scanned) {
									shadow_copy_2[s_x_ - 1 + (s_y_ * world_->width)].scanned = true;
									new_tiles.push_back(s_x_ - 1 + (s_y_ * world_->width));
									world_->blocks[s_x_ - 1 + (s_y_ * world_->width)].locked = false;
									world_->blocks[s_x_ - 1 + (s_y_ * world_->width)].lock_origin = -1;
								}
							} if (s_y_ < (world_->height - 1) and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].lock_origin == (x_ + (y_ * world_->width))) {
								if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].scanned) {
									shadow_copy_2[s_x_ + ((s_y_ + 1) * world_->width)].scanned = true;
									new_tiles.push_back(s_x_ + ((s_y_ + 1) * world_->width));
									world_->blocks[s_x_ + ((s_y_ + 1) * world_->width)].locked = false;
									world_->blocks[s_x_ + ((s_y_ + 1) * world_->width)].lock_origin = -1;
								}
							} if (s_y_ > 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].lock_origin == (x_ + (y_ * world_->width))) {
								if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].scanned) {
									shadow_copy_2[s_x_ + ((s_y_ - 1) * world_->width)].scanned = true;
									new_tiles.push_back(s_x_ + ((s_y_ - 1) * world_->width));
									world_->blocks[s_x_ + ((s_y_ - 1) * world_->width)].locked = false;
									world_->blocks[s_x_ + ((s_y_ - 1) * world_->width)].lock_origin = -1;
								}
							}
						}
						break;
					}
					if (pInfo(peer)->tankIDName == world_->owner_name) {
						pInfo(peer)->worlds_owned.erase(remove(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end(), world_->name), pInfo(peer)->worlds_owned.end());
					}
					else {
						bool on_ = false;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->tankIDName == world_->owner_name) {
								pInfo(currentPeer)->worlds_owned.erase(remove(pInfo(currentPeer)->worlds_owned.begin(), pInfo(currentPeer)->worlds_owned.end(), world_->name), pInfo(currentPeer)->worlds_owned.end());
								on_ = true;
								break;
							}
						}
					}
					if (block_->fg == 11902 || block_->fg == 11550 || block_->fg == 11586 || block_->fg == 10410 || block_->fg == 12654) {
						world_->lockid = 0;
						world_->weather = 0;
						if (world_->d_weather != 0) world_->weather = world_->d_weather;
					}
					int got = 0, got2 = 0;
					modify_inventory(peer, 1424, got);
					modify_inventory(peer, 1424, got *= -1);
					modify_inventory(peer, 5816, got2);
					modify_inventory(peer, 5816, got2 *= -1);
					world_->owner_name = "", world_->owner_id = 0, world_->allow_noclip = true, world_->v_p = false, world_->owner_named = "", world_->entry_level = 1, world_->make_music_blocks_invisible = false, world_->disable_music_blocks = false, world_->music_bpm = 100, world_->open_to_public = false;
					world_->silence = false, world_->rainbows = false;
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`5[```w" + world_->name + "`` has had its `$World Lock`` removed!`5]``");
					gamepacket_t p2(0, pInfo(peer)->netID);
					{
						p2.Insert("OnNameChanged");
						if (not HasRole(pInfo(peer)) and not pInfo(peer)->is_legend)pInfo(peer)->name_color = "`0";
						else if (pInfo(peer)->is_legend) pInfo(peer)->name_color = "`9";
						p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							if (block_->fg == 11902 || block_->fg == 11550 || block_->fg == 11586 || block_->fg == 10410 || block_->fg == 12654) {
								gamepacket_t p21;
								p21.Insert("OnSetCurrentWeather");
								//if (Comet_Dust) p21.Insert(16);
								p21.Insert(world_->weather == 0 ? 80 : world_->weather);
								p21.CreatePacket(currentPeer);
							}
							pInfo(currentPeer)->ac_.clear();
							p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
							if (find(world_->admins.begin(), world_->admins.end(), pInfo(currentPeer)->uid) != world_->admins.end()) {
								gamepacket_t p3(0, pInfo(currentPeer)->netID);
								p3.Insert("OnNameChanged");
								if (not HasRole(pInfo(currentPeer)) and not pInfo(currentPeer)->is_legend)pInfo(currentPeer)->name_color = "`0";
								else if (pInfo(currentPeer)->is_legend) pInfo(currentPeer)->name_color = "`9";
								p3.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``");
								for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
									if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
									if (pInfo(currentPeer2)->world == name_) {
										p3.CreatePacket(currentPeer2);
									}
								}
							}
						}
					}
					world_->admins.clear();
					break;
				}
				default:
					break;
				}
				if (ignore_reset == false) {
					punch_tile(peer, x_, y_, 0x3, p_, pInfo(peer)->netID, 0x0);
					reset_(block_, x_, y_, world_);
				}
			}
			else { /*-1 hp*/
				block_->lp = time_;
				if (items[block_->fg].blockType == BlockTypes::PROVIDER) {
					uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
					if (laikas == items[block_->fg].growTime) {
						add_role_xp(peer, 1, "provider");
						if (pInfo(peer)->startedKit && pInfo(peer)->lvlKit < 50) add_role_xp(peer, rand() % 28, "kit");
						// PROVIDER QUEST HERE
						vector<double> ids;// svarbu: id.max_kiekis <!= 5 if size after decimal point == 2 then count fixed
						vector<vector<int>> id_c;
						vector<int> Calendar{}, Rare_Calendar{};
						if (block_->fg == 1008) {
							pInfo(peer)->gems += rand() % 100 + 1;
							Algorithm::set_bux(peer);
						}
						/*
						if (block_->fg == 9506) {
							pInfo(peer)->gems += rand() % 5000 + 1;
							Algorithm::set_bux(peer);
						}
						*/
						if (block_->fg == 866) { // cow
							ids = { 868.2 };
						}
						else if (block_->fg == 872) { // chicken
							ids = { 874.2 };
						}
						else if (block_->fg == 1044) { // buffalo
							ids = { 868.2 };
						}
						else if (block_->fg == 3888) { // sheep
							ids = { 3890.3 };
						}
						else if (block_->fg == 1632) { // coffee maker
							ids = { 1634 };
						}
						else if (block_->fg == 5116) { // tea set
							ids = { 5114 };
						}
						else if (block_->fg == 2798) { // well
							ids = { 822.2 };
						}
						else if (block_->fg == 7766) { // hatching stone egg
							ids = { 7752, 7754, 7758, 7760, 7780 };
							if (rand() % 100 + 1 < 2) ids = { 12296 };
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 97, data_.YSpeed = 97, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							world_->blocks[x_ + (y_) * world_->width].fg = 0;
							update_tile(peer, x_, y_, 0, false, true);
							delete[] raw;
						}
						else if (block_->fg == 7770) { // hatching ghost egg
							ids = { 7752, 7754, 7758, 7760 };;
							if (rand() % 100 + 1 < 2) ids = { 7750 };
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 97, data_.YSpeed = 97, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							world_->blocks[x_ + (y_) * world_->width].fg = 0;
							update_tile(peer, x_, y_, 0, false, true);
							delete[] raw;
						}
						else if (block_->fg == 7774) { // hatching water egg
							ids = { 7752, 7754, 7758, 7760 };
							if (rand() % 100 + 1 < 2) ids = { 7756 };
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 97, data_.YSpeed = 97, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							world_->blocks[x_ + (y_) * world_->width].fg = 0;
							update_tile(peer, x_, y_, 0, false, true);
							delete[] raw;
						}
						else if (block_->fg == 7778) { // hatching void egg
							ids = { 7752, 7754, 7758, 7760 };
							if (rand() % 100 + 1 < 2) ids = { 7762 };
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 97, data_.YSpeed = 97, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							world_->blocks[x_ + (y_) * world_->width].fg = 0;
							update_tile(peer, x_, y_, 0, false, true);
							delete[] raw;
						}
						else if (block_->fg == 8050) { // hatching easter egg
							ids = { 7752, 7754, 7758, 7760, 8046 };
							if (rand() % 100 + 1 < 2) ids = { 11788 };
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 97, data_.YSpeed = 97, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							world_->blocks[x_ + (y_) * world_->width].fg = 0;
							update_tile(peer, x_, y_, 0, false, true);
							delete[] raw;
						}
						else if (block_->fg == 9302) { // hatching euphoric egg
							ids = { 7752, 7754, 7758, 7760 };
							if (rand() % 100 + 1 < 2) ids = { 9254 };
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 97, data_.YSpeed = 97, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							world_->blocks[x_ + (y_) * world_->width].fg = 0;
							update_tile(peer, x_, y_, 0, false, true);
							delete[] raw;
						}
						else if (block_->fg == 10450) { // diamond builder
							ids = { 10454, 10458.50, 10458.50, 10462.20, 10464.30, 10466.30, 10468.50, 10470.30, 10472.20, 10474.30, 10476.20, 10478.20, 10480.30, 10482, 10484.30, 10460 };
						}
						else if (block_->fg == 8196) { // building blocks machine
							id_c = { {4920, 3}, {4878, 1}, {7524, 3}, {7528, 5}, {7526, 3}, {4922, 3}, {7520, 10}, {7522, 10}, 
								{2280, 5}, {4372, 5}, {716, 3}, {1572, 3}, {11898, 5}, {2596, 3}, {714, 1}, {2632, 3}, {2630, 2},
								{6180, 5}, {6182, 5}, {6184, 5}, {7846, 10}, {7848, 10}, {7272, 5}, {7284, 5}, {334, 5}, {4630, 1},
								{4632, 1}, {8214, 10}, {8206, 10}, {8216, 10}, {8218, 10}, {8220, 5}, {8228, 10}, {8230, 10}, {8232, 10},
								{8234, 10}, {8236, 10}, {8238, 10}, {8210, 10}, {952, 1}, {1110, 5}, {2708, 3}, {1112, 5}, {264, 5}, {8208, 10},
								{414, 5}, {426, 5}, {420, 5}, {4634, 5}, {848, 3}, {2860, 5}, {6324, 5}, {2862, 5}, {8994, 5}, {8990, 5}, {11192, 3},
								{8200, 10}, {10060, 1}, {8202, 10}, {8204, 5}, {8992, 10}, {8224, 3}, {8832, 3}, {10106, 3}, {11194, 5}, {8212, 5},
								{8988, 10}, {8986, 10}, {8984, 10}, {10554, 5}, {8222, 5}, {8824, 5}, {8826, 5}, {8828, 5}, {12530, 5}, {12352, 5},
								{12574, 5}, {13122, 2}, {11696, 5}, {10646, 1}, {13146, 2}, {11698, 5}, {11738, 5}, {11732, 5}, {10708, 5}, {10710, 5},
								{13350, 3}, {11812, 5}, {13384, 5}, {10880, 5}, {12006, 3}, {9740, 5}, {11054, 6}, {11506, 3}, {11278, 1}, {2566, 3},
								{2714, 2}, {2716, 2}, {2710, 3}, {2712, 10}, {3786, 5}, {5726, 5}, {6030, 5}, {6808, 5}
							}; // ne visi
							block_->bbm_d++;
							if (block_->bbm_d >= 10) 
								block_->fg = 8198; // to do: add 10 days time to harvest and after thhat it will become used
							auto vec_r = id_c[rand() % id_c.size()];
							int rand_item = vec_r[0];
							int count_ = vec_r[1];
							WorldDrop new_drop_{};
							new_drop_.id = rand_item, new_drop_.count = count_, new_drop_.uid = uint16_t(world_->drop.size()) + 1, new_drop_.x = (x_ * 32) + rand() % 17, new_drop_.y = (y_ * 32) + rand() % 17;
							if (not use_mag(world_, new_drop_, x_, y_)) dropas_(world_, new_drop_);
							int timed = (items[p_].growTime) / 2;
							// clothing provider time effects
							if (pInfo(peer)->ances == 7166 || pInfo(peer)->affinity_level == 1) timed = (timed * 1.05) - timed;
							if (pInfo(peer)->ances == 7168) timed = (timed * 1.10) - timed;
							if (pInfo(peer)->ances == 7170) timed = (timed * 1.15) - timed;
							if (pInfo(peer)->ances == 7172) timed = (timed * 1.20) - timed;
							if (pInfo(peer)->ances == 7174) timed = (timed * 1.25) - timed;
							if (pInfo(peer)->ances == 9212) timed = (timed * 1.30) - timed;
							timed *= provider_event;
							block_->planted = time(nullptr) - (timed); 
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
							break;
						}
						else if (block_->fg == 8172) { // Item-O-Matic
							ids = { 8174, 8176, 8178, 8180, 8182 };
						}
						else if (block_->fg == 8160) { // Item-O-Matic
							ids = { 8162, 8164, 8166, 8168, 8170 };
						}
						else if (block_->fg == 8148) { // Item-O-Matic
							ids = { 8150, 8152, 8154, 8156, 8158 };
						}
						else if (block_->fg == 8136) { // Item-O-Matic
							ids = { 8138, 8140, 8142, 8144, 8146 };
						}
						else if (block_->fg == 8124) { // Item-O-Matic
							ids = { 8126, 8128, 8130, 8132, 8134 };
						}
						else if (block_->fg == 8112) { // Item-O-Matic
							ids = { 8114, 8116, 8118, 8120, 8122 };
						}
						else if (block_->fg == 8100) { // Item-O-Matic
							ids = { 8102, 8104, 8106, 8108, 8110 };
						}
						else if (block_->fg == 8088) { // Item-O-Matic
							ids = { 8090, 8092, 8094, 8096, 8098 };
						}
						else if (block_->fg == 8076) { // Item-O-Matic
							ids = { 8078, 8080, 8082, 8084, 8086 };
						}
						else if (block_->fg == 11472) { // winterfest 2021 calendar
							ids = { 8802.5, 8800.5, 5428.1, 5430.1, 5432.1, 5434.1, 6956.5, 5446.1, 3584.5, 6414.1, 8480.1, 8554.1, 8210.5, 8534.5, 8664.5, 8262.5, 8976.1, 8278.1, 8280.1, 262.1, 263.1, 8728.1, 8556.1, 1368.10, 8246.1, 5382.2, 9202.1, 6986.1, 1360.5, 1384.1, 7006.1, 2564.5, 8980.1, 6970.1, 3676.1, 8254.5, 5376.1, 5792.1, 8546.1, 8712.5, 7864.1, 8984.1, 7490.1, 7496.1, 7498.1, 10486.1, 10488.1, 10444.1, 10220.1, 10258.1, 7758.1, 9356.10, 7080.1, 7082.1, 7084.1, 7086.1, 7088.1, 7090.1, 7092.1, 7094.1, 7096.1, 10032.1, 5780.1, 8722.1, 9692.1, 7760.1, 7418.1, 7420.1, 7422.1, 8948.1, 8960.1, 10036.1, 10038.1, 10040.1, 10042.1, 10440.1, 9184.1, 7718.1, 6384.1, 11514.1, 11520.1, 11202.1, 11192.1 };
							/*
							struct tm newtime;
							time_t now = time(0);
							localtime_s(&newtime, &now);
							if (today_day == 24) ids = { 11500 };
							if (today_day == 25) ids = { 802, 1758, 8468, 263, 812, 10442, 9370, 8474, 5018, 7752, 8556, 9182, 9184 };*/
						}
						else if (block_->fg == 1636) { // Awkward Friendly Unicorn
							ids = { 728, 360, 308, 306, 2966, 1646, 3170, 1644, 1642, 3524, 1640, 1638, 2582, 3198, 8838, 6794, 10110 };
						}
						else if (block_->fg == 3044) { // Tackle box
							ids = { 2914, 3012, 3014, 3016, 3018, 5528, 5526 };
						}
						else if (block_->fg == 6212) { // Surgical Tool Bag
							ids = { 1258, 1260, 1262, 1264, 1266, 1268, 1270, 4308, 4310, 4312, 4314, 4316, 4318 };
						}
						else if (block_->fg == 6414) { // Star Tool Droid
							ids = { 6520, 6538, 6522, 6528, 6540, 6518, 6530, 6524, 6536, 6534, 6532, 6526, 6416 };
						}
						else if (block_->fg == 928) { // Science station
							ids = { 914,914,914,914,914, 916,916,916,916, 918,918,918, 920,920,924 };
						}
						if (ids.size() != 0) {
							double rand_item = ids[rand() % ids.size()];
							int count_ = 1;
							bool do_rand = true;
							if (to_string(rand_item).find(".") != string::npos) {
								string asd_ = explode(".", to_string(rand_item))[1];
								string s(1, asd_[0]);
								int c_ = atoi(s.c_str());
								if (c_ != 0) {
									if (asd_.size() == 2) {
										do_rand = false;
										c_ /= 10;
									}
									count_ = c_;
								}
							}
							if (count_ > 1 and do_rand)
								count_ = (rand() % count_) + 1;
							int rand_item2 = (int)rand_item;
							WorldDrop new_drop_{};
							new_drop_.id = rand_item2, new_drop_.count = count_, new_drop_.uid = uint16_t(world_->drop.size()) + 1, new_drop_.x = (x_ * 32) + rand() % 17, new_drop_.y = (y_ * 32) + rand() % 17;
							if (not use_mag(world_, new_drop_, x_, y_)) dropas_(world_, new_drop_);
						}
						int timed = (items[p_].growTime) / 2;
						// clothing provider time effects
						if (pInfo(peer)->ances == 7166 || pInfo(peer)->affinity_level == 1) timed = (timed * 1.05) - timed;
						if (pInfo(peer)->ances == 7168) timed = (timed * 1.10) - timed;
						if (pInfo(peer)->ances == 7170) timed = (timed * 1.15) - timed;
						if (pInfo(peer)->ances == 7172) timed = (timed * 1.20) - timed;
						if (pInfo(peer)->ances == 7174) timed = (timed * 1.25) - timed;
						if (pInfo(peer)->ances == 9212) timed = (timed * 1.30) - timed;
						timed = (timed * provider_event);
						block_->planted = time(nullptr) - (timed);
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
				}
				else if (items[block_->fg].blockType == BlockTypes::RANDOM_BLOCK) {
					block_->roll = (rand() % 6);
					punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 0x0, true, block_->roll);
				}
				punch_tile(peer, x_, y_, 0x8, (punch_modifier == 0 ? 6 : (punch_modifier < 0 ? 8 : 5)), pInfo(peer)->netID, 0x0, (block_->roll != 0 ? true : false), (block_->roll != 0 ? block_->roll : 0));
			}
			break;
		}
		case 32:
		{
			if (items[t_].blockType == BlockTypes::LOCK and pInfo(peer)->world == "GROWGANOTH" and pInfo(peer)->admin and (!(pInfo(peer)->owner))) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("You can't wrench anything on this world!");
				p.Insert(0);
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 12272) {
				int ghostKey = 0;
				modify_inventory(peer, 4236, ghostKey);
				if (pInfo(peer)->snackLevel < 1) {
					DialogBuilder builder;

					builder.add_label_icon(true, 982, "`cMaster Ridho")
						.add_smalltext("`2Apakah Kamu Punya Extra Shard!")
						.add_label_icon(false, 486, "`2Berikan Shard Kamuh:");

					builder.add_smalltext("`oWhen you put in a `#Extra Shard`o, there are `$3 `oequally possible outcomes: two different fabulous prizes, or the dreaded third prize of losing all the keys you've put in.")
						.add_spacer(false)
						.add_smalltext("`oEach levels has better prizes than the previous level, but there's always a chance you'll loes all the keys you put in. How far will you push you luck?")
						.add_spacer(false);

					builder.add_smalltext(std::format("`oYou are currently have `${} Digi Gems`o. Would you want to insert your `4Digi Gems`o?", setGems(ghostKey)));

					if (pInfo(peer)->snackLevel != 10) {
						if (ghostKey != 0)
							builder.add_button(pInfo(peer)->snackLevel < 10 ? "insert" : "claim", pInfo(peer)->snackLevel < 10 ? "`wInsert a Digi Gems" : "`wClaim Rewards");
						else
							builder.add_disabled_button(pInfo(peer)->snackLevel < 10 ? "insert" : "claim", pInfo(peer)->snackLevel < 10 ? "`wInsert a Digi Gems" : "`wClaim Rewards");
					}
					builder.add_button(pInfo(peer)->snackLevel == 10 ? "claim" : "rewards", pInfo(peer)->snackLevel == 10 ? "`$Claim Rewards" : "`$Level Rewards")
						.end_dialog("snack_event", "`wCancel", "`wKeep It Up!");

					enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(builder.to_string()).pack());
				}
				else {
					DialogBuilder builder;

					builder.add_label_icon(true, 4498, std::format("`wThe Combiner Prizes `$- Level {}", pInfo(peer)->snackLevel))
						.add_spacer(false);

					builder.add_smalltext(std::format("`oGood Luck! Your current prize is `w{}`o.", snacks::rewards(pInfo(peer)->snackLevel)))
						.add_smalltext("`oYou can either take your prize, or put in another `wDigi Gems `oto move up to the next prize Level hoping for something better")
						.add_spacer(false);

					builder.add_smalltext(std::format("`oYou are currently have `${} Digi Gems`o. Would you want to insert your `cDigi Gems`o?", setGems(ghostKey)));

					if (pInfo(peer)->snackLevel != 10) {
						if (ghostKey != 0)
							builder.add_button("insert", "`wInsert a Digi Gems");
						else
							builder.add_disabled_button("insert", "`wInsert a Digi Gems");
					}

					if (pInfo(peer)->snackLevel >= 1) builder.add_button("claim", "`$Claim Rewards");

					builder.end_dialog("snack_event", "`wCancel", "`wKeep It Up!");

					enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(builder.to_string()).pack());
				}
				break;
			}
			if (t_ == 4210) {
				int ghostKey = 0;
				modify_inventory(peer, 9148, ghostKey);
				if (pInfo(peer)->ghosts.level < 1) {
					DialogBuilder builder;

					builder.add_label_icon(true, 1614, "`wMaster Shifu `$- Pemberian Hadiah")
						.add_smalltext("`oDo you have a `wHalo Gems's`o? So, if you have' it. Stick them to the `wMaster Shifu`o!")
						.add_label_icon(false, 486, "`4Please Read Instructions (below):");

					builder.add_smalltext("`2When you put in a `wHalo Gems`o, there are `$3 `oequally possible outcomes: two different fabulous prizes, or the dreaded third prize of losing all the keys you've put in.")
						.add_spacer(false)
						.add_smalltext("`oEach levels has better prizes than the previous level, but there's always a chance you'll loes all the keys you put in. How far will you push you luck?")
						.add_spacer(false);

					builder.add_smalltext(std::format("`oYou are currently have `${} Halo Gems`o. Would you want to insert your `9Halo Gems`o?", setGems(ghostKey)));

					if (pInfo(peer)->ghosts.level != 10) {
						if (ghostKey != 0)
							builder.add_button(pInfo(peer)->ghosts.level < 10 ? "insert" : "claim", pInfo(peer)->ghosts.level < 10 ? "`wInsert a Halo Gems" : "`wClaim Rewards");
						else
							builder.add_disabled_button(pInfo(peer)->ghosts.level < 10 ? "insert" : "claim", pInfo(peer)->ghosts.level < 10 ? "`wInsert a Halo Gems" : "`wClaim Rewards");
					}
					builder.add_button(pInfo(peer)->ghosts.level == 10 ? "claim" : "rewards", pInfo(peer)->ghosts.level == 10 ? "`$Claim Rewards" : "`$Level Rewards")
						.end_dialog("ghost_event", "`wCancel", "`wKeep It Up!");

					enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(builder.to_string()).pack());
				}
				else {
					DialogBuilder builder;

					builder.add_label_icon(true, 10056, std::format("`wMaster Shifu Prizes `$- Level {}", pInfo(peer)->ghosts.level))
						.add_spacer(false);

					builder.add_smalltext(std::format("`oGood Luck! Your current prize is `w{}`o.", ghosts::rewards(pInfo(peer)->ghosts.level)))
						.add_smalltext("`oYou can either take your prize, or put in another `9Halo Gems `oto move up to the next prize Level hoping for something better")
						.add_spacer(false);

					builder.add_smalltext(std::format("`oYou are currently have `${} Halo Gems`o. Would you want to insert your `9Halo Gems`o?", setGems(ghostKey)));

					if (pInfo(peer)->ghosts.level != 10) {
						if (ghostKey != 0)
							builder.add_button("insert", "`wInsert a Halo Gems");
						else
							builder.add_disabled_button("insert", "`wInsert a Halo Gems");
					}

					if (pInfo(peer)->ghosts.level >= 1) builder.add_button("claim", "`$Claim Rewards");

					builder.end_dialog("ghost_event", "`wCancel", "`wKeep It Up!");

					enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(builder.to_string()).pack());
				}
				break;
			}
			if (t_ == 3898) {
				string user_name = pInfo(peer)->tankIDName;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTelephone``|left|3898|\nadd_textbox|Dial a number to call somebody in Growtopia. Phone numbers have 5 digits, like 12345 (try it - you'd be crazy not to!). Most numbers are not in service!|left|\nadd_text_input|buttonClicked|Phone #||5|\nend_dialog|" + to_string(t_) + "|Hang Up|Dial|\n");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 10656) {
				DialogBuilder builder;

				builder.add_label_icon(true, 1458, "`4Gacha's Your Valentine")
					.add_smalltext("`5REMINDER: `2Lu Bisa Dpt Item Dari Gacha Gampang Bgt Yaitu Donate Rarity Mu Di Well Of Love Dan Kamu Akan Dpt Hadiah")
					.add_spacer(false);

				builder.add_small_font_button("leaderboard", "`8Top Tertinggi Donator")
					.add_small_font_button("stores", "`cTokoh Kamih")
					.add_small_font_button("prize", "`6Hadiah Menarik Yg Bisa Kamu Dapatkan");

				if (pInfo(peer)->owner) {
					builder.add_small_font_button("config", "`bAtur Waktu");
				}

				builder.add_spacer(false);

				builder.add_smalltext("`oAbout Valentine's Wishing:")
					.add_label_icon(false, 6012, std::format("`oTotal Rarity: `w{} rarity`o.", setGems(global::events::valentineRarity)))
					.add_label_icon(false, 1482, std::format("`oTimes Remaining: `w{}`o", global::events::valentineTimers == 0 ? "No Active Events" : Algorithm::second_to_time(global::events::valentineTimers - date_time::get_epoch_time())))
					.add_label_icon(false, 4422, std::format("`oMy Chocolate's: `w{} items`o.", setGems(pInfo(peer)->valentine.chocolates)))
					.add_spacer(false);

				builder.add_smalltext("`o(If you're lucky, you can get `wCustom Rayman's `owith `w0.5% `oof chances)")
					.add_quick_exit()
					.end_dialog("valentine", "", "");

				Algorithm::send_dialog(peer, builder.to_string());
				break;
			}
			if (t_ == 12598) {
				if (block_->shelf_1 != 0) offering_table(peer, block_, "reroll");
				else offering_table(peer, block_);
				break;
			}
			if (t_ == 12986) {
				if (world_->owner_name == pInfo(peer)->tankIDName || pInfo(peer)->admin || guild_access(peer, world_->guild_id) || find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end()) {
					string Day = "";
					Day += "\nadd_button_with_icon|calendarSystem_1|`$Day 1``|" + string(block_->pr >= 1 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_2|`$Day 2``|" + string(block_->pr >= 2 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_3|`$Day 3``|" + string(block_->pr >= 3 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_4|`$Day 4``|" + string(block_->pr >= 4 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_5|`$Day 5``|" + string(block_->pr >= 5 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_6|`$Day 6``|" + string(block_->pr >= 6 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_7|`$Day 7``|" + string(block_->pr >= 7 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_8|`$Day 8``|" + string(block_->pr >= 8 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_9|`$Day 9``|" + string(block_->pr >= 9 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_10|`$Day 10``|" + string(block_->pr >= 10 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_11|`$Day 11``|" + string(block_->pr >= 11 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_12|`$Day 12``|" + string(block_->pr >= 12 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_13|`$Day 13``|" + string(block_->pr >= 13 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_14|`$Day 14``|" + string(block_->pr >= 14 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_15|`$Day 15``|" + string(block_->pr >= 15 ? "noflags|6292||" : "frame|9202||");
					Day += "\nadd_button_with_icon|calendarSystem_16|`$Day 16``|" + string(block_->pr >= 16 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_17|`$Day 17``|" + string(block_->pr >= 17 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_18|`$Day 18``|" + string(block_->pr >= 18 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_19|`$Day 19``|" + string(block_->pr >= 19 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_20|`$Day 20``|" + string(block_->pr >= 20 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_21|`$Day 21``|" + string(block_->pr >= 21 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_22|`$Day 22``|" + string(block_->pr >= 22 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_23|`$Day 23``|" + string(block_->pr >= 23 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_24|`$Day 24``|" + string(block_->pr >= 24 ? "noflags|6292||" : "frame|10486||");
					Day += "\nadd_button_with_icon|calendarSystem_25|`$Day 25``|" + string(block_->pr >= 25 ? "noflags|6292||" : "frame|9202||");
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWinterfest Calendar - 2022``|left|12986|\nadd_textbox|Tap on a button below to view the `2rewards`` available on that day.|left|\nadd_spacer|small|\ntext_scaling_string|Defibrillators|" + Day + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_button|cancel|Close|noflags|0|0|\nend_dialog|wfcalendar_dailyrewards|||\nadd_quick_exit|");
					p.CreatePacket(peer);
				}
			}
			if (t_ == 9498) {
				pInfo(peer)->lastwrenchb = t_;
				if (world_->name == "FISHTOURNAMENT") 
					show_tournament(peer);
			}
			if (t_ == 9158) {
				pInfo(peer)->lastwrenchb = t_;
				DialogBuilder db{ "`o" };
				db.add_label_icon(true, t_, format("`w{}``", items[t_].name)); {
					db.add_image_button("", "news_banner").add_textbox("Available recipes: ");
					for (auto it : basic_craft_info) {
						db.add_label_icon(false, it.result, format("Crafting: {}", items[it.result].name))
							.add_center_button("", to_string(it.item_1.second), it.item_1.first)
							.add_center_button("", to_string(it.item_2.second), it.item_2.first)
							.add_center_button("", to_string(it.item_3.second), it.item_3.first)
							.end_list()
							//.add_spacer(false)
							.add_button(format("craft_{}", it.result), format("{} gems", setGems(it.price)))
							//.end_list()
						    .add_spacer(false);
					}
					db.add_quick_exit()
						.end_dialog("fish_center", "`wClose``", "");
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(db.to_string());
				p.CreatePacket(peer);
			}
			if (t_ == 9156) {
				pInfo(peer)->lastwrenchb = t_;
				bool has_ = false;
				DialogBuilder db{ "`o" };
				db.add_label_icon(true, t_, format("`w{}``", items[t_].name)); {
					db.add_textbox(format("Hello, `w{}``, this is the new way of profit, but before you start, you should follow these rules:", pInfo(peer)->tankIDName))
						.add_textbox("1. Normal fishes can be sold for 1-3 gems / lb. But for perfect one it'll be on different price.")
						.add_textbox("2. Each fishes have different prices (even for perfect and price per lb.)")
						.add_textbox("3. Nothing more i guess, you can just trade your fish. :D")
						.add_textbox("You may see the price list first before trading: ")
						.add_button("price_list", "Fish Prices List")
						.add_textbox("Let's see what do you have: ")
						.add_spacer(false);

					for (int i = 0; i < pInfo(peer)->inv.size(); i++) {
						if (items[pInfo(peer)->inv[i].id].blockType == FISH and items[pInfo(peer)->inv[i].id].mlpr != 0
							and items[pInfo(peer)->inv[i].id].ppl != 0) {
							has_ = true;
							db.add_button(format("sell_fish_{}", pInfo(peer)->inv[i].id), format("Sell {} ({} lb) for {} gems.", items[pInfo(peer)->inv[i].id].name, pInfo(peer)->inv[i].count, setGems(pInfo(peer)->inv[i].count >= items[pInfo(peer)->inv[i].id].fish_max_lb ? items[pInfo(peer)->inv[i].id].mlpr : pInfo(peer)->inv[i].count * items[pInfo(peer)->inv[i].id].ppl)));
						}
					}

					if (has_) {
						db.add_button("sell_all", "Sell all fishes.");
					}

					db.end_dialog("fish_barrel", "`wClose``", "").add_quick_exit();
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(db.to_string());
				p.CreatePacket(peer);
			}
			if (items[t_].blockType == BlockTypes::CRYSTAL) {
				vector<vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
				string mix_with = "";
				for (int i = 0; i < block_->crystals.size(); i++) {
					vector<int> c_ = block_->crystals[i];
					for (int a = 0; a < current_.size(); a++) {
						if (current_[a][0] == c_[0]) {
							current_[a][1] = block_->crystals[i][1];
							break;
						}
					}
				} vector<string> reply{};
				for (int i = 0; i < current_.size(); i++) {
					reply.push_back(to_string(current_[i][1]) + "x `$" + mix_with + (current_[i][0] == 2242 ? "R" : (current_[i][0] == 2244 ? "G" : (current_[i][0] == 2246 ? "B" : (current_[i][0] == 2248 ? "W" : "B")))) + "``");
				}
				vector<string> available_recipes{};
				for (vector<vector<int>> a_ : crystal_receptai) {
					bool can_ = true;
					for (vector<int> b_ : a_) {
						for (int i = 0; i < current_.size(); i++) {
							if (current_[i][0] == b_[0] and current_[i][1] < b_[1]) {
								can_ = false;
								break;
							}
						} if (not can_) {
							break;
						}
					} if (can_) {
						available_recipes.push_back("\nadd_button|" + to_string(a_[5][0]) + "|`$Craft " + items[a_[5][0]].name + "``|noflags|0|0|");
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCrystal Shattering``|left|5104|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|This crystal is currently mixed with " + join(reply, ", ") + ".|left|5274|" + (available_recipes.size() == 0 ? "\nadd_textbox|No recipes are available. Mix more various crystals to see available recipes.|left|" : "\nadd_spacer|small|" + join(available_recipes, "")) + "\nend_dialog|crystal_exchange|Cancel||\n");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].blockType == BlockTypes::DONATION) {
				pInfo(peer)->lastwrenchb = t_;
				WorldBlock block_ = world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * world_->width)];
				string donate_item = "";
				int itemcount = block_.donates.size();
				for (int i_ = 0; i_ < block_.donates.size(); i_++) donate_item += "\nadd_checkbox|" + to_string(itemcount) + "|" + items[block_.donates[i_].item].name + " (`w" + to_string(block_.donates[i_].count) + "``) from `w" + block_.donates[i_].name + "``" + (block_.donates[i_].text != "" ? "`#- \"" + block_.donates[i_].text + "\"``" : "") + "|0";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->staff and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (itemcount != 0 ? "\nadd_textbox|You see `w" + to_string(itemcount) + "`` gift in the box!|left|" : "\nadd_textbox|The box is currently empty.|left|") + "\nadd_textbox|Want to leave a gift for the owner?|left|" + (itemcount >= 20 ? "\nadd_textbox|This box already has `w20`` gifts in it, can't add more until you clear them.|left|" : "\nadd_spacer|small|\nadd_item_picker|itemid|`wGive Gift`` (Min rarity: `52``)|Choose an item to give yourself|") + "\nend_dialog|donation_box_edit|Cancel||\n");
				else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (itemcount == 0 ? "\nadd_textbox|The box is currently empty.|left|" : "\nadd_textbox|You have `w" + to_string(itemcount) + "`` gift waiting:|left|" + donate_item + "\nadd_spacer|small|\nadd_button|clear_selected|`4Retrieve Selected Gifts``|noflags|0|0|\nadd_button|takeall|`4Retrieve All Gifts``|noflags|0|0|") + "" + (itemcount >= 20 ? "\nadd_textbox|This box already has `w20`` gifts in it, can't add more until you clear them.|left|" : "\nadd_spacer|small|\nadd_item_picker|itemid|`wGive Gift`` (Min rarity: `52``)|Choose an item to give yourself|") + "\nend_dialog|donation_box_edit|Cancel||\n");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 1902) {
				pInfo(peer)->lastwrenchb = t_;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|\nadd_label_with_icon|big|`wGolden Ticket Booth|left|1902|\nadd_textbox|`oGolden Tickets cost 100 rarity worth of any items. If you give me extras. I'll keep a record. You can also pay with World Locks. I'll give you 30 Tickets per World Lock.|left|\nadd_spacer|small|\nadd_button|ticket_buy|`9Buy 30 Tickets For 1 World Lock``|noflags|0|0|\nend_dialog|ticket_booth|Thanks for the info|");
				p.CreatePacket(peer);
				//p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGolden Ticket Booth``|left|1902|\nadd_textbox|Golden Tickets cost 100 Rarity worth of any items. If you give me extras, I'll keep a record.|left|\nadd_textbox|You can also pay with World Locks. I'll give you 30 Tickets per World Lock.|left|\nadd_textbox|Just use items on me to give them.|left|\nadd_textbox|You currently have a credit of " + to_string(pInfo(peer)->carnival_credit) + " Rarity.|left|\nend_dialog|ticket_booth|Thanks for the info!||"), p.CreatePacket(peer);
				break;
			}
			if (items[t_].blockType == BlockTypes::BULLETIN_BOARD || items[t_].blockType == BlockTypes::MAILBOX) {
				pInfo(peer)->lastwrenchb = t_;
				string text = "";
				int letters = 0, same = 0;
				bool public_can_add = true, hide_names = false;
				for (int i_ = 0; i_ < world_->bulletins.size(); i_++) if (world_->bulletins[i_].x == x_ and world_->bulletins[i_].y == y_) public_can_add = world_->bulletins[i_].public_can_add, hide_names = world_->bulletins[i_].hide_names;
				for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
					if (world_->bulletin[i_].x == x_ and world_->bulletin[i_].y == y_) {
						if (fixchar(world_->bulletin[i_].name) == pInfo(peer)->tankIDName) same++;
						letters++;
						if (items[t_].blockType == BlockTypes::BULLETIN_BOARD) {
							if (hide_names) text += "\nadd_label|small|`2" + world_->bulletin[i_].text + "``|left|";
							else {
								if (block_access(peer, world_, block_))text += "\nadd_label_with_icon_button|small|" + world_->bulletin[i_].name + ": ```2" + world_->bulletin[i_].text + "``|left|660|edit" + to_string(letters) + "|";
								else text += "\nadd_label_with_icon|small|" + world_->bulletin[i_].name + ": ```2" + world_->bulletin[i_].text + "``|left|660|";
							}
						}
						else text += "\nadd_label_with_icon|small|`#\"" + world_->bulletin[i_].text + "\" - `w" + world_->bulletin[i_].name + "``|left|660|\nadd_spacer|small|";
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (items[t_].blockType == BlockTypes::BULLETIN_BOARD) {
					if (block_access(peer, world_, block_)) p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|" + (letters == 0 ? "\nadd_textbox|The " + items[t_].name + " is empty.|left|" : text) + "\nadd_textbox|Add to conversation?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Add``|noflags|0|0|\nadd_spacer|small|\nadd_label_with_icon|big|`wOwner Options|left|242|\nadd_spacer|small|\nadd_textbox|To remove an individual comment, press the icon to the left of it.|left|\nadd_spacer|small|\nadd_spacer|small|" + (letters == 0 ? "" : "\nadd_button|clear|`4Clear Board``|noflags|0|0|") + "\nadd_checkbox|checkbox_locked|Public can add|" + (public_can_add ? "1" : "0") + "\nadd_checkbox|checkbox_hide|Hide names|" + (hide_names ? "1" : "0") + "\nend_dialog|bulletin_edit|Cancel|OK|\nadd_quick_exit|");
					else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|" + (letters == 0 ? "\nadd_textbox|The " + items[t_].name + " is empty.|left|" : text) + "" + (public_can_add ? (same >= 3 ? "\nadd_textbox|You already have `03`` posts up, take a break!|left|" : "\nadd_textbox|Add to conversation?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Add``|noflags|0|0|") : "") + "\nend_dialog|bulletin_edit|Cancel||\nadd_quick_exit|");
				}
				else {
					if (block_access(peer, world_, block_)) p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (letters == 0 ? "\nadd_textbox|Your mailbox is currently empty.|left|" : "\nadd_textbox|You have `w" + to_string(letters) + "`` letters:|left|\nadd_spacer|small|" + text + "\nadd_spacer|small|\nadd_button|clear|`4Empty Mailbox``|noflags|0|0|") + "" + (letters >= 20 ? "\nadd_textbox|This mailbox already has `w20`` letters in it.  Try again later.|left|" : "\nadd_textbox|Write a letter to yourself?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Send Letter``|noflags|0|0|") + "\nend_dialog|bulletin_edit|Cancel||\nadd_quick_exit|");
					else p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (letters >= 20 ? "\nadd_textbox|This mailbox already has `w20`` letters in it.  Try again later.|left|" : (same >= 3 ? "\nadd_textbox|You've already crammed `w3 ``of your letters into the mailbox, better wait.|left|" : "\nadd_textbox|Want to leave a message for the owner?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Send Letter``|noflags|0|0|")) + "\nend_dialog|bulletin_edit|Cancel||\nadd_quick_exit|");
				}
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 9170) {
				string extra = "";
				if (pInfo(peer)->transmute.size() > 0) extra = "add_smalltext|You have transmuted `2" + to_string(pInfo(peer)->transmute.size()) + "/5`` clothing items.|left|\n"
					"add_button|permanentlist|`wYour Permanent Transmutes``|noflags|0|0|\n"
					"add_spacer|small|\n";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\n"
					"add_label_with_icon|big|`wTransmutabooth``|left|9170|\n"
					"add_spacer|small|\n"
					"add_smalltext|This booth will let you transfer the visuals of one clothing item onto another (of the same slot)!|left|\n"
					"add_smalltext|The transmuted item will keep its properties (and mods!), so have fun and experiment with crazy combos!|left|\n"
					"add_spacer|small|\n"
					+ extra +
					"add_smalltext|Here's where you can permanently change the visuals of clothing!|left|\n"
					"add_button|permanttransmutation|`wTransmutate!``|noflags|0|0|\n"
					"add_spacer|small|\n"
					"add_smalltext|Here's where you can test out transmutations for a short time!|left|\n"
					"add_button|temporaltransmutation|`wTest a Transmute!``|noflags|0|0|\n"
					"add_spacer|small|\n"
					"add_button|transmutationhelp|`wHelp``|noflags|0|0|\n"
					"add_spacer|small|\n"
					"end_dialog|transmutated_device_edit|Close||\n"
					"add_quick_exit|");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 2398) {
				pInfo(peer)->lastwrenchb = t_;
				if (pInfo(peer)->world == "LOCKE" and salesman_open) {
					int wl = 0, dl = 0;
					modify_inventory(peer, 242, wl);
					modify_inventory(peer, 1796, dl);
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (block_access(peer, world_, block_)) p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Locke The Traveling Salesman``|left|2398|\nadd_spacer|small|\nadd_smalltext|Ho there, friend! Locke's my name, and locks are my game. I Love 'em all, Diamond, Huge.. even Small! If you can part with some locks, I'll give you something special in return. Whaddya say?|left|\nadd_spacer|small|\nadd_smalltext|" + (wl + dl != 0 ? "`9(Hmm, smells like you are carrying " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", and " + to_string(dl) + " Diamond Lock" : "") + ")``" : "`9(Hmm, smells like you don't care any world locks)``") + "|left|\nadd_spacer|small|" + shop_list2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
					else p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Locke The Traveling Salesman``|left|2398|\nadd_spacer|small|\nadd_smalltext|Ho there, friend! Locke's my name, and locks are my game. I Love 'em all, Diamond, Huge.. even Small! If you can part with some locks, I'll give you something special in return. Whaddya say?|left|\nadd_spacer|small|\nadd_smalltext|" + (wl + dl != 0 ? "`9(Hmm, smells like you are carrying " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", and " + to_string(dl) + " Diamond Lock" : "") + ")``" : "`9(Hmm, smells like you don't care any world locks)``") + "|left|\nadd_spacer|small|" + shop_list2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
					p.CreatePacket(peer);
					break;
				}
			}
			if (t_ == 4228) {
				int donated, toysgiven;
				readSpecificJSONData("database/growch.json", "total_donated", donated);
				readSpecificJSONData("database/growch.json", "total_toys_given", toysgiven);
				pInfo(peer)->lastwrenchb = t_;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (block_access(peer, world_, block_)) p.Insert(
					"set_default_color|`o\n"
					"add_label_with_icon|big|`wSnack Fu Donator``|left|7076|\n"
					"add_textbox|Selamat Datang Di Snack Fu Kamu Bebas Memberikan Item Nanti Tapi Akan Mendapatkan Item Random|left|\n"
					"add_smalltext|Cara Donate Item Pencet Ke Snack Fu Bukan Di Drop Ya!|left|\n"
					"add_spacer|small|\n"
					"add_smalltext|Total rarity donated: " + setGems(donated) + "|left|\n"
					"add_smalltext|Total item given away: " + setGems(toysgiven) + "|left|\n"
					"add_spacer|small|\n"
					"add_smalltext|You personally donated " + setGems(pInfo(peer)->s4tb) + " rarity|left|\n"
					"add_quick_exit|\n"
					"end_dialog|s4tb|Exit||\n"
				);
				else p.Insert(
					"set_default_color|`o\n"
					"add_label_with_icon|big|`wSnack Fu Donator``|left|7076|\n"
					"add_textbox|Selamat Datang Di Snack Fu Kamu Bebas Memberikan Item Nanti Tapi Akan Mendapatkan Item Random|left|\n"
					"add_smalltext|Cara Donate Item Pencet Ke Snack Fu Bukan Di Drop Ya!|left|\n"
					"add_spacer|small|\n"
				    "add_smalltext|Total rarity donated: " + setGems(donated) + "|left|\n"
					"add_smalltext|Total item given away: " + setGems(toysgiven) + "|left|\n"
					"add_spacer|small|\n"
					"add_smalltext|You personally donated " + setGems(pInfo(peer)->s4tb) + " rarity|left|\n"
					"add_quick_exit|\n"
					"end_dialog|s4tb|Exit||\n"
				);
				p.CreatePacket(peer);
			}
			if (t_ == 1900) {
				pInfo(peer)->lastwrenchb = t_;
				int adaBrp = 0;
				modify_inventory(peer, 1898, adaBrp);
				if (not pInfo(peer)->C_QuestActive and adaBrp >= 10) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (block_access(peer, world_, block_)) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9The Ringmaster``|left|" + to_string(t_) + "|\nadd_smalltext|Come one, come all, to the most extraordinary show in Growtopia! I am the Ringmaster. That means I know a lot about Rings! For 10 Golden Tickets, I might even tell you how you can get a Ring of your own...|left|\nadd_spacer|small|\nadd_button|c_quest|`9Give 10 Golden Tickets``|noflags|0|0|\nadd_spacer|small|\nadd_smalltext|If you had 5 rings of the same type maybe we could have made a deal...|left|\nend_dialog|carnival|Goodbye!||");
					else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9The Ringmaster``|left|" + to_string(t_) + "|\nadd_smalltext|Come one, come all, to the most extraordinary show in Growtopia! I am the Ringmaster. That means I know a lot about Rings! For 10 Golden Tickets, I might even tell you how you can get a Ring of your own...|left|\nadd_spacer|small|\nadd_button|c_quest|`9Give 10 Golden Tickets``|noflags|0|0|\nadd_spacer|small|\nadd_smalltext|If you had 5 rings of the same type maybe we could have made a deal...|left|\nend_dialog|carnival|Goodbye!||");
					p.CreatePacket(peer);
					break;
				}
				else if (not pInfo(peer)->C_QuestActive and adaBrp < 10) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (block_access(peer, world_, block_)) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9The Ringmaster``|left|" + to_string(t_) + "|\nadd_smalltext|Come one, come all, to the most extraordinary show in Growtopia! I am the Ringmaster. That means I know a lot about Rings! For 10 Golden Tickets, I might even tell you how you can get a Ring of your own...|left|\nadd_spacer|small\nadd_spacer|small|\nadd_smalltext|If you had 5 rings of the same type maybe we could have made a deal...|left|\nend_dialog|carnival|Goodbye!||");
					else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9The Ringmaster``|left|" + to_string(t_) + "|\nadd_smalltext|Come one, come all, to the most extraordinary show in Growtopia! I am the Ringmaster. That means I know a lot about Rings! For 10 Golden Tickets, I might even tell you how you can get a Ring of your own...|left|\nadd_spacer|small\nadd_spacer|small|\nadd_smalltext|If you had 5 rings of the same type maybe we could have made a deal...|left|\nend_dialog|carnival|Goodbye!||");
					p.CreatePacket(peer);
					break;
				}
				else {
					SendCarnivalQuest(peer, 0);
					break;
				}
			}
			
			if (t_ == 6016) {
				pInfo(peer)->lastwrenchb = t_;
				bool world_public = false, floating_public = false;
				for (int i_ = 0; i_ < world_->gscan.size(); i_++) if (world_->gscan[i_].x == x_ and world_->gscan[i_].y == y_) {
					if (world_->gscan[i_].world_public) world_public = true;
					if (world_->gscan[i_].floating_public) floating_public = true;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (block_access(peer, world_, block_)) p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|\nadd_textbox|`wThis amazing block can show the stats for the whole world!|left\nadd_spacer|small|\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|worldBlocks|World Blocks|noflags|0|0|\nadd_button|floatingItems|Floating Items|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`wYou can set the stats to be usable by the public.|left\nadd_checkbox|isStatsWorldBlockUsableByPublic|World blocks is usable by public|" + (world_public == false ? "0" : "1") + "\nadd_checkbox|isStatsFloatingItemsUsableByPublic|Floating items is usable by public|" + (floating_public == false ? "0" : "1") + "\nadd_spacer|small|\nend_dialog|statsblock|Cancel|Apply|\n");
				else  p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|" + (floating_public == false and world_public == false ? "\nadd_textbox|`wYou don't have access to this block.|left" : "\nadd_textbox|`wThis amazing block can show the stats for the whole world!|left\nadd_spacer|small|\nadd_textbox|`wWhich stats would you like to view?|left") + "" + (world_public == true ? "\nadd_button|worldBlocks|World Blocks|noflags|0|0|" : "") + "" + (floating_public == true ? "\nadd_button|floatingItems|Floating Items|noflags|0|0|" : "") + "\nadd_spacer|small|\nend_dialog|statsblock|Cancel||\n");
				p.CreatePacket(peer);
			}
			if (items[t_].blockType == BlockTypes::VENDING) {
				if (abs(x_ * 32 - pInfo(peer)->x) > 15 || abs(y_ * 32 - pInfo(peer)->y) > 15) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"); p.Insert("You can only use this in a world that you have world-locked!");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Get closer!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
					break;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(block_access(peer, world_, block_, true) ? get_vending(peer, world_, block_, x_, y_) : get_vending_buyer_side(peer, world_, block_, x_, y_));
				p.CreatePacket(peer);
				break;
			}
			if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
				string owner_name = block_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (owner_name != user_name and not pInfo(peer)->dev) {
					if (items[t_].blockType == BlockTypes::LOCK) {
						if (find(block_->admins.begin(), block_->admins.end(), pInfo(peer)->uid) != block_->admins.end()) {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label|small|This lock is owned by `w" + block_->owner_name + "``, but I have access on it.|left\nend_dialog|lock_edit|Cancel|Remove My Access|");
							p.CreatePacket(peer);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("I'm `4unable`` to pick the lock.");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
						packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						return true;
					}
				}
			}
			else if (block_->locked and items[p_].blockType != BlockTypes::CONSUMABLE) {
				WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
				block2_->owner_name = GetNameByUid(block2_->owner_id);
				string owner_name = block2_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (world_->owner_name != user_name)
				{
					if (owner_name != user_name and not pInfo(peer)->dev) {
						if (find(block2_->admins.begin(), block2_->admins.end(), pInfo(peer)->uid) == block2_->admins.end() and not block2_->open_to_public and not pInfo(peer)->admin) {
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							if (not pInfo(peer)->invis) {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										p.CreatePacket(currentPeer);
									}
								}
							}
							else {
								p.CreatePacket(peer);
							}
							{
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("That area is owned by " + block2_->owner_name);
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
							}
							return true;
						}
						if (items[p_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`w" + block2_->owner_named + "`` allows public building here, but no locks.");
							p.Insert(0);
							p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
							}
							return true;
						}
					}
				}
			}
			else if (not world_->owner_name.empty() and items[p_].blockType != BlockTypes::CONSUMABLE) {
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (owner_name != user_name and not pInfo(peer)->dev) {
					if (items[t_].blockType == BlockTypes::LOCK) {
						if (find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) != world_->admins.end()) {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label|small|This lock is owned by `w" + world_->owner_name + "``, but I have access on it.|left\nend_dialog|lock_edit|Cancel|Remove My Access|");
							p.CreatePacket(peer);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("I'm `4unable`` to pick the lock.");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
						packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						return true;
					}
					if (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end() and not world_->open_to_public and not pInfo(peer)->dev) {
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/punch_locked.wav");
						if (not pInfo(peer)->invis) {
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									p.CreatePacket(currentPeer);
								}
							}
						}
						else {
							p.CreatePacket(peer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("That area is owned by " + world_->owner_name + "``");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
						return true;
					}
					if (items[p_].blockType == BlockTypes::LOCK) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`w" + world_->owner_named + "`` allows public building here, but no locks.");
						p.Insert(0);
						p.Insert(0);
						p.CreatePacket(peer);
						{
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							if (not pInfo(peer)->invis) {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										p.CreatePacket(currentPeer);
									}
								}
							}
							else {
								p.CreatePacket(peer);
							}
						}
						return true;
					}
				}
			} if (world_->owner_name != pInfo(peer)->tankIDName) {
				if (items[t_].magplant or items[t_].item_sucker) {
					switch (t_) {
					case 6948: case 5638: case 6946:
					{
						if (not world_->owner_name.empty()) {
							bool ar_turi_mag = false;
							{
								int c_ = 0;
								if (block_->id != 0) {
									modify_inventory(peer, 5640, c_);
									if (c_ != 0) {
										if (pInfo(peer)->magnetron_x == x_ and pInfo(peer)->magnetron_y == y_ and pInfo(peer)->magnetron_id == block_->id) {
											ar_turi_mag = true;
										}
									}
								}
							}
							bool dont_give = false;
							if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and items[block_->id].blockType != SEED and not items[block_->id].farmable or items[block_->id].rarity == 999 and items[block_->id].blockType != CONSUMABLE) {
								dont_give = true;
							}
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + (block_->id == 0 ? "\nadd_textbox|There is no item selected |left|" : "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|") + (block_->fg == 5638 and not block_->magnetron ? "\nadd_textbox|Building mode: `6DISABLED``|left|" : "\nadd_textbox|Building mode: `5ACTIVE``|left|\nadd_textbox|Use the " + items[5640].name + " to build `2" + items[block_->id].name + "`` directly from the " + items[block_->fg].name + "'s storage.|left|" + (not ar_turi_mag and not dont_give ? "\nadd_button|getplantationdevice|Get Remote|noflags|0|0|" : "") + "") + "\nend_dialog|itemsucker_block|Close||");
							p.CreatePacket(peer);
						}
						break;
					}
					case 6950: case 6952:
					{
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("add_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nadd_smalltext|The device will consume 2300 Gems/hr while active!|left|\nadd_smalltext|Current Fuel = `w" + to_string(block_->pr) + "/8,000``|left|\nend_dialog|autoactionblock|Close||\nadd_quick_exit|");
						p.CreatePacket(peer);
						break;
					}
					}
					if (not items[t_].item_sucker) return true;
				}
			}
			if (items[t_].can_be_changed_two_types) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|boombox_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				else {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_checkbox|checkbox_public|Usable by public|" + (block_->flags & 0x00800000 ? "1" : "0") + "\nadd_checkbox|checkbox_silence|Silenced|" + (block_->flags & 0x02000000 ? "1" : "0") + "\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|boombox_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (items[t_].trickster) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|Rate of fire? (2-20 seconds)|left|\nadd_text_input|often|Seconds:|" + to_string(block_->rate_of_fire) + "|3|\nadd_textbox|Speed of projectiles? (10-250 pixels/second)|left|\nadd_text_input|speed|Speed:|" + to_string(block_->projectile_speed) + "|3|\nadd_checkbox|disable|Disabled|" + (block_->flags & 0x00400000 ? "0" : "1") + "\nadd_smalltext|You can install as many Blaster Blocks (Howlers or Tricksters) as you want in a world, but only 10 projectiles can exist at one time, so don't go crazy!|left|\nend_dialog|blaster|Cancel|Update|");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 5958) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\n"
					"add_label_with_icon|big|`wEpoch Machine``|left|5958|\n"
					"add_spacer|small|\n"
					"embed_data|tilex|" + to_string(x_) + "\n"
					"embed_data|tiley|" + to_string(y_) + "\n"
					"add_textbox|Select your doom:|left|\n"
					"add_checkbox|iceage|Ice Age|" + (block_->epoch_state.first[0] == true ? "1" : "0") + "\n"
					"add_checkbox|volcano|Volcano|" + (block_->epoch_state.first[1] == true ? "1" : "0") + "\n"
					"add_checkbox|islands|Floating Islands|" + (block_->epoch_state.first[2] == true ? "1" : "0") + "\n"
					"add_text_input|cycleTime|Cycle time (minutes):|" + to_string(block_->epoch_state.second) + "|5|\n"
					"end_dialog|epoch_dialog|Cancel|Okay|");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].xeno) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|xenonite_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				else {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|This crystal can either grant or block super powers for all players in your world! Any power that's unchecked will work as normal - people will have the power if they equip an item with it.|left|\nadd_spacer|small|\nadd_checkbox|checkbox_force_dbl|Force Double Jump|" + (world_->X_1 ? "1" : "0") + "\nadd_checkbox|checkbox_block_dbl|Block Double Jump|" + (world_->X_2 ? "1" : "0") + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_hig|Force High Jump|" + (world_->X_3 ? "1" : "0") + "\nadd_checkbox|checkbox_block_hig|Block High Jump|" + (world_->X_4 ? "1" : "0") + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_asb|Force Heat Resist|" + (world_->X_5 ? "1" : "0") + "\nadd_checkbox|checkbox_block_asb|Block Heat Resist|" + (world_->X_6 ? "1" : "0") + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_pun|Force Strong Punch|" + (world_->X_7 ? "1" : "0") + "\nadd_checkbox|checkbox_block_pun|Block Strong Punch|" + (world_->X_8 ? "1" : "0") + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_lng|Force Long Punch|" + (world_->X_9 ? "1" : "0") + "\nadd_checkbox|checkbox_block_lng|Block Long Punch|" + (world_->X_10 ? "1" : "0") + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_spd|Force Speedy|" + (world_->X_11 ? "1" : "0") + "\nadd_checkbox|checkbox_block_spd|Block Speedy|" + (world_->X_12 ? "1" : "0") + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_lngb|Force Long Build|" + (world_->X_13 ? "1" : "0") + "\nadd_checkbox|checkbox_block_lngb|Block Long Build|" + (world_->X_14 ? "1" : "0") + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_spiw|Force Speedy in Water|" + (world_->X_15 ? "1" : "0") + "\nadd_checkbox|checkbox_block_spiw|Block Speedy in Water|" + (world_->X_16 ? "1" : "0") + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_pdmg|Force Punch Damage|" + (world_->X_17 ? "1" : "0") + "\nadd_checkbox|checkbox_block_pdmg|Block Punch Damage|" + (world_->X_18 ? "1" : "0") + "\nadd_spacer|small|\nadd_checkbox|checkbox_block_pwr|Block Use of Powerups|" + (world_->X_19 ? "1" : "0") + "\nend_dialog|xenonite_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (items[t_].mannequin) {
				string ex = "";
				if (block_->mannequin.c_head != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_head) + "|" + items[block_->mannequin.c_head].name + "|0|";
				if (block_->mannequin.c_shirt != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_shirt) + "|" + items[block_->mannequin.c_shirt].name + "|0|";
				if (block_->mannequin.c_pants != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_pants) + "|" + items[block_->mannequin.c_pants].name + "|0|";
				if (block_->mannequin.c_feet != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_feet) + "|" + items[block_->mannequin.c_feet].name + "|0|";
				if (block_->mannequin.c_mask != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_mask) + "|" + items[block_->mannequin.c_mask].name + "|0|";
				if (block_->mannequin.c_hand != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_hand) + "|" + items[block_->mannequin.c_hand].name + "|0|";
				if (block_->mannequin.c_back != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_back) + "|" + items[block_->mannequin.c_back].name + "|0|";
				if (block_->mannequin.c_hair != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_hair) + "|" + items[block_->mannequin.c_hair].name + "|0|";
				if (block_->mannequin.c_neck != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_neck) + "|" + items[block_->mannequin.c_neck].name + "|0|";
				if (not ex.empty()) ex += "\nadd_spacer|small|\nadd_button|clear_selected|`4Remove Selected Items``|noflags|0|0|\nadd_button|clear|`4Remove All Items``|noflags|0|0|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|To dress, select a clothing item then use on the mannequin. To remove clothes, punch it or select which item to remove.<CR><CR>It will go into your backpack if you have room.|" + ex + "\nadd_textbox|<CR><CR>What would you like to write on its sign?``|left|\nadd_text_input|sign_text||" + block_->txt + "|128|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|mannequin_edit|Cancel|OK|");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].dshelf) {
				bool can_take = (block_->shelf_1 != 0 or block_->shelf_2 != 0 or block_->shelf_3 != 0 or block_->shelf_4 != 0 ? true : false);
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\n" + (block_->shelf_2 != 0 ? "add_item_picker|replace2|Item 1: `2" + items[block_->shelf_2].name + "``|Select any item to display|" : "add_item_picker|replace2|`4Display an item``|Select any item to display|") + "\n" + (block_->shelf_1 != 0 ? "add_item_picker|replace1|Item 2: `2" + items[block_->shelf_1].name + "``|Select any item to display|" : "add_item_picker|replace1|`4Display an item``|Select any item to display|") + "\n" + (block_->shelf_3 != 0 ? "add_item_picker|replace3|Item 3: `2" + items[block_->shelf_3].name + "``|Select any item to display|" : "add_item_picker|replace3|`4Display an item``|Select any item to display|") + "\n" + (block_->shelf_4 != 0 ? "add_item_picker|replace4|Item 4: `2" + items[block_->shelf_4].name + "``|Select any item to display|" : "add_item_picker|replace4|`4Display an item``|Select any item to display|") + (can_take ? "\nadd_button|remove|Take All Items|noflags|0|0|" : "") + "\nend_dialog|dispshelf|Okay||");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].vipentrance) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|vip_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				else {
					string add_ = "";
					for (auto own : block_->admins) {
						try {
							ifstream ifs("database/players/" + GetNameByUid(own)+"_.json");
							if (ifs.is_open()) {
								string name_ = "";
								json j;
								ifs >> j;
								if (j["vip"] == 1) name_ = "`1[VIP] " + GetNameByUid(own);
								if (j["vvip"] == 1) name_ = "`9[VVIP] " + GetNameByUid(own);
								if (j["glory"] == 1) name_ = "`c[GLORY] " + GetNameByUid(own);
								if (j["mod"] == 1) name_ = "`#@" + GetNameByUid(own);
								if (j["supermod"] == 1) name_ = "`b@" + GetNameByUid(own);
								if (j["admin"] == 1) name_ = "`8@" + GetNameByUid(own);
								if (j["dev"] == 1) name_ = "`6@" + GetNameByUid(own);
								if (is_reseller(j["userID"].get<int>()) and j["hide_reseller"].get<bool>() == false) name_ += " `c[RESELLER]";
								add_ += "\nadd_checkbox|checkbox_" + to_string(own) + "|" + name_ + "``|1";
							}
							ifs.close();
						}
						catch (exception) {
							continue;
						}
					}
					if (add_.empty()) add_ = "\nadd_label|small|Nobody!|left";
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wVIP list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + add_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to enter|" + (block_->limit_admins ? "1" : "0") + "\nend_dialog|vip_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (items[t_].portrait) {
				bool has_enough = false;
				int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
				{
					modify_inventory(peer, 3478, red);
					modify_inventory(peer, 3480, yellow);
					modify_inventory(peer, 3482, green);
					modify_inventory(peer, 3484, aqua);
					modify_inventory(peer, 3486, blue);
					modify_inventory(peer, 3488, purple);
					modify_inventory(peer, 3490, charcoal);
					modify_inventory(peer, 3492, varnish);
					if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
						has_enough = true;
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string erase = (varnish >= 4 ? "\nadd_button|erase|Erase Painting|noflags|0|0|\nadd_smalltext|`5(Erasing costs 4 Paint Bucket - Varnish)``|left|" : "\nadd_textbox|You'll need 4 Paint Bucket - Varnish to erase this.|left|");
				string tratata = (has_enough ? "\nadd_player_picker|playerNetID|`wPaint Someone``|\nadd_smalltext|`5(Painting costs 2 Paint Bucket of each color)``|left|" : "\nadd_textbox|You'll need 2 of each color of Paint Bucket to paint someone.|left|");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "" + (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0 ? ("\nadd_textbox|The canvas is blank.|left|" + tratata) : "\nadd_textbox|This is a lovely portrait of a Growtopian.|left|" + erase + "\nadd_text_input|artname|Title:|" + block_->txt + "|60|\nadd_smalltext|If you'd like to touch up the painting slightly, you could change the expression:|left|\nadd_checkbox|chk1|Unconcerned|" + (block_->portrait.c_expression == 1 ? "1" : "0") + "|\nadd_checkbox|chk2|Happy|" + (block_->portrait.c_expression == 2 ? "1" : "0") + "|\nadd_checkbox|chk3|Sad|" + (block_->portrait.c_expression == 3 ? "1" : "0") + "|\nadd_checkbox|chk4|Tongue Out|" + (block_->portrait.c_expression == 4 ? "1" : "0") + "|\nadd_checkbox|chk5|Surprised|" + (block_->portrait.c_expression == 5 ? "1" : "0") + "|\nadd_checkbox|chk6|Angry|" + (block_->portrait.c_expression == 6 ? "1" : "0") + "|\nadd_checkbox|chk7|Talking|" + (block_->portrait.c_expression == 7 ? "1" : "0") + "|\nadd_checkbox|chk9|Ecstatic|" + (block_->portrait.c_expression == 9 ? "1" : "0") + "|\nadd_checkbox|chk11|Wry|" + (block_->portrait.c_expression == 11 ? "1" : "0") + "|\nadd_checkbox|chk12|Sleeping|" + (block_->portrait.c_expression == 12 ? "1" : "0") + "|\nadd_checkbox|chk14|Winking|" + (block_->portrait.c_expression == 14 ? "1" : "0") + "|\nadd_checkbox|chk16|Trolling|" + (block_->portrait.c_expression == 16 ? "1" : "0") + "\nadd_checkbox|chk18|Vampire|" + (block_->portrait.c_expression == 18 ? "1" : "0") + "\nadd_checkbox|chk22|Underwater|" + (block_->portrait.c_expression == 22 ? "1" : "0") + "\nadd_checkbox|chk27|What|" + (block_->portrait.c_expression == 27 ? "1" : "0") + "\nadd_checkbox|chk28|Blushed|" + (block_->portrait.c_expression == 28 ? "1" : "0") + "|") + "\nend_dialog|portrait|Cancel|Update|");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 4080) {
				if (pInfo(peer)->DNAInput == 0) {
					SendDNAProcessor(peer, x_, y_, false, false, false, 0, false, false);
				}
				else if (pInfo(peer)->DNAInput >= 1) {
					SendDNAProcessor(peer, x_, y_, false, true, false, 0, true, false);
				}
				break;
			}
			if (t_ == 5086) {
				SendAncestralUpdateChoose(peer);
				break;
			}
			if (t_ == 4124) {
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
				p.Insert("This appears to be a standard model DNA Extractor. I could use items with ancient DNA on it to try to extract some.");
				p.Insert(0), p.Insert(1);
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 2452) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wClothing Compactor``|left|2452|\nadd_textbox|Use (almost) any clothing on this device to crush it down, permanently destroying it. If you just have extra clothes taking up space, crush 'em!|left|\nadd_textbox|The results may surprise you! But probably you will get seeds or gems.|left|\nend_dialog|compactor|Thanks for the info!||");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 4322) {
				string tools = "";
				for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].count >= 20 && pInfo(peer)->inv[i_].id == 1258 || pInfo(peer)->inv[i_].id == 1260 || pInfo(peer)->inv[i_].id == 1262 || pInfo(peer)->inv[i_].id == 1264 || pInfo(peer)->inv[i_].id == 1266 || pInfo(peer)->inv[i_].id == 1268 || pInfo(peer)->inv[i_].id == 1270 || pInfo(peer)->inv[i_].id == 4308 || pInfo(peer)->inv[i_].id == 4310 || pInfo(peer)->inv[i_].id == 4312 || pInfo(peer)->inv[i_].id == 4314 || pInfo(peer)->inv[i_].id == 4316 || pInfo(peer)->inv[i_].id == 4318) tools += "\nadd_button_with_icon|tool" + to_string(pInfo(peer)->inv[i_].id) + "|`$" + items[pInfo(peer)->inv[i_].id].ori_name + "``|noflags|" + to_string(pInfo(peer)->inv[i_].id) + "|" + to_string(pInfo(peer)->inv[i_].count) + "|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Autoclave``|left|4322|\nadd_spacer|small|\nadd_textbox|With this device, you can exchange 20 of any one surgical tool for 1 each of all the other tools. Choose an instrument to dispose of:|left|" + (tools != "" ? "\ntext_scaling_string|Surgical Defibrillator|" + tools + "\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nend_dialog|autoclave|Cancel||");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].easel) {
				bool has_enough = false;
				int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
				{
					modify_inventory(peer, 3478, red);
					modify_inventory(peer, 3480, yellow);
					modify_inventory(peer, 3482, green);
					modify_inventory(peer, 3484, aqua);
					modify_inventory(peer, 3486, blue);
					modify_inventory(peer, 3488, purple);
					modify_inventory(peer, 3490, charcoal);
					modify_inventory(peer, 3492, varnish);
					if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
						has_enough = true;
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|The canvas is blank.|left|" + (block_->id != 0 ? "\nadd_textbox|This is a lovely still-life of " + items[block_->id].name + ".|left|" + (varnish < 4 ? "\nadd_smalltext|You'll need 4 Paint Bucket - Varnish to erase this.|left|" : "\nadd_button|erase|Erase Painting|noflags|0|0|\nadd_smalltext|`5(Erasing costs 4 Paint Bucket - Varnish)``|left|") : (not has_enough ? "\nadd_textbox|You'll need 2 of each color of Paint Bucket to paint something.|left|" : "\nadd_item_picker|paint|`wPaint Something``|Select an item to paint|")) + "\nadd_text_input|artname|Signed:|" + block_->txt + "|60|\nend_dialog|artcanvas|Cancel|Update|");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].audio_rack) {
				pInfo(peer)->lastwrenchb = t_;
				DialogBuilder db{ "`o" };
				db.add_label_icon(true, t_, "`w" + items[t_].name + "``")
					.add_spacer(false)
					.add_button("audio_instruction", "Instructions")
					.add_spacer(false)
					.add_input(3, "audio_volume", "Volume", to_string(block_->audio_volume))
					.add_input(30, "audio_notes", "Note", block_->audio_notes)
					.end_dialog("audio_rack", "`wCancel``", "`wUpdate``");
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert(db.to_string()), p.CreatePacket(peer);
			}
			if (items[t_].entrance or items[t_].can_be_changed_to_public) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|switcheroo_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				else {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_checkbox|checkbox_public|" + (items[t_].can_be_changed_to_public ? "Usable by public" : "Is open to public") + "|" + (block_->flags & 0x00800000 ? "1" : "0") + "\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|switcheroo_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (t_ == 1436 || t_ == 8246 || t_ == 10258) {
				pInfo(peer)->lastwrenchb = t_;
				string logs = "", settings = "", a = "";
				bool show_item_taking = false, show_item_dropping = false, show_people_entering = false, show_people_exiting = false, dont_show_owner = false, dont_show_admins = false, dont_show_noaccess = false;
				for (int i_ = 0; i_ < world_->cctv.size(); i_++) if (world_->cctv[i_].x == x_ and world_->cctv[i_].y == y_) logs += world_->cctv[i_].logs;
				for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) if (world_->cctv_settings[i_].x == x_ and world_->cctv_settings[i_].y == y_) settings = a + "\nadd_checkbox|checkbox_showpick|Show Item Taking|" + (world_->cctv_settings[i_].show_item_taking ? "1" : "0") + "\nadd_checkbox|checkbox_itemdrop|Show Item Dropping|" + (world_->cctv_settings[i_].show_item_dropping ? "1" : "0") + "\nadd_checkbox|checkbox_showenter|Show People Entering|" + (world_->cctv_settings[i_].show_people_entering ? "1" : "0") + "\nadd_checkbox|checkbox_showexit|Show People Exiting|" + (world_->cctv_settings[i_].show_people_exiting ? "1" : "0") + "\nadd_checkbox|checkbox_noshowowner|Don't Show Owner|" + (world_->cctv_settings[i_].dont_show_owner ? "1" : "0") + "\nadd_checkbox|checkbox_noshowadmin|Don't Show Admins|" + (world_->cctv_settings[i_].dont_show_admins ? "1" : "0") + "\nadd_checkbox|checkbox_noshowother|Don't Show People Without Access|" + (world_->cctv_settings[i_].dont_show_noaccess ? "1" : "0");
				if (settings == "") {
					WorldCCTVSettings cctvs_{};
					cctvs_.x = pInfo(peer)->lastwrenchx, cctvs_.y = pInfo(peer)->lastwrenchy;
					cctvs_.show_item_taking = false, cctvs_.show_item_dropping = false, cctvs_.show_people_entering = true, cctvs_.show_people_exiting = false, cctvs_.dont_show_owner = dont_show_owner == 1 ? true : false, cctvs_.dont_show_admins = false, cctvs_.dont_show_noaccess = false;
					world_->cctv_settings.push_back(cctvs_);
					WorldCCTV cctv_{};
					cctv_.x = pInfo(peer)->lastwrenchx, cctv_.y = pInfo(peer)->lastwrenchy;
					cctv_.logs = "";
					world_->cctv.push_back(cctv_);
					settings = "\nadd_checkbox|checkbox_showpick|Show Item Taking|0\nadd_checkbox|checkbox_itemdrop|Show Item Dropping|0\nadd_checkbox|checkbox_showenter|Show People Entering|1\nadd_checkbox|checkbox_showexit|Show People Exiting|0\nadd_checkbox|checkbox_noshowowner|Don't Show Owner|0\nadd_checkbox|checkbox_noshowadmin|Don't Show Admins|0\nadd_checkbox|checkbox_noshowother|Don't Show People Without Access|0";
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|" + (logs == "" ? "\nadd_textbox|The camera log is empty.|left|" : logs) + "" + settings + "" + (logs != "" ? "\nadd_button|clear|`4Clear Log``|noflags|0|0|" : "") + "\nend_dialog|camera_edit||OK|\nadd_quick_exit|");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 4296 || t_ == 8558) {
				if (has_playmod(pInfo(peer), "Malpractice")) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("I know it's just a robot, but the authorities don't even trust you operating on that with your malpractice issues.");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->lastwrenchb = t_;
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nadd_smalltext|Surgeon Skill: " + to_string(pInfo(peer)->surgery_skill) + "|left|\nadd_textbox|Are you sure you want to perform surgery on this robot? Whether you succeed or fail, the robot will be destroyed in the process.|left|\nend_dialog|surge|Cancel|Okay!|"), p.CreatePacket(peer);
				}
				break;
			}
			if (items[t_].kranken) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(
					"set_default_color|`o\n"
					"add_label_with_icon|big|`wKranken's Galactic Block``|left|10962|\n"
					"add_spacer|small|\n"
					"add_custom_textbox|`wAdjust the color of your block here, by including 0-255 of Red, Green and Blue.`|size:medium|\n"
					"add_text_input|kranken_r|Red|" + to_string(block_->r) + "|3|\n"
					"add_text_input|kranken_g|Green|" + to_string(block_->g) + "|3|\n"
					"add_text_input|kranken_b|Blue|" + to_string(block_->b) + "|3|\n"
					"add_spacer|small|\n"
					"add_custom_textbox|`wPick one of the available patterns for your block.`|size:medium|\n"
					"add_button_with_icon|kranken_block_pattern|||" + to_string(kranken_pattern::get_pattern(block_->kranken_pattern).second) + "||\n"
					"add_button_with_icon||END_LIST|noflags|0||\n"
					"add_checkbox|kranken_world_save|Set this color as the default for this world.|0\n"
					"end_dialog|kranken_edit|Cancel|Save|\n"
					"add_quick_exit|\n"
					"embed_data|tilex|" + to_string(x_) + "|\n"
					"embed_data|tiley|" + to_string(y_) + "|\n"
					"embed_data|pattern|" + to_string(block_->kranken_pattern) + "|"
				);
				p.CreatePacket(peer);
			}
			if (t_ == 10058) {
				string weather_list = "";
				for (int i_ = 0; i_ < block_->weatherListID.size(); i_++) weather_list += "\nadd_label_with_icon_button|small|" + items[block_->weatherListID[i_]].name + "|left|" + to_string(block_->weatherListID[i_]) + "|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nadd_smalltext|Add weather machines from your inventory to be able to cycle through them automatically.<CR>Never have the same weather every day again|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "|" + (block_->weatherListID.size() != 0 ? weather_list : "") + "\nadd_text_input|cycletime|Cycle time (minutes):|" + to_string(block_->epoch_cycle) + "|5|\nadd_spacer|big|\nadd_item_picker|choose|Add Weather Machine!``|Choose the Weather Machine you want to add!|\nadd_button|rweatherlist|Remove Weather Machines|\nend_dialog|weatherInfinity|Cancel|Save|");
				p.CreatePacket(peer);
				break;
			}

			else if (t_ == 4358) {
				gamepacket_t p;
				string care = "";
				//get_wl_value(peer, care);
				p.Insert("OnDialogRequest"), p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9GTPS Salesman``|left|4358|\nadd_spacer|small|\nadd_image_button||interface/large/salesman_open.rttex||||\nadd_smalltext|Ho there, friend! Locke's my name, and locks are my game. I Love 'em all, Diamond, Huge.. even Small! If you can part with some locks, I'll give you something special in return. Whaddya say?|left|\nadd_spacer|small|" + care + "\nadd_spacer|small|" + shop_list2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
				p.CreatePacket(peer);
			}
			if (t_ == 1790) {
				if (pInfo(peer)->lastquest == "" || !pInfo(peer)->quest_active) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9The Legendary Wizard``|left|" + to_string(t_) + "|\nadd_textbox|`oGreetings, traveler! I am the Legendary Wizard. Should you wich to embark on a Legendary Quest, simply choose one below.|\nadd_spacer|small|\nadd_button|honor|`9Quest For Honor|noflags|0|0|\nadd_button|fire|`9Quest For Fire|noflags|0|0|/\nadd_button|steel|`9Quest Of Steel|noflags|0|0|\nadd_button|Ruler Sword|`bQuest Of The `4Ruler Sword|13560|0|0|\nadd_button|blade|`9Quest For The Blade|noflags|0|0|\nadd_button|candour|`9Quest For Candour|noflags|0|0|\nadd_button|thesky|`9Quest For The Sky|noflags|0|0|\nadd_button|theowl|`9Quest Of The Owl|noflags|0|0|\nadd_button|mech|`9Quest Of The Mech|noflags|0|0|"
						//"\nadd_button|zodiac|`9Quest Of The Constellation|noflags|0|0|"
						"\nend_dialog|legendary_wizard|No Thanks||\n");
					p.CreatePacket(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "honor") {
					send_QuestView_honor(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "fire") {
					send_QuestView_fire(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "steel") {
					send_QuestView_steel(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "heavens") {
					send_QuestView_heavens(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "Ruler Sword") {
					send_QuestView_kamish(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "blade") {
					send_QuestView_blade(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "candour") {
					send_QuestView_candour(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "thesky") {
					send_QuestView_thesky(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "theowl") {
					send_QuestView_theowl(peer);
					break;
				}
				else if (pInfo(peer)->lastquest == "mech") {
					send_QuestView_mech(peer);
					break;
				}
				/*
				else if (pInfo(peer)->lastquest == "zodiac") {
					send_QuestView_zodiac(peer);
					break;
				}
				*/
			}
			if (t_ == 4582) {
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFood Grinder``|left|4582|\nadd_textbox|Use items on here to try to grind them up into tasty food. Only certain things can be ground up.|left|\nadd_textbox|You might be surprised what you can grind!|left|\nend_dialog|grinder|Thanks for the info!||"), p.CreatePacket(peer);
				break;
			}
			if (t_ == 6142) {
				pInfo(peer)->lastwrenchb = t_;
				string name_ = pInfo(peer)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * world_->width)];
					string foundlist = "";
					gamepacket_t p;
					for (int it = 0; it < world_->drop.size(); it++) {
						if (world_->drop[it].id != 0 && world_->drop[it].id != 112) {
							if (block_->flags & 0x00200000) {
								if (world_->drop[it].x == 0 && world_->drop[it].y == 0) continue;
								if (world_->drop[it].x / 32 == (x_ - 1) && world_->drop[it].y / 32 == y_ || world_->drop[it].x / 32 == (x_ - 2) && world_->drop[it].y / 32 == y_ || world_->drop[it].x / 32 == (x_ - 3) && world_->drop[it].y / 32 == y_) {
									foundlist += to_string(world_->drop[it].id) + "," + to_string(world_->drop[it].count) + "," + to_string(world_->drop[it].uid) + ",";
								}
							}
							else {
								if (world_->drop[it].x == 0 && world_->drop[it].y == 0) continue;
								if (world_->drop[it].x / 32 == (x_ + 1) && world_->drop[it].y / 32 == y_ || world_->drop[it].x / 32 == (x_ + 2) && world_->drop[it].y / 32 == y_ || world_->drop[it].x / 32 == (x_ + 3) && world_->drop[it].y / 32 == y_) {
									foundlist += to_string(world_->drop[it].id) + "," + to_string(world_->drop[it].count) + "," + to_string(world_->drop[it].uid) + ",";
								}
							}
						}
					}
					if (foundlist != "") p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wExtractor Dynamo``|left|6142|\nadd_spacer|small|\nadd_textbox|GrowTech: use the Extractor Dynamo to pick out the items from the floating items in your world! - Thanks, Technician Dave.|left|\nadd_spacer|small|\nadd_textbox|Press on the icon to extract the item into your inventory.|left|\nadd_spacer|small|\nadd_textbox|`wItem List:|left|\nadd_label_with_icon_button_list|small|`w%s x %s|left|extractOnceObj_|itemID_itemAmount_worldObj|" + foundlist + "\nadd_spacer|small|\nend_dialog|dynamo_extractor|Close||");
					else p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("There are no floating items in the extraction area!");
					p.CreatePacket(peer);
				}
				break;
			}
			if (t_ == 2646) {
				if (block_->spotlight != "") {
					string spotlight = "";
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						if (block_->spotlight == pInfo(currentPeer)->tankIDName) spotlight = pInfo(currentPeer)->tankIDName;
					}
					block_->spotlight = spotlight;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wShine the Spotlight!``|left|2646|\nadd_spacer|small|\nadd_textbox|" + (block_->spotlight == "" ? "The light is currently off." : "The light is shining on " + block_->spotlight + ".") + "|left|\nadd_spacer|small|\nadd_player_picker|ID|`wChoose a " + (block_->spotlight == "" ? "superstar" : "new star") + "``|" + (block_->spotlight == "" ? "" : "\nadd_button|off|Turn it off|noflags|0|0|") + "\nend_dialog|2646|Nevermind||"), p.CreatePacket(peer);
				break;
			}
			if (items[t_].magplant or items[t_].item_sucker) {
				switch (t_) {
				case 6948: case 5638: case 6946:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(get_sucker(peer, world_, block_, x_, y_));
					p.CreatePacket(peer);
					break;
				}
				/*
					case 6950: case 6952:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("add_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nadd_smalltext|The device will consume 2300 Gems/hr while active!|left|\nadd_smalltext|Current Fuel = `w" + to_string(block_->pr) + "/8,000``|left|" + (block_->pr < 8000 ? "\nadd_smalltext|Refuel this with gems!|left|\nadd_text_input|refillfuel|Add Gems:|0|5|\nadd_button|addfuel|`wAdd Gems``|noflags|0|0|" : "") + "\nadd_spacer|small|\nadd_smalltext|" + (block_->id == 0 ? "No block type selected!" : "Target block is: `2" + items[block_->id].name + "``") + "|left|\nadd_item_picker|selecttarget|`wChoose Target Item``|Choose the target item!|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|autoactionblock|Close|OK|\nadd_quick_exit|");
					p.CreatePacket(peer);
					break;
				}
				*/
				}
				break;
			}
			switch (items[t_].blockType) {
			case BlockTypes::WEATHER:
			{
				switch (t_) {
				case 3694:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|Adjust the color of your heat wave here, by including 0-255 of Red, Green, and Blue.|left|\nadd_text_input|red|Red|" + to_string(block_->r) + "|3|\nadd_text_input|green|Green|" + to_string(block_->g) + "|3|\nadd_text_input|blue|Blue|" + to_string(block_->b) + "|3|\nend_dialog|weatherspcl|Cancel|Okay|");
					p.CreatePacket(peer);
					break;
				}
				case 5000:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|You can scan any Background Block to set it up in your weather machine.|left|\nadd_item_picker|choose|Item: `2" + items[(block_->id != 0 ? block_->id : 14)].name + "``|Select any Background Block|\nend_dialog|weatherspcl|Cancel|Okay|");
					p.CreatePacket(peer);
					break;
				}
				case 3832:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_item_picker|choose|Item: `2" + items[(block_->id != 0 ? block_->id : 14)].name + "``|Select any item to rain down|\nadd_text_input|gravity|Gravity:|" + to_string(block_->gravity) + "|5|\nadd_checkbox|spin|Spin Items|" + (block_->spin ? "1" : "0") + "\nadd_checkbox|invert|Invert Sky Colors|" + (block_->invert ? "1" : "0") + "\nend_dialog|weatherspcl|Cancel|Okay|");
					p.CreatePacket(peer);
					break;
				}
				}
				break;
			}
			case BlockTypes::DISPLAY:
			{
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|" + (block_->id != 0 ? "A " + items[block_->id].ori_name + " is on display here." : "The Display Block is empty. Use an item on it to display the item!") + "|left|" + (block_->id != 0 and user_name == owner_name or owner_name.empty() ? "\nend_dialog|displayblock|Leave it|Pick it up|" : "\nend_dialog|displayblock|Okay||"));
				p.CreatePacket(peer);
				break;
			}
			case BlockTypes::LOCK:
			{
				if (t_ == 202 or t_ == 204 or t_ == 206 or t_ == 4994) {
					string access_list_ = "";
					for (int i_ = 0; i_ < block_->admins.size(); i_++) {
						access_list_ += "\nadd_checkbox|checkbox_/" + to_string(block_->admins[i_]) + "|`w" + GetNameByUid(block_->admins[i_]) + "``|1";
					}
					if (access_list_.empty())
						access_list_ = "\nadd_label|small|Currently, you're the only one with access.``|left";
					if (t_ == 4994) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wAccess list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to Build or Break|" + (block_->open_to_public ? "1" : "0") + "\nadd_checkbox|checkbox_ignore|Ignore empty air|" + (block_->empty_air ? "1" : "0") + "\nadd_button|recalcLock|`wRe-apply lock``|noflags|0|0|\nadd_spacer|small|\nadd_smalltext|This lock allows Building or Breaking.|left|\nadd_smalltext|(ONLY if 'Allow anyone to Build or Break' is checked above)!|left|\nadd_spacer|small|\nadd_smalltext|Leaving this box unchecked only allows Breaking.|left|\nadd_checkbox|checkbox_buildonly|Only Allow Building!|" + (block_->build_only ? "1" : "0") + "\nadd_smalltext|People with lock access can both build and break unless you check below. The lock owner can always build and break.|left|\nadd_checkbox|checkbox_admins|Admins Are Limited|" + (block_->limit_admins ? "1" : "0") + "\nend_dialog|lock_edit|Cancel|OK|");
						p.CreatePacket(peer);
					}
					else {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wAccess list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to Build and Break|" + (block_->open_to_public ? "1" : "0") + "\nadd_checkbox|checkbox_ignore|Ignore empty air|" + (block_->empty_air ? "1" : "0") + "\nadd_button|recalcLock|`wRe-apply lock``|noflags|0|0|\nend_dialog|lock_edit|Cancel|OK|");
						p.CreatePacket(peer);
					}
				}
				else {
					if (t_ == 5814 and world_->guild_id != 0) {
						send_edit_lock(peer, world_, t_, x_, y_);
					}
					else {
						string access_list_ = "";
						for (int i_ = 0; i_ < world_->admins.size(); i_++) {
							access_list_ += "\nadd_checkbox|checkbox_/" + to_string(world_->admins[i_]) + "|`w" + GetNameByUid(world_->admins[i_]) + "``|1";
						}
						if (access_list_.empty())
							access_list_ = "\nadd_label|small|Currently, you're the only one with access.``|left";
						string world_key = "\nadd_button|getKey|Get World Key|noflags|0|0|";
						int c_ = 0;
						modify_inventory(peer, 1424, c_);
						if (c_ != 0) {
							world_key = "";
						}
						string extra = "";
						if (pInfo(peer)->lock == 8470)
							extra = format("\nadd_checkbox|checkbox_noclip|Allow /ghost (noclip) for moderators|{}", (world_->allow_noclip ? "1" : "0"));
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						string e_ = "";
						//" + (t_ == 4802 ? "\nadd_label|small|Ye Royal Options|left\nadd_checkbox|checkbox_silence|Silence, Peasants!|" + e_ + (world_->silence ? "1" : "0") + "\nadd_checkbox|checkbox_rainbows|Royal Rainbows!|" + (world_->rainbows ? "1" : "0") : "") + "
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wAccess list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to Build and Break|" + (world_->open_to_public ? "1" : "0") +
							"\nadd_checkbox|checkbox_vending|Allow admins to edit vending|" + (world_->v_p ? "1" : "0")
							+ "\nadd_checkbox|checkbox_cheat_antibounce|Disallow antibounce cheat|" + (world_->no_antibounce ? "1" : "0")
							+ extra + "\nadd_checkbox|checkbox_disable_music|Disable Custom Music Blocks|" + (world_->disable_music_blocks ? "1" : "0") + "\nadd_text_input|tempo|Music BPM|" + to_string(world_->music_bpm) + "|3|\nadd_checkbox|checkbox_disable_music_render|Make Custom Music Blocks invisible|" + (world_->make_music_blocks_invisible ? "1" : "0") + (not pInfo(peer)->home_world.empty() ? "\nadd_smalltext|Your current home world is: " + pInfo(peer)->home_world + "|left|" : "") + "\nadd_checkbox|checkbox_set_as_home_world|Set as Home World|" + (pInfo(peer)->home_world == world_->name ? "1" : "0") + (t_ == 4802 ? "\nadd_label|small|Royal Options|left\nadd_checkbox|checkbox_silence|Silence, Peasants!|" + e_ + (world_->silence ? "1" : "0") + "\nadd_checkbox|checkbox_rainbows|Royal Rainbows!|" + (world_->rainbows ? "1" : "0") : "") + "|\nadd_text_input|minimum_entry_level|World Level: |" + to_string(world_->entry_level) + "|3|\nadd_smalltext|Set minimum world entry level.|" + (world_->World_Time != 0 ? "\nadd_smalltext|Current World Timer set to: `2" + to_string(world_->World_Time) + " minutes``.|left|" : "") + "\nadd_button|sessionlength_dialog|`wSet World Timer``|noflags|0|0|\nadd_button|clear_a_world|`wClear World|noflags|0|0|\nadd_button|changecat|`wCategory: " + (world_->Category != "None" and world_->Category != "" ? world_->Category : "None") + "``|noflags|0|0|" + world_key + "\nend_dialog|lock_edit|Cancel|OK|");
						p.CreatePacket(peer);
					}
				}
				break;
			}
			case BlockTypes::SIGN:
			{
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|" + (t_ == 1684 or t_ == 1912 or t_ == 4482 ? "Enter an ID. You can use this as a destination for Doors.``" : "What would you like to write on this sign?``") + "|left|\nadd_text_input|sign_text||" + (t_ == 1684 or t_ == 1912 or t_ == 4482 ? block_->door_id : block_->txt) + "|128|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|sign_edit|Cancel|OK|");
				p.CreatePacket(peer);
				break;
			}
			case BlockTypes::ADVENTURE:
			{
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wThe Adventure Begins``|left|4722|\nadd_smalltext|Players that step here will have their adventure items reset. If they don't reach `2Adventure's End`` within the time and life limit, they'll lose their checkpoint and be sent to the white door.|left|\nadd_spacer|small|\nadd_text_input|nameEnter|Adventure Name|" + block_->heart_monitor + "|32|\nadd_spacer|small|\nend_dialog|advbegins|Cancel|Update|");
				p.CreatePacket(peer);
				break;
			}
			case BlockTypes::STORAGE:
			{
				if (pInfo(peer)->tankIDName == world_->owner_name || pInfo(peer)->admin == 1) {
					pInfo(peer)->lastwrenchb = t_;
					if (block_->door_destination != "" && t_ == 8878) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSafe Vault``|left|8878|\nadd_textbox|Please enter your password to access the Safe Vault.|left|\nadd_text_input_password|storage_password||" + (pInfo(peer)->dev ? block_->door_destination : "") + "|12|\nadd_button|check_password|`wEnter Password``|noflags|0|0|\nadd_button|show_recoveryanswer|`wRecover Password``|noflags|0|0|\nend_dialog|storageboxpassword|Exit||\nadd_quick_exit|"), p.CreatePacket(peer);
					}
					else load_storagebox(peer, world_, block_);
				}
				break;
			}
			case BlockTypes::DOOR: case BlockTypes::PORTAL:
			{
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string open_ = (block_->open ? "1" : "0");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_text_input|door_name|Label|" + block_->txt + "|100|\nadd_text_input|door_target|Destination|" + block_->door_destination + "|24|\nadd_smalltext|Enter a Destination in this format: `2WORLDNAME:ID``|left|\nadd_smalltext|Leave `2WORLDNAME`` blank (:ID) to go to the door with `2ID`` in the `2Current World``.|left|\nadd_text_input|door_id|" + (t_ == 762 ? "Password" : "ID") + "|" + block_->door_id + "|11|\nadd_smalltext|Set a unique `2ID`` to target this door as a Destination from another!|left|" + (not world_->owner_name.empty() ? "\nadd_checkbox|checkbox_locked|Is open to public|" + open_ + "" : "") + "\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|door_edit|Cancel|OK|");
				p.CreatePacket(peer);
				break;
			}
			}
			// wrench
			break;
		}
		default:
		{
			if (items[block_->fg].charger and p_ == 2286 or p_ == 2204) {
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) break;
				if (p_ == 2204) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"); 
					p.Insert(pInfo(peer)->netID);
					p.Insert("Your " + items[p_].name + " doesn't need charging!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (block_->id != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("That charger is already in use!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else {
					int c_ = -1;
					if (modify_inventory(peer, p_, c_) == 0) {
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/mlaunch.wav");
						block_->id = p_, block_->planted = time(nullptr) + 3600;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						PlayerMoving data_effect_{};
						data_effect_.packetType = 19;
						data_effect_.punchX = p_;
						data_effect_.punchY = pInfo(peer)->netID;
						data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
						BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
						raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 4;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								p.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc, raw_effect;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
				}
				return true;
			}
			if (items[block_->fg].fossil_prep and p_ == 4134 or p_ == 3936) {
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) break;
				if (p_ == 3936) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Your " + items[p_].name + " need to be polished!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (block_->id != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("That charger is already in use!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else {
					int c_ = -1;
					if (modify_inventory(peer, p_, c_) == 0) {
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/mlaunch.wav");
						block_->id = p_, block_->planted = time(nullptr) + 5400;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						PlayerMoving data_effect_{};
						data_effect_.packetType = 19;
						data_effect_.punchX = p_;
						data_effect_.punchY = pInfo(peer)->netID;
						data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
						BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
						raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 4;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								p.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc, raw_effect;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
				}
				return true;
			}
			if (t_ == 5714) {
				pInfo(peer)->lastwrenchb = t_;
				int item = p_, got = 0;
				modify_inventory(peer, item, got);
				if (got == 0) break;
				if (items[item].untradeable == 1 || item == 1424 || items[item].rarity >= 363 || items[item].rarity == 0 || items[item].rarity < 1) {
					gamepacket_t p;
					if (not block_access(peer, world_, block_) or block_access(peer, world_, block_)) p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("I'm sorry, we can't accept items without rarity!"), p.CreatePacket(peer);
					break;
				}
				else {
					pInfo(peer)->lastchoosenitem = item;
					gamepacket_t p;
					if (not block_access(peer, world_, block_) or block_access(peer, world_, block_)) p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGiant Pot O' Gold``|left|5714|\nadd_spacer|small|\nadd_textbox|How many `2" + items[item].name + "`` (rarity " + setGems(items[item].rarity) + ") do you want to drop in the pot? You are carrying " + to_string(got) + " right now.|left|\nadd_text_input|amt||" + to_string(got) + "|3|\nadd_textbox|Thanks for donating, the pot gets ever fuller!|left|\nend_dialog|giantpotogold|Exit|Donate!|");
					p.CreatePacket(peer);
				}
			}
			if (t_ == 4264) {
				pInfo(peer)->lastwrenchb = t_;
				int item = p_, got = 0;
				modify_inventory(peer, item, got);
				if (got <= 0) break;
				if (items[item].untradeable == 1 || item == 5816 || item == 1424 || items[item].rarity >= 999 || items[item].rarity < 1) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("I'm sorry, we can't accept items without rarity!"), p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->lastchoosenitem = item;
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert(
						"set_default_color|`o\n"
						"add_label_with_icon|big|`wStuff-4-Toys Box``|left|4264|\n"
						"add_spacer|small|\n"
						"add_textbox|How many `2" + items[item].name + "`` (rarity " + setGems(items[item].rarity) + ") do you want to donate to our program? You are carrying " + to_string(got) + " right now.|left|\n"
						"add_text_input|donate_rarity||" + to_string(got) + "|3|\n"
						"add_textbox|We appreciate you donating whatever you can! You are bringing light into the lives of Growtopians who can't scrape together a World Lock of their own.|left|\n"
						"end_dialog|s4tb|Exit|Donate!|");
					p.CreatePacket(peer);
				}
			}
			if (t_ == 4124) {
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) break;
				if (p_ == 3942 or p_ == 3946 or p_ == 3948 or p_ == 3950) {
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDNA Extractor``|left|4124|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nembed_data|item|" + to_string(p_) + "\nadd_textbox|Are you sure you want to destroy a " + items[p_].name + " for a slim chance of extracting a tiny bit of prehistoric DNA?|left|\nend_dialog|dnaget|No|Yes|");
					p.CreatePacket(peer);
				}
				else if (p_ == 32 || p_ == 18) break;
				else {
					gamepacket_t p2;
					p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("No ancient DNA detected."), p2.Insert(0), p2.Insert(0), p2.CreatePacket(peer);
					break;
				}
			}
			if (items[t_].id == 10656) {
				int itemId = p_, inventory = 0;

				pInfo(peer)->lastwrenchb = p_;

				modify_inventory(peer, itemId, inventory);
				if (itemId < 0 || itemId > items.size()) break;
				if (inventory < 0 || inventory > 200) break;

				if (items[itemId].rarity == 1 || items[itemId].rarity == 999) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4This box only accepts items rarity items 2+ or greater`7]``"), p.CreatePacket(peer);
					break;
				}

				DialogBuilder builder;

				builder.add_label_icon(true, items[itemId].id, std::format("`w{} - `$Donating", items[itemId].name))
					.add_smalltext("`5NOTE: `oGiving the highest rarity, will give more good items! So, are you lucky?")
					.add_spacer(false);

				builder.add_label_icon(false, 486, std::format("`oYou're donating `w{}`o. How many items would you want to donate?", items[itemId].name))
					.add_text_input(15, "amount", "", to_string(inventory))
					.add_spacer(false);

				builder.add_smalltext("`o(After give, you'll automaticly get the `wChocolate's `ofrom toys).");

				builder.end_dialog("valentine", "`wCancel", "`wDo it now!");

				Algorithm::send_dialog(peer, builder.to_string());
			}
			if (items[t_].blockType == BlockTypes::DONATION) {
				pInfo(peer)->lastwrenchb = t_;
				int item = p_, got = 0;
				modify_inventory(peer, item, got);
				if (got == 0) break;
				if (items[item].untradeable == 1 || item == 1424 || item == 13592 || item == 9500 || item == 8530 || item == 8532 || item == 9150 || item == 9636) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4You can't place that in the box, you need it!`7]``"), p.CreatePacket(peer);
				}
				else if (items[item].rarity == 1) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4This box only accepts items rarity 2+ or greater`7]``"), p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->lastchoosenitem = item;
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|How many to put in the box as a gift? (Note: You will `4LOSE`` the items you give!)|left|\nadd_text_input|count|Count:|" + to_string(got) + "|5|\nadd_text_input|sign_text|Optional Note:||128|\nadd_spacer|small|\nadd_button|give|`4Give the item(s)``|noflags|0|0|\nadd_spacer|small|\nadd_button|cancel|`wCancel``|noflags|0|0|\nend_dialog|give_item|||\n");
					p.CreatePacket(peer);
				}
				return false;
			}
			if (items[t_].mannequin) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("`5[`2It's not safe to use an unlocked " + items[t_].name + "!``]``");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (not world_->open_to_public and world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(peer)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(peer)->uid) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				else if (items[p_].blockType != CLOTHING) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("`5[`2That would just be weird. Try putting clothes on your " + items[t_].name + " instead!``]``");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else {
					if (items[p_].untradeable) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`5[`2You cannot place " + items[p_].name + " on " + items[t_].name + "!``]``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					if (check_transmuted(peer, p_)) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"),
							p.Insert(pInfo(peer)->netID),
							p.Insert("`4This item has been transmuted. You need to keep at least one item in your inventory!"),
							p.CreatePacket(peer);
						break;
					}
					else if (items[p_].clothType == ClothTypes::ANCES) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`5[`2It's not safe to place " + items[p_].name + " on " + items[t_].name + "!``]``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					else {
						uint16_t current_mannequin_item = 0;
						switch (items[p_].clothingType) {
						case 0: current_mannequin_item = block_->mannequin.c_hair;
							break;
						case 1: current_mannequin_item = block_->mannequin.c_shirt;
							break;
						case 2: current_mannequin_item = block_->mannequin.c_pants;
							break;
						case 3: current_mannequin_item = block_->mannequin.c_feet;
							break;
						case 4: current_mannequin_item = block_->mannequin.c_head;
							break;
						case 5: current_mannequin_item = block_->mannequin.c_hand;
							break;
						case 6: current_mannequin_item = block_->mannequin.c_back;
							break;
						case 7: current_mannequin_item = block_->mannequin.c_mask;
							break;
						case 8: current_mannequin_item = block_->mannequin.c_neck;
							break;
						case 9: {
							return false;
						}
						} if (current_mannequin_item == p_) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`5[`2You giggle as you swap two identical items``]``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
						else {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|Do you really want to put your " + items[p_].name + " on the " + items[t_].name + "?|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nembed_data|put|" + to_string(p_) + "\nend_dialog|mannequin_edit|No|Yes|");
							p.CreatePacket(peer);
						}
					}
				}
				return false;
			}
			/*
			if (t_ == 1902) {
				pInfo(peer)->lastwrenchb = t_;
				int got = 0;
				if (p_ > items.size()) break;
				modify_inventory(peer, p_, got);
				if (got == 0) break;
				if (items[p_].rarity == 999 && p_ != 242) {
					Algorithm::send_bubble(peer, pInfo(peer)->netID, "`5[`2I can't give this to the ticket booth!`5]``");
					break;
				}
				DialogBuilder db{ "`o" };
				db.add_label_icon(true, p_, format("`wGive {}``", items[p_].name));
				if (p_ == 242) {
					db.add_textbox(format("Golden Tickets cost 100 Rarity worth of any items. If you give me extras, I'll keep a record. "
						"Those things worth to 30 Golden Tickets, and you have {} of them. You currently have a credit of {} Rarity. "
						" So... how many you wanna give me?", items[p_].rarity, got, pInfo(peer)->carnival_credit));
				}
				else {
					db.add_textbox(format("Golden Tickets cost 100 Rarity worth of any items. If you give me extras, I'll keep a record. "
						"Those things have {} Rarity, and you have {} of them. You currently have a credit of {} Rarity. "
						" So... how many you wanna give me?", items[p_].rarity, got, pInfo(peer)->carnival_credit));
				}
				db.add_text_input(5, "ticket_amount", "", to_string(got))
				.end_dialog("ticket_booth", "`wCancel``", "`wOK``");
				pInfo(peer)->lastchoosenitem = p_;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(db.to_string());
				p.CreatePacket(peer);
			}
			*/
			if (t_ == 2452) {
				pInfo(peer)->lastwrenchb = t_;
				int item = p_, got = 0;
				modify_inventory(peer, item, got);
				if (got == 0) break;
				vector<int> list{ 4534, 4628, 5020, 5206, 5322, 5712, 6294, 6338, 6758, 6892, 7196, 7384, 7568, 7570, 7572, 7574, 7676, 7678, 7680, 7682, 7836, 7838, 7840, 7842, 8006, 8010, 8288, 8290, 8292, 8294, 8304, 8432, 8434, 8436, 8438, 8576, 8578, 8580, 8816, 8818, 8820, 8822, 8898, 8900, 8902, 8904, 9008, 9010, 9012, 9014, 9116, 9118, 9120, 9122, 9136, 9138, 9236, 9348, 9408, 9462, 9464, 9606, 9648, 9760, 10044, 10128, 10166, 10246, 10426, 10618, 10666, 10718, 10810, 11006, 11116, 11232, 11306, 11440, 11506, 11704, 11750, 11882, 11906, 12246, 12344, 12432, 12642, 12834, 12872, 13022, 4988, 5480, 4590, 4746, 5088, 7192, 8582, 5154, 8012, 8008, 10496, 10914, 11308, 11442, 11508, 11552, 11662, 11706, 11752, 11884, 11908, 12248, 12346, 12434, 12644, 12836, 12874, 12958, 13024 };

				// todo here
				if (find(list.begin(), list.end(), item) != list.end()) {
					pInfo(peer)->lastchoosenitem = item;
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|You have " + to_string(got) + " " + items[item].name + ". How many will you crush?|left|\nadd_textbox|`4Beware:`` If you don't have room in your inventory for the resulting items, they will drop on the floor.|left|\nadd_text_input|count||" + to_string(got) + "|5|\nend_dialog|iotm_compactor|Cancel|OK|");
					p.CreatePacket(peer);
				}
				else if (items[item].r_1 == 2037 || items[item].r_2 == 2037 || items[item].r_1 == 2035 || items[item].r_2 == 2035 || items[item].r_1 + items[item].r_2 == 0 || items[item].blockType != BlockTypes::CLOTHING || items[item].untradeable || item == 1424 || items[item].rarity > 200) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2Only spliceable clothing can be crushed!``]``"), p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->lastchoosenitem = item;
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|You have " + to_string(got) + " " + items[item].name + ". How many will you crush?|left|\nadd_textbox|`4Beware:`` If you don't have room in your inventory for the resulting items, they will drop on the floor.|left|\nadd_text_input|count||" + to_string(got) + "|5|\nend_dialog|compactor|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (t_ == 4582) {
				pInfo(peer)->lastwrenchb = t_;
				int item = p_, got = 0;
				modify_inventory(peer, item, got);
				if (got == 0) break;
				gamepacket_t p;
				if (items[item].grindable_prize == 0) p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2That's not grindable``]``");
				else if (items[item].grindable_prize != 0 && got < items[item].grindable_count) p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2I need " + to_string(items[item].grindable_count) + " of those to grind them!``]``");
				else {
					pInfo(peer)->lastchoosenitem = item;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGrind " + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|You have " + to_string(got) + " " + items[item].name + ". It takes " + to_string(items[item].grindable_count) + " per grind. How many times will you grind (max " + to_string(got / items[item].grindable_count) + ")?|left|\nadd_textbox|`4Beware:`` If you don't have room in your inventory for the resulting items, they will drop on the floor.|left|\nadd_text_input|count||" + to_string(got / items[item].grindable_count) + "|5|\nend_dialog|grinder|Cancel|OK|");
				}
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].blockType == BlockTypes::DISPLAY) {
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				if ((world_->owner_name.empty() and not is_block_owner(peer, world_, block_))) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("This area must be locked to put your item on display!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if ((world_->owner_name.empty() and not is_block_owner(peer, world_, block_))) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Only the block's owner can place items in it.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (owner_name != user_name and not pInfo(peer)->dev and not world_->owner_name.empty()) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Only the block's owner can place items in it.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (block_->id != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Remove what's in there first!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (p_ == 1424 or p_ == 5816) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("No sir.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (items[p_].untradeable) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("You can't display untradeable items.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (check_transmuted(peer, p_)) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"),
						p.Insert(pInfo(peer)->netID),
						p.Insert("`4This item has been transmuted. You need to keep at least one item in your inventory!"),
						p.CreatePacket(peer);
				}
				else if (items[p_].blockType == BlockTypes::LOCK or items[p_].blockType == BlockTypes::DISPLAY) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Sorry, no displaying Display Blocks or Locks.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else {
					int c_ = -1;
					if (modify_inventory(peer, p_, c_) == 0) {
						block_->id = p_;
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/blorb.wav");

						// update item visual in display block
						PlayerMoving data_effect_{};
						data_effect_.packetType = 19;
						data_effect_.punchX = p_;
						data_effect_.punchY = pInfo(peer)->netID;
						data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
						BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
						raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 4;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								p.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc, raw_effect;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
						return true;
					}
				}
				return false;
			}
			switch (items[p_].blockType) {
			case BlockTypes::CLOTHING:
			{
				equip_clothes(peer, p_);
				break;
			}
			case BlockTypes::CONSUMABLE:
			{
				if (pInfo(peer)->last_consumable + 500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) pInfo(peer)->last_consumable = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				else break;
				if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 3616) != world_->active_jammers.end()) {
					if (!guild_access(peer, world_->guild_id) and world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end()) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Can't use consumables here!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						break;
					}
				}
				if (world_->X_19) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("The Xenonite Crystal won't let me use " + items[p_].name + "!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
					break;
				}
				switch (p_) {
				
				case 3098: case 3218: case 3014: case 5526: case 5528: case 3012: case 3018: case 3020: case 2914: case 4248: case 4246: case 3016:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (block_->fg != (p_ == 5528 ? 5602 : p_ == 5526 ? 4658 : 0) and block_->fg != 8964) {
						gamepacket_t p, p2;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(p_ == 5528 and block_->fg != 5602 and !(block_->flags & 0x00400000) ? "This bait can only be used in ice water." : p_ == 5526 and block_->fg != 4658 and !(block_->flags & 0x00400000) ? "This bait can only be used in uranium water." : "Something is blocking the way!"), p.CreatePacket(peer);
						p2.Insert("OnConsoleMessage"), p2.Insert(p_ == 5528 and block_->fg != 5602 and !(block_->flags & 0x00400000) ? "This bait can only be used in ice water." : p_ == 5526 and block_->fg != 4658 and !(block_->flags & 0x00400000) ? "This bait can only be used in uranium water." : "Something is blocking the way!"), p2.CreatePacket(peer);
					}
					else {
						if (pInfo(peer)->hand == 3040 || pInfo(peer)->hand == 3010 || pInfo(peer)->hand == 2912 || pInfo(peer)->hand == 3008 || pInfo(peer)->hand == 3100 || pInfo(peer)->hand == 5740 || pInfo(peer)->hand == 6254 || pInfo(peer)->hand == 6256 || pInfo(peer)->hand == 6932 || pInfo(peer)->hand == 10262) {
							if (!(pInfo(peer)->hand == 3010 || pInfo(peer)->hand == 3040 || pInfo(peer)->hand == 10262)) {
								Algorithm::send_bubble(peer, pInfo(peer)->netID, "This rod is no longer supported.");
								break;
							}
							if (block_->flags == 0x04000000 && pInfo(peer)->fishing_used == 0) {
								if (abs(pInfo(peer)->x / 32 - x_) <= 1 && abs(y_ - pInfo(peer)->y / 32) == 1 && pInfo(peer)->x / 32 != x_ && pInfo(peer)->y / 32 != y_) {
									modify_inventory(peer, p_, got = -1);
									pInfo(peer)->fish_seconds = 1850;
									if (pInfo(peer)->hair == 3042) pInfo(peer)->fish_seconds *= 3;
									pInfo(peer)->fishing_used = p_, pInfo(peer)->f_x = x_, pInfo(peer)->f_y = y_, pInfo(peer)->move_warning = 0, pInfo(peer)->f_xy = pInfo(peer)->x + pInfo(peer)->y, pInfo(peer)->punch_warning = 0;
									FishMoving data_{};
									data_.stopped_fishing = 0, data_.netID = pInfo(peer)->netID, data_.x = pInfo(peer)->f_x, data_.y = pInfo(peer)->f_y;
									BYTE* raw = packFishMoving(&data_);
									int got_item = 0;
									if (thedaytoday == 3) got_item = 3;
									vector<int> fish_reward = { 242, 1796, 7188 };
									int item_ = fish_reward[rand() % fish_reward.size()];
									if (rand() % 50 < 1 + got_item) item_ = fish_reward[rand() % fish_reward.size()];
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
								}
								else {
									gamepacket_t p, p2;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Sit still before you try to fish!"), p.CreatePacket(peer);
									p2.Insert("OnConsoleMessage"), p2.Insert("Sit still before you try to fish!"), p2.CreatePacket(peer);
								}
							}
							else if (block_->flags == 0x04000000 && pInfo(peer)->fishing_used == 0 && block_->bg == 3556) {
								if (abs(pInfo(peer)->x / 32 - x_) <= 1 && abs(y_ - pInfo(peer)->y / 32) == 1 && pInfo(peer)->x / 32 != x_ && pInfo(peer)->y / 32 != y_) {
									modify_inventory(peer, p_, got = -1);
									pInfo(peer)->fish_seconds = 1850;
									if (pInfo(peer)->hair == 3042) pInfo(peer)->fish_seconds *= 3;
									pInfo(peer)->fish_water = "cave";
									pInfo(peer)->fishing_used = p_, pInfo(peer)->f_x = x_, pInfo(peer)->f_y = y_, pInfo(peer)->move_warning = 0, pInfo(peer)->f_xy = pInfo(peer)->x + pInfo(peer)->y, pInfo(peer)->punch_warning = 0;
									FishMoving data_{};
									data_.stopped_fishing = 0, data_.netID = pInfo(peer)->netID, data_.x = pInfo(peer)->f_x, data_.y = pInfo(peer)->f_y;
									BYTE* raw = packFishMoving(&data_);
									int got_item = 0;
									if (thedaytoday == 3) got_item = 3;
									vector<int> fish_reward = { 242, 1796, 7188 };
									int item_ = fish_reward[rand() % fish_reward.size()];
									if (rand() % 50 < 1 + got_item) item_ = fish_reward[rand() % fish_reward.size()];
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
								}
								else {
									gamepacket_t p, p2;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Sit still before you try to fish!"), p.CreatePacket(peer);
									p2.Insert("OnConsoleMessage"), p2.Insert("Sit still before you try to fish!"), p2.CreatePacket(peer);
								}
							}
							else if (block_->flags == (0x04000000 | 0x00400000) && pInfo(peer)->fishing_used == 0 && block_->fg == 5602 && p_ == 5528) {
								if (abs(pInfo(peer)->x / 32 - x_) <= 1 && abs(y_ - pInfo(peer)->y / 32) == 1 && pInfo(peer)->x / 32 != x_ && pInfo(peer)->y / 32 != y_) {
								    modify_inventory(peer, p_, got = -1);
									pInfo(peer)->fish_seconds = 1850;
									if (pInfo(peer)->hair == 3042) pInfo(peer)->fish_seconds *= 3;
									pInfo(peer)->fish_water = "ice";
									pInfo(peer)->fishing_used = p_, pInfo(peer)->f_x = x_, pInfo(peer)->f_y = y_, pInfo(peer)->move_warning = 0, pInfo(peer)->f_xy = pInfo(peer)->x + pInfo(peer)->y, pInfo(peer)->punch_warning = 0;
									FishMoving data_{};
									data_.stopped_fishing = 0, data_.netID = pInfo(peer)->netID, data_.x = pInfo(peer)->f_x, data_.y = pInfo(peer)->f_y;
									BYTE* raw = packFishMoving(&data_);
									int got_item = 0;
									if (thedaytoday == 3) got_item = 3;
									vector<int> fish_reward = { 242, 1796, 7188 };
									int item_ = fish_reward[rand() % fish_reward.size()];
									if (rand() % 50 < 1 + got_item) item_ = fish_reward[rand() % fish_reward.size()];
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
								}
								else {
									gamepacket_t p, p2;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Sit still before you try to fish!"), p.CreatePacket(peer);
									p2.Insert("OnConsoleMessage"), p2.Insert("Sit still before you try to fish!"), p2.CreatePacket(peer);
								}
							}
							else if (block_->flags == (0x04000000 | 0x00400000) && pInfo(peer)->fishing_used == 0 && block_->fg == 4658 && p_ == 5526) {
								if (abs(pInfo(peer)->x / 32 - x_) <= 1 && abs(y_ - pInfo(peer)->y / 32) == 1 && pInfo(peer)->x / 32 != x_ && pInfo(peer)->y / 32 != y_) {
									int got_item = 0;
									if (thedaytoday == 3) got_item = 3;
									vector<int> fish_reward = { 242, 1796, 7188 };
									int item_ = fish_reward[rand() % fish_reward.size()];
									if (rand() % 50 < 1 + got_item) item_ = fish_reward[rand() % fish_reward.size()];
									modify_inventory(peer, p_, got = -1);
									pInfo(peer)->fish_seconds = 1850;
									if (pInfo(peer)->hair == 3042) pInfo(peer)->fish_seconds *= 3;
									pInfo(peer)->fish_water = "uranium";
									pInfo(peer)->fishing_used = p_, pInfo(peer)->f_x = x_, pInfo(peer)->f_y = y_, pInfo(peer)->move_warning = 0, pInfo(peer)->f_xy = pInfo(peer)->x + pInfo(peer)->y, pInfo(peer)->punch_warning = 0;
									FishMoving data_{};
									data_.stopped_fishing = 0, data_.netID = pInfo(peer)->netID, data_.x = pInfo(peer)->f_x, data_.y = pInfo(peer)->f_y;
									BYTE* raw = packFishMoving(&data_);

									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
								}
								else {
									gamepacket_t p, p2;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Sit still before you try to fish!"), p.CreatePacket(peer);
									p2.Insert("OnConsoleMessage"), p2.Insert("Sit still before you try to fish!"), p2.CreatePacket(peer);
								}
							}
							else if ((block_->flags == 0x04000000 && pInfo(peer)->fishing_used != 0) || (block_->flags == (0x04000000 | 0x00400000) && pInfo(peer)->fishing_used != 0)) stop_fishing(peer, false, "");
						}
						else {
							gamepacket_t p, p2;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You'll need a fishing rod to fish!"), p.CreatePacket(peer);
							p2.Insert("OnConsoleMessage"), p2.Insert("You'll need a fishing rod to fish!"), p2.CreatePacket(peer);
						}
					}
					break;
				}/*
				case 8774:
				{
					vector<int> Random{ 1, 2, 3, 4, 5 };
					int Random_Number = Random[rand() % Random.size()];
					gamepacket_t p, p1, p3;
					p.Insert("OnTalkBubble"), p1.Insert("OnConsoleMessage");
					p.Insert(pInfo(peer)->netID);
					p.Insert("`6I SHALL FACE THE FINALE PARKOUR!!!"), p1.Insert("CP:_PL:0_OID:_CT:[W]_ `6<`w" + pInfo(peer)->tankIDName + "```6> `6I SHALL FACE THE FINALE PARKOUR!!!");
					p.Insert(0), p.Insert(0);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							p.CreatePacket(currentPeer), p1.CreatePacket(currentPeer);
						}
					}
					long long time_ = time(nullptr);
					int a9sd = pInfo(peer)->Time_Remaining - time_;
					gamepacket_t cd(0, pInfo(peer)->netID);
					cd.Insert("OnCountdownStart"), cd.Insert(a9sd), cd.Insert(-1), cd.CreatePacket(peer);
					p3.Insert("OnConsoleMessage"), p3.Insert("You're in the running! (`$Competitor: Finale Ticket!`` mod added)"), p3.CreatePacket(peer);
					pInfo(peer)->At_Clashparkour = true, pInfo(peer)->Time_Remaining = time(nullptr) + 10 + 5;
					string World = "CLASHPARKOUR_" + to_string(Random_Number);
					join_world(peer, World);
					break;
				}
				case 2992:
				{
					if (pInfo(peer)->wolf_world == true) break;
					int adaBrp = 0;
					modify_inventory(peer, p_, adaBrp);
					if (adaBrp == 0) break;
					if (modify_inventory(peer, p_, adaBrp = -1) == 0) {
						vector<int> Random{ 1 };
						int Random_Number = Random[rand() % Random.size()];
						gamepacket_t p, p1, p3;
						p.Insert("OnTalkBubble"), p1.Insert("OnConsoleMessage");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`6I SHALL FACE THE WOLF!!!"), p1.Insert("CP:_PL:0_OID:_CT:[W]_ `6<`w" + pInfo(peer)->tankIDName + "```6> `6I SHALL FACE THE WOLF!!!");
						p.Insert(0), p.Insert(0);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								packet_(currentPeer, "action|play_sfx\nfile|audio/snd037.wav\ndelayMS|0");
								p.CreatePacket(currentPeer), p1.CreatePacket(currentPeer);
							}
						}
						p3.Insert("OnConsoleMessage"), p3.Insert("You're one with the pack! (`$Howlin' Mad`` mod added)"), p3.CreatePacket(peer);
						pInfo(peer)->wolf_world = true;
						pInfo(peer)->Wolf_Time = (duration_cast<seconds>(system_clock::now().time_since_epoch())).count() + (600 + (pInfo(peer)->hair == 9072 ? 60 : 0));
						string World = "WOLFWORLD_" + to_string(Random_Number);
						join_world(peer, World);
					}
					break;
				}*/
				case 4132:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					bool remove = false;
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32) && world_->drop[i_].id == 3936) {
							if (rand() % 10 < 4)  gems_(peer, world_, rand() % (items[p_].max_gems + 1), x_ * 32, y_ * 32, p_);
							remove = true;
							PlayerMoving data_{};
							data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop[i_].uid;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
							WorldDrop drop_block_{};
							drop_block_.id = 4134, drop_block_.count = world_->drop[i_].count, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = world_->drop[i_].x, drop_block_.y = world_->drop[i_].y;
							dropas_(world_, drop_block_);
							world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
						}
					}
					if (remove) modify_inventory(peer, p_, got = -1);
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You can only brush Fossils that have never been picked up!"), p.CreatePacket(peer);
					}
					break;
				}
				case 12600:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (world_->owner_name == pInfo(peer)->tankIDName || pInfo(peer)->dev) {
						int normal_tree = 0, custom_tree = 0;
						long long times_ = time(nullptr);
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) 
						{
							if (items[world_->blocks[i_].fg].blockType == BlockTypes::SEED and
								(times_ - world_->blocks[i_].planted <= items[world_->blocks[i_].fg].growTime ?
									times_ - world_->blocks[i_].planted : items[world_->blocks[i_].fg].growTime) !=
								items[world_->blocks[i_].fg].growTime) {
								if (world_->blocks[i_].fg == 5179) custom_tree++;
								else normal_tree++;
							}
						}
						
						int price = (10 * normal_tree) + (200 * custom_tree);
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wUltra World Spray``|left|12600|\nadd_spacer|small|\nadd_textbox|There is `2" + setGems(custom_tree + normal_tree) + "`` ungrown tree that this spray will work on.|\nadd_spacer|small|\nadd_textbox|Are you sure you want to use the Ultra World Spray on this world? This will cost you " + setGems(price) + " gems.|\nend_dialog|world_spray|No|Yes|\n\nadd_quick_exit|");
						p.CreatePacket(peer);
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You must own the world!"), p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					break;
				}
				/*
				case 9502:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (world_->owner_name == pInfo(peer)->tankIDName || pInfo(peer)->dev) {
						int ungrown = 0;
						long long times_ = time(nullptr);
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) if (items[world_->blocks[i_].fg].blockType == BlockTypes::PROVIDER and (times_ - world_->blocks[i_].planted <= items[world_->blocks[i_].fg].growTime ? times_ - world_->blocks[i_].planted : items[world_->blocks[i_].fg].growTime) != items[world_->blocks[i_].fg].growTime) ungrown++;
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wUltra Provider Spray``|left|9502|\nadd_spacer|small|\nadd_textbox|There is `2" + to_string(ungrown) + "`` unready provider that this spray will work on.|\nadd_spacer|small|\nadd_textbox|Are you sure you want to use the Ultra Provider Spray on this world?|\nend_dialog|provd_spray|No|Yes|\n\nadd_quick_exit|");
						p.CreatePacket(peer);
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You must own the world!"), p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					break;
				}
				*/
				case 7480:
				{
					pInfo(peer)->back = 7480;
					update_clothes(peer);
					break;
				}
				case 5664:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (block_->fg == 0) {
						modify_inventory(peer, p_, got = -1);
						gamepacket_t p;
						p.Insert("OnAddNotification");
						p.Insert("interface/large/special_event.rttex");
						vector<int> list{ 5652, 3398, 386, 4422, 364, 9342, 9340, 9334, 9332, 9336, 9338, 4400, 7808, 7810, 4416, 7818, 7820, 7822, 7824, 5644, 390, 7826, 7830, 9324, 5658, 3396, 2384, 5660, 10654, 3400, 4418, 388, 3408, 1470, 3404, 3406, 10662, 2390, 5656, 5648, 2396, 384, 5664, 386, 4424, 366 };
						int item = list[rand() % list.size()];
						WorldDrop drop_block_{};
						drop_block_.id = item, drop_block_.count = (item == 7810 || item == 7808 || item == 4400 || item == 390 || item == 3408 || item == 4422 || item == 3404 || item == 386 ? 5 : (item == 4418 || item == 5660 ? 2 : 1)), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
						p.Insert("`2Valentine's Card:`` Cupid has just spawned a `#" + items[item].name + "``.");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) p.CreatePacket(currentPeer);
						}
					}
					break;
				}
				case 722:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (block_->fg == 0) {
						modify_inventory(peer, p_, got = -1);
						block_->fg = 718;
						gamepacket_t p;
						p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2`4Pi`wna`2ta`` `wBash``!:`` `oSmash the `wUltra`` `4Pi`wna`2ta``! `#Get some help``!``"), p.Insert("audio/cumbia_horns.wav");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
							update_tile(currentPeer, x_, y_, 718, false, false);
							p.CreatePacket(currentPeer);
						}
					}
					break;
				}
				case 1220:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					if (world_->name == "GROWGANOTH" && Halloween) {
						modify_inventory(peer, p_, got = -1);
						p.Insert("`5Growganoth pulls you closer!``");
						gamepacket_t p2(0, pInfo(peer)->netID);
						p2.Insert("OnSetPos"), p2.Insert(1584, 432), p2.CreatePacket(peer);
						packet_(peer, "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0");
					}
					else p.Insert("The sigil fizzles... try using it near Growganoth!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
					break;
				}
				case 3400:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (block_->fg != 10) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`4This potion is clearly labeled for use only on rocks.``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					int c_ = -1;
					if (modify_inventory(peer, 3400, c_) == 0) {
						block_->fg = 392;
						PlayerMoving data_{};
						data_.packetType = 17;
						data_.netID = 44;
						data_.YSpeed = 44;
						data_.x = x_ * 32 + 16;
						data_.y = y_ * 32 + 16;
						PlayerMoving data_2{};
						data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
						BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
						BYTE* blc = raw2 + 56;
						form_visual(blc, *block_, *world_, peer, false);
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								packet_(currentPeer, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw2, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					break;
				}
				case 3742:
				{
					if (items[t_].blockType == BlockTypes::PROVIDER) {
						long long time_ = time(NULL);
						uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
						if (laikas < unsigned int(items[block_->fg].growTime)) {
							long long spray_time_ = 3600 * 12; // 12 hours
							block_->planted -= spray_time_;
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							if (time_ - block_->planted <= items[block_->fg].growTime) {
								if (spray_time_ < 86400)
									p.Insert(items[block_->fg].name + " `eaged`` `$" + to_string(spray_time_ / 60 / 60) + "`` hours");
								else
									p.Insert(items[block_->fg].name + " `eaged`` `$" + to_string(spray_time_ / 86400) + "`` days");
							}
							else {
								p.Insert(items[block_->fg].name + " is ready!");
							}
							p.CreatePacket(peer);
							{
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/spray.wav");
								p.CreatePacket(peer);
							}
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
							int c_ = -1;
							modify_inventory(peer, p_, c_);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("This " + items[block_->fg].name + " is already ready, don't waste your spray on it!");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Use this on a provider to speed it up.");
						p.Insert(0);
						p.Insert(1);
						p.CreatePacket(peer);
					}
					break;
				}
				case 228: case 1062: case 1778: case 5764: case 10672:
				{
					if (items[t_].blockType == BlockTypes::SEED) {
						long long time_ = time(NULL);
						uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
						if (laikas < unsigned int(items[block_->fg].growTime)) {
							long long spray_time_ = 3600; // 1 hours
							if (p_ == 1062)
								spray_time_ = _int64(2.592e+6); // 30 days
							if (p_ == 1778)
								spray_time_ = 86400; // 24 hours
							if (p_ == 5764)
								spray_time_ = 259200; // 72 hours
							block_->planted -= spray_time_;
							gamepacket_t p, p2(0, pInfo(peer)->netID);
							p.Insert("OnTextOverlay");
							if (time_ - block_->planted <= items[block_->fg].growTime) {
								if (spray_time_ < 86400) p.Insert(items[block_->fg - 1].name + " Tree aged `$" + to_string(spray_time_ / 60 / 60) + "`` hours");
								else p.Insert(items[block_->fg - 1].name + " Tree aged `$" + to_string(spray_time_ / 86400) + "`` days");
							}
							else p.Insert(items[block_->fg - 1].name + " Tree grew to full size!");
							p.CreatePacket(peer);
							p2.Insert("OnPlayPositioned"), p2.Insert("audio/spray.wav"), p2.CreatePacket(peer);
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw, blc;
							if (block_->locked) upd_lock(*block_, *world_, peer);
							int c_ = -1;
							modify_inventory(peer, p_, c_);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("This tree has already bloomed, don't waste your spray on it!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Use this on a growing tree to speed it's growth."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					}
					break;
				}
				case 3822: case 5458: case 6760:
				{
					apply_dye(peer, world_, block_, p_, x_, y_, 0x0000FFFF, (p_ == 6760 ? 32 : 16), -16, -16, false);
					break;
				}
				case 3824: case 5460: case 6762:
				{
					apply_dye(peer, world_, block_, p_, x_, y_, 0x00FF00FF, -16, (p_ == 6762 ? 32 : 16), -16, false);
					break;
				}
				case 3826: case 5462: case 6764:
				{
					apply_dye(peer, world_, block_, p_, x_, y_, 0xFF0000FF, -16, -16, (p_ == 6764 ? 32 : 16), false);
					break;
				}
				case 3828: case 5464: case 6766:
				{
					apply_dye(peer, world_, block_, p_, x_, y_, 0x000000FF, (p_ == 6766 ? -32 : -16), (p_ == 6766 ? -32 : -16), (p_ == 6766 ? -32 : -16), false);
					break;
				}
				case 3830: case 5466: case 6768:
				{
					apply_dye(peer, world_, block_, p_, x_, y_, 0xFFFFFFFF, 32, 32, 32, true);
					break;
				}
				case 9490: case 9492: case 9494: case 9496: case 9498:
				{
					int got = 0, maxGems = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (p_ == 9490) maxGems = 50000;
					else if (p_ == 9492) maxGems = 100000;
					else if (p_ == 9494) maxGems = 250000;
					else if (p_ == 9496) maxGems = 500000;
					else if (p_ == 9498) maxGems = 1000000;
					if (modify_inventory(peer, p_, got = -1) == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID), p.Insert("`9You earned " + setGems(maxGems) + " ė!``"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems += maxGems), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
							if (pInfo(peer)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
							p.CreatePacket(peer);
						}
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 47, data_.YSpeed = 47, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
						break;
					}
				}
				case 10394:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					modify_inventory(peer, p_, got = -1);
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID), p.Insert("`5GULP! You got " + setGems(items[p_].max_gems3) + " ė!``"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					{
						gamepacket_t p;
						p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems += items[p_].max_gems3), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
						if (pInfo(peer)->supp >= 2) p.Insert((float)Algorithm::GetServerTime(), (float)1, (float)0);
						p.CreatePacket(peer);
					}
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					break;
				}
				case 11304:
				{
					if (pInfo(peer)->gp == 1) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID), p.Insert("Looks like you already have the Royal GrowPass this month, please use again when your Grow Pass ended.``"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						break;
					}
					else {
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						modify_inventory(peer, p_, got = -1);
						pInfo(peer)->gp = 1;
						PlayMods new_playmod{};
						new_playmod.id = 101;
						new_playmod.time = time(nullptr) + 2678400;
						pInfo(peer)->playmods.push_back(new_playmod);
						gamepacket_t p(3000), p2(500), p3;
						p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("You've unlocked `cGrow Pass`` only skin colors``!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
						p2.Insert("OnAddNotification"), p2.Insert("interface/cash_icon_overlay.rttex"), p2.Insert("You've unlocked the `2Mentor ``& `2Grow4Good`` title!"), p2.Insert("audio/piano_nice.wav.wav"), p2.Insert(0), p2.CreatePacket(peer);
						p3.Insert("OnConsoleMessage"), p3.Insert("We received your royalty, thanks for supporting `1TayoPs``. (`oRoyal Grow Pass mod added `o31 days left``)"), p3.CreatePacket(peer);
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							gamepacket_t p3, p4;
							p3.Insert("OnParticleEffect");
							p3.Insert(198);
							p3.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
							p4.Insert("OnParticleEffect");
							p4.Insert(46);
							p4.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
							p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
					break;
				}
				case 11538:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					modify_inventory(peer, p_, got = -1);
					pInfo(peer)->gtwl += 1;
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID), p.Insert("You receieved 1 `1TayoPoint``"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					break;
				}
				case 1488:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					modify_inventory(peer, p_, got = -1);
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("`5GULP! You got smarter!``");
					p.Insert(0);
					p.Insert(1);
					p.CreatePacket(peer);
					add_peer_xp(peer, 10000);
					break;
				}
				case 5706:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					vector<int> list{ 3567, 13, 57, 17, 381, 1139, 21, 101, 379, 117, 27, 23, 581, 195, 105, 191, 377, 1307, 697, 881, 167, 185, 1323, 165, 3783, 369, 25, 171, 53, 103, 179, 29, 249, 177, 1325, 337, 189, 169, 55, 223, 175, 885, 119, 3573, 199, 549, 681, 655, 107, 163, 31, 671, 889, 887, 193, 127, 1433, 173, 7631, 413, 3571, 3569, 2809, 9393, 225, 111, 109, 201, 59, 607, 285, 2029, 2013, 2015, 1611, 995, 997, 963, 1481, 219, 197, 2023, 2021, 9331, 1305, 823, 1039, 231, 487, 483, 2019, 427, 1757, 2009, 281, 781, 329, 459, 1041, 421, 2787, 2789, 1043, 2797, 181, 613, 65, 4983, 283, 553, 425, 4635, 987, 627, 2017, 989, 61, 4639, 973, 3523, 331, 265, 859, 433, 253, 339, 1105, 439, 4567, 333, 677, 5673, 1427, 5603, 183, 10533, 5731, 7223, 10833, 6035, 6813, 1113, 1047, 653, 2811, 4703, 1429, 847, 665 };
					vector<pair<int, int>> receivingitems;
					int free = get_free_slots(pInfo(peer)), slot = 5, getcount = 1, inventoryfull = 0;
					if (free >= slot) {
						for (int i = 0; i < slot; i++) {
							int itemid = list[rand() % list.size()];
							receivingitems.push_back(make_pair(itemid, getcount));
						}
						for (int i = 0; i < slot; i++) {
							int itemcount = 0;
							modify_inventory(peer, receivingitems[i].first, itemcount);
							if (itemcount + getcount > 200) inventoryfull = 1;
						}
						if (inventoryfull == 0) {
							for (int i = 0; i < slot; i++) modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
							modify_inventory(peer, p_, got = -1);
						}
					}
					break;
				}
				case 1828: case 11286: case 3870:
				{
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(p_ == 3870 ? "That's like a hundred years old. No." : "Ew, it has raisins! I'm not eating that."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					break;
				}
				case 1066:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got >= 1) {
						modify_inventory(peer, p_, got = -1);
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 50, data_.YSpeed = 50, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
					break;
				}
				case 6140:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got >= 1) {
						string foundlist = "";
						gamepacket_t p;
						if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Only the owner of this tile has access!"), p.CreatePacket(peer);
							break;
						}
						for (int i_ = 0; i_ < world_->drop.size(); i_++) if (world_->drop[i_].id != 0 && world_->drop[i_].id != 112 && world_->drop[i_].x > 0 && world_->drop[i_].y > 0 && world_->drop[i_].x / 32 == x_ && world_->drop[i_].y / 32 == y_) foundlist += to_string(world_->drop[i_].id) + "," + to_string(world_->drop[i_].count) + "," + to_string(world_->drop[i_].uid) + ",";
						if (foundlist != "") p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wExtract-O-Snap``|left|6140|\nadd_spacer|small|\nadd_textbox|GrowTech: use the Extract-O-Snap to pick out the items from the floating items in your world! - Thanks, Technician Dave.|leftvadd_spacer|small|\nadd_textbox|Press on the icon to extract the item into your inventory.|left|\nadd_spacer|small|\nadd_textbox|`wItem List:|left|\nadd_label_with_icon_button_list|small|`w%s : %s|left|extractOnceObj_|itemID_itemAmount_worldObj|" + foundlist + "\nadd_spacer|small|\nend_dialog|extractor|Close||");
						else p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("There are no floating items in the extraction area!");
						p.CreatePacket(peer);
					}
					break;
				}
				case 5136:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got >= 1) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|\nadd_label_with_icon|big|`wConsume " + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|`7How Many? ``(you have `w" + to_string(got) + "``)|left|\nadd_text_input|count||" + to_string(got) + "|3|\nembed_data|itemID|" + to_string(p_) + "\nend_dialog|consumedgem|Cancel|OK|");
						p.CreatePacket(peer);
					}
					break;
				}
				case 6336:
				{
					/*
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					DialogBuilder db("`o");
					db.add_label_icon(true, 6336, "`0Growpedia")
						.add_spacer(false)
						.add_textbox("`wHello TayoPsns! On Growpedia, you can see knowledge on TayoPs``")
						.add_spacer(false)
						.add_label_icon_button(false, "<-- Upgrade Red Ancestral", 5084, "rces").add_spacer(false)
						.add_label_icon_button(false, "<-- Upgrade Blue Ancestral", 5080, "bces").add_spacer(false)
						.add_label_icon_button(false, "<-- Upgrade Green Ancestral", 5162, "gces").add_spacer(false)
						.add_label_icon_button(false, "<-- Upgrade Yellow Ancestral", 5078, "yces").add_spacer(false)
						.add_label_icon_button(false, "<-- Upgrade Purple Ancestral", 7166, "pces").add_spacer(false)
						.add_label_icon_button(false, "<-- Obtain Ingredient Fish Center", 9158, "lnegros").add_spacer(false)
						.end_dialog("growpedia", "Close", "")
						;
					p.Insert(db.to_string());
					p.CreatePacket(peer);
					*/

					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_quick_exit\n"
						"add_label_with_icon|big|`wGuidebook|left|6336|\nadd_spacer|small|\n"
						"set_custom_spacing|x:5;y:10|\n"
						"add_custom_button|splicing|image:interface/large/gui_splicing.rttex;image_size:495,170;width:0.4;|\n"
						"add_custom_button|combining|image:interface/large/gui_combining.rttex;image_size:495,170;width:0.4;|\n"
						"add_custom_break|\n"
						"add_custom_button|crystals|image:interface/large/gui_crystals.rttex;image_size:495,170;width:0.4;|\n"
						"add_custom_button|combusting|image:interface/large/gui_combusting.rttex;image_size:495,170;width:0.4;|\n"
						"set_custom_spacing|x:0;y:0|\n"
						"add_custom_break|\n"
						"add_spacer|small|\n"
						"set_custom_spacing|x:5;y:10|\n"
						"add_custom_button|news|image:interface/large/gui_news.rttex;image_size:495,170;width:0.4;|\n"
						"add_custom_button|rules|image:interface/large/gui_rules.rttex;image_size:495,170;width:0.4;|\n"
						"set_custom_spacing|x:0;y:0|\n"
                        "add_custom_break|\n"
                        "end_dialog|guide_book|Close||");
					p.CreatePacket(peer);
					break;
				}
				case 9148:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got >= 1) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|\nadd_label_with_icon|big|`wConsume " + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|`7How Many? ``(you have `w" + to_string(got) + "``)|left|\nadd_text_input|count||" + to_string(got) + "|3|\nembed_data|itemID|" + to_string(p_) + "\nend_dialog|consumedgem|Cancel|OK|");
						p.CreatePacket(peer);
					}
					break;
				}
				case 9502: case 9504: case 9506: {
					if (has_playmod(pInfo(peer), "Boosted")) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID), p.Insert("Looks like you're already boosted.``"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						break;
					}
					else {
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						modify_inventory(peer, p_, got = -1);
						add_playmod(peer, 127, p_ == 9502 ? 86400 : p_ == 9504 ? 259200 : 604800);
						gamepacket_t p(3000), p2(500), p3;
						p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("You've activated the `5Boost``!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
						p3.Insert("OnConsoleMessage"), p3.Insert("Enjoy the extra gems drop and unlimited broadcast (with price aswell (grin))."), p3.CreatePacket(peer);
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							gamepacket_t p3, p4;
							p3.Insert("OnParticleEffect");
							p3.Insert(198);
							p3.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
							p4.Insert("OnParticleEffect");
							p4.Insert(46);
							p4.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
							p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
					break;
				}
				case 1826:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got >= 1) {
						modify_inventory(peer, p_, got = -1);
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 92, data_.YSpeed = 92, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
					break;
				}
				case 406:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					modify_inventory(peer, p_, got = -1);
					if (rand() % 100 < 28) {
						WorldDrop drop_seed_{};
						drop_seed_.id = p_ + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
						if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
					}
					else if (rand() % 50 < 14) {
						WorldDrop drop_seed_{};
						drop_seed_.id = p_, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
						if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
					}
					else gems_(peer, world_, rand() % (items[p_].max_gems + 1), x_ * 32, y_ * 32, p_);
					break;
				}
				case 4490: case 2036: case 2034: case 7590: case 11656: case 2290: case 3122: case 1152: case 6330: case 1212: case 1234: case 3762: case 8534: case 2410: case 5256: case 3110: case 2000: case 2412: case 4426: case 4172: case 5282: case 3242: case 3186: case 8936: case 5636:
				{
					int got = 0, given = 1, needed = items[p_].consume_needed;
					modify_inventory(peer, p_, got);
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					if (got >= items[p_].consume_needed) {
						if (modify_inventory(peer, items[p_].consume_prize, given) == 0) {
							modify_inventory(peer, p_, needed *= -1);
							p.Insert("`5" + items[p_].name + " combine to create a`` `2" + items[items[p_].consume_prize].name + "```5!``");
						}
						else p.Insert("You don't have enough inventory space!");
					}
					else p.Insert("`4You'll need more " + items[p_].name + " than that!``");
					p.CreatePacket(peer);
					break;
				}
				case 10228:
				{
					if (get_free_slots(pInfo(peer)) >= 1) {
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						vector<pair<int, int>> mooncakes{ {11286, 1} , {1096, 10}, {1098, 10}, {1094, 10}, {1058, 10}, {3870, 4} };
						bool toobig = false;
						for (int i = 0; i < mooncakes.size(); i++) {
							int have = 0;
							modify_inventory(peer, mooncakes[i].first, have);
							if (have + mooncakes[i].second > 200) toobig = true;
						}
						if (toobig) {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your inventory is full!");
							p.CreatePacket(peer);
						}
						if (toobig) break;
						if (rand() % 500 < 1) mooncakes.insert(mooncakes.end(), { 12620,1 });
						vector<pair<int, int>> receivingitems;
						int free = get_free_slots(pInfo(peer)), slot = 5, getcount = 1;
						if (free >= slot) {
							for (int i = 0; i < slot; i++) {
								int randa = rand() % mooncakes.size(), itemid = mooncakes[randa].first, count = rand() % mooncakes[randa].second + 1;
								vector<pair<int, int>>::iterator p_r = find_if(receivingitems.begin(), receivingitems.end(), [itemid](const pair < int, int>& element) { return element.first == itemid; });
								if (p_r != receivingitems.end()) receivingitems[p_r - receivingitems.begin()].second += count;
								else receivingitems.push_back(make_pair(itemid, count));
							}
							string received = "";
							for (int i = 0; i < receivingitems.size(); i++) {
								int itemcount = 0;
								modify_inventory(peer, receivingitems[i].first, itemcount);
								if (itemcount + receivingitems[i].second > 200) toobig = true;
								else received += "`5" + to_string(receivingitems[i].second) + " " + items[receivingitems[i].first].name + "``" + (receivingitems.size() - i == 1 ? "" : " ");
							}
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							if (toobig == false) {
								for (int i = 0; i < receivingitems.size(); i++) modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
								modify_inventory(peer, p_, got = -1);
								p.Insert("`0You got`` " + received + "`0.``");
							}
							else p.Insert("Your inventory is full!");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
					}
					break;
				}
				case 10756:
				{
					if (get_free_slots(pInfo(peer)) >= 2) {
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						vector<int> shard{ 10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10764 };
						vector<int> egg{ 8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550, 2554 };
						bool toobig = false;
						for (int i = 0; i < shard.size(); i++) {
							int have = 0;
							modify_inventory(peer, shard[i], have);
							if (have >= 199) toobig = true;
						}
						for (int i = 0; i < egg.size(); i++) {
							int have = 0;
							modify_inventory(peer, egg[i], have);
							if (have >= 199) toobig = true;
						}
						if (toobig) break;
						vector<pair<int, int>> receivingitems;
						int free = get_free_slots(pInfo(peer)), slot = 2, getcount = 1, inventoryfull = 0;
						if (free >= slot) {
							for (int i = 0; i < slot; i++) {
								int itemid = i == 0 ? shard[rand() % shard.size()] : egg[rand() % egg.size()];
								receivingitems.push_back(make_pair(itemid, getcount = 1));
							}
							for (int i = 0; i < slot; i++) {
								int itemcount = 0;
								modify_inventory(peer, receivingitems[i].first, itemcount);
								if (itemcount + receivingitems[i].second > 200) inventoryfull = 1;
							}
							if (inventoryfull == 0) {
								string received = "";
								for (int i = 0; i < slot; i++) {
									int receiveds = receivingitems[i].second;
									modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
									if (i == 0)received += "`2" + to_string(receiveds) + " " + items[receivingitems[i].first].ori_name + "`` and ";
									else received += "`2" + to_string(receiveds) + " " + items[receivingitems[i].first].ori_name + "``";
								}
								modify_inventory(peer, p_, got = -1);
								gamepacket_t p;
								p.Insert("OnConsoleMessage"), p.Insert("You received " + received + " from a Golden Egg Carton."), p.CreatePacket(peer);
								{
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You received " + received + " from a Golden Egg Carton."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								}
							}
						}
					}
					break;
				}
				case 5404: case 5402: case 13054: case 10396: case 11476: case 7672: case 2306: case 5750: case 9286: case 7346: case 9680: case 11860: case 11036: case 1680: case 1360: case 10536: case 11758: case 11756: case 10386: case 9018: case 11398: case 8410: case 8408: case 8414: case 8412: case 7954: case 7484: case 5948: case 12262: case 12264: case 12044: case 12046: case 12566: case 12568:
				{
					if (get_free_slots(pInfo(peer)) >= 1) {
						int got = 0, received = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						bool toobig = false;
						for (int i = 0; i < items[p_].noob_item.size(); i++)for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == items[p_].noob_item[i].first && pInfo(peer)->inv[i_].count + items[p_].noob_item[i].second >= 200) toobig = true;
						if (items[p_].newdropchance != 0) for (int i = 0; i < items[p_].rare_item.size(); i++)for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == items[p_].rare_item[i].first && pInfo(peer)->inv[i_].count + items[p_].rare_item[i].second >= 200) toobig = true;
						int random = rand() % items[p_].noob_item.size(), itemid = items[p_].noob_item[random].first;
						got = items[p_].noob_item[random].second;
						if (items[p_].newdropchance != 0 && (rand() % items[p_].newdropchance) < 1) {
							if (items[p_].rare_item.size() != 0) random = (rand() % items[p_].rare_item.size()), itemid = items[p_].rare_item[random].first, got = items[p_].rare_item[random].second;
							if (p_ == 1680) {
								vector<int> PhoenixPrize = { 2854, 4820, 1674, 3969, 6312, 8588, 11008, 12186 };
								if (rand() % 1000 < 1) itemid = PhoenixPrize[rand() % PhoenixPrize.size()];
								if (itemid == 1674 || itemid == 2854 || itemid == 4820 || itemid == 3696 || itemid == 6312 || itemid == 8588 || itemid == 11008 || itemid == 12186) {
									string texts = "A `4" + items[p_].ori_name + "`` rewards `2" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` with a `5Rare " + items[itemid].ori_name + "``.";
									gamepacket_t p;
									p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` " + texts + "``");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										p.CreatePacket(currentPeer);
									}
								}
							}
						}
						if (p_ == 1680) {
							modify_inventory(peer, p_, got = -1);
							WorldDrop drop_block_{};
							drop_block_.id = itemid, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x, drop_block_.y = pInfo(peer)->y - 32, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
							dropas_(world_, drop_block_);
							PlayerMoving data_{};
							gamepacket_t p;
							p.Insert("OnParticleEffect"), p.Insert(73), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y - 32);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								p.CreatePacket(currentPeer);
							}
						}
						else {
							received = got;
							if (modify_inventory(peer, itemid, got) == 0) {
								//if (p_ == 12566) if (pInfo(peer)->garuda < 15) pInfo(peer)->garuda++;
								modify_inventory(peer, p_, got = -1);
								gamepacket_t p, p2;
								p.Insert("OnConsoleMessage"), p.Insert("You received `2" + to_string(received) + " " + items[itemid].name + "`` from the " + items[p_].name + "."), p.CreatePacket(peer);
								p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("You received `2" + to_string(received) + " " + items[itemid].name + "`` from the " + items[p_].name + "."), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
							}
						}
					}
					break;
				}
				
				case 834: case 5766: case 1406: case 9264:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					modify_inventory(peer, p_, got = -1);
					if (rand() % 100 < 2 and p_ == 834) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Received 1 Summer Surprise!");
						p.Insert(0);
						p.Insert(1);
						p.CreatePacket(peer);
						WorldDrop drop_block_{};
						drop_block_.id = 836, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x, drop_block_.y = pInfo(peer)->y, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
						dropas_(world_, drop_block_);
					}
					gamepacket_t p;
					p.Insert("OnParticleEffect"), p.Insert(40), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						p.CreatePacket(currentPeer);
					}
					break;
				}
				case 5804:
				case 5806:
				case 5808:
				case 5810:
				case 5812:
				case 6822:
				case 5770:
				case 5772:
				case 5774:
				case 5776:
				case 5778:
				case 6002:
				case 6052:
				case 6272:
				case 6274:
				case 6276:
				case 7232:
				case 7234:
				case 6122:
				case 6672:
				case 6322:
				case 7062:
				case 7130:
				case 6278:
				case 6824:
				case 6744:
				case 6894:
				case 7370:
				case 7474:
				case 7656:
				case 7684:
				case 7932:
				case 8416:
				case 10114:
				case 8028:
				case 7698:
				//case 9490:
				case 10116: case 12544: case 12542:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (pInfo(peer)->growmoji.find(items[p_].emoji + "0&") != string::npos) {
						modify_inventory(peer, p_, got = -1);
						replaceAll(pInfo(peer)->growmoji, items[p_].emoji + "0&", items[p_].emoji + "1&");
						gamepacket_t p;
						p.Insert("OnAddNotification");
						p.Insert("interface/large/friend_button.rttex");
						p.Insert("You've unlocked `$" + items[p_].ori_name + "``!");
						p.Insert("audio/hub_open.wav");
						p.Insert(0);
						p.CreatePacket(peer);
						form_emoji(peer);
					}
					break;
				}
				case 830: case 9164: case 942: case 1060: case 1136: case 1402: case 1532: case 3562: case 5176: case 4774: case 7380: case 7588: case 9488: case 8556: case 9582: case 9602:
				{
					if (p_ == 830) {
						int got = 0;
						modify_inventory(peer, 834, got);
						if (got < 100) {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Beach blast requires 100 Fireworks."), p.Insert(0), p.Insert(1);
							p.CreatePacket(peer);
							break;
						}
					}
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0" + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|This item creates a new world! Enter a unique name for it.|left||\nadd_text_input|name|New World Name||256|\nend_dialog|blast|Cancel|`5Create!``|\n");
					p.CreatePacket(peer);
					pInfo(peer)->lastchoosenitem = p_;
					break;
				}
				case 1280: case 2580: case 2480:
				{
					if (p_ == 1280) {
						if (has_playmod(pInfo(peer), "Recently Name-Changed")) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID), p.Insert("You recently changed your name.``"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							break;
						}
						pInfo(peer)->lastchoosenitem = p_;
						SendBirth_Dialog(peer, "");
					}
					else {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						if (p_ == 2580) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSwap World Names``|left|2580|\nadd_smalltext|This will swap the name of the world you are standing in with another world `4permanently``.  You must own both worlds, with a World Lock in place.<CR>Your `wChange of Address`` will be consumed if you press `5Swap 'Em``.|left|\nadd_textbox|Enter the other world's name:|left|\nadd_text_input|name_box|||32|\nadd_spacer|small|\nend_dialog|world_swap|Cancel|Swap 'Em!|");
						if (p_ == 2480) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMegaphone``|left|2480|\nadd_textbox|Enter a message you want to broadcast to every player in Growtopia! This will use up 1 Megaphone.|left|\nadd_text_input|words|||128|\nembed_data|itemID|2480\nend_dialog|megaphone|Nevermind|Broadcast|\n");
						p.CreatePacket(peer);
					}
					break;
				}
				case 7190:
				{
					uint32_t my_rank = 0;
					string guildName = "";
					if (pInfo(peer)->guild_id != 0) {
						uint32_t guild_id = pInfo(peer)->guild_id;
						vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
						if (p != guilds.end()) {
							Guild* guild_information = &guilds[p - guilds.begin()];
							for (GuildMember member_search : guild_information->guild_members) {
								guildName = guild_information->guild_name;
								if (member_search.member_name == pInfo(peer)->tankIDName) {
									my_rank = member_search.role_id;
									break;
								}
							}
						}
						if (my_rank == 3) {
							DialogBuilder guild("`o");
							guild.add_label_icon(true, 5814, "`wChange Guild Name``")
								.add_textbox("Current Guild Name:" + guildName);
							guild.add_text_input(15, "new_guild_name", "Guild Name:", "")
								.add_button("confirm", "Confirm")
								.end_dialog("change_guild_name", "Close", "");
							enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(guild.to_string()).pack());
						}
						else {
							gamepacket_t p;
							p.Insert("OnTextOverlay"), p.Insert("Only Guild Leader can Change Guild Name!"), p.CreatePacket(peer);
							break;
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTextOverlay"), p.Insert("You must have Guild to use Guild Name Changer!"), p.CreatePacket(peer);
						break;
					}
					break;
				}
				/*
				case 5524: 
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (not world_->open_to_public and world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(peer)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(peer)->tankIDName) == check_lock->admins.end())) break;
						}
					}
					//if (items[t_].blockType == BlockTypes::MAIN_DOOR or items[t_].blockType == BlockTypes::BEDROCK)return true;

					if ((block_->flags & 0x04000000) and not block_->uranium and t_ == 4658) {
						block_->flags |= 0x00400000;
						block_->uranium = true;
						int c_ = -1;
						modify_inventory(peer, p_, c_);
					}
					//block_->flags = (block_->flags & 0x04000000 ? block_->flags ^ 0x04000000 : block_->flags | 0x04000000);
					{

						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == pInfo(peer)->world) {
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					break;
				}
				*/
				/*case 13863: {
					hand_phone(p_)
					//if (hand_phone(peer));

					break;
				} */
				case 13862:
					if (pInfo(peer)->musik) hand_phone(peer);
					break;

				case 1404:
				{
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					if (world_->owner_name == pInfo(peer)->tankIDName or pInfo(peer)->admin) {
						bool used = false;
						if (block_->flags & 0x10000000) {
							p.Insert("You can't move door on fire!");
						}
						else {
							if (y_ < (world_->width - (6 * (world_->width / 100))) && y_ > 0) {
								if (block_->fg == 0 || block_->fg == 6 || block_->fg == 8 || block_->fg == 9570) {
									WorldBlock* block2_ = GetTile({x_, y_ + 1}, world_);
									if (block2_ == nullptr) return false;
									// crash block2_ gak ketemu.... (out of range)
									if (block2_->flags & 0x10000000) {
										p.Insert("You can't move door on fire!");
									}
									else {
										if (block2_->fg == 0 || block2_->fg == 6 || block2_->fg == 8 and y_ < (world_->width - (6 * (world_->width / 100)))) {
											p.Insert("You've moved the door!");
											used = true;
											int c_ = -1;
											modify_inventory(peer, p_, c_);
											for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
												if (world_->blocks[i_].fg == 6) world_->blocks[i_].fg = 0, update_tile(peer, i_ % world_->width, i_ / world_->width, 0, false, true);
												if (i_ < ((world_->width * world_->height) - ((world_->width) * (6 * (world_->width / 100)))) && (world_->blocks[i_].fg == 8 || world_->blocks[i_].fg == 9570)) world_->blocks[i_].fg = 0, update_tile(peer, i_ % world_->width, i_ / world_->width, 0, false, true);
											}
											PlayerMoving data_{};
											data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
											int alloc = alloc_(world_, block_);
											BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
											BYTE* blc = raw + 56;
											form_visual(blc, *block_, *world_, peer, false);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
												pInfo(currentPeer)->x = float(x_) * 32, pInfo(currentPeer)->y = float(y_) * 32;
												gamepacket_t p(0, pInfo(currentPeer)->netID);
												p.Insert("OnSetPos"), p.Insert(float(x_) * 32, float(y_) * 32), p.CreatePacket(currentPeer);
												send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
												update_tile(currentPeer, x_, y_, world_->blocks[x_ + (y_ * world_->width)].fg = 6, false, false);
												update_tile(currentPeer, x_, y_ + 1, world_->blocks[x_ + (y_ + 1) * world_->width].fg = (world_->d_weather == 255 ? 9570 : 8), false, false);
											}
											delete[] raw, blc;
											if (block_->locked) upd_lock(*block_, *world_, peer);
										}
									}
								}
							}
							if (used == false) {
								packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
								p.Insert("There's no room to put the door there! You need 2 empty spaces vertically.");
							}
						}
					}
					else p.Insert("You can only use this in a world that you have world-locked!");
					p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					break;
				}
				case 3062: case 3102:
				{
					if (items[t_].blockType == BlockTypes::MAIN_DOOR or items[t_].blockType == BlockTypes::BEDROCK or block_->flags & 0x04000000 or t_ == 9570) {
						if (p_ == 3102 || p_ == 3062) {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("That won't burn!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
						return true;
					}
					if (t_ == 0) {
						if (p_ == 3102 || p_ == 3062) {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("There's nothing to burn!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
						return true;
					}
					if (block_->flags & 0x10000000) {
						if (p_ == 3102 || p_ == 3062) {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("That area is burned already!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
						return true;
					}
					int c_ = -1;
					if (modify_inventory(peer, p_, c_) == 0) {
						if (p_ == 3062) {
							if (block_->flags & 0x10000000) {
							}
							else {
								//if (block_->flags & 0x04000000)  block_->flags ^= 0x04000000;
								add_peer_xp(peer, 1);
								block_->flags |= 0x10000000;
								if (rand() % 100 < (items[p_].newdropchance + 5)) {
									WorldDrop drop_seed_{};
									drop_seed_.id = p_ + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
									if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
								}
								else if (rand() % 10 < 4)  gems_(peer, world_, rand() % (items[p_].max_gems + 1), x_ * 32, y_ * 32, p_);

								if (block_->fg == 3090) {
									update_tile(peer, x_, y_, block_->fg = 3128, false, true);
									vector<pair<int, int>> receivingitems;
									for (int i_ = 0; i_ < world_->drop.size(); i_++) {
										if (world_->drop[i_].id == 0) continue;
										if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32) && (items[world_->drop[i_].id].grindable_prize != 0 && items[world_->drop[i_].id].grindable_count == 0)) {
											receivingitems.push_back(make_pair(world_->drop[i_].id, world_->drop[i_].count));
											PlayerMoving data_{};
											data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop[i_].uid;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[]raw;
											world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
										}
									}
									for (int i = 0; i < receivingitems.size(); i++) {
										int item = receivingitems[i].first;
										if (items[item].grindable_prize != 0 && items[item].grindable_count == 0) item = items[item].grindable_prize;
										WorldDrop drop_block_{};
										drop_block_.id = item, drop_block_.count = receivingitems[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
										dropas_(world_, drop_block_);
									}
								}
								else if (block_->fg == 7764 || block_->fg == 9300 || block_->fg == 8048 || block_->fg == 7768 || block_->fg == 7772 || block_->fg == 7776) block_->fg += 2, block_->planted = time(nullptr) - (items[p_].growTime / 2);
							}
						}
						else if (p_ == 3102) {
							vector<int> random_xy{ 2, 1, 0, -1 };
							for (int i = 0; i < 7; i++) {
								int randomx = random_xy[rand() % random_xy.size()] + x_, randomy = random_xy[rand() % random_xy.size()] + y_;
								if (randomx > 0 && randomx < world_->width && randomy > 0 && randomy < world_->height - 7) {
									WorldBlock* dropx = &world_->blocks[randomx + (randomy * world_->width)];
									if (dropx->fg == 6 || dropx->fg == 12258 || dropx->flags & 0x10000000 || dropx->fg == 6 || dropx->fg == 8 || (randomx == x_ && randomy == y_)) {
									}
									else {
										dropx->flags = (dropx->flags & 0x10000000 ? dropx->flags : dropx->flags |= 0x10000000);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = randomx, data_.punchY = randomy, data_.characterState = 0x8;
										int alloc = alloc_(world_, dropx);
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
										BYTE* blc = raw + 56;
										form_visual(blc, *dropx, *world_, peer, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(peer)->world) {
												send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
									}
								}
							}
							block_->flags = (block_->flags & 0x10000000 ? block_->flags : block_->flags |= 0x10000000);
						}
						PlayerMoving data_{}, data2{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						data2.packetType = 19, data2.punchX = p_, data2.punchY = 1, data2.x = x_ * 32 + 16, data2.y = y_ * 32 + 16;
						BYTE* raw2 = packPlayerMoving(&data_);
						raw2[3] = 4, raw2[8] = pInfo(peer)->netID;
						int alloc = alloc_(world_, block_);
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == pInfo(peer)->world) {
								if (p_ == 3102) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("`0[```4BURN, PUNY MORTALS!```0]``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(currentPeer);
									packet_(currentPeer, "action|play_sfx\nfile|audio/flame_go.wav\ndelayMS|0");
								}
								if (p_ == 3062) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("`0[```4MWAHAHAHA!! FIRE FIRE FIRE```0]``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(currentPeer);
									packet_(currentPeer, "action|play_sfx\nfile|audio/flame_go.wav\ndelayMS|0");
								}
								send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE), send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw2, blc;
						if (block_->locked) upd_lock(*block_, *world_, peer);
					}
					break;
				}
				case 822:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (not world_->open_to_public and world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(peer)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(peer)->uid) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					}
					if (block_->flags & 0x10000000) {
						//pInfo(peer)->fires++;
						block_->flags ^= 0x10000000;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						int alloc = alloc_(world_, block_);
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == pInfo(peer)->world) send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw, blc;
						if (block_->locked) upd_lock(*block_, *world_, peer);
					}
					else {
						if (items[t_].blockType == BlockTypes::MAIN_DOOR or items[t_].blockType == BlockTypes::BEDROCK)return true;
						PlayerMoving data_{};
						data_.packetType = 19;
						data_.punchX = 822, data_.punchY = 1;
						data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 4, raw[8] = pInfo(peer)->netID;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw;
						if (block_->fg == 4658 and block_->flags & 0x00400000) block_->fg = 0;
						if (block_->fg == 5602 and block_->flags & 0x00400000) block_->fg = 0;
						block_->flags = (block_->flags & 0x04000000 ? block_->flags ^ 0x04000000 : block_->flags | 0x04000000);
						{
							if (block_->flags & 0x04000000) {
								int c_ = -1;
								modify_inventory(peer, 822, c_);
							}
							else {
								// sansas gauti atgal
								if (rand() % 100 < 50) {
									int c_ = 1;
									modify_inventory(peer, 822, c_);
								}
							}
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(peer)->world) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
						}
						break;
					}
				}
				case 5524:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (not world_->open_to_public and world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(peer)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(peer)->uid) == check_lock->admins.end())) break;
						}
					}
					{
						if (block_->flags & 0x04000000 and t_ == 4658 and !(block_->flags & 0x00400000)) {
							int c_ = -1;
							modify_inventory(peer, 5524, c_);
							block_->flags |= 0x00400000;
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 221, data_.YSpeed = 221, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
						}
						else {
							Algorithm::send_bubble(peer, pInfo(peer)->netID, "That water is already combined.");
							break;
						}
						{

							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(peer)->world) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
						}
						break;
					}
					break;
				}
				case 5522:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (not world_->open_to_public and world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->admin and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(peer)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(peer)->uid) == check_lock->admins.end())) break;
						}
					}
					{
						if (block_->flags & 0x04000000 and t_ == 5602 and !(block_->flags & 0x00400000)) {
							int c_ = -1;
							modify_inventory(peer, 5522, c_);
							block_->flags |= 0x00400000;

							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 221, data_.YSpeed = 221, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
						}
						else {
							Algorithm::send_bubble(peer, pInfo(peer)->netID, "That water is already combined.");
							break;
						}
						{
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(peer)->world) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
						}
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
						break;
					}
					break;
				}
				case 1866:
				{
					int c_ = -1;
					if (modify_inventory(peer, p_, c_) == 0) {
						if (block_->flags & 0x08000000) {
							block_->flags ^= 0x08000000;
						}
						else {
							block_->flags |= 0x08000000;
						}
						PlayerMoving data_{};
						data_.packetType = 19;
						data_.punchX = 1866, data_.punchY = 1;
						data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 4, raw[8] = pInfo(peer)->netID;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw;
						{
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(peer)->world) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
						}
					}
					break;
				}
				case 3478: case 3480: case 3482: case 3484: case 3486: case 3488: case 3490: case 3492:
				{
					if (not block_access(peer, world_, block_)) break;
					if (pInfo(peer)->hand != 3494 and pInfo(peer)->hand != 7938) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("You need a " + items[3494].name + " or a " + items[7938].name + " to apply paint!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					} if (block_->fg == 0 and block_->bg == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("There's nothing to paint!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					} if (items[block_->fg].blockType == BlockTypes::MAIN_DOOR or items[block_->fg].blockType == BlockTypes::BEDROCK or items[block_->fg].blockType == BlockTypes::LOCK or block_->fg == 9570) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("That's too special to paint.");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					bool alr_painted = false;
					if (block_->flags & 0x20000000 and block_->flags & 0x40000000 and block_->flags & 0x80000000) {
						if (p_ == 3490) alr_painted = true;
					}
					else if (block_->flags & 0x20000000 and block_->flags & 0x80000000) {
						if (p_ == 3488) alr_painted = true;
					}
					else if (block_->flags & 0x80000000) {
						if (p_ == 3486) alr_painted = true;
					}
					else if (block_->flags & 0x40000000 and block_->flags & 0x80000000) {
						if (p_ == 3484) alr_painted = true;
					}
					else if (block_->flags & 0x40000000) {
						if (p_ == 3482) alr_painted = true;
					}
					else if (block_->flags & 0x20000000 and block_->flags & 0x40000000) {
						if (p_ == 3480) alr_painted = true;
					}
					else if (block_->flags & 0x20000000) {
						if (p_ == 3478) alr_painted = true;
					}
					if (alr_painted) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("That block is already painted that color!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					{
						int colour = 0x00000000;
						float particle_ = 0;
						if (p_ == 3478) { // raudona spalva
							colour |= 0x20000000;
							particle_ = 65280.00;
						}
						else if (p_ == 3480) { // geltona spalva
							colour |= 0x20000000;
							colour |= 0x40000000;
							particle_ = 16776960.00;
						}
						else if (p_ == 3482) { // zalia spalva
							colour |= 0x40000000;
							particle_ = 16711680.00;
						}
						else if (p_ == 3484) { // sviesiai melyna spalva
							colour |= 0x40000000;
							colour |= 0x80000000;
							particle_ = 4294901760.00;
						}
						else if (p_ == 3486) { // melyna spalva
							colour |= 0x80000000;
							particle_ = 4278190080.00;
						}
						else if (p_ == 3488) { // rozine spalva
							colour |= 0x20000000;
							colour |= 0x80000000;
							particle_ = 4278255360.00;
						}
						else if (p_ == 3490) { // juoda spalva
							colour |= 0x20000000;
							colour |= 0x40000000;
							colour |= 0x80000000;
							particle_ = 1010580480.00;
						}
						else { // balta spalva
							bool has_something_to_change = false;
							if (block_->flags & 0x20000000 or block_->flags & 0x40000000 or block_->flags & 0x80000000) {
								has_something_to_change = true;
							} if (not has_something_to_change) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Don't waste your varnish on an unpainted block!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
								break;
							}
							particle_ = 3875520768.00;
						}
						int c_ = -1;
						if (modify_inventory(peer, p_, c_) == 0) {
							if (block_->flags & 0x20000000) block_->flags = block_->flags ^ 0x20000000;
							if (block_->flags & 0x40000000) block_->flags = block_->flags ^ 0x40000000;
							if (block_->flags & 0x80000000) block_->flags = block_->flags ^ 0x80000000;
							if (colour != 0x00000000) block_->flags |= colour;
							{
								PlayerMoving p_data_{};
								p_data_.packetType = 17;
								p_data_.netID = 168;
								p_data_.YSpeed = 168;
								p_data_.XSpeed = particle_;
								p_data_.x = (x_ * 32) + 16;
								p_data_.y = (y_ * 32) + 16;
								BYTE* p_raw = packPlayerMoving(&p_data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, p_raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] p_raw;
							}
							{
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								int alloc = alloc_(world_, block_);
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, peer, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
								if (block_->locked) {
									upd_lock(*block_, *world_, peer);
								}
							} if (items[block_->fg].collisionType != 1 and not items[block_->fg].entrance and not items[block_->fg].toggleable) {
								int c_ = rand() % (items[p_].max_gems + 1);
								if (c_ != 0) {
									bool no_seed = false, no_gems = false, no_block = false;
									for (int i_ = 0; i_ < world_->drop.size(); i_++) {
										if (abs(world_->drop[i_].y - y_ * 32) <= 16 and abs(world_->drop[i_].x - x_ * 32) <= 16) {
											if (world_->drop[i_].id == 112 and items[t_].rarity < 8) {
												no_gems = true;
											}
											else {
												no_seed = true, no_block = true;
											}
										}
									} if (rand() % 100 < 5 and not no_block) {
										WorldDrop drop_block_{};
										drop_block_.id = p_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
										dropas_(world_, drop_block_);
									}
									else if (rand() % 100 < 35 and not no_seed) {
										WorldDrop drop_seed_{};
										drop_seed_.id = 3479, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
										dropas_(world_, drop_seed_);
									}
									else if (not no_gems) {
										int c_ = rand() % (items[p_].max_gems + 1);
										gems_(peer, world_, c_, x_ * 32, y_ * 32, p_);
									}
								}
							}
						}
					}
					break;
				}
				case 3560:
				{
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					if (world_->owner_name == pInfo(peer)->tankIDName or pInfo(peer)->admin) {
						int used = 0;
						if (block_->fg == 0) {
							if (LockMove(peer, x_, y_)) {
								p.Insert("You've moved the world lock!");
								used = 1;
								int c_ = -1;
								modify_inventory(peer, p_, c_);
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, peer, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw, blc;
								if (block_->locked) upd_lock(*block_, *world_, peer);
							}
						}
						if (used == 0) {
							packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
							p.Insert("There's no room to put the lock there! You need 1 empty space vertically.");
						}
					}
					else p.Insert("You can only use this in a world that you have world-locked!");
					p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					break;
				}
				default:
				{
					//for (vector<string> get_ : info_about_playmods)
					{
						auto get_mod = get_playmod_id(p_);
						if (get_mod <= 0) break;
						Playmod playmod = info_about_playmods[get_mod];
						vector<string> id_items = explode("_", playmod.consumableid_time);
						string playmod_name = playmod.name;
						string playmod_on_add = playmod.onUsed;
						string playmod_sound = playmod.onRemoved;
						string playmod_action = playmod.howWork;
						string playmod_text = playmod.usetext;
						string gravity_mod = playmod.gravity;
						int playmod_id = get_mod;
						int playmod_time = atoi(id_items[1].c_str());
						//for (string item_and_time : id_items) 
						{
							//uint32_t item_id = atoi(id_items[0].c_str());
							//uint32_t playmod_time = atoi(id_items[1].c_str());
							//if (item_id == p_) 
							{
								ENetPeer* clicked_on = get_clicked_on(world_, x_, y_);
								if (playmod_action == "drop" and clicked_on == NULL or playmod_action.empty() and clicked_on == NULL or playmod_action == "consume" and clicked_on == NULL or playmod_action == "cutewords" and clicked_on == NULL) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Must be used on a person."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									return true;
								}
								if ((clicked_on != nullptr and pInfo(peer)->tankIDName != "iDems" and pInfo(clicked_on)->knockback)) clicked_on = peer;
								if (p_ == 384 and pInfo(clicked_on)->netID == pInfo(peer)->netID) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("Use that on somebody else!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(peer);
									return true;
								}
								if (playmod_action == "pet") {
									int c_ = playmod_time * -1;
									if (modify_inventory(peer, p_, c_) == 0) {
										uint32_t pet_id = atoi(playmod_name.c_str());
										int c_2 = 1;
										if (modify_inventory(peer, pet_id, c_2) != 0) {
											WorldDrop drop_block_{};
											drop_block_.id = pet_id, drop_block_.count = c_2, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
											dropas_(world_, drop_block_);
										}
										else {
											pInfo(peer)->hand = pet_id;
											update_clothes(peer);
										}
										PlayerMoving data_{};
										data_.packetType = 17;
										data_.netID = 44;
										data_.YSpeed = 44;
										data_.x = pInfo(peer)->x + 10;
										data_.y = pInfo(peer)->y + 10 + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												packet_(currentPeer, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert(playmod_text);
										p.Insert(0);
										p.CreatePacket(peer);
									}
									return true;
								}
								int c_ = -1;
								if (modify_inventory(peer, p_, c_) == 0) {
									if (playmod_action == "cutewords") {
										if (p_ == 276) SendRespawn(clicked_on, true, 0, 1);
										else if (p_ == 732)
											add_ban(clicked_on, 120, "Ban Wand Effect", pInfo(peer)->tankIDName);
										else if (p_ == 278)
											add_curse(clicked_on, 600, "Curse Wand Effect", (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``", true);
										else if (p_ == 8500) {
											string malady_text = "The patient has no malady.";
											int give = 1;
											if (pInfo(clicked_on)->surgery_type == 18) malady_text = "The patient has a `5torn Punching Muscle``.";
											else if (pInfo(clicked_on)->surgery_type == 18) malady_text = "The patient has a `5Gemcuts``.";
											else if (pInfo(clicked_on)->surgery_type == 20) malady_text = "The patient has a `5Grumbleteeth``.";
											else if (pInfo(clicked_on)->surgery_type == 21) malady_text = "The patient has a `5Chicken Feet``.";
											else if (pInfo(clicked_on)->surgery_type == 22) malady_text = "The patient has a `5Broken Heart``.";
											else if (pInfo(clicked_on)->surgery_type == 24) malady_text = "The patient has a `5Ecto-Bones``.";
											else if (pInfo(clicked_on)->surgery_type == 25) malady_text = "The patient has a `5Moldy Guts``.";
											else if (pInfo(clicked_on)->surgery_type == 26) malady_text = "The patient has a `5Fatty Liver``.";
											else if (pInfo(clicked_on)->surgery_type == 27) malady_text = "The patient has a `5Chaos Infection``.";
											else if (pInfo(clicked_on)->surgery_type == 28) malady_text = "The patient has a `5Lupus``.";
											else {
												PlayerMoving extended_particle_data_{};
												extended_particle_data_.packetType = 36, extended_particle_data_.x = pInfo(clicked_on)->x + 16, extended_particle_data_.y = pInfo(clicked_on)->y + 16, extended_particle_data_.characterState = 0x8, extended_particle_data_.netID = 175;
												BYTE* ex_raw = packPlayerMoving(&extended_particle_data_);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
													send_raw(currentPeer, 4, ex_raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
												delete[] ex_raw;
												modify_inventory(peer, 8500, give);
											}
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert(malady_text);
											p.Insert(0), p.Insert(1);
											p.CreatePacket(peer);
										}
										else {
											gamepacket_t p4;
											p4.Insert("OnConsoleMessage");
											string text = "";
											gamepacket_t p2(p_ == 752 ? 500 : 0);
											p2.Insert("OnTalkBubble");
											p2.Insert(pInfo(clicked_on)->netID);
											vector<string> random_words{
												"`4'ADORE ME'``",
												"`4'SAY YES'``",
												"`4'MISS YOU'``"
											};
											if (p_ == 618) {
												random_words = { "`4'ARGH!!!'``" };
												SendRespawn(clicked_on, true, 0, 1);
											}
											if (p_ == 2734 || p_ == 4752) {
												/*
												if (clicked_on == peer && pInfo(clicked_on)->stage_pineapple >= 600) {
													gamepacket_t p;
													p.Insert("OnTalkBubble"), p.Insert(pInfo(clicked_on)->netID), p.Insert("`2I can't stomach another one...``"), p.Insert(0), p.Insert(0), p.CreatePacket(clicked_on);
													int give_1 = 1;
													modify_inventory(peer, p_, give_1);
												}
												else {
													if (pInfo(clicked_on)->stage_pineapple == 600) {
														vector<uint16_t> list{ 4716 , 6098 , 2738 , 6122 , 3616 , 2740 , 2730 , 9656 , 9662 , 2760 , 4772 , 3624 , 2736 , 2758 , 2762 , 6100 , 2752 , 9664 , 6118 , 3618 , 9652 , 6102 , 6110 , 10908 , 6104 , 9668 , 2734 , 10902 , 10900 , 10898 , 2748 , 10896 , 2744 };
														if (total_pineapple_eaten > 50000) list.push_back(2732);
														if (total_pineapple_eaten > 250000) list.push_back(3622);
														if (total_pineapple_eaten > 500000) list.push_back(2746);
														if (total_pineapple_eaten > 500000) list.push_back(2746);
														if (total_pineapple_eaten > 1000000) list.push_back(2742);
														uint16_t prize_to_pacient = list[rand() % list.size()];
														text = "`7[```9PINEAPPLE MAGIC!`` " + pInfo(peer)->tankIDName + " got a `2" + items[prize_to_pacient].name + "``!`7]``";
														int give = 1;
														modify_inventory(peer, prize_to_pacient, give);
													}
													add_pineapple(clicked_on, (p_ == 2734 ? 1 : 200));
													pInfo(clicked_on)->total_pineapple += ((p_ == 2734 ? 1 : 200));
													total_pineapple_eaten += ((p_ == 2734 ? 1 : 200));
												}*/
											}
											if (p_ == 616) random_words = { "`4'Awwwww!'``" };
											if (p_ == 752) random_words = { "HEADS"  ,  "TAILS" };
											string random_phrase = random_words[rand() % random_words.size()];
											p2.Insert(random_phrase);
											p2.Insert(0);
											gamepacket_t p(0, pInfo(clicked_on)->netID);
											p.Insert("OnPlayPositioned");
											p.Insert("audio/eat.wav");
											gamepacket_t p3(0, pInfo(clicked_on)->netID);
											p3.Insert("OnAction");
											p3.Insert("/love");
											if (p_ == 618) text = pInfo(clicked_on)->tankIDName + " snuggled the wrong bunny!";
											else if (p_ != 616 and p_ != 752 and p_ != 2734 and p_ != 4752)text = pInfo(clicked_on)->tankIDName + " shouts " + random_phrase + " uncontrollably!";
											if (text != "") p4.Insert(text);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
												p.CreatePacket(currentPeer);
												if (p_ != 2734 and p_ != 4752) p2.CreatePacket(currentPeer);
												if (p_ != 618 and p_ != 752 and p_ != 2734 and p_ != 4752) p3.CreatePacket(currentPeer);
												if (text != "") p4.CreatePacket(currentPeer);
											}
										}
										PlayerMoving data_{};
										data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
										data_.punchX = p_, data_.punchY = pInfo(peer)->netID;
										BYTE* raw;
										data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
										raw = packPlayerMoving(&data_);
										int32_t to_netid = pInfo(clicked_on)->netID;
										raw[3] = 5;
										memcpy(raw + 8, &to_netid, 4);
										update_clothes(clicked_on);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw;
										return true;
									}
									if (playmod_action == "consume") {
										if (p_ == 3240) {
											pInfo(clicked_on)->geiger_ = 100;
											for (int i_ = 0; i_ < pInfo(clicked_on)->playmods.size(); i_++) {
												if (pInfo(clicked_on)->playmods[i_].id == 10) pInfo(clicked_on)->playmods[i_].time = 1;
											}
										}
										gamepacket_t p2;
										p2.Insert("OnTalkBubble");
										p2.Insert(pInfo(clicked_on)->netID);
										p2.Insert(playmod_name);
										p2.Insert(0);
										gamepacket_t p(0, pInfo(clicked_on)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/eat.wav");
										PlayerMoving data_{};
										data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
										data_.punchX = p_;
										data_.punchY = pInfo(peer)->netID;
										BYTE* raw;
										data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
										raw = packPlayerMoving(&data_);
										int32_t to_netid = pInfo(clicked_on)->netID;
										raw[3] = 5;
										memcpy(raw + 8, &to_netid, 4);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw;
										return true;
									}
									if (playmod_action == "drop") {
										if (p_ == 782) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("`w[" + pInfo(clicked_on)->tankIDName + " `wfeels strangely better!]");
											p.Insert(0);
											gamepacket_t p2;
											p2.Insert("OnConsoleMessage");
											p2.Insert("`7[`w" + pInfo(clicked_on)->tankIDName + " `ofeels strangely better!`7]");
											p2.Insert(0);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == name_) p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
											}
											for (int i_ = 0; i_ < pInfo(peer)->playmods.size(); i_++) if (pInfo(peer)->playmods[i_].id == 28 || pInfo(peer)->playmods[i_].id == 41 || pInfo(peer)->playmods[i_].id == 49 || pInfo(peer)->playmods[i_].id == 48 || pInfo(peer)->playmods[i_].id == 71 || pInfo(peer)->playmods[i_].id == 72 || pInfo(peer)->playmods[i_].id == 73 || pInfo(peer)->playmods[i_].id == 4 || pInfo(peer)->playmods[i_].id == 16 || pInfo(peer)->playmods[i_].id == 17 || pInfo(peer)->playmods[i_].id == 19 || pInfo(peer)->playmods[i_].id == 27 || pInfo(peer)->playmods[i_].id == 42) pInfo(peer)->playmods[i_].time = 1;
										}
										else {
											int c_ = rand() % (items[p_].max_gems + 1);
											if (c_ != 0) {
												bool no_seed = false, no_gems = false, no_block = false;
												for (int i_ = 0; i_ < world_->drop.size(); i_++) {
													if (abs(world_->drop[i_].y - y_ * 32) <= 16 and abs(world_->drop[i_].x - x_ * 32) <= 16) {
														if (world_->drop[i_].id == 112 and items[t_].rarity < 8) {
															no_gems = true;
														}
														else {
															no_seed = true, no_block = true;
														}
													}
												}
												if (rand() % 100 < 5 and not no_block) {
													WorldDrop drop_block_{};
													drop_block_.id = p_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
													if (not use_mag(world_, drop_block_, drop_block_.x, drop_block_.y)) dropas_(world_, drop_block_);
												}
												else if (rand() % 100 < 35 and not no_seed) {
													WorldDrop drop_seed_{};
													drop_seed_.id = p_ + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
													if (not use_mag(world_, drop_seed_, drop_seed_.x, drop_seed_.y)) dropas_(world_, drop_seed_);
												}
												else if (not no_gems) {
													int c_ = rand() % (items[p_].max_gems + 1);
													gems_(peer, world_, c_, x_ * 32, y_ * 32, p_);
												}
											}
										}
									}
									else if (not playmod_action.empty()) {
										if (playmod_action == "throw") {
											uint32_t playmod_effect = atoi(playmod.eff.c_str());
											PlayerMoving data_{};
											data_.packetType = 17;
											data_.netID = playmod_effect;
											data_.YSpeed = playmod_effect;
											data_.x = x_ * 32 + rand() % 17;
											data_.y = y_ * 32 + rand() % 17;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == world_->name) {
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
											}
											delete[] raw;
										}
										else {
											uint32_t playmod_effect = atoi(playmod.eff.c_str());
											PlayerMoving data_{};
											data_.packetType = 17;
											data_.netID = playmod_effect;
											data_.YSpeed = playmod_effect;
											data_.x = x_ * 32 + 16;
											data_.y = y_ * 32 + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == world_->name) {
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
											}
											delete[] raw;
										}
									}
									if (clicked_on != NULL) {
										if (pInfo(clicked_on)->knockback)
											clicked_on = peer;

										bool alr_have = false;
										for (PlayMods peer_playmod : pInfo(clicked_on)->playmods) {
											if (peer_playmod.id == playmod_id) {
												if (p_ == 384 and peer_playmod.user == pInfo(peer)->tankIDName) {
													alr_have = true;
													break;
												}
												else {
													alr_have = true;
													break;
												}
											}
										}
										if (not alr_have) {
											PlayMods new_playmod{};
											new_playmod.id = playmod_id;
											new_playmod.time = time(nullptr) + playmod_time;
											new_playmod.user = pInfo(peer)->tankIDName;
											pInfo(clicked_on)->playmods.push_back(new_playmod);
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert(playmod_on_add + " (`$" + playmod_name + "`` mod added, `$" + Algorithm::to_playmod_time(playmod_time) + "``left)");
											p.CreatePacket(clicked_on);
											update_clothes(clicked_on);
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`4>> `#" + pInfo(clicked_on)->name_color + pInfo(clicked_on)->tankIDName + "```` is now `#" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "````'s valentine!``");
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
													if (p_ == 384) p.CreatePacket(currentPeer);
												}
											}
										}
									}
									{
										PlayerMoving data_{};
										data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
										data_.punchX = p_;
										data_.punchY = pInfo(peer)->netID;
										BYTE* raw;
										int32_t to_netid = 0;
										if (clicked_on != NULL and playmod_action.empty() or playmod_action == "drop" and clicked_on != NULL) {
											data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
											raw = packPlayerMoving(&data_);
											to_netid = pInfo(clicked_on)->netID;
											raw[3] = 5;
										}
										else {
											data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
											raw = packPlayerMoving(&data_);
											to_netid = pInfo(peer)->netID;
											raw[3] = 4;
										}
										memcpy(raw + 8, &to_netid, 4);
										gamepacket_t p1;
										p1.Insert("OnTalkBubble");
										if (not playmod_text.empty()) {
											p1.Insert(pInfo(clicked_on)->netID), p1.Insert(playmod_text), p1.Insert(0);
											if (clicked_on != NULL) update_clothes(clicked_on);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
											if (not playmod_text.empty()) p1.CreatePacket(currentPeer);
											if (not playmod_sound.empty() and clicked_on != NULL or playmod_action == "drop" and clicked_on != NULL) {
												gamepacket_t p(0, pInfo(clicked_on)->netID);
												p.Insert("OnPlayPositioned");
												p.Insert("audio/" + playmod_sound);
												p.CreatePacket(currentPeer);
											}
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[]raw;
									}
								}
								return true;
							}
						}
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Hmm, it seems [`5" + items[p_].name + "`w] is not implemented yet but will be soon!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert(items[p_].name + " is not implemented yet but will be soon! If you want it faster let us know!");
						p.CreatePacket(peer);
					}
					break;
				}
				}
				break;
			}
			default:
			{
				if (p_ == 776) {
					if (x_ == 0 or y_ == 0 or x_ == 99 or y_ == 59) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						p.Insert("Don't Throw waste out of the world!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						return false;
					}
				}
				if (items[p_].magplant or items[p_].mag_multiple) {
					if (world_->owner_name != pInfo(peer)->tankIDName) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Only the world owner is allowed to place that here!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Only the world owner is allowed to place that here!");
							p.CreatePacket(peer);
						}
						return false;
					}
				}
				if (block_->locked) {
					WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
					block2_->owner_name = GetNameByUid(block2_->owner_id);
					string owner_name = block2_->owner_name, user_name = pInfo(peer)->tankIDName;
					if (owner_name != user_name and world_->owner_name != user_name and not pInfo(peer)->dev) {
						if (block2_->fg == 4994 or find(block2_->admins.begin(), block2_->admins.end(), pInfo(peer)->uid) == block2_->admins.end() and not block2_->open_to_public) {
							if (block2_->fg == 4994) {
								if (not block2_->open_to_public) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
									if (p_ != 18) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("That area is owned by " + block2_->owner_name);
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(peer);
									}
									return true;
								}
								if (not block2_->build_only and block2_->open_to_public) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
									if (p_ != 18) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("This lock allows breaking only!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(peer);
									}
									return false;
								}
							}
							else {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
								if (p_ != 18) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("That area is owned by " + block2_->owner_name);
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(peer);
								}
								return false;
							}
						}
						if (items[p_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`w" + block2_->owner_name + "`` allows public building here, but no locks.");
							p.Insert(0);
							p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
							}
							return false;
						}
					}
				}
				else if (not world_->owner_name.empty() and items[p_].blockType != BlockTypes::CONSUMABLE) {
					string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
					if (owner_name != user_name and not pInfo(peer)->dev) {
						if (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end() and not world_->open_to_public) {
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							if (not pInfo(peer)->invis) {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										p.CreatePacket(currentPeer);
									}
								}
							}
							else {
								p.CreatePacket(peer);
							}
							if (p_ != 18) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("That area is owned by " + (world_->owner_named.substr(0, 2) == "`o" ? "`w" + world_->owner_name : world_->owner_named) + "``");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
							}
							return false;
						}
						if (items[p_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`w" + world_->owner_name + "`` allows public building here, but no locks.");
							p.Insert(0);
							p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
							}
							return false;
						}
					}
				}
				if (items[p_].blockType == BlockTypes::DOOR || items[p_].blockType == BlockTypes::PORTAL || items[p_].blockType == BlockTypes::LOCK || p_ == 1684) {
					if (find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) == world_->admins.end() and world_->owner_name != pInfo(peer)->tankIDName) {
						//if (patchPath(world_, pInfo(peer)->x, pInfo(peer)->y, x_ + (y_ * world_->width), peer)) 
						if (!AllowedPath(world_, pInfo(peer), pInfo(peer)->x / 32, pInfo(peer)->y / 32))
						{
							gamepacket_t p, p2(0, pInfo(peer)->netID);
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Something is blocking the way, get closer."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							p2.Insert("OnPlayPositioned"), p2.Insert("audio/punch_locked.wav"), p2.CreatePacket(peer);
							return true;
						}
					}
				}
				if (world_->owner_name.empty() and items[p_].item_sucker) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("This item can only be used in World-Locked worlds!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
					return false;
				}
				// statymas
				if (items[block_->fg].blockType == BlockTypes::CRYSTAL and items[p_].blockType == BlockTypes::CRYSTAL) {
					vector<vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
					int abcc = -1;
					string mix_with = "";
					if (modify_inventory(peer, p_, abcc) == 0) {
						bool obtained_ = false;
						for (int i = 0; i < block_->crystals.size(); i++) {
							vector<int> c_ = block_->crystals[i];
							if (c_[0] == p_) {
								block_->crystals[i][1]++;
								obtained_ = true;
							} for (int a = 0; a < current_.size(); a++) {
								if (current_[a][0] == c_[0]) {
									current_[a][1] = block_->crystals[i][1];
									break;
								}
							}
						} if (not obtained_) {
							block_->crystals.push_back({ p_, 1 });
							for (int a = 0; a < current_.size(); a++) {
								if (current_[a][0] == p_) {
									current_[a][1] = 1;
									break;
								}
							}
						} vector<string> reply{};
						for (int i = 0; i < current_.size(); i++) {
							reply.push_back(to_string(current_[i][1]) + "x `$" + mix_with + (current_[i][0] == 2242 ? "R" : (current_[i][0] == 2244 ? "G" : (current_[i][0] == 2246 ? "B" : (current_[i][0] == 2248 ? "W" : "B")))) + "``");
						} {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("This Crystal is currently mixed with " + join(reply, ", "));
							p.CreatePacket(peer);
						}
					}
					return true;
				}
				//grow4good(peer, false, "place", 1);
				if (p_ == 611) p_ = 610;
				if (block_->fg == 610 and p_ == 610) {
					// add kazkas
					int a = -1;
					if (modify_inventory(peer, 611, a, true) == 0) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 66, data_.YSpeed = 66, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
						BYTE* raw_e = packPlayerMoving(&data_);
						if (block_->bunny_egg_progress < 2001) {
							pInfo(peer)->egg++;
							block_->bunny_egg_progress++;
						}
						if (block_->bunny_egg_progress > 1000) {
							int burst_chance = 350;
							if (block_->bunny_egg_progress > 1500) burst_chance = 125;
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							if (rand() % burst_chance < 1) {
								p.Insert("`6The egg has exploded!``");
								block_->fg = 0, block_->bunny_egg_progress = 0;
								update_tile(peer, x_, y_, 0, false, true);
							}
							else p.Insert(block_->bunny_egg_progress <= 1500 ? "This oversized egg has a fair chance to burst!" : "`6This over-sized egg has a good chance to burst!``");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw_e, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw_e, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					return true;
				}
				else if (items[p_].blockType == BlockTypes::SEED and items[block_->fg].blockType != BlockTypes::SEED and block_->fg != 0 or items[p_].blockType != BlockTypes::BACKGROUND and items[p_].blockType != BlockTypes::SEED and block_->fg != 0) {
					packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
					return false;
				}
				else if (items[p_].blockType == BlockTypes::BACKGROUND and items[block_->fg].blockType == BlockTypes::BEDROCK or items[p_].blockType == BlockTypes::BACKGROUND and items[block_->fg].blockType == BlockTypes::MAIN_DOOR) {
					return false;
				}
				if (p_ == 4516) {
					if (world_->owner_name == "" || world_->owner_name != pInfo(peer)->tankIDName) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						p.Insert("Only the owner of the world can place this.");
						p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						return false;
					}
				}
				if (p_ == 5000 or p_ == 3832 or p_ == 10058 or p_ == 2072 or p_ == 226 or p_ == 3616 or p_ == 1276 or p_ == 1278 or p_ == 4758 or p_ == 3750 or p_ == 4992 or p_ == 3072 or p_ == 4884 or p_ == 1436 or p_ == 8246 or p_ == 10258) {
					/*
					if (world_->owner_name.empty()) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("This item can only be used in World-Locked worlds!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						return false;
					}
					*/
					bool block_place = false;
					int cctv_count = 0;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (world_->blocks[i_].fg == p_) {
							if (p_ != 1436 and p_ != 8246 and p_ != 10258) block_place = true;
						}
						if (p_ == 1436 || p_ == 8246 || p_ == 10258) {
							if (world_->blocks[i_].fg == 1436 || world_->blocks[i_].fg == 8246 || world_->blocks[i_].fg == 10258)  cctv_count++;
						}
					}
					if (block_place or cctv_count >= 8) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						if (p_ == 1436 || p_ == 8246 || p_ == 10258) p.Insert("``You can only have 8 " + items[p_].name + " in a world.");
						else {
							if (p_ == 5000 or p_ == 3832 or p_ == 10058) {
								p.Insert("``You can only have one " + items[p_].name + " in a world.");
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned"), p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
											p.CreatePacket(currentPeer);
										}
									}
									else p.CreatePacket(peer);
								}
							}
							else p.Insert("This world already has a `$" + items[p_].name + "`` somewhere on it, installing two would be dangerous!");
						}
						p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						return false;
					}
				}
				if (items[p_].collisionType == 1) {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_ and not pInfo(currentPeer)->ghost) {
							if (y_ == pInfo(currentPeer)->y / 32) {
								if (pInfo(currentPeer)->state == 0 and x_ * 32 < pInfo(currentPeer)->x and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state == 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state != 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 20) {
									return false;
								}
							}
						}
					}
				}
				int c_ = -1;
				switch (items[p_].blockType) {
				case BlockTypes::CRYSTAL:
				{
					block_->crystals.push_back({ p_, 1 });
					punch_tile(peer, x_, y_, 0x3, p_, mag_place ? -1 : pInfo(peer)->netID, 0x0);
					break;
				}
				case BlockTypes::PROVIDER:
				{
					punch_tile(peer, x_, y_, 0x3, p_, pInfo(peer)->netID, 0x0);
					long long time_ = time(nullptr);
					if (items[block_->fg].properties & Property_AutoPickup)
						block_->planted = time_;
					else {
						block_->planted = time(nullptr) - (items[block_->fg].growTime / 2);
					}

					if (p_ == 12986) block_->planted = time_ - ((39600 * 2) + 7200);
					if (provider_event > 1) block_->planted -= items[p_].growTime / 2;
					break;
				}
				case BlockTypes::SEED:
				{
					if (items[block_->fg].blockType == BlockTypes::SEED) {
						long long time_ = time(nullptr);
						int timed = items[block_->fg].growTime / 4;
						if (has_playmod(pInfo(peer), "Reduced Growtime..") and rand() % items[pInfo(peer)->ances].chance < 1) timed = (timed * 1.02);
						uint32_t laikas = uint32_t((time_ - block_->planted <= timed ? time_ - block_->planted : timed));
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						if (block_->sp) {
							p.Insert("It would be too dangerous to try to mix three seeds."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							return false;
						}
						if (laikas == items[block_->fg].growTime) {
							p.Insert("This tree is already too big to splice another seed with."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							return false;
						}
						for (int i_ = 0; i_ < items.size(); i_++) {
							if (items[i_].r_1 == p_ and items[i_].r_2 == block_->fg or items[i_].r_2 == p_ and items[i_].r_1 == block_->fg) {
								p.Insert("`w" + items[p_].name + "`` and `w" + items[block_->fg].name + "`` have been spliced to make a `$" + items[i_].name + " Tree``!");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
								packet_(peer, "action|play_sfx\nfile|audio/success.wav\ndelayMS|0");
								block_->fg = i_ + 1, block_->sp = 1;
								PlayerMoving data_{};
								data_.packetType = 13, data_.plantingTree = p_;
								BYTE* raw = packPlayerMoving(&data_);
								raw[2] = 1;
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[]raw;
								{
									PlayerMoving data_{};
									data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
									BYTE* blc = raw + 56;
									form_visual(blc, *block_, *world_, peer, false);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
									if (block_->locked) {
										upd_lock(*block_, *world_, peer);
									}
								}
								if (not mag_place) modify_inventory(peer, p_, c_, false);
								return true;
							}
							else if (i_ + 1 == items.size()) {
								bool changed_ = false;
								if (p_ == 339 and block_->fg == 627 or block_->fg == 339 and p_ == 627) {
									uint32_t s_ = p_ == 339 ? block_->fg : p_;
									i_ = 742;
									changed_ = true;
								}
								else if (p_ == 743 and block_->fg == 253 or block_->fg == 743 and p_ == 253) {
									uint32_t s_ = p_ == 743 ? block_->fg : p_;
									i_ = 758;
									changed_ = true;
								}
								else if (p_ == 743 and block_->fg == 285 or block_->fg == 745 and p_ == 285) {
									uint32_t s_ = p_ == 745 ? block_->fg : p_;
									i_ = 6674;
									changed_ = true;
								} if (changed_) {
									p.Insert("`w" + items[p_].name + "`` and `w" + items[block_->fg].name + "`` have been spliced to make a `$" + items[i_].name + " Tree``!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(peer);
									packet_(peer, "action|play_sfx\nfile|audio/success.wav\ndelayMS|0");
									block_->fg = i_ + 1, block_->sp = 1;
									//plant_(peer, block_, x_, y_, p_, false);
									PlayerMoving data_{};
									data_.packetType = 13, data_.plantingTree = p_;
									BYTE* raw = packPlayerMoving(&data_);
									raw[2] = 1;
									send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									delete[]raw;
									{
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, peer, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										if (block_->locked) {
											upd_lock(*block_, *world_, peer);
										}
									}
									if (not mag_place) modify_inventory(peer, p_, c_, false);
									return true;
								}
								p.Insert("Hmm, it looks like `w" + items[block_->fg].name + "`` and `w" + items[p_].name + "`` can't be spliced.");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
								return false;
							}
						}
					}
					break;
				}
				case BlockTypes::LOCK:
				{
					if (x_ == 0 and y_ == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`0No locks there! Don't ask why.");
						p.Insert(0);
						p.CreatePacket(peer);
					}
					if (p_ == 202 or p_ == 204 or p_ == 206 or p_ == 4994) {
						if (not world_->owner_name.empty() and world_->owner_name != pInfo(peer)->tankIDName) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("You must be world owner to place locks!");
							p.Insert(0);
							p.CreatePacket(peer);
							return true;
						}
						// current bedrock layer estimate
						int bedrock_ = (world_->height * world_->width) - (6 * (world_->width / 100) * world_->width);
						if (y_ >= (bedrock_ / world_->width)) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("You can't place this on bedrock.");
							p.Insert(0);
							p.CreatePacket(peer);
							return true;
						}
						/*
						int safe_dis = p_ == 206 ? 7 : p_ == 204 ? 3 : 0; // nes kitaip susipisa viskas
						if (x_ < safe_dis or y_ < safe_dis or 100 - safe_dis < x_ or 60 - safe_dis < y_) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("You can't place that here, move " + to_string(x_ < safe_dis ? safe_dis - x_ : y_ < safe_dis ? safe_dis - y_ : 100 - safe_dis < x_ ? x_ - (100 - safe_dis) : 60 - safe_dis < y_ ? y_ - (60 - safe_dis) : 0) + " block away from border!");
							p.Insert(0);
							p.CreatePacket(peer);
							return true;
						}
						*/
						block_->owner_name = pInfo(peer)->tankIDName;
						block_->owner_id = pInfo(peer)->uid;
						if (HasRole(pInfo(peer))) block_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
						int lock_size = p_ == 202 ? 10 : (p_ == 204 ? 48 : (p_ == 202 ? 200 : 200));
						vector<vector<int>> tiles_ = lock_tiles(world_, x_, y_, lock_size);
						lock_size = tiles_.size();
						//cout << lock_size << endl;
						PlayerMoving data_{};
						data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						data_.netID = pInfo(peer)->id;
						data_.plantingTree = p_;
						BYTE* raw;
						if (tiles_.size() != 0) {
							raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc_(world_, block_));
							int lalala = 8;
							memcpy(raw + 8, &lock_size, 2);
							memcpy(raw + 12, &lalala, 2);
							BYTE* blc = raw + 56;
							for (int i_ = 0; i_ < tiles_.size(); i_++) {
								vector<int> update_tiles = tiles_[i_];
								int x = update_tiles[0];
								int y = update_tiles[1];
								int sq_ = x + (y * world_->width);
								WorldBlock* block_ = &world_->blocks[sq_];
								if (block_->locked) {
									//cout << "was alrd lock" << endl;
									//continue;
								}
								else {
									block_->locked = true;
									block_->lock_origin = x_ + (y_ * world_->width);
									memcpy(blc + (i_ * 2), &sq_, 2);
								}
							}
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
									send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
						}
						else {
							raw = packPlayerMoving(&data_, 56);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
						}
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Area locked."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						{
							PlayerMoving data_{};
							data_.packetType = 13, data_.plantingTree = p_;
							BYTE* raw = packPlayerMoving(&data_);
							raw[2] = 1;
							send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[]raw;
						}
						break;
					}
					if (not world_->owner_name.empty()) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Only one `$World Lock`` can be placed in a world, you'd have to remove the other one first."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						return false;
					}
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (world_->blocks[i_].fg == 202 or world_->blocks[i_].fg == 204 or world_->blocks[i_].fg == 206 or world_->blocks[i_].fg == 4994) {
							if (world_->blocks[i_].owner_name != pInfo(peer)->tankIDName) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your `$World Lock`` can't be placed in this world unless everyone else's locks are removed."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								return false;
							}
						}
					}
					if (pInfo(peer)->w_d == today_day && pInfo(peer)->w_w >= 1000000000 && pInfo(peer)->admin == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You locked too many new worlds today, try tomorrow!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						return false;
					}
					else if (pInfo(peer)->w_d != today_day && pInfo(peer)->w_w != 0) pInfo(peer)->w_w = 0;
					pInfo(peer)->w_w++, pInfo(peer)->w_d = today_day;
					pInfo(peer)->worlds_owned.push_back(world_->name);
					world_->owner_name = pInfo(peer)->tankIDName;
					world_->owner_named = ((pInfo(peer)->tmod == 1 and not pInfo(peer)->d_name.empty()) ? (pInfo(peer)->dev == 1 ? "`6@" : pInfo(peer)->admin == 1 ? "`8@" : pInfo(peer)->supermod == 1 ? "`b@" : (pInfo(peer)->tmod == 1) ? "`#@" :
						pInfo(peer)->glory == 1 ? "`c[GLORY] " : pInfo(peer)->vvip == 1 ? "`9[VVIP] " : pInfo(peer)->vip == 1 ? "`1[VIP] " : "`0") : (pInfo(peer)->tankIDName == world_->owner_name) ? "`2" : (guild_access(peer, world_->guild_id) or find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->uid) != world_->admins.end()) ? "`^" : "`0") + pInfo(peer)->tankIDName;
					if (is_reseller(peer) and not pInfo(peer)->hide_reseller) world_->owner_named += " `c[RESELLER]"; 
					PlayerMoving data_{};
					data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8, data_.netID = pInfo(peer)->id, data_.plantingTree = p_;
					BYTE* raw = packPlayerMoving(&data_, 56);
					world_->lockid = p_;
					world_->owner_id = pInfo(peer)->uid;
					pInfo(peer)->lock = p_;
					if (p_ == 11550 || p_ == 11902 || p_ == 11586 || p_ == 10410) {
						if (p_ == 11902) world_->weather = 58;
						if (p_ == 11550) world_->weather = 54;
						if (p_ == 11586) world_->weather = 55;
						if (p_ == 10410) world_->weather = 53;
						gamepacket_t p;
						p.Insert("OnSetCurrentWeather"), p.Insert(world_->weather == 0 ? 80 : world_->weather);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
							pInfo(currentPeer)->lock = p_;
							p.CreatePacket(currentPeer);
						}
					}
					gamepacket_t p, p2;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + (pInfo(peer)->name_color != "`0" ? pInfo(peer)->name_color : "`o") + "" + world_->owner_name + "```5]``"), p.Insert(0);
					p2.Insert("OnConsoleMessage"), p2.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + (pInfo(peer)->name_color != "`0" ? pInfo(peer)->name_color : "`o") + "" + world_->owner_name + "```5]``");
					gamepacket_t p3(0, pInfo(peer)->netID);
					{
						p3.Insert("OnNameChanged");
						if (not HasRole(pInfo(peer))) pInfo(peer)->name_color = "`2";
						p3.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_datemaster ? " `4Datemaster" : "") + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer), p3.CreatePacket(currentPeer);
						}
					}
					delete[] raw;
					{
						PlayerMoving data_{};
						data_.packetType = 13, data_.plantingTree = p_;
						BYTE* raw = packPlayerMoving(&data_);
						raw[2] = 1;
						send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						delete[]raw;
					}
					break;
				}
				default:
				{
					if (p_ == 610) {
						punch_tile(peer, x_, y_, 0x3, 611, mag_place ? -1 : pInfo(peer)->netID, 0x0);
						{
							punch_tile(peer, x_, y_, 0x3, p_, -1, 0x0);
						}
					}
					else {
						punch_tile(peer, x_, y_, 0x3, p_, mag_place ? -1 : pInfo(peer)->netID, 0x0);
					}
					break;
				}
				}
				if (items[p_].blockType == BlockTypes::BACKGROUND)
					block_->bg = p_;
				else {
					block_->fg = p_;
				}
				if (items[p_].blockType == BlockTypes::SEED) {
					plant_(world_, peer, block_, x_, y_, p_, true, mag_place);
				}
				if (items[p_].heart_monitor) {
					block_->heart_monitor = (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "``";
					GlobalMonitors new_monitor;
					new_monitor.active = 1, new_monitor.world_name = world_->name, new_monitor.x = x_, new_monitor.y = y_;
					monitors.push_back(new_monitor);
				}
				if (items[p_].blockType == BlockTypes::PROVIDER or items[p_].vipentrance or items[p_].heart_monitor) {
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false, false, x_, y_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw, blc;
					if (block_->locked) upd_lock(*block_, *world_, peer);
				}
				block_->lp = 0;
				if (items[p_].multiple_sides and pInfo(peer)->state == 16) {
					block_->flags |= 0x00200000;
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw, blc;
					if (block_->locked) upd_lock(*block_, *world_, peer);
				}
				add_role_xp(peer, 1, "builder");
				if (pInfo(peer)->startedKit && pInfo(peer)->lvlKit < 50) add_role_xp(peer, 1, "kit");
				if (not mag_place) modify_inventory(peer, (p_ == 610 ? 611 : p_), c_, false);
				break;
			}
			}
			break;
		}
		}
	}
	return true;
}
void move_(ENetPeer* peer, PlayerMoving* data) {
	data->netID = pInfo(peer)->netID;
	BYTE* raw = packPlayerMoving(data);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL || peer == currentPeer || pInfo(currentPeer)->world != pInfo(peer)->world) continue;
		send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
	}
	delete[]raw;
}
WorldBlock* GetMagplant(ENetPeer* peer) {
	World* world = GetCurrentWorld(pInfo(peer)->world);
	for (auto& machine : world->machines) {
		if (machine.x == pInfo(peer)->magnetron_x and machine.y == pInfo(peer)->magnetron_y and machine.id == 5638) {
			WorldBlock* tile = GetTile(machine.x, machine.y, world);
			if (tile->magnetron and tile->id == pInfo(peer)->magnetron_id) {
				return tile;
			}
		}
	}
	return nullptr;
}
void AutoPunch(ENetPeer* peer, int x, int y) {
	edit_tile(peer, x, y, 18);
}
void AutoPlace(ENetPeer* peer, int x, int y, int placeID) {
	if (placeID == 0 || placeID >= items.size()) return;
	if (placeID == 5640) {
		bool empty = false;
		World* world_ = GetCurrentWorld(pInfo(peer)->world);
		for (auto& machine : world_->machines) 
		{
			if (machine.x == pInfo(peer)->magnetron_x and machine.y == pInfo(peer)->magnetron_y and machine.id == 5638) 
			{
				WorldBlock* tile = GetTile(machine.x, machine.y, world_); 
				if (tile->magnetron and tile->id == pInfo(peer)->magnetron_id) {
					if (tile->pr > 0) {
						placeID = tile->pr;
						if (edit_tile(peer, x, y, tile->id, true)) tile->pr--;
						if (tile->pr <= 0) {
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, tile));
							BYTE* blc = raw + 56;
							form_visual(blc, *tile, *world_, NULL, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, tile), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
						}
						break;
					}
					else {
						empty = true;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("The `2" + items[machine.id].name + "`` is empty!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
				else {
					if (placeID == 5640 and not empty) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("There is no active `2" + items[5638].name + "``!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
			}
		}
		return;
	}
	else {
		int remove = -1;
		bool removed = true;
		World* world = GetCurrentWorld(pInfo(peer)->world);
		WorldBlock* tile = GetTile(x, y, world);

		if (tile->fg % 2 != 0 and placeID % 2 != 0)
			removed = false;
		
		if (edit_tile(peer, x, y, placeID, true)) 
			modify_inventory(peer, placeID, remove = -1, removed), remove = 0; 

		return;
	}
}
void autoPunch_tile(ENetPeer* peer, int x_, int y_) {
	edit_tile(peer, x_, y_, 18);
}
void autoPlace_tile(ENetPeer* peer, int x_, int y_, int placeId) {
	if (placeId == 0) return;
	bool empty = false;
	if (placeId == 5640) {
		string name_ = pInfo(peer)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			for (int i_ = 0; i_ < world_->machines.size(); i_++) {
				WorldMachines machine = world_->machines[i_];
				if (machine.x == pInfo(peer)->magnetron_x and machine.y == pInfo(peer)->magnetron_y and machine.id == 5638) {
					if (machine.enabled) {
						WorldBlock* itemas = &world_->blocks[machine.x + (machine.y * world_->width)];
						if (itemas->magnetron and itemas->id == pInfo(peer)->magnetron_id) {
							if (itemas->pr > 0) {
								placeId = itemas->id;
								if (edit_tile(peer, x_, y_, itemas->id, true)) itemas->pr--;
								if (itemas->pr <= 0) {
									PlayerMoving data_{};
									data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
									BYTE* blc = raw + 56;
									form_visual(blc, *itemas, *world_, NULL, false);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
								}
								break;
							}
							else {
								empty = true;
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("The `2" + items[machine.id].name + "`` is empty!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
							}
						}
					}
					break;
				}
			}
			if (placeId == 5640 and not empty) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("There is no active `2" + items[5638].name + "``!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
			return;
		}
	}
	else
		if (!edit_tile(peer, x_, y_, placeId)) return;
}

void OnCatchWrongAction(ENetPeer* peer, int packetType, string cch) {
	replaceAll(cch, "\n", "");
	add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "`6 [" + pInfo(peer)->ip + " BANNED BY SYSTEM (PACKET BYPASS/SPAM) +" + cch, "");
	cout << "banned for bypassing/spamming packets >> " << pInfo(peer)->tankIDName << endl;
	add_ban(peer, 86400 * 999, "Spaming packet (maybe dupe/crash)!", "`4System``");
	cout << "Account with name : " + pInfo(peer)->tankIDName + "(" + pInfo(peer)->requestedName + ") (" + pInfo(peer)->ip + ") Sending Unknown Packet (" << packetType << "): " << cch << endl;
	ofstream Logs("database/server_logs.txt", ios::app);
	Logs << "Account with name : " + pInfo(peer)->tankIDName + "(" + pInfo(peer)->requestedName + ") (" + pInfo(peer)->ip + ") Sending Unknown Packet (" + to_string(packetType) + "): " + cch + "\n";
	Logs.close();
}